<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=https://rc1242rc.github.io/testbit/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://rc1242rc.github.io/testbit/fonts/vendor/jost/jost-v4-latin-500.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://rc1242rc.github.io/testbit/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><script>(()=>{var e=localStorage.getItem("theme");e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><link rel=stylesheet href=https://rc1242rc.github.io/testbit/main.1fa2debdf0a1b20e7268d11906902449af896197928a5bdae9dca95b629cdd73746db3d8c6afacb7320d9deb149a318c764669d08a1ddfd34a657ab2aeab866a.css integrity="sha512-H6LevfChsg5yaNEZBpAkSa+JYZeSilva6dypW2Kc3XN0bbPYxq+stzINnesUmjGMdkZp0Iod39NKZXqyrquGag==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>file src/SuperRenormHP.cpp - GAMBIT</title><meta name=description content="[No description available]"><link rel=canonical href=https://rc1242rc.github.io/testbit/documentation/code/files/superrenormhp_8cpp/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="file src/SuperRenormHP.cpp"><meta property="og:description" content="[No description available]"><meta property="og:url" content="https://rc1242rc.github.io/testbit/documentation/code/files/superrenormhp_8cpp/"><meta property="og:site_name" content="GAMBIT"><meta property="og:image" content="https://rc1242rc.github.io/testbit/gambit_logo.png"><meta property="og:image:alt" content="GAMBIT"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content><meta name=twitter:creator content><meta name=twitter:title content="file src/SuperRenormHP.cpp"><meta name=twitter:description content="[No description available]"><meta name=twitter:image content="https://rc1242rc.github.io/testbit/gambit_logo.png"><meta name=twitter:image:alt content="file src/SuperRenormHP.cpp"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://rc1242rc.github.io/#/schema/organization/1","name":"Doks","url":"https://rc1242rc.github.io/","sameAs":["https://github.com/GambitBSM"],"logo":{"@type":"ImageObject","@id":"https://rc1242rc.github.io/#/schema/image/1","url":"https://rc1242rc.github.io/logo-doks.png","width":450,"height":416,"caption":"Doks"},"image":{"@id":"https://rc1242rc.github.io/#/schema/image/1"}},{"@type":"WebSite","@id":"https://rc1242rc.github.io/#/schema/website/1","url":"https://rc1242rc.github.io/","name":"GAMBIT","description":"Documentation for the Global And Modular BSM Inference Tool","publisher":{"@id":"https://rc1242rc.github.io/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://rc1242rc.github.io/testbit/documentation/code/files/superrenormhp_8cpp/","url":"https://rc1242rc.github.io/testbit/documentation/code/files/superrenormhp_8cpp/","name":"file src\/SuperRenormHP.cpp","description":"[No description available]","isPartOf":{"@id":"https://rc1242rc.github.io/#/schema/website/1"},"about":{"@id":"https://rc1242rc.github.io/#/schema/organization/1"},"datePublished":"0001-01-01T00:00:00CET","dateModified":"0001-01-01T00:00:00CET","breadcrumb":{"@id":"https://rc1242rc.github.io/testbit/documentation/code/files/superrenormhp_8cpp/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://rc1242rc.github.io/testbit/documentation/code/files/superrenormhp_8cpp/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://rc1242rc.github.io/testbit/documentation/code/files/superrenormhp_8cpp/"]}]},{"@type":"BreadcrumbList","@id":"https://rc1242rc.github.io/testbit/documentation/code/files/superrenormhp_8cpp/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/testbit","url":"https://rc1242rc.github.io/testbit","name":"Home"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/testbit/documentation/","url":"https://rc1242rc.github.io/testbit/documentation/","name":"Documentation"}},{"@type":"ListItem","position":4,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/testbit/documentation/code/","url":"https://rc1242rc.github.io/testbit/documentation/code/","name":"Code"}},{"@type":"ListItem","position":5,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/testbit/documentation/code/files/","url":"https://rc1242rc.github.io/testbit/documentation/code/files/","name":"Files"}},{"@type":"ListItem","position":6,"item":{"@id":"https://rc1242rc.github.io/testbit/documentation/code/files/superrenormhp_8cpp/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://rc1242rc.github.io/testbit/documentation/code/files/superrenormhp_8cpp/#/schema/image/2","url":"https://rc1242rc.github.io/testbit/gambit_logo.png","contentUrl":"https://rc1242rc.github.io/testbit/gambit_logo.png","caption":"file src\/SuperRenormHP.cpp"}]}]}</script><meta name=theme-color content="#fff"><link rel=icon href=https://rc1242rc.github.io/testbit/favicon.ico sizes=any><link rel=icon type=image/svg+xml href=https://rc1242rc.github.io/testbit/favicon.svg><link rel=apple-touch-icon sizes=180x180 href=https://rc1242rc.github.io/testbit/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://rc1242rc.github.io/testbit/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://rc1242rc.github.io/testbit/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://rc1242rc.github.io/testbit/site.webmanifest></head><body class="documentation single light"><div class=sticky-top><div class=header-bar></div><header class="navbar navbar-expand-md navbar-light doks-navbar"><nav class="container-xxl flex-wrap flex-md-nowrap" aria-label="Main navigation"><a class="navbar-brand p-0 me-auto" href=/ aria-label=GAMBIT><img class=logo-light src=https://rc1242rc.github.io/testbit/images/gambit_logo.png width=50px>
<img class="logo-dark d-none" src=https://rc1242rc.github.io/testbit/images/gambit_logo.png width=50px>
GAMBIT</a>
<button class="btn btn-menu order-2 d-block d-lg-none" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasDoks aria-controls=offcanvasDoks aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><div class="offcanvas offcanvas-end border-0 py-lg-1" tabindex=-1 id=offcanvasDoks data-bs-backdrop=true aria-labelledby=offcanvasDoksLabel><div class="header-bar d-lg-none"></div><div class="offcanvas-header d-lg-none"><h2 class="h5 offcanvas-title ps-2" id=offcanvasDoksLabel><a class=text-dark href=/>GAMBIT</a></h2><button type=button class="btn-close text-reset me-2" data-bs-dismiss=offcanvas aria-label="Close main menu"></button></div><div class="offcanvas-body p-4 p-lg-0"><ul class="nav flex-column flex-lg-row align-items-lg-center mt-2 mt-lg-0 ms-lg-2 me-lg-auto"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Documentation
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/testbit/documentation/installation/introduction/>Installation</a></li><li><a class=dropdown-item href=/testbit/documentation/examples/colliderbit>Examples</a></li><li><a class=dropdown-item href=/testbit/documentation/help/faqs/>Help</a></li><li><a class=dropdown-item href=/testbit/documentation/code/index_classes>Code Reference</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Community
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/testbit/community/publications/>Publications</a></li><li><a class=dropdown-item href=/testbit/community/talks/>Talks</a></li><li><a class=dropdown-item href=/testbit/community/members/>Members</a></li><li><a class=dropdown-item href=/testbit/community/code_of_conduct/>Code of Conduct</a></li><li><a class=dropdown-item href=/testbit/community/contact/>Contact</a></li></ul></li></ul><hr class="text-black-50 my-4 d-lg-none"><form class="doks-search position-relative flex-grow-1 ms-lg-auto me-lg-2"><input id=search class="form-control is-search" type=search placeholder="Search site..." aria-label="Search site..." autocomplete=off><div id=suggestions class="shadow bg-white rounded d-none"></div></form><hr class="text-black-50 my-4 d-lg-none"><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=https://github.com/GambitBSM><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><small class="ms-2 d-lg-none">GitHub</small></a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn btn-doks-light dropdown-toggle" id=doks-versions data-bs-toggle=dropdown aria-expanded=false data-bs-display=static aria-label="Toggle version menu">
<span class=d-none>Doks</span> TestBit
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=doks-versions><li><a class=dropdown-item href=/maindevelopment/documentation/code/index_classes/>MainDevelopment</a></li><li><a class=dropdown-item href=/testbit/documentation/code/index_classes/>TestBit</a></li></ul></div></div></div></nav></header></div><div class="wrap container-xxl" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class=docs-links aria-label="Main navigation"><ul class="list-unstyled collapsible-sidebar"><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-installation aria-expanded=false>
Installation</button><div class=collapse id=section-installation><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/testbit/documentation/installation/introduction/>Getting Started</a></li><li><a class="docs-link rounded" href=/testbit/documentation/installation/docker_usage/>Docker Usage</a></li><li><a class="docs-link rounded" href=/testbit/documentation/installation/installation_for_linux/>Installation for Linux</a></li><li><a class="docs-link rounded" href=/testbit/documentation/installation/installation_for_windows/>Installation for Windows</a></li><li><a class="docs-link rounded" href=/testbit/documentation/installation/installation_for_macos/>Installation for macOS</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-examples aria-expanded=false>
Examples</button><div class=collapse id=section-examples><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/testbit/documentation/examples/colliderbit/>ColliderBit</a></li><li><a class="docs-link rounded" href=/testbit/documentation/examples/anotherbit/>AnotherBit</a></li><li><a class="docs-link rounded" href=/testbit/documentation/examples/anotherbit2/>AnotherBit2</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-help aria-expanded=false>
Help</button><div class=collapse id=section-help><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/testbit/documentation/help/faqs/>FAQs</a></li><li><a class="docs-link rounded" href=/testbit/documentation/help/compiler_matrix/>Compiler Matrix</a></li><li><a class="docs-link rounded" href=/testbit/documentation/help/known_issues/>Known Issues</a></li><li><a class="docs-link rounded" href=/testbit/documentation/help/configuration_examples/>Configuration Examples</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-code aria-expanded=false>
Code Reference</button><div class=collapse id=section-code><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/testbit/documentation/code/index_classes/>Classes</a></li><li><a class="docs-link rounded" href=/testbit/documentation/code/index_files/>Files</a></li><li><a class="docs-link rounded" href=/testbit/documentation/code/index_pages/>Pages</a></li><li><a class="docs-link rounded" href=/testbit/documentation/code/index_namespaces/>Namespaces</a></li></ul></div></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=d-xl-none><button class="btn btn-outline-primary btn-sm doks-toc-toggle collapsed" type=button data-bs-toggle=collapse data-bs-target=#onThisPage aria-controls=doks-docs-nav aria-expanded=false aria-label="Toggle On this page navigation">
<span>On this page</span>
<span><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"/><polyline points="7 6 12 11 17 6"/></svg><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"/><polyline points="17 18 12 13 7 18"/></svg></span></button><div class=collapse id=onThisPage><div class="card card-body mt-3 py-1"><div class=page-links><nav id=TableOfContents><ul><li><ul><li><a href=#detailed-description>Detailed Description</a></li><li><a href=#source-code>Source code</a></li></ul></li></ul></nav></div></div></div></div><div class="page-links d-none d-xl-block"><h3>On this page</h3><nav id=TableOfContents><ul><li><ul><li><a href=#detailed-description>Detailed Description</a></li><li><a href=#source-code>Source code</a></li></ul></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9 mx-xl-auto"><h1>file src/SuperRenormHP.cpp</h1><p class=lead></p><p>[No description available] <a href=#detailed-description>More&mldr;</a></p><h2 id=detailed-description>Detailed Description <a href=#detailed-description class=anchor aria-hidden=true>#</a></h2><p><strong>Author</strong>: Iñigo Saez Casares (<a href=mailto:inigo.saez_casares@ens-paris-saclay.fr>inigo.saez_casares@ens-paris-saclay.fr</a>)</p><p><strong>Date</strong>: 2019 December</p><p>Super Renormalizable Higgs Portal DM specific module functions for DarkBit</p><hr><p>Authors (add name and date if you modify):</p><hr><h2 id=source-code>Source code <a href=#source-code class=anchor aria-hidden=true>#</a></h2><pre><code>//   GAMBIT: Global and Modular BSM Inference Tool
//   *********************************************

// TODO: Temporarily disabled until project is ready
/*
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;math.h&gt;
#include &lt;type_traits&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;functional&gt;

#include &lt;gsl/gsl_math.h&gt;
#include &lt;gsl/gsl_errno.h&gt;
#include &lt;gsl/gsl_rng.h&gt;
#include &lt;gsl/gsl_monte_plain.h&gt;
#include &lt;gsl/gsl_monte_vegas.h&gt;
#include &lt;gsl/gsl_integration.h&gt;
#include &lt;gsl/gsl_min.h&gt;
#include &lt;gsl/gsl_interp.h&gt;
#include &lt;gsl/gsl_spline.h&gt;
#include &lt;gsl/gsl_sf_bessel.h&gt;

#include &quot;gambit/Elements/gambit_module_headers.hpp&quot;
#include &quot;gambit/Elements/spectrum_helpers.hpp&quot;
#include &quot;gambit/Utils/util_functions.hpp&quot;
#include &quot;gambit/Utils/ascii_table_reader.hpp&quot;
#include &quot;gambit/Utils/numerical_constants.hpp&quot;
#include &quot;gambit/Utils/statistics.hpp&quot;
#include &quot;gambit/DarkBit/DarkBit_rollcall.hpp&quot;
#include &quot;gambit/DarkBit/DarkBit_utils.hpp&quot;

namespace Gambit
{
  namespace DarkBit
  {

    //                                                                //
    //      General Functions and Classes for Higgs Portal DM         //
    //                                                                //

    // \brief Supporting classes and functions for the Higgs Portal DM module.
    

    //------------- Numerical constants and other useful things -------------//

    // masses
    const double Mp = Gambit::m_planck; // Planck mass [GeV]
    const double me = Gambit::m_electron*1e9; // electron mass [eV]
    const double mH = 125.1*1e9; // Higgs boson mass [eV] (PDG 2019)
    const double mT = 172.9*1e9; // top quark mass [eV] (PDG 2019)

    // mathematical constants
    const double pi=Gambit::pi;

    // physical constants
    const double alphaEM = Gambit::alpha_EM; // fine structure constant
    const double alphaS = pi; // strong coupling constant, don't use this (take from spectrum)
    const double v = 246e9; // electroweak vev [eV]
    const double hbar_GeV = Gambit::hbar; // reduced Planck constant [GeV.s]
    const double hbar_eV = Gambit::hbar*1e9; // reduced Planck constant [eV.s]
    const double hbar_cgs = 1.054571818e-27; // reduced Planck constant [cgs]
    const double cs = Gambit::s2cm; // speed of light [cm/s]
    const double kb = Gambit::K2eV; // Boltzmann constant [eV/K]
    const double G_cgs = 6.674e-8; // Gravitational constant [cm³/g/s²]
    const double G_SI = 6.674e-11; // Gravitational constant [m³/kg/s²]
    const double Mpc_2_km = 3.0857e19; // Mpc to km
    const double kg_2_GeV = 1.7827e27; // kg to GeV

    // cosmological constants
    const double s0(2891); // current entropy density [1/cm³]
    // const double rhoC(4.84e3); // current critical density [eV/cm³]

    // astrophysical constants
    const double r0(26.2225e21); // Sun's distance from the galactic center [cm]
    const double Rsun(5.9598e10); // Solar radius [cm]
    const double L0 = 2.388672e45; // solar photon luminosity [eV/s]
    const double rho0(0.3e9); // local DM density (Milky Way) [eV/cm³]

    // other constants
    const double C(50./27.); // loop function from the decay of the Higgs boson into two photons

    // Minimum finite result returnable from log(double x);
    const double logmin = log(std::numeric_limits&lt;double&gt;::min());




    //            Support class to handle Solar models                //

    // gsl error handler
    void handler_Ls (const char * reason, const char * file, int line, int gsl_errno)
    {
      if (gsl_errno == 15)
      {
        throw gsl_errno;
      }

      if (gsl_errno == 1)
      {
        std::cerr &lt;&lt; &quot;gsl: &quot; &lt;&lt; file &lt;&lt; &quot;:&quot; &lt;&lt; line &lt;&lt; &quot;: ERROR: &quot; &lt;&lt; reason &lt;&lt; &quot; and  gsl_errno = &quot; &lt;&lt; gsl_errno &lt;&lt; std::endl;
        std::cerr &lt;&lt; &quot;it seems like you are trying to scan DM masses &lt;= 0.5eV, solar neutrino likelihoods only work for DM masses &gt; mMin = 0.5eV!&quot; &lt;&lt; std::endl;
        std::cerr &lt;&lt; &quot;if you want to change the value of mMin, you can do it from DarkBit/src/SuperRenormHP.cpp and recompute the interpolation tables(delete the existing one and it will be done automatically), but be careful to check to convergence with the new values! you may have to increase the number of points in the interpolation routine&quot; &lt;&lt; std::endl;
      }
      else { std::cerr &lt;&lt; &quot;gsl: &quot; &lt;&lt; file &lt;&lt; &quot;:&quot; &lt;&lt; line &lt;&lt; &quot;: ERROR: &quot; &lt;&lt; reason &lt;&lt; &quot; and  gsl_errno = &quot; &lt;&lt; gsl_errno &lt;&lt; std::endl; abort(); }
    }

    const double da = 1.66053906660e-24; // dalton to g


    class StellarModel
    {
      public :

        StellarModel (std::string datafile);

        double sigmaL (double const&amp; w, double const&amp; r);
        double getQuantity (std::string const&amp; quantity, double const&amp; r);
        double L_integrated (double const&amp; mS);
        void Ls_interpolate ();
        double Ls (double const&amp; mS, double const&amp; theta);
        double PhiB8 (double const&amp; mS, double const&amp; theta);

        ~StellarModel();

      private :

        int m_nbins;
        const std::vector&lt;std::string&gt; m_names = {&quot;Mass&quot;, &quot;Radius&quot;, &quot;Temp&quot;, &quot;Rho&quot;, &quot;Pres&quot;, &quot;Lumi&quot;, &quot;H1&quot;, &quot;He4&quot;, &quot;He3&quot;, &quot;C12&quot;, &quot;C13&quot;, &quot;N14&quot;, &quot;N15&quot;, &quot;O16&quot;, &quot;O17&quot;, &quot;O18&quot;, &quot;Ne&quot;, &quot;Na&quot;, &quot;Mg&quot;, &quot;Al&quot;, &quot;Si&quot;, &quot;P&quot;, &quot;S&quot;, &quot;Cl&quot;, &quot;Ar&quot;, &quot;K&quot;, &quot;Ca&quot;, &quot;Sc&quot;, &quot;Ti&quot;, &quot;V&quot;, &quot;Cr&quot;, &quot;Mn&quot;, &quot;Fe&quot;, &quot;Co&quot;, &quot;Ni&quot;};
        const std::vector&lt;std::string&gt; m_elements = {&quot;H1&quot;, &quot;He4&quot;, &quot;He3&quot;, &quot;C12&quot;, &quot;C13&quot;, &quot;N14&quot;, &quot;N15&quot;, &quot;O16&quot;, &quot;O17&quot;, &quot;O18&quot;, &quot;Ne&quot;, &quot;Na&quot;, &quot;Mg&quot;, &quot;Al&quot;, &quot;Si&quot;, &quot;P&quot;, &quot;S&quot;, &quot;Cl&quot;, &quot;Ar&quot;, &quot;K&quot;, &quot;Ca&quot;, &quot;Sc&quot;, &quot;Ti&quot;, &quot;V&quot;, &quot;Cr&quot;, &quot;Mn&quot;, &quot;Fe&quot;, &quot;Co&quot;, &quot;Ni&quot;};
        // Ionisation of species i assuming full ionisation.
        const std::vector&lt;double&gt; m_Z = {1.0, 2.0, 2.0, 6.0, 6.0, 7.0, 7.0, 8.0, 8.0, 8.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0, 18.0, 19.0, 20.0, 21.0, 22.0, 23.0, 24.0, 25.0, 26.0, 27.0, 28.0};
        // Atomic weight of species i (exact weight if isotope is known OR estimate from average solar abundance from data if available OR estimate from natural terrestrial abundance).
        const std::vector&lt;double&gt; m_A = {1.007825, 4.002603, 3.016029, 12.000000, 13.003355, 14.003074, 15.000109, 15.994915, 16.999132, 17.999160, 20.1312812, 22.989769, 24.3055, 26.9815385, 28.085, 30.973762, 32.0675, 35.4515, 36.275403, 39.0983, 40.078, 44.955908, 47.867, 50.9415, 51.9961, 54.938044, 55.845, 58.933194, 58.6934};

        ASCIItableReader m_model;
        std::map&lt;std::string, gsl_spline*&gt; m_interp;
        std::map&lt;std::string, gsl_interp_accel*&gt; m_acc;

        gsl_spline * m_Ls_interp;
        gsl_interp_accel * m_Ls_accel;

        const std::vector&lt;std::string&gt; m_quantities = {&quot;Temp&quot;, &quot;wp&quot;, &quot;ne&quot;, &quot;SumNz&quot;};

    };

    StellarModel::StellarModel (std::string datafile)
    {
      m_model = ASCIItableReader(datafile);
      m_model.setcolnames(m_names);

      m_nbins = m_model[&quot;Mass&quot;].size();

      std::vector&lt;double&gt; T, wp, ne, SumNz;

      double sumz, temp, sumz2;

      for (int i=0; i&lt;m_nbins; ++i)
      {

        sumz = 0;
        sumz2 = 0;

        for (size_t j=0; j&lt;m_elements.size(); ++j)
        {
          sumz += m_Z[j]*m_model[m_elements[j]][i]/m_A[j]/da*m_model[&quot;Rho&quot;][i];
          sumz2 += m_Z[j]*m_Z[j]*m_model[m_elements[j]][i]/m_A[j]/da*m_model[&quot;Rho&quot;][i];
        }

        temp = m_model[&quot;Temp&quot;][i]*kb;

        T.push_back(temp);
        wp.push_back(sqrt(4*pi*alphaEM*sumz*cs*cs*cs*hbar_eV*hbar_eV*hbar_eV/me));
        ne.push_back(sumz);
        SumNz.push_back(sumz2);

      }

      std::map&lt;std::string, std::vector&lt;double&gt;&gt; quantities;

      quantities[&quot;Temp&quot;] = T;
      quantities[&quot;wp&quot;] = wp;
      quantities[&quot;ne&quot;] = ne;
      quantities[&quot;SumNz&quot;] = SumNz;

      const double * rr = m_model[&quot;Radius&quot;].data();

      for (auto it=m_quantities.begin(); it!=m_quantities.end(); ++it)
      {
        m_interp[*it] = gsl_spline_alloc(gsl_interp_cspline, m_nbins);
        m_acc[*it] = gsl_interp_accel_alloc();
        gsl_spline_init(m_interp[*it], rr, quantities[*it].data(), m_nbins);
      }

      Ls_interpolate();
    }

    // function returning the interpolated quantities (Temp, wp, ne SumNz) at a given radius r inside the Sun
    double StellarModel::getQuantity (std::string const&amp; quantity, double const&amp; r)
    {
      return gsl_spline_eval(m_interp[quantity], r, m_acc[quantity]);
    }

    // function to compute the damping rate of longitudinal photons inside the Sun (inverse bremsstrahlung)
    double StellarModel::sigmaL (double const&amp; w, double const&amp; r)
    {
      double result = 0;

      double temp = getQuantity(&quot;Temp&quot;, r), ne = getQuantity(&quot;ne&quot;, r), wp = getQuantity(&quot;wp&quot;, r);
      double D = 64*pow(pi, 2)*pow(alphaEM, 3)*ne*getQuantity(&quot;SumNz&quot;, r);
      double N = 3*sqrt(2*pi*temp)*pow(me, 3./2.)*pow(w, 3);

      double x = w/2./temp;

      // tries to use the gsl_sf_bessel_K0 and sinh functions (fails if x is too big)
      try
      {
        double F = gsl_sf_bessel_K0(x)*sinh(x);
        result += D/N*F*pow(cs, 6)*pow(hbar_eV, 6);
      }

      // uses a first order development at high x instead of the full functions
      catch (int gsl_errno)
      {
        double F = sqrt(pi/2./x)*(1-(1/8./x));
        result += D/N*F*pow(cs, 6)*pow(hbar_eV, 6);
      }

      if (w &gt; wp) { result += 8*pi*pow(alphaEM, 2)*ne*sqrt(1-pow(wp/w, 2))/pow(me, 3)/3.*pow(cs, 3)*pow(hbar_eV, 3); }

      return result;
    }

    StellarModel::~StellarModel()
    {
      for (auto it=m_quantities.begin(); it!=m_quantities.end(); ++it)
      {
        gsl_spline_free (m_interp[*it]);
        gsl_interp_accel_free(m_acc[*it]);
      }
    }

    struct my_f_params { double mS; StellarModel *model; };

    // function to be integrated for mS &lt; w &lt; inf and 0 &lt; r &lt; R0
    double myF (double const&amp; w, double const&amp; r, my_f_params *params)
    {
      StellarModel *model = params-&gt;model;
      double mS = params-&gt;mS;
      double N1, N2, D1, D2, D3;

      N1 = pow((w*w-mS*mS), 3./2.)*w*w;
      N2 = w*w*model-&gt;sigmaL(w, r);

      D1 = pow(2*pi, 3)*alphaEM;
      D2 = exp(w/model-&gt;getQuantity(&quot;Temp&quot;, r))-1;
      D3 = pow(w*model-&gt;sigmaL(w, r), 2)+pow(w*w-pow(model-&gt;getQuantity(&quot;wp&quot;, r), 2), 2);

      return N1*N2*pow(r, 2)/D1/D2/D3;
    }

    // gsl integrand remapped from (ms, +infinity) to (0, 1)
    double integrand (double x[], size_t dim, void *p)
    {
      struct my_f_params *params = (struct my_f_params *)p;
      (void)(dim);

      double mS = params-&gt;mS;

      double t = x[0], r = x[1];

      return myF(mS + (1-t)/t, r, params)/pow(t, 2);
    }

    const double mSmax = 1e5; // maximum mass up to which Ls is computed, for higher masses Ls is set to zero manually in the capability function

    double StellarModel::L_integrated (double const&amp; mS)
    {
      const size_t dim = 2, calls = 1e5;
      double  xl[dim] = {0, 0.0006}, xu[dim] = {1, 0.9995};
      double result, abserr;

      gsl_monte_vegas_state *s = gsl_monte_vegas_alloc(dim);
      gsl_monte_vegas_init(s);

      gsl_rng *r = gsl_rng_alloc(gsl_rng_taus2);

      gsl_monte_function F;

      my_f_params params = {mS, this};

      F.f = &amp;integrand;
      F.dim = dim;
      F.params = &amp;params;

      gsl_monte_vegas_integrate(&amp;F, xl, xu, dim, 1e4, r, s, &amp;result, &amp;abserr);
      do
      {
        gsl_monte_vegas_integrate (&amp;F, xl, xu, dim, calls, r, s,
                                   &amp;result, &amp;abserr);
        std::cout &lt;&lt; mS &lt;&lt; &quot; &quot; &lt;&lt; result &lt;&lt; &quot; &quot; &lt;&lt; abserr/result &lt;&lt; &quot; &quot; &lt;&lt; gsl_monte_vegas_chisq (s) &lt;&lt; std::endl;
      }
    while ( (fabs (gsl_monte_vegas_chisq (s) - 1.0) &gt; 0.2) or (abserr/result &gt; 1e-3));

      std::cout &lt;&lt; &quot;Final: &quot; &lt;&lt; mS &lt;&lt; &quot; &quot; &lt;&lt; result &lt;&lt; &quot; &quot; &lt;&lt; abserr/result &lt;&lt; &quot; &quot; &lt;&lt; gsl_monte_vegas_chisq (s) &lt;&lt; std::endl;

      gsl_monte_vegas_free(s);

      return 4*pi*pow(Rsun, 3)*result/pow(cs, 3)/pow(hbar_eV, 4);
    }

    void StellarModel::Ls_interpolate ()
    {
      const int nPoints = 100;
      const double mMin = 5e-4, mMax = mSmax;
      const double deltaM = log10(mMax/mMin)/nPoints;
      const std::string filename = GAMBIT_DIR &quot;/DarkBit/data/SuperRenormHP_Ls.dat&quot;;
      std::vector&lt;double&gt; mS, Ls;

      // checks if an interpolation table file for Ls already exists and reads it if that is the case
      if (Utils::file_exists(filename))
      {
        ASCIItableReader table = ASCIItableReader(filename);
        table.setcolnames({&quot;mS&quot;, &quot;Ls&quot;});
        mS = table[&quot;mS&quot;];
        Ls = table[&quot;Ls&quot;];
      }

      // builds an interpolation table for Ls and writes it in a file
      else
      {
        for (int i=0; i&lt;=nPoints; ++i)
        {
          mS.push_back(mMin*pow(10, deltaM*i));
        }

        for (auto it=mS.begin(); it!=mS.end(); ++it)
        {
          Ls.push_back(L_integrated(*it));
        }

        std::ofstream fout (filename.c_str());

        for (size_t i=0; i&lt;mS.size(); ++i)
        {
          fout &lt;&lt; mS[i] &lt;&lt; &quot;  &quot; &lt;&lt; Ls[i] &lt;&lt; std::endl;
        }

        fout.clear(); fout.close();
      }

      // interpolates Ls from the interpolation table
      m_Ls_interp = gsl_spline_alloc(gsl_interp_cspline, nPoints+1);
      m_Ls_accel = gsl_interp_accel_alloc();
      gsl_spline_init(m_Ls_interp, mS.data(), Ls.data(), nPoints+1);
    }

    // returns the value of the interpolated Ls for a given set of parameters (mS, theta)
    double StellarModel::Ls (double const&amp; mS, double const&amp; theta)
    {
      return gsl_spline_eval(m_Ls_interp, mS, m_Ls_accel)*pow(me/v*theta, 2);
    }

    //                   Capability functions                         //

    //------------- Process catalogue -------------//

    void TH_ProcessCatalog_SuperRenormHP(DarkBit::TH_ProcessCatalog &amp;result)
    {
      using namespace Pipes::TH_ProcessCatalog_SuperRenormHP;
      using std::vector;
      using std::string;

      // Initialize empty catalog and decay channel
      TH_ProcessCatalog catalog;
      TH_Process process_dec(&quot;S&quot;);

      // Import particle masses and couplings

      // Convenience macros
      #define getSMmass(Name, spinX2)                                           \
       catalog.particleProperties.insert(std::pair&lt;string, TH_ParticleProperty&gt; \
       (Name , TH_ParticleProperty(SM.get(Par::Pole_Mass,Name), spinX2)));
      #define addParticle(Name, Mass, spinX2)                                   \
       catalog.particleProperties.insert(std::pair&lt;string, TH_ParticleProperty&gt; \
       (Name , TH_ParticleProperty(Mass, spinX2)));

      // Import Spectrum objects
      const Spectrum&amp; spec  = *Dep::SuperRenormHP_spectrum;
      const SubSpectrum&amp; he = spec.get_HE();
      const SubSpectrum&amp; SM = spec.get_LE();
      const SMInputs&amp; SMI   = spec.get_SMInputs();

      // Import couplings
      double theta = he.get(Par::dimensionless, &quot;theta&quot;);
      double vev = he.get(Par::mass1,&quot;vev&quot;);
      double C = 50./27.; // loop factor for the decay into two photons
      double alpha = 1./SMI.alphainv; // alpha_EM(mZ)^MSbar (5 active flavours)

      // Get SM pole masses
      getSMmass(&quot;e-_1&quot;,     1)
      getSMmass(&quot;e+_1&quot;,     1)
      getSMmass(&quot;e-_2&quot;,     1)
      getSMmass(&quot;e+_2&quot;,     1)
      getSMmass(&quot;e-_3&quot;,     1)
      getSMmass(&quot;e+_3&quot;,     1)
      getSMmass(&quot;Z0&quot;,     2)
      getSMmass(&quot;W+&quot;,     2)
      getSMmass(&quot;W-&quot;,     2)
      getSMmass(&quot;g&quot;,      2)
      getSMmass(&quot;gamma&quot;,  2)
      getSMmass(&quot;u_3&quot;,      1)
      getSMmass(&quot;ubar_3&quot;,   1)
      getSMmass(&quot;d_3&quot;,      1)
      getSMmass(&quot;dbar_3&quot;,   1)

      // Pole masses not available for the light quarks.
      addParticle(&quot;u_1&quot;   , SMI.mU,  1) // mu(2 GeV)^MS-bar, not pole mass
      addParticle(&quot;ubar_1&quot;, SMI.mU,  1) // mu(2 GeV)^MS-bar, not pole mass
      addParticle(&quot;d_1&quot;   , SMI.mD,  1) // md(2 GeV)^MS-bar, not pole mass
      addParticle(&quot;dbar_1&quot;, SMI.mD,  1) // md(2 GeV)^MS-bar, not pole mass
      addParticle(&quot;u_2&quot;   , SMI.mCmC,1) // mc(mc)^MS-bar, not pole mass
      addParticle(&quot;ubar_2&quot;, SMI.mCmC,1) // mc(mc)^MS-bar, not pole mass
      addParticle(&quot;d_2&quot;   , SMI.mS,  1) // ms(2 GeV)^MS-bar, not pole mass
      addParticle(&quot;dbar_2&quot;, SMI.mS,  1) // ms(2 GeV)^MS-bar, not pole mass
      // double alpha_s = SMI.alphaS;      // alpha_s(mZ)^MSbar

      // Masses for neutrino flavour eigenstates. Set to zero.
      // (presently not required)
      addParticle(&quot;nu_e&quot;,     0.0, 1)
      addParticle(&quot;nubar_e&quot;,  0.0, 1)
      addParticle(&quot;nu_mu&quot;,    0.0, 1)
      addParticle(&quot;nubar_mu&quot;, 0.0, 1)
      addParticle(&quot;nu_tau&quot;,   0.0, 1)
      addParticle(&quot;nubar_tau&quot;,0.0, 1)

      // Higgs-sector masses
      double mS = spec.get(Par::Pole_Mass,&quot;S&quot;);
      double mH = spec.get(Par::Pole_Mass,&quot;h0_1&quot;);
      addParticle(&quot;S&quot;,        mS, 0)  // Scalar DM
      addParticle(&quot;h0_1&quot;,     mH, 0)  // SM-like Higgs
      addParticle(&quot;pi0&quot;,   meson_masses.pi0,       0)
      addParticle(&quot;pi+&quot;,   meson_masses.pi_plus,   0)
      addParticle(&quot;pi-&quot;,   meson_masses.pi_minus,  0)
      addParticle(&quot;eta&quot;,   meson_masses.eta,       0)
      addParticle(&quot;rho0&quot;,  meson_masses.rho0,      1)
      addParticle(&quot;rho+&quot;,  meson_masses.rho_plus,  1)
      addParticle(&quot;rho-&quot;,  meson_masses.rho_minus, 1)
      addParticle(&quot;omega&quot;, meson_masses.omega,     1)

      // Get rid of convenience macros
      #undef getSMmass
      #undef addParticle


      // decay into two photons (through a loop of heavy fermions)
      double gamma_ph = (theta*theta*alpha*alpha*mS*mS*mS*C*C)/(256.*pi*pi*pi*vev*vev);

      TH_Channel dec_channel_ph(daFunk::vec&lt;string&gt;(&quot;gamma&quot;, &quot;gamma&quot;), daFunk::cnst(gamma_ph));
      process_dec.channelList.push_back(dec_channel_ph);

      // decay into e+/e- pair
      double me1 = SM.get(Par::Pole_Mass,&quot;e-_1&quot;);
      double gamma_e1 = ( mS &gt;= 2*me1 ) ? pow(theta,2)*pow(me1,2)*mS/(8*pi*pow(vev,2))*pow(1 - 4*pow(me1,2)/pow(mS,2), 3./2.) : 0;

      TH_Channel dec_channel_e1(daFunk::vec&lt;string&gt;(&quot;e-_1&quot;, &quot;e+_1&quot;), daFunk::cnst(gamma_e1));
      process_dec.channelList.push_back(dec_channel_e1);

      // decay into mu+/mu- pair
      double me2 = SM.get(Par::Pole_Mass,&quot;e-_2&quot;);
      double gamma_e2 = ( mS &gt;= 2*me2 ) ? pow(theta,2)*pow(me2,2)*mS/(8*pi*pow(vev,2))*pow(1 - 4*pow(me2,2)/pow(mS,2), 3./2.) : 0;

      TH_Channel dec_channel_e2(daFunk::vec&lt;string&gt;(&quot;e-_2&quot;, &quot;e+_2&quot;), daFunk::cnst(gamma_e2));
      process_dec.channelList.push_back(dec_channel_e2);

      // Import Decay information //

      // Import decay table from DecayBit
      const DecayTable* tbl = &amp;(*Dep::decay_rates);

      // Set of imported decays
      std::set&lt;string&gt; importedDecays;

      // Minimum branching ratio
      double minBranching = 0.;

      // Import relevant decays (only Higgs and subsequent decays)
      using DarkBit_utils::ImportDecays;
      // Notes: Virtual Higgs decays into offshell W+W- final states are not
      // imported.  All other channels are correspondingly rescaled.  Decay
      // into SS final states is accounted for, leading to zero photons.
      ImportDecays(&quot;h0_1&quot;, catalog, importedDecays, tbl, minBranching, daFunk::vec&lt;std::string&gt;(&quot;Z0&quot;, &quot;W+&quot;, &quot;W-&quot;));

      // Add the decay process to the catalog
      catalog.processList.push_back(process_dec);

      // Validate
      // catalog.validate();

      result = catalog;
    } // function TH_ProcessCatalog_SuperRenormHP

    // capability function to provide the initial energy density as produced by the freeze-in mechanism (in GeV/cm^3)
    void SuperRenormHP_relic_density (double &amp;result)
    {
      using namespace Pipes::SuperRenormHP_relic_density;
      double mS = *Param[&quot;mS&quot;], theta = *Param[&quot;theta&quot;];
      double lambda = *Param[&quot;lambda&quot;];

      result = lambda*theta*theta*s0*mS*1e11;
    }

    // capability function to provide the total width of the S scalar (in GeV)
    void SuperRenormHP_width (double &amp;result)
    {
      using namespace Pipes::SuperRenormHP_width;

      result = 0.;

      std::string DM_ID = *Dep::DarkMatter_ID;
      TH_ProcessCatalog catalog = *Dep::TH_ProcessCatalog;

      // Check whether the process catalog has the decay prosses
      if (Dep::TH_ProcessCatalog-&gt;find(DM_ID) != NULL)
      {
        // decay S -&gt; gamma gamma
        const TH_Channel* dec_channel_ph = catalog.getProcess(DM_ID).find({&quot;gamma&quot;, &quot;gamma&quot;});
        if (dec_channel_ph != NULL)
        {
          result += dec_channel_ph-&gt;genRate-&gt;bind()-&gt;eval();
        }

        // decay S -&gt; e-_1 e+_1
        const TH_Channel* dec_channel_e1 = catalog.getProcess(DM_ID).find({&quot;e-_1&quot;, &quot;e+_1&quot;});
        if (dec_channel_e1 != NULL)
        {
          result += dec_channel_e1-&gt;genRate-&gt;bind()-&gt;eval();
        }

        // decay S -&gt; e-_2 e+_2
        const TH_Channel* dec_channel_e2 = catalog.getProcess(DM_ID).find({&quot;e-_2&quot;, &quot;e+2&quot;});
        if (dec_channel_e2 !=NULL)
        {
          result += dec_channel_e2-&gt;genRate-&gt;bind()-&gt;eval();
        }
      }

    }

    // capability function to provide the lifetime of the S scalar (in s)
    void SuperRenormHP_lifetime (double &amp;result)
    {
      using namespace Pipes::SuperRenormHP_lifetime;

      double width = *Dep::DM_width;

      result = 1/width*hbar_GeV;
    }

    void RD_oh2_SuperRenormHP (double &amp;result)
    {
      using namespace Pipes::RD_oh2_SuperRenormHP;

      double RD = *Dep::DM_relic_density;

      double rhoC_over_h2 = 3*pow(100/Mpc_2_km, 2)*pow(Mp, 2)/(8*pi)/hbar_GeV/pow(cs, 3); // critical density un Gev/cm^3

      result = RD/rhoC_over_h2;
    }

    //------------- Functions to compute stellar cooling likelihoods -------------//

    // capability function to compute the solar DM luminosity
    void SuperRenormHP_solar_luminosity (double &amp;result)
    {
      using namespace Pipes::SuperRenormHP_solar_luminosity;
      const double mS = *Param[&quot;mS&quot;]*1e9, theta = *Param[&quot;theta&quot;];

      gsl_error_handler_t *old_handler = gsl_set_error_handler (&amp;handler_Ls);

      static StellarModel model (GAMBIT_DIR &quot;/DarkBit/data/SolarModel_AGSS09met.dat&quot;);

      if (mS &lt; mSmax) { result = model.Ls(mS, theta); }

      else { result = 0; }

      gsl_set_error_handler (old_handler);
    }

    // capability function to compute the likelihood from the solar luminosity limit ( L_DM &lt; 0.1*L0 ) (conservative limit)
    void calc_lnL_solar_luminosity (double &amp;result)
    {
      using namespace Pipes::calc_lnL_solar_luminosity;

      const double limit = 0.1*L0;
      const double Ls = *Dep::solar_DM_luminosity;

      if (Ls &gt; limit) { result = logmin; }

      else { result = 0; }
    }

    // values for the observed and SSM predicted neutrni fluxes as well as the corresponding errors taken from: arXiv:1605.06502v2
    // capability function to compute the predicted solar neutrino flux (B8)
    void SuperRenormHP_solar_neutrino_flux_B8 (double &amp;result)
    {
      using namespace Pipes::SuperRenormHP_solar_neutrino_flux_B8;

      const double Ls = *Dep::solar_DM_luminosity;
      const double alpha = *Param[&quot;alpha&quot;];

      const double Phi0 = 4.95e6;

      result = Phi0*pow(1+Ls/L0, alpha);
    }

    // capability function to compute the predicted solar neutrino flux (Be7)
    void SuperRenormHP_solar_neutrino_flux_Be7 (double &amp;result)
    {
      using namespace Pipes::SuperRenormHP_solar_neutrino_flux_Be7;

      const double Ls = *Dep::solar_DM_luminosity;
      const double alpha = *Param[&quot;alpha&quot;];

      const double Phi0 = 4.71e9;

      result = Phi0*pow(1+Ls/L0, alpha);
    }

    // capability function to compute the likelihood from the solar B8 neutrino flux
    void calc_lnL_solar_neutrino_B8 (double &amp;result)
    {
      using namespace Pipes::calc_lnL_solar_neutrino_B8;

      const bool profile = runOptions-&gt;getValueOrDef&lt;bool&gt;(false, &quot;profile_systematics&quot;);
      const double Phi_predicted = *Dep::solar_neutrino_flux_B8;

      const double Phi_obs = 5e6;
      const double sigma_obs = 0.03*Phi_obs, sigma_theo = 0.14*Phi_predicted;

      result = Stats::gaussian_loglikelihood(Phi_predicted, Phi_obs, sigma_theo, sigma_obs, profile);
    }

    // capability function to compute the likelihood from the solar Be7 neutrino flux
    void calc_lnL_solar_neutrino_Be7 (double &amp;result)
    {
      using namespace Pipes::calc_lnL_solar_neutrino_Be7;

      const bool profile = runOptions-&gt;getValueOrDef&lt;bool&gt;(false, &quot;profile_systematics&quot;);
      const double Phi_predicted = *Dep::solar_neutrino_flux_Be7;

      const double Phi_obs = 4.82e9;
      const double sigma_obs = 0.05*Phi_obs, sigma_theo = 0.07*Phi_predicted;

      result = Stats::gaussian_loglikelihood(Phi_predicted, Phi_obs, sigma_theo, sigma_obs, profile);
    }

    //------------- Functions to compute short range forces likelihoods -------------//

    // capability to provide the Higgs-Nucleon coupling constant fN, such as described in arXiv:1306.4710
    void func_Higgs_Nucleon_coupling_fN (Higgs_Nucleon_coupling_fN &amp;result)
    {
      using namespace Pipes::func_Higgs_Nucleon_coupling_fN;

      const double sigmas = *Param[&quot;sigmas&quot;]*1e-3, sigmal = *Param[&quot;sigmal&quot;]*1e-3; // nuclear parameters in GeV (model input in MeV)
      const Spectrum SM = *Dep::SM_spectrum; // SM spectrum needed to get light quark masses

      const double z = 1.49; // isospin breaking ratio
      const double mu = SM.get(Par::mass1, &quot;u_1&quot;), md = SM.get(Par::mass1, &quot;d_1&quot;), ms = SM.get(Par::mass1, &quot;d_2&quot;); // light quark masses [GeV]
      const double mn = Gambit::m_neutron, mp = Gambit::m_proton; // nucleon masses [GeV]

      // intermediate quantities
      const double ml = 0.5*(mu+md);
      const double sigma0 = sigmal - sigmas*(2.*ml/ms);;
      const double y = 1 - sigma0/sigmal;

      std::vector&lt;double&gt; fu, fd, fs, mN = {mn, mp};

      for (size_t i(0); i&lt;mN.size(); ++i)
      {
        fu.push_back(mu/(mu+md)*sigmal/mN[i]*(2*z+y*(1-z))/(1+z));
        fd.push_back(md/(mu+md)*sigmal/mN[i]*(2-y*(1-z))/(1+z));
        fs.push_back(ms/(mu+md)*sigmal/mN[i]*y);
      }

      result.neutron =  2./9. + 7./9.*(fu[0]+fd[0]+fs[0]);
      result.proton  =  2./9. + 7./9.*(fu[1]+fd[1]+fs[1]);
    }

    // Modified Inverse-Square Law (ISL) by adding a new Yukawa potential to the Newtonian gravitational potential: Vnew(r) = -(alpha*G*m1*m2)/r * exp(-r/lambda)
    // where alpha is the strenght of the new force and lambda its range

    // experimental parameters from Sushkov et al. 2011 arXiv:1108.2547
    const double rhoAu = 19, rhoTi = 4.5, rhog = 2.6, dAu = 700e-8, dTi = 100e-8, R = 15.6; // in cgs units

    // capability function returning the new force from the SuperRenormHP model for the experiment from Shuskov et al. 2011
    void New_Force_Sushkov2011_SuperRenormHP (daFunk::Funk &amp;result)
    {
      using namespace Pipes::New_Force_Sushkov2011_SuperRenormHP;

      if (ModelInUse(&quot;symmetron&quot;))
      {
        const double powv = *Param[&quot;vval&quot;], powmu = *Param[&quot;mu&quot;];
        double vval = pow(10, powv)*Gambit::m_planck_red, mu = pow(10, powmu);

        double Rad = 16.5; // sphere radius in cm
        double muR = mu*Rad/Gambit::gev2cm; // dimensionless term
        daFunk::Funk d = daFunk::var(&quot;d&quot;); // separation between plates
        daFunk::Funk mux = d*1e-6/(Gambit::gev2cm*1e-2)*mu+muR;

        double GeV2Newtons = 8.19e5; // Newton/GeV^2

        daFunk::Funk force = 4.*M_PI*vval*vval*muR/sqrt(2)*tanh(mux/sqrt(2))*pow(1./cosh(mux/sqrt(2)),2.0) * GeV2Newtons; // take neg of force??
        result = force;
      }
      else
      {
        const double alpha = *Param[&quot;alpha&quot;], lambda = *Param[&quot;lambda&quot;]*1e2; // lambda in cm

        daFunk::Funk d = daFunk::var(&quot;d&quot;);

        daFunk::Funk force = 4*pow(pi, 2)*G_cgs*R*alpha*pow(lambda, 3)*exp(-d/lambda)*pow(rhoAu + (rhoTi-rhoAu)*exp(-dAu/lambda) + (rhog-rhoTi)*exp(-(dAu+dTi)/lambda), 2)*1e-5; // *1e-5 conversion from dyn(cgs) to N (SI)
        result = force;
      }

    }

    // capability function to compute the likelihood from Sushkov et al. 2011
    void calc_lnL_ShortRangeForces_Sushkov2011 (double &amp;result)
    {
      using namespace Pipes::calc_lnL_ShortRangeForces_Sushkov2011;

      daFunk::Funk ForceNew = *Dep::New_Force_Sushkov2011*1e12; // new force in pN

      static ASCIItableReader data = ASCIItableReader(GAMBIT_DIR &quot;/DarkBit/data/ShortRangeForces/Sushkov2011.dat&quot;);
      data.setcolnames({&quot;distance&quot;, &quot;Fres&quot;, &quot;sigma&quot;, &quot;binWidth&quot;});
      static std::vector&lt;double&gt; distance = data[&quot;distance&quot;]; // [microns]
      static std::vector&lt;double&gt; Fres = data[&quot;Fres&quot;]; // [pN]
      static std::vector&lt;double&gt; sigma = data[&quot;sigma&quot;]; // [pN]
      static std::vector&lt;double&gt; width = data[&quot;binWidth&quot;]; // [microns]

      std::vector&lt;boost::shared_ptr&lt;daFunk::FunkBase&gt;&gt; ForceNewBinned;
      std::vector&lt;boost::shared_ptr&lt;daFunk::FunkBound&gt;&gt; FnewBound;

      double d, delta;

      for (size_t i(0); i&lt;distance.size(); ++i)
      {
        d = distance[i]*1e-4;
        delta = width[i]*1e-4;
        ForceNewBinned.push_back(ForceNew-&gt;gsl_integration(&quot;d&quot;, d-delta/2, d+delta/2)/delta);
        FnewBound.push_back(ForceNewBinned[i]-&gt;bind());
      }

      std::vector&lt;double&gt; likelihood;
      double norm, Fnew;

      for (size_t i(0); i&lt;distance.size(); ++i)
      {
        norm = 1.; // we take the likelihood ratio to avoid having different normalizations accross the parameter space;
        Fnew = FnewBound[i]-&gt;eval();
        likelihood.push_back( (Fnew&lt;Fres[i]) ? norm : norm*exp(-pow(Fres[i]-Fnew, 2)/pow(sigma[i], 2)) );
      }

      result = log(*std::min_element(likelihood.begin(), likelihood.end())); // we take the minimum likelihood, since we don't have the correlations between data bins
    }

  }
}
*/
</code></pre><hr><p>Updated on 2022-07-20 at 17:18:45 +0000</p><div class=edit-page><a href=https://github.com/RC1242RC/gambit_gh_pages/blob/master/content/en/documentation/code/Files/SuperRenormHP_8cpp.md><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828.0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>Edit this page on GitHub</a></div></main></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Powered by <a class=text-muted href=https://www.netlify.com/>Netlify</a>, <a class=text-muted href=https://gohugo.io/>Hugo</a>, and <a class=text-muted href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline><li class=list-inline-item><a href=/testbit/license/>License</a></li></ul></div></div></div></footer><script src=/testbit/js/bootstrap.min.54bf0932b8a36d0e152b1635b099a6ef1394d35327e2437550a075c9c8ed1bd8aed5847c21b36fc02ed24014c031d9ca24017b0c78b1639d7e2fa8329898b842.js integrity="sha512-VL8JMrijbQ4VKxY1sJmm7xOU01Mn4kN1UKB1ycjtG9iu1YR8IbNvwC7SQBTAMdnKJAF7DHixY51+L6gymJi4Qg==" crossorigin=anonymous defer></script>
<script src=/testbit/js/highlight.min.5b48bc253dc75aeea5fb366ecf700f4925e2b6eb1a1466f2124b722d68148d67bc0a9365d2b8ad9c585161b46372d23b08509a16f1fd518542b894756d4752d0.js integrity="sha512-W0i8JT3HWu6l+zZuz3APSSXitusaFGbyEktyLWgUjWe8CpNl0ritnFhRYbRjctI7CFCaFvH9UYVCuJR1bUdS0A==" crossorigin=anonymous defer></script>
<script src=/testbit/main.min.40265e9a032aeba5eaf67baac3cbbc22667a7533215d326eeb3e9f4d5e4be40f9ff4dcd22949db73ae527ca26a19d7998091a8973c82af760b2c0daa335190ed.js integrity="sha512-QCZemgMq66Xq9nuqw8u8ImZ6dTMhXTJu6z6fTV5L5A+f9NzSKUnbc65SfKJqGdeZgJGolzyCr3YLLA2qM1GQ7Q==" crossorigin=anonymous defer></script>
<script src=https://rc1242rc.github.io/testbit/index.min.a9e8ad821b751fa50133c3aa34a59cd35272c1cf2c5998ff27d4feca4a0d22445ae367b71bd8ea9be1e28558292ba08731585d275b00c18a8364fce62bfdcbd6.js integrity="sha512-qeitght1H6UBM8OqNKWc01Jywc8sWZj/J9T+ykoNIkRa42e3G9jqm+HihVgpK6CHMVhdJ1sAwYqDZPzmK/3L1g==" crossorigin=anonymous defer></script></body></html>