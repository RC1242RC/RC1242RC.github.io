<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=https://rc1242rc.github.io/maindevelopment/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://rc1242rc.github.io/maindevelopment/fonts/vendor/jost/jost-v4-latin-500.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://rc1242rc.github.io/maindevelopment/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><script>(()=>{var e=localStorage.getItem("theme");e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><link rel=stylesheet href=https://rc1242rc.github.io/maindevelopment/main.1fa2debdf0a1b20e7268d11906902449af896197928a5bdae9dca95b629cdd73746db3d8c6afacb7320d9deb149a318c764669d08a1ddfd34a657ab2aeab866a.css integrity="sha512-H6LevfChsg5yaNEZBpAkSa+JYZeSilva6dypW2Kc3XN0bbPYxq+stzINnesUmjGMdkZp0Iod39NKZXqyrquGag==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>file src/Cascades.cpp - GAMBIT</title><meta name=description content="[No description available]"><link rel=canonical href=https://rc1242rc.github.io/maindevelopment/documentation/code/files/cascades_8cpp/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="file src/Cascades.cpp"><meta property="og:description" content="[No description available]"><meta property="og:url" content="https://rc1242rc.github.io/maindevelopment/documentation/code/files/cascades_8cpp/"><meta property="og:site_name" content="GAMBIT"><meta property="og:image" content="https://rc1242rc.github.io/maindevelopment/gambit_logo.png"><meta property="og:image:alt" content="GAMBIT"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content><meta name=twitter:creator content><meta name=twitter:title content="file src/Cascades.cpp"><meta name=twitter:description content="[No description available]"><meta name=twitter:image content="https://rc1242rc.github.io/maindevelopment/gambit_logo.png"><meta name=twitter:image:alt content="file src/Cascades.cpp"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://rc1242rc.github.io/#/schema/organization/1","name":"Doks","url":"https://rc1242rc.github.io/","sameAs":["https://github.com/GambitBSM"],"logo":{"@type":"ImageObject","@id":"https://rc1242rc.github.io/#/schema/image/1","url":"https://rc1242rc.github.io/logo-doks.png","width":450,"height":416,"caption":"Doks"},"image":{"@id":"https://rc1242rc.github.io/#/schema/image/1"}},{"@type":"WebSite","@id":"https://rc1242rc.github.io/#/schema/website/1","url":"https://rc1242rc.github.io/","name":"GAMBIT","description":"Documentation for the Global And Modular BSM Inference Tool","publisher":{"@id":"https://rc1242rc.github.io/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://rc1242rc.github.io/maindevelopment/documentation/code/files/cascades_8cpp/","url":"https://rc1242rc.github.io/maindevelopment/documentation/code/files/cascades_8cpp/","name":"file src\/Cascades.cpp","description":"[No description available]","isPartOf":{"@id":"https://rc1242rc.github.io/#/schema/website/1"},"about":{"@id":"https://rc1242rc.github.io/#/schema/organization/1"},"datePublished":"0001-01-01T00:00:00CET","dateModified":"0001-01-01T00:00:00CET","breadcrumb":{"@id":"https://rc1242rc.github.io/maindevelopment/documentation/code/files/cascades_8cpp/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://rc1242rc.github.io/maindevelopment/documentation/code/files/cascades_8cpp/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://rc1242rc.github.io/maindevelopment/documentation/code/files/cascades_8cpp/"]}]},{"@type":"BreadcrumbList","@id":"https://rc1242rc.github.io/maindevelopment/documentation/code/files/cascades_8cpp/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/maindevelopment","url":"https://rc1242rc.github.io/maindevelopment","name":"Home"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/maindevelopment/documentation/","url":"https://rc1242rc.github.io/maindevelopment/documentation/","name":"Documentation"}},{"@type":"ListItem","position":4,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/maindevelopment/documentation/code/","url":"https://rc1242rc.github.io/maindevelopment/documentation/code/","name":"Code"}},{"@type":"ListItem","position":5,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/maindevelopment/documentation/code/files/","url":"https://rc1242rc.github.io/maindevelopment/documentation/code/files/","name":"Files"}},{"@type":"ListItem","position":6,"item":{"@id":"https://rc1242rc.github.io/maindevelopment/documentation/code/files/cascades_8cpp/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://rc1242rc.github.io/maindevelopment/documentation/code/files/cascades_8cpp/#/schema/image/2","url":"https://rc1242rc.github.io/maindevelopment/gambit_logo.png","contentUrl":"https://rc1242rc.github.io/maindevelopment/gambit_logo.png","caption":"file src\/Cascades.cpp"}]}]}</script><meta name=theme-color content="#fff"><link rel=icon href=https://rc1242rc.github.io/maindevelopment/favicon.ico sizes=any><link rel=icon type=image/svg+xml href=https://rc1242rc.github.io/maindevelopment/favicon.svg><link rel=apple-touch-icon sizes=180x180 href=https://rc1242rc.github.io/maindevelopment/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://rc1242rc.github.io/maindevelopment/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://rc1242rc.github.io/maindevelopment/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://rc1242rc.github.io/maindevelopment/site.webmanifest></head><body class="documentation single light"><div class=sticky-top><div class=header-bar></div><header class="navbar navbar-expand-md navbar-light doks-navbar"><nav class="container-xxl flex-wrap flex-md-nowrap" aria-label="Main navigation"><a class="navbar-brand p-0 me-auto" href=/ aria-label=GAMBIT><img class=logo-light src=https://rc1242rc.github.io/maindevelopment/images/gambit_logo.png width=50px>
<img class="logo-dark d-none" src=https://rc1242rc.github.io/maindevelopment/images/gambit_logo.png width=50px>
GAMBIT</a>
<button class="btn btn-menu order-2 d-block d-lg-none" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasDoks aria-controls=offcanvasDoks aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><div class="offcanvas offcanvas-end border-0 py-lg-1" tabindex=-1 id=offcanvasDoks data-bs-backdrop=true aria-labelledby=offcanvasDoksLabel><div class="header-bar d-lg-none"></div><div class="offcanvas-header d-lg-none"><h2 class="h5 offcanvas-title ps-2" id=offcanvasDoksLabel><a class=text-dark href=/>GAMBIT</a></h2><button type=button class="btn-close text-reset me-2" data-bs-dismiss=offcanvas aria-label="Close main menu"></button></div><div class="offcanvas-body p-4 p-lg-0"><ul class="nav flex-column flex-lg-row align-items-lg-center mt-2 mt-lg-0 ms-lg-2 me-lg-auto"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Documentation
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/maindevelopment/documentation/installation/introduction/>Installation</a></li><li><a class=dropdown-item href=/maindevelopment/documentation/examples/colliderbit>Examples</a></li><li><a class=dropdown-item href=/maindevelopment/documentation/help/faqs/>Help</a></li><li><a class=dropdown-item href=/maindevelopment/documentation/code/index_classes>Code Reference</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Community
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/maindevelopment/community/publications/>Publications</a></li><li><a class=dropdown-item href=/maindevelopment/community/talks/>Talks</a></li><li><a class=dropdown-item href=/maindevelopment/community/members/>Members</a></li><li><a class=dropdown-item href=/maindevelopment/community/code_of_conduct/>Code of Conduct</a></li><li><a class=dropdown-item href=/maindevelopment/community/contact/>Contact</a></li></ul></li></ul><hr class="text-black-50 my-4 d-lg-none"><form class="doks-search position-relative flex-grow-1 ms-lg-auto me-lg-2"><input id=search class="form-control is-search" type=search placeholder="Search site..." aria-label="Search site..." autocomplete=off><div id=suggestions class="shadow bg-white rounded d-none"></div></form><hr class="text-black-50 my-4 d-lg-none"><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=https://github.com/GambitBSM><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><small class="ms-2 d-lg-none">GitHub</small></a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn btn-doks-light dropdown-toggle" id=doks-versions data-bs-toggle=dropdown aria-expanded=false data-bs-display=static aria-label="Toggle version menu">
<span class=d-none>Doks</span> MainDevelopment
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=doks-versions><li><a class=dropdown-item href=/maindevelopment/documentation/code/index_classes/>MainDevelopment</a></li><li><a class=dropdown-item href=/testbit/documentation/code/index_classes/>TestBit</a></li></ul></div></div></div></nav></header></div><div class="wrap container-xxl" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class=docs-links aria-label="Main navigation"><ul class="list-unstyled collapsible-sidebar"><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-installation aria-expanded=false>
Installation</button><div class=collapse id=section-installation><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/maindevelopment/documentation/installation/introduction/>Getting Started</a></li><li><a class="docs-link rounded" href=/maindevelopment/documentation/installation/docker_usage/>Docker Usage</a></li><li><a class="docs-link rounded" href=/maindevelopment/documentation/installation/installation_for_linux/>Installation for Linux</a></li><li><a class="docs-link rounded" href=/maindevelopment/documentation/installation/installation_for_windows/>Installation for Windows</a></li><li><a class="docs-link rounded" href=/maindevelopment/documentation/installation/installation_for_macos/>Installation for macOS</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-examples aria-expanded=false>
Examples</button><div class=collapse id=section-examples><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/maindevelopment/documentation/examples/colliderbit/>ColliderBit</a></li><li><a class="docs-link rounded" href=/maindevelopment/documentation/examples/anotherbit/>AnotherBit</a></li><li><a class="docs-link rounded" href=/maindevelopment/documentation/examples/anotherbit2/>AnotherBit2</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-help aria-expanded=false>
Help</button><div class=collapse id=section-help><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/maindevelopment/documentation/help/faqs/>FAQs</a></li><li><a class="docs-link rounded" href=/maindevelopment/documentation/help/compiler_matrix/>Compiler Matrix</a></li><li><a class="docs-link rounded" href=/maindevelopment/documentation/help/known_issues/>Known Issues</a></li><li><a class="docs-link rounded" href=/maindevelopment/documentation/help/configuration_examples/>Configuration Examples</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-code aria-expanded=false>
Code Reference</button><div class=collapse id=section-code><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/maindevelopment/documentation/code/index_classes/>Classes</a></li><li><a class="docs-link rounded" href=/maindevelopment/documentation/code/index_files/>Files</a></li><li><a class="docs-link rounded" href=/maindevelopment/documentation/code/index_pages/>Pages</a></li><li><a class="docs-link rounded" href=/maindevelopment/documentation/code/index_namespaces/>Namespaces</a></li></ul></div></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=d-xl-none><button class="btn btn-outline-primary btn-sm doks-toc-toggle collapsed" type=button data-bs-toggle=collapse data-bs-target=#onThisPage aria-controls=doks-docs-nav aria-expanded=false aria-label="Toggle On this page navigation">
<span>On this page</span>
<span><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"/><polyline points="7 6 12 11 17 6"/></svg><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"/><polyline points="17 18 12 13 7 18"/></svg></span></button><div class=collapse id=onThisPage><div class="card card-body mt-3 py-1"><div class=page-links><nav id=TableOfContents><ul><li><ul><li><a href=#namespaces>Namespaces</a></li><li><a href=#detailed-description>Detailed Description</a></li><li><a href=#source-code>Source code</a></li></ul></li></ul></nav></div></div></div></div><div class="page-links d-none d-xl-block"><h3>On this page</h3><nav id=TableOfContents><ul><li><ul><li><a href=#namespaces>Namespaces</a></li><li><a href=#detailed-description>Detailed Description</a></li><li><a href=#source-code>Source code</a></li></ul></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9 mx-xl-auto"><h1>file src/Cascades.cpp</h1><p class=lead></p><p>[No description available] <a href=#detailed-description>More&mldr;</a></p><h2 id=namespaces>Namespaces <a href=#namespaces class=anchor aria-hidden=true>#</a></h2><table><thead><tr><th>Name</th></tr></thead><tbody><tr><td><strong><a href=/documentation/code/namespaces/namespacegambit/>Gambit</a></strong><br>TODO: see if we can use this one:</td></tr><tr><td><strong><a href=/documentation/code/namespaces/namespacegambit_1_1darkbit/>Gambit::DarkBit</a></strong></td></tr></tbody></table><h2 id=detailed-description>Detailed Description <a href=#detailed-description class=anchor aria-hidden=true>#</a></h2><p><strong>Author</strong>:</p><ul><li>Christoph Weniger (<a href=mailto:c.weniger@uva.nl>c.weniger@uva.nl</a>)</li><li>Lars A. Dal (<a href=mailto:l.a.dal@fys.uio.no>l.a.dal@fys.uio.no</a>)</li></ul><p><strong>Date</strong>:</p><ul><li>2013 Jul - 2015 May</li><li>2014 Mar, Jul, Sep, Oct</li></ul><p>GAMBIT side of Cascade decay codes.</p><hr><p>Authors (add name and date if you modify):</p><hr><h2 id=source-code>Source code <a href=#source-code class=anchor aria-hidden=true>#</a></h2><pre><code>//   GAMBIT: Global and Modular BSM Inference Tool
//   *********************************************

#include &quot;gambit/Elements/gambit_module_headers.hpp&quot;
#include &quot;gambit/DarkBit/DarkBit_rollcall.hpp&quot;

//#define DARKBIT_DEBUG

namespace Gambit
{
  namespace DarkBit
  {

    //
    //                        Cascade Decays
    //

    enum cascadeMC_SpecialEvents {MC_INIT=-1, MC_NEXT_STATE=-2, MC_FINALIZE=-3};

    void cascadeMC_InitialStates(std::set&lt;std::string&gt; &amp;result)
    {
      using namespace Pipes::cascadeMC_InitialStates;
      std::string DMid= *Dep::DarkMatter_ID;
      std::string DMbarid = *Dep::DarkMatterConj_ID;

      result.clear();

      if ( runOptions-&gt;getValueOrDef(false, &quot;ignore_all&quot;) ) return;

      // What type of process are we dealing with?
      TH_Process process = (*Dep::DM_process == &quot;annihilation&quot;) ?
        (*Dep::TH_ProcessCatalog).getProcess(DMid, DMbarid) : (*Dep::TH_ProcessCatalog).getProcess(DMid);

      // Loop over all cascade MC final states
      for (const auto&amp; cMCFinalState : *Dep::cascadeMC_FinalStates)
      {
        // Loop over all hard process final states (cascade MC initial states)
        for (const auto&amp; channel : process.channelList)
        {
          if (channel.nFinalStates == 2)
          {
            if ( not runOptions-&gt;getValueOrDef(false, &quot;ignore_two_body&quot;) )
            {
              #ifdef DARKBIT_DEBUG
                std::cout &lt;&lt; &quot;Checking for missing two-body final states: &quot;
                          &lt;&lt; channel.finalStateIDs[0] &lt;&lt; &quot; &quot; &lt;&lt; channel.finalStateIDs[1]  &lt;&lt; std::endl;
              #endif
              if (not Dep::FullSimYieldTable-&gt;hasChannel(channel.finalStateIDs[0], channel.finalStateIDs[1], cMCFinalState))
              {
                for (const auto&amp; particle : channel.finalStateIDs)
                  if (not Dep::FullSimYieldTable-&gt;hasChannel(particle, cMCFinalState))
                    result.insert(particle);
              }
            }
          }
          else if (channel.nFinalStates == 3)
          {
            if (not runOptions-&gt;getValueOrDef(false, &quot;ignore_three_body&quot;))
            {
              #ifdef DARKBIT_DEBUG
                std::cout &lt;&lt; &quot;Checking for missing three-body final states: &quot;
                          &lt;&lt; channel.finalStateIDs[0] &lt;&lt; &quot; &quot; &lt;&lt; channel.finalStateIDs[1]
                          &lt;&lt; &quot; &quot; &lt;&lt; channel.finalStateIDs[2] &lt;&lt; std::endl;
              #endif
              for (const auto&amp; particle : channel.finalStateIDs)
                if (not Dep::FullSimYieldTable-&gt;hasChannel(particle, cMCFinalState))
                  result.insert(particle);
            }
          }
        }
      }

      // Remove particles we don't have decays for.
      for (auto it = result.begin(); it != result.end();)
      {
          if ((*Dep::TH_ProcessCatalog).find(*it, &quot;&quot;) == NULL)
          {
            #ifdef DARKBIT_DEBUG
              std::cout &lt;&lt; &quot;Erasing (because no decays known): &quot; &lt;&lt; *it &lt;&lt; std::endl;
            #endif
            result.erase(it++);
          }
          else
          {
            #ifdef DARKBIT_DEBUG
              std::cout &lt;&lt; &quot;Keeping (because decay known): &quot; &lt;&lt; *it &lt;&lt; std::endl;
            #endif
            ++it;
          }
      }

      #ifdef DARKBIT_DEBUG
        std::cout &lt;&lt; &quot;Number of missing final states: &quot; &lt;&lt; result.size() &lt;&lt; std::endl;
        for (auto state : result) std::cout &lt;&lt; state &lt;&lt; std::endl;
      #endif
    }

    void cascadeMC_FinalStates(std::set&lt;std::string&gt; &amp;states)
    {
      using namespace Pipes::cascadeMC_FinalStates;
      static bool first = true;
      if (first)
      {
        states.clear();
        if (Downstream::neededFor(&quot;cascadeMC_gammaSpectra&quot;)) states.insert(&quot;gamma&quot;);
        if (Downstream::neededFor(&quot;cascadeMC_electronSpectra&quot;)) states.insert(&quot;e-_1&quot;);
        if (Downstream::neededFor(&quot;cascadeMC_positronSpectra&quot;)) states.insert(&quot;e+_1&quot;);
        if (Downstream::neededFor(&quot;cascadeMC_antiprotonSpectra&quot;)) states.insert(&quot;pbar&quot;);
        if (Downstream::neededFor(&quot;cascadeMC_antideuteronSpectra&quot;)) states.insert(&quot;Dbar&quot;);
        first = false;
        #ifdef DARKBIT_DEBUG
          std::cout &lt;&lt; &quot;Final states to generate: &quot; &lt;&lt; states.size() &lt;&lt; std::endl;
          for (const auto&amp; state : states) std::cout &lt;&lt; &quot;  &quot; &lt;&lt; state &lt;&lt; std::endl;
        #endif
      }
    }

    void cascadeMC_DecayTable(DarkBit::DecayChain::DecayTable &amp;table)
    {
      using namespace DecayChain;
      using namespace Pipes::cascadeMC_DecayTable;
      std::set&lt;std::string&gt; disabled;
      // Note: One could add to &quot;disabled&quot; particles decays that are in the
      // process catalog but should for some reason not propagate to the FCMC
      // DecayTable.
      try
      {
        table = DecayTable(*Dep::TH_ProcessCatalog, *Dep::FullSimYieldTable, disabled);
      }
      catch(Piped_exceptions::description err)
      {
        DarkBit_error().raise(err.first,err.second);
      }
      #ifdef DARKBIT_DEBUG
        table.printTable();
      #endif
    }

    void cascadeMC_LoopManager(std::string&amp; result)
    {
      using namespace Pipes::cascadeMC_LoopManager;
      const std::set&lt;std::string&gt;&amp; chainList = *Dep::cascadeMC_InitialStates;
      int cMC_minEvents = 2;  // runOptions-&gt;getValueOrDef&lt;int&gt;(2, &quot;cMC_minEvents&quot;);
      // Get YAML options
      int cMC_maxEvents = runOptions-&gt;getValueOrDef&lt;int&gt;(20000, &quot;cMC_maxEvents&quot;);

      // Initialization run
      Loop::executeIteration(MC_INIT);

      // Check whether there is anything to do
      if ( chainList.size() == 0 )
      {
        return;
      }

      // Iterate over initial state particles
      for (const auto&amp; particle : chainList)
      {
        result = particle;
        int it;
        int counter = 0;
        bool finished = false;
        // Set next initial state
        Loop::executeIteration(MC_NEXT_STATE);
        // Event generation loop
        #pragma omp parallel private(it) shared(counter, finished)
        {
          while (!finished)
          {
            #pragma omp critical (cascadeMC_Counter)
            {
              counter++;
              it = counter;
            }
            Loop::executeIteration(it);
            #pragma omp critical (cascadeMC_Counter)
            {
              if((*Loop::done and ((counter &gt;= cMC_minEvents) or piped_errors.inquire()))
                or (counter &gt;= cMC_maxEvents))
                  finished=true;
              if (counter &gt;= cMC_maxEvents)
                DarkBit_warning().raise(LOCAL_INFO,
                    &quot;WARNING FCMC: cMC_maxEvents reached without convergence.&quot;);
            }
          }
        }
        // Raise any exceptions
        piped_invalid_point.check();
        piped_warnings.check(DarkBit_warning());
        piped_errors.check(DarkBit_error());
        Loop::reset();
      }
      Loop::executeIteration(MC_FINALIZE);
    }

    void cascadeMC_EventCount(std::map&lt;std::string, int&gt; &amp;counts)
    {
      using namespace Pipes::cascadeMC_EventCount;
      static std::map&lt;std::string, int&gt; counters;
      switch(*Loop::iteration)
      {
        case MC_INIT:
          counters.clear();
          break;
        case MC_NEXT_STATE:
          counters[*Dep::cascadeMC_LoopManagement] = 0;
          break;
        case MC_FINALIZE:
          // For performance, only return the actual result once finished
          counts=counters;
          break;
        default:
        #pragma omp atomic
          counters[*Dep::cascadeMC_LoopManagement]++;
      }
    }

    void cascadeMC_GenerateChain(
        DarkBit::DecayChain::ChainContainer &amp;chain)
    {
      using namespace DecayChain;
      using namespace Pipes::cascadeMC_GenerateChain;
      static int    cMC_maxChainLength;
      static double cMC_Emin;
      switch(*Loop::iteration)
      {
        case MC_INIT:
          cMC_maxChainLength = runOptions-&gt;getValueOrDef&lt;int&gt;    (-1, &quot;cMC_maxChainLength&quot;);
          cMC_Emin = runOptions-&gt;getValueOrDef&lt;double&gt; (-1, &quot;cMC_Emin&quot;);
          return;
        case MC_NEXT_STATE:
        case MC_FINALIZE:
          return;
      }
      shared_ptr&lt;ChainParticle&gt; chn;
      try
      {
        chn.reset(new ChainParticle( vec3(0), &amp;(*Dep::cascadeMC_DecayTable), *Dep::cascadeMC_LoopManagement) );
        chn-&gt;generateDecayChainMC(cMC_maxChainLength,cMC_Emin);
      }
      catch(Piped_exceptions::description err)
      {
        Loop::wrapup();
        piped_errors.request(err);
      }
      chain=ChainContainer(chn);
    }

    void cascadeMC_sampleSimYield( const SimYieldTable &amp;table,
        const DarkBit::DecayChain::ChainParticle* endpoint,
        std::string finalState,
        const TH_ProcessCatalog &amp;catalog,
        std::map&lt;std::string, std::map&lt;std::string, SimpleHist&gt; &gt; &amp;histList,
        std::string initialState,
        double weight, int cMC_numSpecSamples
        )
    {
      #ifdef DARKBIT_DEBUG
        std::cout &lt;&lt; &quot;SampleSimYield&quot; &lt;&lt; std::endl;
      #endif
      std::string p1,p2;
      double gamma,beta;
      double M;
      switch(endpoint-&gt;getnChildren())
      {
        case 0:
        {
          p1 = endpoint-&gt;getpID();
          p2 = &quot;&quot;;
          const DarkBit::DecayChain::ChainParticle* parent = endpoint-&gt;getParent();
          if(parent == NULL)
          {
            endpoint-&gt;getBoost(gamma,beta);
            M = endpoint-&gt;m;
          }
          else
          {
            parent-&gt;getBoost(gamma,beta);
            M = endpoint-&gt;E_parentFrame();
          }
          break;
        }
        case 2:
        {
          p1=(*endpoint)[0]-&gt;getpID();
          p2=(*endpoint)[1]-&gt;getpID();
          endpoint-&gt;getBoost(gamma,beta);
          M = endpoint-&gt;m;
          break;
        }
        default:
          piped_errors.request(LOCAL_INFO,
              &quot;cascadeMC_sampleSimYield called with invalid endpoint state.&quot;);
          return;
      }
      const SimYieldChannel &amp;chn = table.getChannel(p1 , p2, finalState);
      // Get Lorentz boost information

      const double gammaBeta = gamma*beta;
      // Mass of final state squared
      const double m = catalog.getParticleProperty(finalState).mass;
      const double msq = m*m;
      // Get histogram edges
      double histEmin, histEmax;
      histList[initialState][finalState].getEdges(histEmin, histEmax);

      // Calculate energies to sample between.  A particle decaying
      // isotropically in its rest frame will give a box spectrum.  This is
      // assumed and used here to add box contributions rather than points to
      // the histograms.  Limits are chosen such that we only sample energies
      // that can contribute to histogram bins.
      const double Ecmin = std::max( gamma*histEmin
          - gammaBeta*sqrt(histEmin*histEmin-msq) , 0*chn.Ecm_min );  // CW: chn.Ecm_min refers to initial not final energies
      const double Ecmax = std::min(std::min(
            // Highest energy that can contribute to the histogram
            gamma*histEmax + gammaBeta*sqrt(histEmax*histEmax-msq),
            // Highest energy in SimYieldChannel
            chn.Ecm_max ),
            // Estimate for highest kinematically allowed CoM energy
          0.5*(M*M + msq)/M );
      if(Ecmin&gt;=Ecmax) return;
      const double logmin = log(Ecmin);
      const double logmax = log(Ecmax);
      const double dlogE=logmax-logmin;

      #ifdef DARKBIT_DEBUG
        std::cout &lt;&lt; &quot;M = &quot; &lt;&lt; M &lt;&lt; std::endl;
        std::cout &lt;&lt; &quot;E_lab = &quot; &lt;&lt; endpoint-&gt;E_Lab() &lt;&lt; std::endl;
        std::cout &lt;&lt; &quot;p_lab = &quot; &lt;&lt; endpoint-&gt;p_Lab() &lt;&lt; std::endl;
        std::cout &lt;&lt; &quot;Lorentz factors gamma, beta: &quot; &lt;&lt; gamma &lt;&lt; &quot;, &quot;
          &lt;&lt; beta &lt;&lt; std::endl;
        std::cout &lt;&lt; &quot;Initial state: &quot; &lt;&lt; initialState &lt;&lt; std::endl;
        std::cout &lt;&lt; &quot;Channel: &quot; &lt;&lt; p1 &lt;&lt; &quot; &quot; &lt;&lt; p2 &lt;&lt; std::endl;
        std::cout &lt;&lt; &quot;Final particles: &quot; &lt;&lt; finalState &lt;&lt; std::endl;
        std::cout &lt;&lt; &quot;Event weight: &quot;    &lt;&lt; weight &lt;&lt; std::endl;
        std::cout &lt;&lt; &quot;histEmin/histEmax: &quot; &lt;&lt; histEmin &lt;&lt; &quot; &quot; &lt;&lt; histEmax
          &lt;&lt; std::endl;
        std::cout &lt;&lt; &quot;chn.Ecm_min/max: &quot; &lt;&lt; chn.Ecm_min &lt;&lt; &quot; &quot; &lt;&lt; chn.Ecm_max
          &lt;&lt; std::endl;
        std::cout &lt;&lt; &quot;Ecmin/max: &quot; &lt;&lt; Ecmin &lt;&lt; &quot; &quot; &lt;&lt; Ecmax &lt;&lt; std::endl;
        std::cout &lt;&lt; &quot;Final state mass^2: &quot; &lt;&lt; msq &lt;&lt; std::endl;
      #endif

      //double specSum=0; (Unused)
      int Nsampl=0;
      SimpleHist spectrum(histList[initialState][finalState].binLower);
      while(Nsampl&lt;cMC_numSpecSamples)
      {
        // Draw an energy in the CoM frame of the endpoint. Logarithmic
        // sampling.
        double E_CoM= exp(logmin+(logmax-logmin)*Random::draw());
        double dN_dE = chn.dNdE_bound-&gt;eval(E_CoM, M);

        double weight2 = E_CoM*dlogE*dN_dE;
        //specSum += weight2; (Unused)
        weight2 *= weight;
        double tmp1 = gamma*E_CoM;
        double tmp2 = gammaBeta*sqrt(E_CoM*E_CoM-msq);
        // Add box spectrum to histogram
        spectrum.addBox(tmp1-tmp2,tmp1+tmp2,weight2);
        Nsampl++;
      }
      #ifdef DARKBIT_DEBUG
        std::cout &lt;&lt; &quot;Number of samples = &quot; &lt;&lt; Nsampl &lt;&lt; std::endl;
      #endif
      if(Nsampl&gt;0)
      {
        spectrum.multiply(1.0/Nsampl);
        // Add bin contents of spectrum histogram to main histogram as weighted
        // events
        #pragma omp critical (cascadeMC_histList)
          histList[initialState][finalState].addHistAsWeights_sameBin(spectrum);
      }
    }

    void cascadeMC_Histograms(std::map&lt;std::string, std::map&lt;std::string,
        SimpleHist&gt; &gt; &amp;result)
    {
      using namespace DecayChain;
      using namespace Pipes::cascadeMC_Histograms;

      // YAML options
      static int    cMC_numSpecSamples;
      static int    cMC_endCheckFrequency;
      static double cMC_gammaBGPower;
      static double cMC_gammaRelError;
      static int    cMC_NhistBins;
      static double cMC_binLow;
      static double cMC_binHigh;
      // Histogram list shared between all threads
      static std::map&lt;std::string, std::map&lt;std::string, SimpleHist&gt; &gt; histList;

      switch(*Loop::iteration)
      {
        case MC_INIT:
          // Initialization
          cMC_numSpecSamples = runOptions-&gt;getValueOrDef&lt;int&gt;   (25, &quot;cMC_numSpecSamples&quot;);
          cMC_endCheckFrequency  =
            runOptions-&gt;getValueOrDef&lt;int&gt;   (25,     &quot;cMC_endCheckFrequency&quot;);
          cMC_gammaBGPower       =
            runOptions-&gt;getValueOrDef&lt;double&gt;(-2.5,   &quot;cMC_gammaBGPower&quot;);
          cMC_gammaRelError      =
            runOptions-&gt;getValueOrDef&lt;double&gt;(0.20,   &quot;cMC_gammaRelError&quot;);

          // Note: use same binning for all particle species
          cMC_NhistBins = runOptions-&gt;getValueOrDef&lt;int&gt;   (140,     &quot;cMC_NhistBins&quot;);
          cMC_binLow = runOptions-&gt;getValueOrDef&lt;double&gt;(0.001,  &quot;cMC_binLow&quot;);
          cMC_binHigh = runOptions-&gt;getValueOrDef&lt;double&gt;(10000.0,&quot;cMC_binHigh&quot;);
          histList.clear();
          return;
        case MC_NEXT_STATE:
          // Initialize histograms
          for (const auto&amp; state : *Dep::cascadeMC_FinalStates)
          {
            #ifdef DARKBIT_DEBUG
              std::cout &lt;&lt; &quot;Defining new histList entry!!!&quot; &lt;&lt; std::endl;
              std::cout &lt;&lt; &quot;for: &quot; &lt;&lt; *Dep::cascadeMC_LoopManagement &lt;&lt; &quot; &quot; &lt;&lt; state &lt;&lt; std::endl;
            #endif
            double FinalStateMass = Dep::TH_ProcessCatalog-&gt;getParticleProperty(state).mass;
            histList[*Dep::cascadeMC_LoopManagement][state] = SimpleHist(cMC_NhistBins,cMC_binLow+FinalStateMass,cMC_binHigh+FinalStateMass,true);
          }
          return;
        case MC_FINALIZE:
          // For performance, only return the actual result once finished
          result = histList;
          return;
      }

      // Get list of endpoint states for this chain
      vector&lt;const ChainParticle*&gt; endpoints;
      Dep::cascadeMC_ChainEvent-&gt;chain-&gt;collectEndpointStates(endpoints, false);
      // Iterate over final states of interest
      for (const auto&amp; state : *Dep::cascadeMC_FinalStates)
      {
        // Iterate over all endpoint states of the decay chain. These can
        // either be final state particles themselves or parents of final state
        // particles.  The reason for not using only final state particles is
        // that certain endpoints (e.g. quark-antiquark pairs) cannot be
        // handled as separate particles.
        for (const auto&amp; endpoint : endpoints)
        {
          #ifdef DARKBIT_DEBUG
            std::cout &lt;&lt; &quot;  working on endpoint: &quot; &lt;&lt; endpoint-&gt;getpID() &lt;&lt; std::endl;
            endpoint-&gt;printChain();
          #endif

          // Weighting factor (correction for mismatch between decay width
          // of available decay channels and total decay width)
          double weight;
          // Analyze single particle endpoints
          bool ignored = true;
          if(endpoint-&gt;getnChildren() ==0)
          {
            weight = endpoint-&gt;getWeight();
            // Check if the final state itself is the particle we are looking
            // for.
            if(endpoint-&gt;getpID() == state)
            {
              double E = endpoint-&gt;E_Lab();
              #pragma omp critical (cascadeMC_histList)
                histList[*Dep::cascadeMC_LoopManagement][state].addEvent(E,weight);
              ignored = false;
            }
            // Check if tabulated spectra exist for this final state
            else if((*Dep::FullSimYieldTable).hasChannel( endpoint-&gt;getpID(), state ))
            {
              cascadeMC_sampleSimYield(
                  *Dep::FullSimYieldTable, endpoint, state, *Dep::TH_ProcessCatalog,
                  histList, *Dep::cascadeMC_LoopManagement, weight,
                  cMC_numSpecSamples
                  );
              // Check if an error was raised
              ignored = false;
              if(piped_errors.inquire())
              {
                Loop::wrapup();
                return;
              }
            }
          }
          // Analyze multiparticle endpoints (the endpoint particle is here the
          // parent of final state particles).
          else
          {
            weight = (*endpoint)[0]-&gt;getWeight();
            bool hasTabulated = false;
            if(endpoint-&gt;getnChildren() == 2)
            {
              #ifdef DARKBIT_DEBUG
                std::cout &lt;&lt; &quot;  check whether two-body final state is tabulated: &quot;
                  &lt;&lt; (*endpoint)[0]-&gt;getpID() &lt;&lt; &quot; &quot; &lt;&lt; (*endpoint)[1]-&gt;getpID() &lt;&lt;
                  std::endl;
              #endif
              // Check if tabulated spectra exist for this final state
              if((*Dep::FullSimYieldTable).hasChannel(
                    (*endpoint)[0]-&gt;getpID() , (*endpoint)[1]-&gt;getpID(), state ))
              {
                hasTabulated = true;
                cascadeMC_sampleSimYield(*Dep::FullSimYieldTable, endpoint, state,
                    *Dep::TH_ProcessCatalog, histList,
                    *Dep::cascadeMC_LoopManagement, weight,
                    cMC_numSpecSamples
                    );
                // Check if an error was raised
                ignored = false;
                if(piped_errors.inquire())
                {
                  Loop::wrapup();
                  return;
                }
              }
            }
            if(!hasTabulated)
            {
              for (int i=0; i&lt;(endpoint-&gt;getnChildren()); i++)
              {
                const ChainParticle* child = (*endpoint)[i];
                // Check if the child particle is the particle we are looking
                // for.
                if(child-&gt;getpID() == state)
                {
                  double E = child-&gt;E_Lab();
                  #pragma omp critical (cascadeMC_histList)
                    histList[*Dep::cascadeMC_LoopManagement][state].addEvent(E,weight);
                  ignored = false;
                }
                // Check if tabulated spectra exist for this final state
                else if((*Dep::FullSimYieldTable).hasChannel( child-&gt;getpID(), state))
                {
                  cascadeMC_sampleSimYield(*Dep::FullSimYieldTable, child, state,
                      *Dep::TH_ProcessCatalog, histList,
                      *Dep::cascadeMC_LoopManagement, weight,
                      cMC_numSpecSamples
                      );
                  // Check if an error was raised
                  ignored = false;
                  if(piped_errors.inquire())
                  {
                    Loop::wrapup();
                    return;
                  }
                }
              }
            }
          }
          if (ignored)
          {
            DarkBit_warning().raise(LOCAL_INFO, &quot;WARNING FCMC: Missing complete decay &quot;
             &quot;information for &quot; + endpoint-&gt;getpID() + &quot;. This state is ignored.&quot;);
          }
        }
      }

      // Check if finished every cMC_endCheckFrequency events
      if((*Loop::iteration % cMC_endCheckFrequency) == 0)
      {
        enum status{untouched,unfinished,finished};
        status cond = untouched;
        for (const auto&amp; state : *Dep::cascadeMC_FinalStates)
        {
          // End conditions currently only implemented for gamma final state
          if (state == &quot;gamma&quot;)
          {
            SimpleHist hist;
            #pragma omp critical (cascadeMC_histList)
              hist = histList[*Dep::cascadeMC_LoopManagement][state];
            #ifdef DARKBIT_DEBUG
              std::cout &lt;&lt; &quot;Checking whether convergence is reached&quot; &lt;&lt; std::endl;
              for ( int i = 0; i &lt; hist.nBins; i++ )
                std::cout &lt;&lt; &quot;Estimated error at &quot; &lt;&lt; hist.binCenter(i) &lt;&lt; &quot; GeV : &quot; &lt;&lt; hist.getRelError(i) &lt;&lt; std::endl;
            #endif
            double sbRatioMax=-1.0;
            int maxBin=0;
            for (int i=0; i&lt;hist.nBins; i++)
            {
              double E = hist.binCenter(i);
              double background = pow(E,cMC_gammaBGPower);
              double sbRatio = hist.binVals[i]/background;
              if(sbRatio&gt;sbRatioMax)
              {
                sbRatioMax = sbRatio;
                maxBin=i;
              }
            }
            #ifdef DARKBIT_DEBUG
              std::cout &lt;&lt; &quot;Estimated maxBin: &quot; &lt;&lt; maxBin &lt;&lt; std::endl;
              std::cout &lt;&lt; &quot;Energy at maxBin: &quot; &lt;&lt; hist.binCenter(maxBin) &lt;&lt; std::endl;
              std::cout &lt;&lt; &quot;Estimated error at maxBin: &quot; &lt;&lt; hist.getRelError(maxBin) &lt;&lt; std::endl;
              std::cout &lt;&lt; &quot;Value at maxBin: &quot; &lt;&lt; hist.getBinValues()[maxBin];
            #endif

            // Check if end condition is fulfilled. If not, set cond to
            // unfinished.
            if(hist.getRelError(maxBin) &gt; cMC_gammaRelError) cond = unfinished;

            // If end condition is fulfilled, set cond to finished, unless
            // already set to unfinished by another condition.
            else if(cond != unfinished) cond = finished;
          }
        }
        // Break Monte Carlo loop if all end conditions are fulfilled.
        if(cond==finished)
        {
          #ifdef DARKBIT_DEBUG
            std::cout &lt;&lt; &quot;!! wrapping up !!&quot; &lt;&lt; std::endl;
            std::cout &lt;&lt; &quot;Performed iterations: &quot; &lt;&lt; *Loop::iteration &lt;&lt; std::endl;
          #endif
          Loop::wrapup();
        }
      }
    }

    void cascadeMC_fetchSpectra(std::map&lt;std::string, daFunk::Funk&gt; &amp;spectra,
        std::string finalState,
        const std::set&lt;std::string&gt; &amp;ini,
        const std::set&lt;std::string&gt; &amp;fin,
        const std::map&lt;std::string, std::map&lt;std::string,SimpleHist&gt; &gt; &amp;h,
        const std::map&lt;std::string,int&gt; &amp;eventCounts)
    {
      spectra.clear();

      // Make sure final state has actually been calculated
      bool calculated = (std::find(fin.begin(), fin.end(), finalState) != fin.end());
      if (not calculated) DarkBit_error().raise(LOCAL_INFO, finalState + &quot; not calculated!&quot;);

      // Iterate over initial states
      for (const auto&amp; initial_state : ini)
      {
        #ifdef DARKBIT_DEBUG
          std::cout &lt;&lt; &quot;Trying to get cascade spectra for initial state: &quot; &lt;&lt; initial_state &lt;&lt; std::endl;
          std::cout &lt;&lt; eventCounts.at(initial_state) &lt;&lt; &quot; events generated&quot; &lt;&lt; std::endl;
          int i = 0;
        #endif

        SimpleHist hist = h.at(initial_state).at(finalState);
        hist.divideByBinSize();
        std::vector&lt;double&gt; E = hist.getBinCenters();
        std::vector&lt;double&gt; dN_dE = hist.getBinValues();
        // Normalize to per-event spectrum
        for (std::vector&lt;double&gt;::iterator it2 = dN_dE.begin(); it2 != dN_dE.end(); ++it2)
        {
          *it2 /= eventCounts.at(initial_state);
          #ifdef DARKBIT_DEBUG
            std::cout &lt;&lt; E[i] &lt;&lt; &quot; &quot; &lt;&lt; *it2 &lt;&lt; std::endl;
            i++;
          #endif
        }
        // Default values provide 1-2% accuracy for singular integrals
        // Make this optional.
        spectra[initial_state] = daFunk::Funk(new daFunk::FunkInterp(&quot;E&quot;, E, dN_dE, &quot;lin&quot;));

        for (size_t i = 1; i&lt;E.size()-1; i++)
        {
          if (dN_dE[i]/(dN_dE[i-1]+dN_dE[i+1]+dN_dE[i]*1e-4) &gt; 1e2)
          {
            #ifdef DARKBIT_DEBUG
              std::cout &lt;&lt; &quot;Set singularity at &quot; &lt;&lt; E[i] &lt;&lt; &quot; with width &quot; &lt;&lt; E[i+1]-E[i] &lt;&lt; endl;
            #endif
            spectra[initial_state]-&gt;set_singularity(&quot;E&quot;, E[i], (E[i+1]-E[i]));
          }
        }
      }
    }

    void print_spectrum_debug_info(const str&amp; fs, const std::map&lt;std::string, daFunk::Funk&gt; &amp; spectra)
    {
      std::cout &lt;&lt; &quot;Retrieving cascade spectra for &quot; &lt;&lt; fs &lt;&lt; &quot; final states&quot; &lt;&lt; std::endl;
      std::cout &lt;&lt; &quot;Number of simulated final states: &quot; &lt;&lt; spectra.size() &lt;&lt; std::endl;
      for ( auto it = spectra.begin(); it != spectra.end(); it ++ )
      {
        std::cout &lt;&lt; &quot;Particle: &quot; &lt;&lt; it-&gt;first &lt;&lt; std::endl;
        auto f= it-&gt;second;
        for ( double E = 0.1; E &lt; 1000; E*=1.5 )
        {
          std::cout &lt;&lt; &quot;  &quot; &lt;&lt; E &lt;&lt; &quot; &quot; &lt;&lt; f-&gt;bind(&quot;E&quot;)-&gt;eval(E) &lt;&lt; std::endl;
        }
        std::cout &lt;&lt; &quot;  Integrated spectrum: &quot; &lt;&lt; f-&gt;gsl_integration(&quot;E&quot;, 0, 1000)-&gt;bind()-&gt;eval() &lt;&lt; std::endl;
      }
    }

    void cascadeMC_gammaSpectra(std::map&lt;std::string, daFunk::Funk&gt; &amp;spectra)
    {
      using namespace Pipes::cascadeMC_gammaSpectra;
      cascadeMC_fetchSpectra(spectra, &quot;gamma&quot;, *Dep::cascadeMC_InitialStates,
          *Dep::cascadeMC_FinalStates, *Dep::cascadeMC_Histograms,
          *Dep::cascadeMC_EventCount);
      #ifdef DARKBIT_DEBUG
        print_spectrum_debug_info(&quot;gamma&quot;, spectra);
      #endif
    }

    void cascadeMC_electronSpectra(std::map&lt;std::string, daFunk::Funk&gt; &amp;spectra)
    {
      using namespace Pipes::cascadeMC_electronSpectra;
      cascadeMC_fetchSpectra(spectra, &quot;e-_1&quot;, *Dep::cascadeMC_InitialStates,
          *Dep::cascadeMC_FinalStates, *Dep::cascadeMC_Histograms,
          *Dep::cascadeMC_EventCount);
      #ifdef DARKBIT_DEBUG
        print_spectrum_debug_info(&quot;electron&quot;, spectra);
      #endif
    }

    void cascadeMC_positronSpectra(std::map&lt;std::string, daFunk::Funk&gt; &amp;spectra)
    {
      using namespace Pipes::cascadeMC_positronSpectra;
      cascadeMC_fetchSpectra(spectra, &quot;e+_1&quot;, *Dep::cascadeMC_InitialStates,
          *Dep::cascadeMC_FinalStates, *Dep::cascadeMC_Histograms,
          *Dep::cascadeMC_EventCount);
      #ifdef DARKBIT_DEBUG
        print_spectrum_debug_info(&quot;positron&quot;, spectra);
      #endif
    }

    void cascadeMC_antiprotonSpectra(std::map&lt;std::string, daFunk::Funk&gt; &amp;spectra)
    {
      using namespace Pipes::cascadeMC_antiprotonSpectra;
      cascadeMC_fetchSpectra(spectra, &quot;pbar&quot;, *Dep::cascadeMC_InitialStates,
          *Dep::cascadeMC_FinalStates, *Dep::cascadeMC_Histograms,
          *Dep::cascadeMC_EventCount);
      #ifdef DARKBIT_DEBUG
        print_spectrum_debug_info(&quot;antiproton&quot;, spectra);
      #endif
    }

    void cascadeMC_antideuteronSpectra(std::map&lt;std::string, daFunk::Funk&gt; &amp;spectra)
    {
      using namespace Pipes::cascadeMC_antideuteronSpectra;
      cascadeMC_fetchSpectra(spectra, &quot;Dbar&quot;, *Dep::cascadeMC_InitialStates,
          *Dep::cascadeMC_FinalStates, *Dep::cascadeMC_Histograms,
          *Dep::cascadeMC_EventCount);
      #ifdef DARKBIT_DEBUG
        print_spectrum_debug_info(&quot;antideuteron&quot;, spectra);
      #endif
    }

    /*
    void cascadeMC_PrintResult(bool &amp;dummy)
    {
      dummy=true;
      using namespace Pipes::cascadeMC_PrintResult;
      logger() &lt;&lt; &quot;************************&quot; &lt;&lt; std::endl;
      logger() &lt;&lt; &quot;Cascade decay results:&quot; &lt;&lt; std::endl;
      logger() &lt;&lt; &quot;------------------------&quot; &lt;&lt; EOM;
      std::map&lt;std::string, std::map&lt;std::string,SimpleHist&gt; &gt;
        cascadeMC_HistList = *Dep::cascadeMC_Histograms;

      for (std::map&lt;std::string, std::map&lt;std::string,SimpleHist&gt; &gt;::iterator
          it = cascadeMC_HistList.begin();
          it != cascadeMC_HistList.end(); ++it )
      {
        logger() &lt;&lt; &quot;Initial state: &quot; &lt;&lt; (it-&gt;first) &lt;&lt; &quot;:&quot; &lt;&lt; EOM;
        int nEvents = (*Dep::cascadeMC_EventCount).at(it-&gt;first);
        logger() &lt;&lt; &quot;Number of events: &quot; &lt;&lt; nEvents &lt;&lt; EOM;
        for (std::map&lt;std::string,SimpleHist&gt;::iterator
            it2 = (it-&gt;second).begin(); it2 != (it-&gt;second).end(); ++it2 )
        {
          logger() &lt;&lt; (it2-&gt;first) &lt;&lt; &quot;: &quot;;
          //(it2-&gt;second).divideByBinSize();
          (it2-&gt;second).multiply(1.0/nEvents);
          for (int i=0;i&lt;50;i++)
          {
            logger() &lt;&lt; (it2-&gt;second).binVals[i] &lt;&lt; &quot;  &quot;;
          }
          logger() &lt;&lt; std::endl;
        }
        logger() &lt;&lt; &quot;------------------------&quot; &lt;&lt; std::endl;
      }
      logger() &lt;&lt; &quot;************************&quot; &lt;&lt; EOM;
    }
    */
  }
}

#undef DARKBIT_DEBUG
</code></pre><hr><p>Updated on 2022-07-20 at 17:18:45 +0000</p><div class=edit-page><a href=https://github.com/RC1242RC/gambit_gh_pages/blob/master/content/en/documentation/code/Files/Cascades_8cpp.md><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828.0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>Edit this page on GitHub</a></div></main></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Powered by <a class=text-muted href=https://www.netlify.com/>Netlify</a>, <a class=text-muted href=https://gohugo.io/>Hugo</a>, and <a class=text-muted href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline><li class=list-inline-item><a href=/maindevelopment/license/>License</a></li></ul></div></div></div></footer><script src=/maindevelopment/js/bootstrap.min.54bf0932b8a36d0e152b1635b099a6ef1394d35327e2437550a075c9c8ed1bd8aed5847c21b36fc02ed24014c031d9ca24017b0c78b1639d7e2fa8329898b842.js integrity="sha512-VL8JMrijbQ4VKxY1sJmm7xOU01Mn4kN1UKB1ycjtG9iu1YR8IbNvwC7SQBTAMdnKJAF7DHixY51+L6gymJi4Qg==" crossorigin=anonymous defer></script>
<script src=/maindevelopment/js/highlight.min.5b48bc253dc75aeea5fb366ecf700f4925e2b6eb1a1466f2124b722d68148d67bc0a9365d2b8ad9c585161b46372d23b08509a16f1fd518542b894756d4752d0.js integrity="sha512-W0i8JT3HWu6l+zZuz3APSSXitusaFGbyEktyLWgUjWe8CpNl0ritnFhRYbRjctI7CFCaFvH9UYVCuJR1bUdS0A==" crossorigin=anonymous defer></script>
<script src=/maindevelopment/main.min.40265e9a032aeba5eaf67baac3cbbc22667a7533215d326eeb3e9f4d5e4be40f9ff4dcd22949db73ae527ca26a19d7998091a8973c82af760b2c0daa335190ed.js integrity="sha512-QCZemgMq66Xq9nuqw8u8ImZ6dTMhXTJu6z6fTV5L5A+f9NzSKUnbc65SfKJqGdeZgJGolzyCr3YLLA2qM1GQ7Q==" crossorigin=anonymous defer></script>
<script src=https://rc1242rc.github.io/maindevelopment/index.min.b20e6e327ff8d439d9d5c469bf00fccca223cb45e9470b71b3703868676dcdc5cf556cf9c5f767d1f5fadf45be2b3734e8c7e6403ac8f763231a05b17e8baca9.js integrity="sha512-sg5uMn/41DnZ1cRpvwD8zKIjy0XpRwtxs3A4aGdtzcXPVWz5xfdn0fX630W+Kzc06MfmQDrI92MjGgWxfousqQ==" crossorigin=anonymous defer></script></body></html>