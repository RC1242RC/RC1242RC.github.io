<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=https://rc1242rc.github.io/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://rc1242rc.github.io/fonts/vendor/jost/jost-v4-latin-500.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://rc1242rc.github.io/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><script>(()=>{var e=localStorage.getItem("theme");e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><link rel=stylesheet href=https://rc1242rc.github.io/main.f12f7e04ea768acebec10c86baf049d74d6a79f24bc0dfb7ed77aa60462432916dd1ce8f41c78b69496adf650b3039a28a210183cce598f09b95d6fecb5ff999.css integrity="sha512-8S9+BOp2is6+wQyGuvBJ101qefJLwN+37XeqYEYkMpFt0c6PQceLaUlq32ULMDmiiiEBg8zlmPCbldb+y1/5mQ==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>file modules/classparse.py - GAMBIT</title><meta name=description content="[No description available]"><link rel=canonical href=https://rc1242rc.github.io/documentation/code/colliderbit_development/files/classparse_8py/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="file modules/classparse.py"><meta property="og:description" content="[No description available]"><meta property="og:url" content="https://rc1242rc.github.io/documentation/code/colliderbit_development/files/classparse_8py/"><meta property="og:site_name" content="GAMBIT"><meta property="og:image" content="https://rc1242rc.github.io/gambit_logo.png"><meta property="og:image:alt" content="GAMBIT"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content><meta name=twitter:creator content><meta name=twitter:title content="file modules/classparse.py"><meta name=twitter:description content="[No description available]"><meta name=twitter:image content="https://rc1242rc.github.io/gambit_logo.png"><meta name=twitter:image:alt content="file modules/classparse.py"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://rc1242rc.github.io/#/schema/organization/1","name":"Doks","url":"https://rc1242rc.github.io/","sameAs":["https://github.com/GambitBSM"],"logo":{"@type":"ImageObject","@id":"https://rc1242rc.github.io/#/schema/image/1","url":"https://rc1242rc.github.io/logo-doks.png","width":450,"height":416,"caption":"Doks"},"image":{"@id":"https://rc1242rc.github.io/#/schema/image/1"}},{"@type":"WebSite","@id":"https://rc1242rc.github.io/#/schema/website/1","url":"https://rc1242rc.github.io/","name":"GAMBIT","description":"Documentation for the Global And Modular BSM Inference Tool","publisher":{"@id":"https://rc1242rc.github.io/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://rc1242rc.github.io/documentation/code/colliderbit_development/files/classparse_8py/","url":"https://rc1242rc.github.io/documentation/code/colliderbit_development/files/classparse_8py/","name":"file modules\/classparse.py","description":"[No description available]","isPartOf":{"@id":"https://rc1242rc.github.io/#/schema/website/1"},"about":{"@id":"https://rc1242rc.github.io/#/schema/organization/1"},"datePublished":"0001-01-01T00:00:00CET","dateModified":"0001-01-01T00:00:00CET","breadcrumb":{"@id":"https://rc1242rc.github.io/documentation/code/colliderbit_development/files/classparse_8py/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://rc1242rc.github.io/documentation/code/colliderbit_development/files/classparse_8py/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://rc1242rc.github.io/documentation/code/colliderbit_development/files/classparse_8py/"]}]},{"@type":"BreadcrumbList","@id":"https://rc1242rc.github.io/documentation/code/colliderbit_development/files/classparse_8py/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/","url":"https://rc1242rc.github.io/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/documentation/","url":"https://rc1242rc.github.io/documentation/","name":"Documentation"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/documentation/code/","url":"https://rc1242rc.github.io/documentation/code/","name":"Code"}},{"@type":"ListItem","position":4,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/documentation/code/colliderbit_development/","url":"https://rc1242rc.github.io/documentation/code/colliderbit_development/","name":"Colliderbit Development"}},{"@type":"ListItem","position":5,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/documentation/code/colliderbit_development/files/","url":"https://rc1242rc.github.io/documentation/code/colliderbit_development/files/","name":"Files"}},{"@type":"ListItem","position":6,"item":{"@id":"https://rc1242rc.github.io/documentation/code/colliderbit_development/files/classparse_8py/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://rc1242rc.github.io/documentation/code/colliderbit_development/files/classparse_8py/#/schema/image/2","url":"https://rc1242rc.github.io/gambit_logo.png","contentUrl":"https://rc1242rc.github.io/gambit_logo.png","caption":"file modules\/classparse.py"}]}]}</script><meta name=theme-color content="#fff"><link rel=icon href=https://rc1242rc.github.io/favicon.ico sizes=any><link rel=icon type=image/svg+xml href=https://rc1242rc.github.io/favicon.svg><link rel=apple-touch-icon sizes=180x180 href=https://rc1242rc.github.io/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://rc1242rc.github.io/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://rc1242rc.github.io/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://rc1242rc.github.io/site.webmanifest></head><body class="documentation single light"><div class=sticky-top><div class=header-bar></div><header class="navbar navbar-expand-md navbar-light doks-navbar"><nav class="container-xxl flex-wrap flex-md-nowrap" aria-label="Main navigation"><a class="navbar-brand p-0 me-auto" href=https://rc1242rc.github.io/ aria-label=GAMBIT><img class=logo-light src=https://rc1242rc.github.io//images/gambit_logo.png width=50px>
<img class="logo-dark d-none" src=https://rc1242rc.github.io//images/gambit_logo.png width=50px>
GAMBIT</a>
<button class="btn btn-menu order-2 d-block d-lg-none" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasDoks aria-controls=offcanvasDoks aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><div class="offcanvas offcanvas-end border-0 py-lg-1" tabindex=-1 id=offcanvasDoks data-bs-backdrop=true aria-labelledby=offcanvasDoksLabel><div class="header-bar d-lg-none"></div><div class="offcanvas-header d-lg-none"><h2 class="h5 offcanvas-title ps-2" id=offcanvasDoksLabel><a class=text-dark href=/>GAMBIT</a></h2><button type=button class="btn-close text-reset me-2" data-bs-dismiss=offcanvas aria-label="Close main menu"></button></div><div class="offcanvas-body p-4 p-lg-0"><ul class="nav flex-column flex-lg-row align-items-lg-center mt-2 mt-lg-0 ms-lg-2 me-lg-auto"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Documentation
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/documentation/installation/introduction/>Installation</a></li><li><a class=dropdown-item href=/documentation/examples/colliderbit>Examples</a></li><li><a class=dropdown-item href=/documentation/help/faqs/>Help</a></li><li><a class=dropdown-item href=/documentation/code/index_classes>Code Reference</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Community
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/community/publications/>Publications</a></li><li><a class=dropdown-item href=/community/talks/>Talks</a></li><li><a class=dropdown-item href=/community/members/>Members</a></li><li><a class=dropdown-item href=/community/code_of_conduct/>Code of Conduct</a></li><li><a class=dropdown-item href=/community/contact/>Contact</a></li></ul></li></ul><hr class="text-black-50 my-4 d-lg-none"><form class="doks-search position-relative flex-grow-1 ms-lg-auto me-lg-2"><input id=search class="form-control is-search" type=search placeholder="Search site..." aria-label="Search site..." autocomplete=off><div id=suggestions class="shadow bg-white rounded d-none"></div></form><hr class="text-black-50 my-4 d-lg-none"><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=https://github.com/GambitBSM><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><small class="ms-2 d-lg-none">GitHub</small></a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn btn-doks-light dropdown-toggle" id=doks-versions data-bs-toggle=dropdown aria-expanded=false data-bs-display=static aria-label="Toggle version menu">
<span class=d-none>Doks</span>
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=doks-versions></ul></div></div></div></nav></header></div><div class="wrap container-xxl" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class=docs-links aria-label="Main navigation"><ul class="list-unstyled collapsible-sidebar"><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-installation aria-expanded=false>
Installation</button><div class=collapse id=section-installation><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/installation/introduction/>Getting Started</a></li><li><a class="docs-link rounded" href=/documentation/installation/docker_usage/>Docker Usage</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_linux/>Installation for Linux</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_windows/>Installation for Windows</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_macos/>Installation for macOS</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-examples aria-expanded=false>
Examples</button><div class=collapse id=section-examples><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/examples/colliderbit/>ColliderBit</a></li><li><a class="docs-link rounded" href=/documentation/examples/anotherbit/>AnotherBit</a></li><li><a class="docs-link rounded" href=/documentation/examples/anotherbit2/>AnotherBit2</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-help aria-expanded=false>
Help</button><div class=collapse id=section-help><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/help/faqs/>FAQs</a></li><li><a class="docs-link rounded" href=/documentation/help/compiler_matrix/>Compiler Matrix</a></li><li><a class="docs-link rounded" href=/documentation/help/known_issues/>Known Issues</a></li><li><a class="docs-link rounded" href=/documentation/help/configuration_examples/>Configuration Examples</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-code aria-expanded=false>
Code Reference</button></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section- aria-expanded=false>
GAMBIT_VERSION_HERE</button><div class=collapse id=section-><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/code/colliderbit_development/index_classes/>Classes</a></li><li><a class="docs-link rounded" href=/documentation/code/colliderbit_development/index_files/>Files</a></li><li><a class="docs-link rounded" href=/documentation/code/colliderbit_development/index_pages/>Pages</a></li><li><a class="docs-link rounded" href=/documentation/code/colliderbit_development/index_namespaces/>Namespaces</a></li></ul></div></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=d-xl-none><button class="btn btn-outline-primary btn-sm doks-toc-toggle collapsed" type=button data-bs-toggle=collapse data-bs-target=#onThisPage aria-controls=doks-docs-nav aria-expanded=false aria-label="Toggle On this page navigation">
<span>On this page</span>
<span><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"/><polyline points="7 6 12 11 17 6"/></svg><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"/><polyline points="17 18 12 13 7 18"/></svg></span></button><div class=collapse id=onThisPage><div class="card card-body mt-3 py-1"><div class=page-links><nav id=TableOfContents><ul><li><ul><li><a href=#namespaces>Namespaces</a></li><li><a href=#source-code>Source code</a></li></ul></li></ul></nav></div></div></div></div><div class="page-links d-none d-xl-block"><h3>On this page</h3><nav id=TableOfContents><ul><li><ul><li><a href=#namespaces>Namespaces</a></li><li><a href=#source-code>Source code</a></li></ul></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9 mx-xl-auto"><h1>file modules/classparse.py</h1><p class=lead></p><p>[No description available]</p><h2 id=namespaces>Namespaces <a href=#namespaces class=anchor aria-hidden=true>#</a></h2><table><thead><tr><th>Name</th></tr></thead><tbody><tr><td><strong><a href=/documentation/code/colliderbit_development/namespaces/namespacemodules/>modules</a></strong></td></tr><tr><td><strong><a href=/documentation/code/colliderbit_development/namespaces/namespacemodules_1_1classparse/>modules::classparse</a></strong></td></tr></tbody></table><h2 id=source-code>Source code <a href=#source-code class=anchor aria-hidden=true>#</a></h2><pre><code>

from __future__ import print_function
from collections import OrderedDict
import os

import modules.active_cfg as active_cfg
exec(&quot;import configs.&quot; + active_cfg.module_name + &quot; as cfg&quot;)
import modules.gb as gb
import modules.utils as utils
import modules.classutils as classutils
import modules.funcutils as funcutils
import modules.infomsg as infomsg

#
# Module-level globals
#

template_done   = []
templ_spec_done = []
added_parent    = []

includes = OrderedDict()


# ====== run ========

# Main function for parsing classes

def run():

    # Clear the module-level dict that keeps track of include statements
    includes.clear()

    #
    # Loop over all classes 
    #
    
    for class_name_long, class_el in gb.loaded_classes_in_xml.items():

        # Clear all info messages
        infomsg.clearInfoMessages()

        # Generate dicts with different variations of the class name
        class_name       = classutils.getClassNameDict(class_el)
        abstr_class_name = classutils.getClassNameDict(class_el, abstract=True)

        # Print current class
        print()
        print('  ' + utils.modifyText('Class:','underline') + ' ' + class_name['long_templ'])

        # Check if this is a template class
        is_template = utils.isTemplateClass(class_el)


        # Make list of all types used in this class
        all_types_in_class = utils.getAllTypesInClass(class_el, include_parents=True)

        # Set a bunch of generally useful variables 
        original_class_file_el   = gb.id_dict[class_el.get('file')]
        original_file_name       = original_class_file_el.get('name')
        original_file_name_base  = os.path.basename(original_file_name)
        original_class_file_dir  = os.path.split(original_file_name)[0]
        extras_src_file_name     = os.path.join(gb.boss_output_dir, gb.general_src_file_prefix + class_name['short'] + cfg.source_extension)

        short_abstr_class_fname  = gb.new_header_files[class_name['long']]['abstract']
        abstr_class_fname        = os.path.join(gb.boss_output_dir, short_abstr_class_fname)

        # namespaces    = class_name['long'].split('::')[:-1]
        namespaces    = utils.getNamespaces(class_el, include_self=False)
        has_namespace = bool(len(namespaces))

        has_copy_constructor, copy_constructor_id         = classutils.checkCopyConstructor(class_el, return_id=True)
        has_assignment_operator, assignment_is_artificial = classutils.checkAssignmentOperator(class_el)
        
        if has_assignment_operator or assignment_is_artificial:
            construct_assignment_operator = True
        else:
            construct_assignment_operator = False


        # Register paths of original files in global dict
        gb.original_file_paths[original_file_name_base] = original_file_name


        # Read content of original class file
        f = open(original_file_name, 'r')
        original_file_content = f.read()
        f.close()
        original_file_content_nocomments = utils.removeComments(original_file_content, insert_blanks=True)


        # Prepare entries in gb.new_code and includes
        if abstr_class_fname not in gb.new_code.keys():
            gb.new_code[abstr_class_fname] = {'code_tuples':[], 'add_include_guard':True}
            gb.new_code[abstr_class_fname + '.FOR_GAMBIT'] = {'code_tuples':[], 'add_include_guard':True}
        if original_file_name not in gb.new_code.keys():
            gb.new_code[original_file_name] = {'code_tuples':[], 'add_include_guard':False}
        if original_file_name not in includes.keys():
            includes[original_file_name] = []
        if extras_src_file_name not in gb.new_code.keys():
            gb.new_code[extras_src_file_name] = {'code_tuples':[], 'add_include_guard':False}


        # Treat the first specialization of a template class differently
        if is_template and class_name['long'] not in template_done:
            template_bracket, template_types = utils.getTemplateBracket(class_el)
            
            empty_templ_class_decl = ''
            empty_templ_class_decl += classutils.constrEmptyTemplClassDecl(abstr_class_name['short'], namespaces, template_bracket, indent=cfg.indent)
            empty_templ_class_decl += classutils.constrTemplForwDecl(class_name['short'], namespaces, template_bracket, indent=cfg.indent)

            gb.new_code[abstr_class_fname]['code_tuples'].append( (0, empty_templ_class_decl) )


        # Get template arguments for specialization, 
        # and check that they are acceptable
        if is_template and class_name['long'] not in templ_spec_done:
            spec_template_types = utils.getSpecTemplateTypes(class_el)
            for template_type in spec_template_types:
                if (template_type not in gb.accepted_types):
                    raise Exception(&quot;The template specialization type '&quot; + template_type + &quot;' for class &quot; + class_name['long'] + &quot; is not among accepted types.&quot;)


        #
        # For the backend: Construct code for the abstract class header file and register it
        #
        
        constrAbstractClassHeaderCode(class_el, class_name, abstr_class_name, namespaces, is_template, 
                                      has_copy_constructor, construct_assignment_operator, abstr_class_fname, file_for_gambit=False)

        #
        # For GAMBIT: Construct code for the abstract class header file and register it
        #
        
        constrAbstractClassHeaderCode(class_el, class_name, abstr_class_name, namespaces, is_template, 
                                      has_copy_constructor, construct_assignment_operator, abstr_class_fname, file_for_gambit=True)



        #
        # Add abstract class to inheritance list of original class
        #

        addAbsClassToInheritanceList(class_el, class_name, abstr_class_name, is_template,
                                     original_file_name, original_file_content_nocomments)
        

        #
        # Generate code for #include statements in orginal header/source file 
        #

        addIncludesToOriginalClassFile(class_el, namespaces, is_template, original_file_name, 
                                       original_file_content_nocomments, original_file_content,
                                       short_abstr_class_fname)



        #
        # Generate additional member functions in the original class:
        # - Abstract class versions of member functions that make use of loaded types.
        # - Extra versions of functions that use default value arguments.
        # - Functions for returning references to public member variables. 
        # Declarations go in the original class header while implementations go in a separate source file.
        #

        generateClassMemberInterface(class_el, class_name, abstr_class_name, namespaces,
                                     original_file_name, original_file_content_nocomments, 
                                     original_class_file_el, extras_src_file_name,
                                     has_copy_constructor, construct_assignment_operator)
        

        #
        # Generate factory functions source file
        #

        generateFactoryFunctions(class_el, class_name, is_template)


        #
        # Generate a header containing the GAMBIT wrapper class
        #

        generateWrapperHeader(class_el, class_name, abstr_class_name, namespaces, short_abstr_class_fname,
                              construct_assignment_operator, has_copy_constructor, copy_constructor_id)


        #
        # Construct utility functions for dealing with pointer-to-wrapper from Abstract class.
        # ('wrapper_creator', 'wrapper_deleter', 'set_delete_BEptr')
        #

        constrWrapperUtils(class_name)


        #
        # Add typedef to 'abstracttypedefs.hpp'
        #

        addAbstractTypedefs(abstr_class_name, namespaces)


        #
        # Add typedef to 'wrappertypdefs.hpp'
        #

        addWrapperTypedefs(class_name, namespaces)


        #
        # Add include guards to the original headers
        #
        gb.new_code[original_file_name]['add_include_guard'] = True
        gb.new_code[original_file_name]['include_guard_prefix'] = 'boss'

        #
        # Keep track of classes done
        #

        gb.classes_done.append(class_name)
        if is_template: 
            if class_name['long'] not in template_done:
                template_done.append(class_name['long'])
            if class_name['long'] not in templ_spec_done:
                templ_spec_done.append(class_name['long'])
        

        print()

    #
    # END: Loop over all classes in gb.loaded_classes_in_xml
    #    

# ====== END: run ========



# ====== constrAbstractClassHeaderCode ========

# Construct code for the abstract class header file and register it

def constrAbstractClassHeaderCode(class_el, class_name, abstr_class_name, namespaces, is_template,
                                  has_copy_constructor, construct_assignment_operator, abstr_class_fname, file_for_gambit=False):

    if file_for_gambit:
        abstr_class_fname = abstr_class_fname + '.FOR_GAMBIT'

    class_decl = ''

    # Add include statements
    include_statements  = []
    include_statements += ['#include &lt;cstddef&gt;']
    if gb.debug_mode or file_for_gambit: 
        include_statements += ['#include &lt;iostream&gt;']
    include_statements += ['#include &quot;' + os.path.join(gb.gambit_backend_incl_dir, 'abstractbase.hpp') + '&quot;']
    include_statements += ['#include &quot;' + gb.frwd_decls_abs_fname + cfg.header_extension + '&quot;']
    include_statements += ['#include &quot;' + gb.frwd_decls_wrp_fname + cfg.header_extension + '&quot;']
    include_statements += utils.getIncludeStatements(class_el, convert_loaded_to='wrapper_decl', exclude_types=[class_name], include_parents=True, use_full_path=False, forward_declared='include')

    include_statements = utils.orderIncludeStatements(include_statements)
    include_statements_code = '\n'.join(include_statements) + 2*'\n'
    class_decl += include_statements_code

    # # Add include statement for the enum declaration header. Put this inside a #ifndef ... #endif block
    # # to avoid multiple declaration when the abstract class header is included from the original class header. 
    # enum_include_statement_code  = ''
    # enum_include_statement_code += '#ifndef ENUMS_DECLARED\n'
    # enum_include_statement_code += '#define ENUMS_DECLARED\n'
    # enum_include_statement_code += '#include &quot;' + gb.enum_decls_wrp_fname + cfg.header_extension + '&quot;\n'
    # # enum_include_statement_code += '#include &quot;' + os.path.join(gb.backend_types_basedir, gb.gambit_backend_name_full, gb.enum_decls_wrp_fname + cfg.header_extension) + '&quot;\n'
    # enum_include_statement_code += '#endif\n'
    # enum_include_statement_code += '\n'
    # class_decl += enum_include_statement_code

    # Add the the code for the abstract class
    if (is_template == True) and (class_name['long'] in templ_spec_done):
        pass
    elif (is_template == True) and (class_name['long'] not in templ_spec_done):
        class_decl += classutils.constrAbstractClassDecl(class_el, class_name, abstr_class_name, namespaces, 
                                                         indent=cfg.indent, file_for_gambit=file_for_gambit, 
                                                         template_types=spec_template_types, 
                                                         has_copy_constructor=has_copy_constructor,
                                                         construct_assignment_operator=construct_assignment_operator)
        class_decl += '\n'
    else:
        class_decl += classutils.constrAbstractClassDecl(class_el, class_name, abstr_class_name, namespaces, 
                                                         indent=cfg.indent, file_for_gambit=file_for_gambit,
                                                         has_copy_constructor=has_copy_constructor,
                                                         construct_assignment_operator=construct_assignment_operator)
        class_decl += '\n'

    # - Register code
    gb.new_code[abstr_class_fname]['code_tuples'].append( (-1, class_decl) )

# ====== END: constrAbstractClassHeaderCode ========



# ====== addAbsClassToInheritanceList ========

# Add abstract class to inheritance list of original class

def addAbsClassToInheritanceList(class_el, class_name, abstr_class_name, is_template,
                                 original_file_name, original_file_content_nocomments):

    # Find positions in the original file
    line_number    = int(class_el.get('line'))
    class_name_pos = classutils.findClassNamePosition(class_el, original_file_content_nocomments)
    newline_pos    = utils.findNewLinePos(original_file_content_nocomments, line_number)


    # Special preparations for template classes:
    if is_template:
    
        # - Determine whether this is the source for the general template 
        #   or for a specialization (look for '&lt;' after class name)
        temp_pos = class_name_pos + len(class_name['short'])
        while True:
            next_char = original_file_content_nocomments[temp_pos]
            if next_char not in [' ', '\t', '\n']:
                break
            else:
                temp_pos += 1
        if next_char == '&lt;':
            src_is_specialization = True
        else:
            src_is_specialization = False

        # - Prepare the template bracket string
        if src_is_specialization:
            add_template_bracket = '&lt;' + ','.join(spec_template_types) + '&gt;'
        else:
            add_template_bracket = '&lt;' + ','.join(template_types) + '&gt;'


    # If no previous parent classes:
    if ('bases' not in class_el.keys()) and (class_name['long'] not in added_parent):

        # - Calculate insert position
        insert_pos = class_name_pos + len(class_name['short'])
        if is_template and src_is_specialization:
            insert_pos += len(add_template_bracket)

        # - Generate code
        add_code = ' : public virtual ' + abstr_class_name['short']
        if is_template == True:
            add_code += add_template_bracket

    # If there are previous parent classes
    else:

        # - Get colon position
        if is_template and src_is_specialization:
            temp_pos = class_name_pos + len(class_name['short']) + len(add_template_bracket)
        else:
            temp_pos = class_name_pos + len(class_name['short'])
        colon_pos = temp_pos + original_file_content_nocomments[temp_pos:newline_pos].find(':')

        # - Calculate insert position
        insert_pos = colon_pos + 1

        # - Generate code
        add_code = ' public virtual ' + abstr_class_name['short']
        if is_template == True:
            add_code += add_template_bracket
        add_code += ','

    # - Register new code
    gb.new_code[original_file_name]['code_tuples'].append( (insert_pos, add_code) )

    # - Update added_parent dict
    added_parent.append(class_name['long'])

# ====== END: addAbsClassToInheritanceList ========



# ====== addIncludesToOriginalClassFile ========

# Generate code for #include statements in orginal header/source file

def addIncludesToOriginalClassFile(class_el, namespaces, is_template, original_file_name, 
                                   original_file_content_nocomments, original_file_content,
                                   short_abstr_class_fname):

    # Generate include statement for abstract class header
    include_line = '#include &quot;' + os.path.join(gb.backend_types_basedir, gb.gambit_backend_name_full, short_abstr_class_fname ) + '&quot;'

    # Check that we haven't included that statement already
    if include_line in includes[original_file_name]:
        return

    # Check for namespace
    has_namespace = bool(len(namespaces))

    # Find class name position in the original file
    class_name_pos = classutils.findClassNamePosition(class_el, original_file_content_nocomments)


    # Find insert position
    if is_template == True:
        insert_pos = original_file_content_nocomments[:class_name_pos].rfind('template')
    else:
        insert_pos = max(original_file_content_nocomments[:class_name_pos].rfind('class'), original_file_content_nocomments[:class_name_pos].rfind('struct'))
    # - Adjust for the indentation
    use_indent = ''
    while insert_pos &gt; 0:
        char = original_file_content[insert_pos-1]
        if char in [' ','\t']:
            use_indent += char
            insert_pos -= 1
        else:
            break

    # Construct code
    include_code = ''
    include_code += use_indent

    for ns in namespaces:
        include_code += '} '

    include_code += '\n'*has_namespace
    include_code += use_indent + '#define ENUMS_DECLARED\n'
    include_code += use_indent + include_line + '\n'
    include_code += use_indent + '#include &quot;' + os.path.join(gb.gambit_backend_incl_dir, gb.abstract_typedefs_fname + cfg.header_extension) +  '&quot;\n'
    include_code += use_indent + '#include &quot;' + os.path.join(gb.gambit_backend_incl_dir, gb.wrapper_typedefs_fname + cfg.header_extension) +  '&quot;\n'
    include_code += use_indent

    for ns in namespaces:
        include_code += 'namespace ' + ns + ' { '

    include_code += '\n'*has_namespace

    # Register code
    gb.new_code[original_file_name]['code_tuples'].append( (insert_pos, include_code) )

    # Register include line
    includes[original_file_name].append(include_line)

# ====== END: addIncludesToOriginalClassFile ========



# ====== generateClassMemberInterface ========

# Generate additional member functions in the original class:
# - Abstract class versions of member functions that make use of loaded types.
# - Extra versions of functions that use default value arguments.
# - Functions for returning references to public member variables. 
# Declarations go in the original class header while implementations go in a separate source file.
    
def generateClassMemberInterface(class_el, class_name, abstr_class_name, namespaces,
                                 original_file_name, original_file_content_nocomments,
                                 original_class_file_el, extras_src_file_name,
                                 has_copy_constructor, construct_assignment_operator):

    # Find class name position in the original file
    class_name_pos = classutils.findClassNamePosition(class_el, original_file_content_nocomments)

    # Create lists of all public, 'non-artificial' members of the class
    member_methods   = []
    member_variables = []
    member_operators = []
    if 'members' in class_el.keys():
        for mem_id in class_el.get('members').split():
            el = gb.id_dict[mem_id]
            if not 'artificial' in el.keys():
                if el.get('access') == 'public':
                    if (el.tag == 'Method'): # and (not funcutils.ignoreFunction(el)):
                        member_methods.append(el)
                    elif (el.tag == 'OperatorMethod'): #and (not funcutils.ignoreFunction(el)):
                        if funcutils.usesNativeType(el):
                            member_operators.append(el)
                    elif (el.tag in ('Field', 'Variable')):
                        if classutils.isAcceptedMemberVariable(el):
                            member_variables.append(el)

    # Determine insert position
    rel_pos_start, rel_pos_end = utils.getBracketPositions(original_file_content_nocomments[class_name_pos:], delims=['{','}'])
    class_body_start = class_name_pos + rel_pos_start
    class_body_end   = class_name_pos + rel_pos_end
    insert_pos = class_body_end

    # Generate code for wrapper functions for each each member function.
    # A declaration goes into the original class header, 
    # while implementations are put in a new source file.

    declaration_code     = '\n'
    implementation_code  = '\n'
    current_access = None
    for method_el in member_methods:

        # We need to generate as many overloaded versions as there are arguments with default values
        n_overloads = funcutils.numberOfDefaultArgs(method_el)
        
        # Check for native types
        uses_native_type = funcutils.usesNativeType(method_el)

        # If no native types are used and no arguments have default values, we don't need a wrapper
        if (not uses_native_type) and (n_overloads == 0):
            continue

        # Generate wrapper code
        for remove_n_args in range(n_overloads+1):
            
            # Check that function is acceptable
            if funcutils.ignoreFunction(method_el, remove_n_args=remove_n_args):
                continue

            if (remove_n_args==0) and (not uses_native_type):
                continue

            # The declaration is put inside the original class
            method_access = method_el.get('access')
            if method_access != current_access:
                declaration_code += ' '*(len(namespaces)+1)*cfg.indent + method_access +':\n'
                current_access = method_access
            declaration_code += classutils.constrWrapperFunction(method_el, indent=cfg.indent, n_indents=len(namespaces)+2, 
                                                                 remove_n_args=remove_n_args, only_declaration=True)
            declaration_code += '\n'

            
            # The implementation goes into a new source file
            implementation_code += classutils.constrWrapperFunction(method_el, indent=cfg.indent, n_indents=0, 
                                                                    remove_n_args=remove_n_args, include_full_namespace=True)
            implementation_code += 2*'\n'

    # - Register code
    gb.new_code[original_file_name]['code_tuples'].append( (insert_pos, declaration_code) )            
    gb.new_code[extras_src_file_name]['code_tuples'].append( (-1, implementation_code) )            


    # Generate code for each member operator
    operator_declaration_code    = '\n'
    operator_implementation_code = '\n'
    for operator_el in member_operators:
        operator_access = operator_el.get('access')
        if operator_access != current_access:
            operator_declaration_code += ' '*(len(namespaces)+1)*cfg.indent + operator_access +':\n'
            current_access = operator_access

        # If default arguments are used, we need several overloads
        n_overloads = funcutils.numberOfDefaultArgs(operator_el)
        for remove_n_args in range(n_overloads+1):

            # Put declaration in original class
            operator_declaration_code += classutils.constrWrapperFunction(operator_el, indent=cfg.indent, n_indents=len(namespaces)+2, 
                                                                          remove_n_args=remove_n_args, only_declaration=True)
            operator_declaration_code += '\n'


            # Put implementation in a new source file
            operator_implementation_code += classutils.constrWrapperFunction(operator_el, indent=cfg.indent, n_indents=0, 
                                                                             remove_n_args=remove_n_args, include_full_namespace=True)
            operator_implementation_code += 2*'\n'


    # - Register code
    gb.new_code[original_file_name]['code_tuples'].append( (insert_pos, operator_declaration_code) )            
    gb.new_code[extras_src_file_name]['code_tuples'].append( (-1, operator_implementation_code) )            


    # Generate a reference-returning method for each (public) member variable:
    ref_func_declaration_code    = ''
    ref_func_implementation_code = ''
    if len(member_variables) &gt; 0:
        n_indents = len(namespaces)
        ref_func_declaration_code += '\n'
        ref_func_declaration_code += ' '*cfg.indent*(n_indents+1) + 'public:\n'
        for var_el in member_variables:

            # Put declaration in original code
            ref_func_declaration_code += classutils.constrVariableRefFunction(var_el, virtual=False, indent=cfg.indent, n_indents=n_indents+2, 
                                                                              only_declaration=True, add_return_type_suffix=True)
            ref_func_declaration_code += '\n'

            # Put implementation in a new source file
            ref_func_implementation_code += classutils.constrVariableRefFunction(var_el, virtual=False, indent=cfg.indent, n_indents=0,
                                                                                 include_full_namespace=True, add_return_type_suffix=True) 
            ref_func_implementation_code += '\n'


    # - Register code
    if ref_func_declaration_code != '':
        gb.new_code[original_file_name]['code_tuples'].append( (insert_pos, ref_func_declaration_code) )            
        gb.new_code[extras_src_file_name]['code_tuples'].append( (-1, ref_func_implementation_code) )            



    # Generate pointer-based copy and assignment functions

    # If class contains pure virtual members, do not generate any factory functions
    if class_name['long_templ'] in gb.contains_pure_virtual_members:
        reason = &quot;Contains pure virtual member functions.&quot;
        infomsg.NoPointerCopyAndAssignmentFunctions(class_name['long_templ'], reason).printMessage()
    else:

        n_indents = len(namespaces)
        ptr_declaration_code = '\n'
        ptr_implementation_code = '\n'

        if has_copy_constructor or construct_assignment_operator:
            ptr_declaration_code += ' '*cfg.indent*(n_indents+1) + 'public:\n'

        if has_copy_constructor:
            ptr_declaration_code += classutils.constrPtrCopyFunc(class_el, abstr_class_name['short'], class_name['short'], virtual=False, indent=cfg.indent, n_indents=n_indents+2, only_declaration=True)
            ptr_declaration_code += '\n'

        if construct_assignment_operator:
            ptr_declaration_code += ' '*cfg.indent*(n_indents+2) + 'using ' + abstr_class_name['short'] + '::pointer_assign' + gb.code_suffix + ';\n'
            ptr_declaration_code += classutils.constrPtrAssignFunc(class_el, abstr_class_name['short'], class_name['short'], virtual=False, indent=cfg.indent, n_indents=n_indents+2, only_declaration=True)
        
        ptr_implementation_code += '#include &quot;' + os.path.join(gb.backend_types_basedir, gb.gambit_backend_name_full,'identification.hpp') + '&quot;\n'
        ptr_implementation_code += '\n'
        if has_copy_constructor:
          ptr_implementation_code += classutils.constrPtrCopyFunc(class_el, abstr_class_name['short'], class_name['short'], virtual=False, indent=cfg.indent, n_indents=0, include_full_namespace=True)
          ptr_implementation_code += '\n'
        if construct_assignment_operator:
          ptr_implementation_code += classutils.constrPtrAssignFunc(class_el, abstr_class_name['short'], class_name['short'], virtual=False, indent=cfg.indent, n_indents=0, include_full_namespace=True)
          ptr_implementation_code += '\n'
        ptr_implementation_code += '#include &quot;' + os.path.join(gb.gambit_backend_incl_dir, 'backend_undefs.hpp') + '&quot;\n'

        # - Generate include statements for the new source file
        include_statements = []
        include_statements += utils.getIncludeStatements(class_el, convert_loaded_to='none', input_element='class', use_full_path=True, forward_declared='only')
        include_statements += utils.getIncludeStatements(class_el, convert_loaded_to='wrapper', input_element='class', use_full_path=True, forward_declared='exclude')
        include_statements.append('#include &quot;' + os.path.join(gb.gambit_backend_incl_dir, gb.abstract_typedefs_fname + cfg.header_extension) + '&quot;')
        include_statements.append('#include &quot;' + os.path.join(gb.gambit_backend_incl_dir, gb.wrapper_typedefs_fname + cfg.header_extension) + '&quot;')

        if utils.isHeader(original_class_file_el):
            use_path = utils.shortenHeaderPath(original_file_name)
            include_statements.append( '#include &quot;' + use_path + '&quot;')

        include_statements = list( OrderedDict.fromkeys(include_statements) )
        include_statements = utils.orderIncludeStatements(include_statements)
        include_statements_code = '\n'.join(include_statements) + '\n'

        # - Register the code
        gb.new_code[original_file_name]['code_tuples'].append( (insert_pos, ptr_declaration_code) )

        gb.new_code[extras_src_file_name]['code_tuples'].append( (0, include_statements_code) )            
        gb.new_code[extras_src_file_name]['code_tuples'].append( (-1, ptr_implementation_code) )


# ====== END: generateClassMemberInterface ========



# ====== generateFactoryFunctions ========

# Generate factory functions source file

def generateFactoryFunctions(class_el, class_name, is_template):

    # If class contains pure virtual members, do not generate any factory functions
    if class_name['long_templ'] in gb.contains_pure_virtual_members:
        reason = &quot;Contains pure virtual member functions.&quot;
        infomsg.NoFactoryFunctions(class_name['long_templ'], reason).printMessage()
        return 

    # Generate factory file content
    factory_file_content  = ''

    if is_template:
        spec_template_types = utils.getSpecTemplateTypes(class_el)
        factory_file_content += classutils.constrFactoryFunctionCode(class_el, class_name, indent=cfg.indent, template_types=spec_template_types, skip_copy_constructors=True, use_wrapper_return=False, use_wrapper_args=True)
    else:
        factory_file_content += classutils.constrFactoryFunctionCode(class_el, class_name, indent=cfg.indent, skip_copy_constructors=True, use_wrapper_return=False, use_wrapper_args=True)
    factory_file_content += '\n'

    # If no file content has been generated (no public constructors), return without doing anything
    if factory_file_content.strip() == '':
        return

    # Generate factory file name
    dir_name = gb.boss_output_dir
    factory_file_name = os.path.join(dir_name, gb.factory_file_prefix + class_name['short'] + cfg.source_extension)

    # Register code
    if factory_file_name not in gb.new_code.keys():
        gb.new_code[factory_file_name] = {'code_tuples':[], 'add_include_guard':False}
    gb.new_code[factory_file_name]['code_tuples'].append( (-1, factory_file_content) )

    # Register that this class has a factory file
    gb.class_factory_file_dict[class_name['long_templ']] = factory_file_name

# ====== END: generateFactoryFunctions ========



# ====== generateWrapperHeader ========

# Generate a header containing the GAMBIT wrapper class

def generateWrapperHeader(class_el, class_name, abstr_class_name, namespaces, short_abstr_class_fname,
                          construct_assignment_operator, has_copy_constructor, copy_constructor_id):

    # Set file names and paths
    wrapper_decl_header_fname = gb.new_header_files[class_name['long']]['wrapper_decl']
    wrapper_def_header_fname  = gb.new_header_files[class_name['long']]['wrapper_def']
    wrapper_header_fname      = gb.new_header_files[class_name['long']]['wrapper']

    wrapper_decl_header_path = os.path.join(gb.boss_output_dir, wrapper_decl_header_fname)
    wrapper_def_header_path  = os.path.join(gb.boss_output_dir, wrapper_def_header_fname)
    wrapper_header_path      = os.path.join(gb.boss_output_dir, wrapper_header_fname)
    
    # Get code for the declaration and implementation headers
    wrapper_decl_header_content, wrapper_def_header_content = classutils.generateWrapperHeaderCode(class_el, class_name, abstr_class_name,
                                                                                                   namespaces, short_abstr_class_fname, 
                                                                                                   construct_assignment_operator, has_copy_constructor,
                                                                                                   copy_constructor_id=copy_constructor_id)

    # Code for the overall header file
    wrapper_decl_header_include_path = gb.new_header_files[class_name['long']]['wrapper_decl']
    wrapper_def_header_include_path  = gb.new_header_files[class_name['long']]['wrapper_def']
    wrapper_header_content  = '\n'
    wrapper_header_content += '#include &quot;' + wrapper_decl_header_include_path + '&quot;\n'
    wrapper_header_content += '#include &quot;' + wrapper_def_header_include_path + '&quot;\n'
    wrapper_header_content += '\n'


    # Register code
    if wrapper_decl_header_path not in gb.new_code.keys():
        gb.new_code[wrapper_decl_header_path] = {'code_tuples':[], 'add_include_guard':True}
    gb.new_code[wrapper_decl_header_path]['code_tuples'].append( (0, wrapper_decl_header_content) )

    if wrapper_def_header_path not in gb.new_code.keys():
        gb.new_code[wrapper_def_header_path] = {'code_tuples':[], 'add_include_guard':True}
    gb.new_code[wrapper_def_header_path]['code_tuples'].append( (0, wrapper_def_header_content) )

    if wrapper_header_path not in gb.new_code.keys():
        gb.new_code[wrapper_header_path] = {'code_tuples':[], 'add_include_guard':True}
    gb.new_code[wrapper_header_path]['code_tuples'].append( (0, wrapper_header_content) )

# ====== END: generateWrapperHeader ========


# ====== constrWrapperUtils ========

# Construct functions for dealing with wrapper pointer from abstract class 
# ('wrapper_creator', 'wrapper_deleter', 'set_delete_BEptr')

def constrWrapperUtils(class_name):

    wrapper_class_name = classutils.toWrapperType(class_name['long'], include_namespace=True)
    abstr_class_name = classutils.toAbstractType(class_name['long'], include_namespace=True)

    # Include statement for the header file
    wrapper_include_statement_decl = '#include &quot;' + gb.new_header_files[class_name['long']]['wrapper_fullpath'] + '&quot;\n'

    wr_utils_decl = ''
    wr_utils_impl = ''


    #
    # wrapper_creator
    #

    # Function declaration
    wr_utils_decl  = '\n'
    wr_utils_decl += wrapper_class_name + '* wrapper_creator(' + abstr_class_name + '*);\n'

    # Function implementation
    wr_utils_impl  = '\n'
    wr_utils_impl += wrapper_class_name + '* wrapper_creator(' + abstr_class_name + '* abs_ptr)\n'
    wr_utils_impl += '{\n'
    wr_utils_impl += ' '*cfg.indent + 'return new ' + wrapper_class_name + '(abs_ptr);\n'
    wr_utils_impl += '}\n'

    # #
    # # wrapper_creator
    # #

    # # Function declaration
    # wr_utils_decl  = '\n'
    # wr_utils_decl += 'void wrapper_creator(' + abstr_class_name + '*);\n'

    # # Function implementation
    # wr_utils_impl  = '\n'
    # wr_utils_impl += 'void wrapper_creator(' + abstr_class_name + '* abs_ptr)\n'
    # wr_utils_impl += '{\n'
    # wr_utils_impl += ' '*cfg.indent + 'abs_ptr-&gt;set_wptr( new ' + wrapper_class_name + '(abs_ptr) );\n'
    # wr_utils_impl += '}\n'


    #
    # wrapper_deleter
    #

    # Function declaration
    wr_utils_decl += '\n'
    wr_utils_decl += 'void wrapper_deleter(' + wrapper_class_name + '*);\n'

    # Function implementation
    wr_utils_impl += '\n'
    wr_utils_impl += 'void wrapper_deleter(' + wrapper_class_name + '* wptr)\n'
    wr_utils_impl += '{\n'
    wr_utils_impl += ' '*cfg.indent + 'wptr-&gt;set_delete_BEptr(false);\n'
    wr_utils_impl += ' '*cfg.indent + 'delete wptr;\n'
    wr_utils_impl += '}\n'


    #
    # set_delete_BEptr
    #

    # Function declaration
    wr_utils_decl += '\n'
    wr_utils_decl += 'void set_delete_BEptr(' + wrapper_class_name + '*, bool);\n'

    # Function implementation
    wr_utils_impl += '\n'
    wr_utils_impl += 'void set_delete_BEptr(' + wrapper_class_name + '* wptr, bool setting)\n'
    wr_utils_impl += '{\n'
    wr_utils_impl += ' '*cfg.indent + 'wptr-&gt;set_delete_BEptr(setting);\n'
    wr_utils_impl += '}\n'


    # Register code
    w_creator_header_path = os.path.join(gb.boss_output_dir, gb.wrapper_utils_fname + cfg.header_extension)
    w_creator_source_path = os.path.join(gb.boss_output_dir, gb.wrapper_utils_fname + cfg.source_extension)

    if w_creator_header_path not in gb.new_code.keys():
        gb.new_code[w_creator_header_path] = {'code_tuples':[], 'add_include_guard':True}

        gb.new_code[w_creator_header_path]['code_tuples'].append( (0, '#include &quot;' + os.path.join(gb.gambit_backend_incl_dir, gb.wrapper_typedefs_fname + cfg.header_extension) + '&quot;\n') )
        gb.new_code[w_creator_header_path]['code_tuples'].append( (0, '#include &quot;' + os.path.join(gb.gambit_backend_incl_dir, gb.abstract_typedefs_fname + cfg.header_extension) + '&quot;\n') )

    gb.new_code[w_creator_header_path]['code_tuples'].append( (0, wrapper_include_statement_decl) )        
    gb.new_code[w_creator_header_path]['code_tuples'].append( (-1, wr_utils_decl) )        

    if w_creator_source_path not in gb.new_code.keys():
        w_creator_include = '#include &quot;' + os.path.join(gb.gambit_backend_incl_dir, gb.wrapper_utils_fname + cfg.header_extension) + '&quot;\n'
        gb.new_code[w_creator_source_path] = {'code_tuples':[(0,w_creator_include)], 'add_include_guard':False}
    gb.new_code[w_creator_source_path]['code_tuples'].append( (-1, wr_utils_impl) )        

# ====== END: constrWrapperUtils ========




# ====== addAbstractTypedefs ========

# Add typedef to 'abstracttypedefs.hpp'

def addAbstractTypedefs(abstr_class_name, namespaces):

    indent = ' '*cfg.indent*len(namespaces)
    abstr_typedef_code  = ''
    abstr_typedef_code += utils.constrNamespace(namespaces, 'open', indent=cfg.indent)

    temp_namespace_list = [gb.gambit_backend_namespace] + namespaces
    abstr_typedef_code += indent + 'typedef ' + '::'.join(temp_namespace_list) + '::' + abstr_class_name['short'] + ' ' + abstr_class_name['short'] + ';\n'

    abstr_typedef_code += utils.constrNamespace(namespaces, 'close', indent=cfg.indent)
    abstr_typedef_code += '\n'

    frw_decl_include_statement       = '#include &quot;' + os.path.join(gb.backend_types_basedir, gb.gambit_backend_name_full, gb.frwd_decls_abs_fname + cfg.header_extension) + '&quot;\n'
    identification_include_statement = '#include &quot;' + os.path.join(gb.backend_types_basedir, gb.gambit_backend_name_full, 'identification.hpp') + '&quot;\n\n'
    undef_include_statement          = '#include &quot;' + os.path.join(gb.gambit_backend_incl_dir, 'backend_undefs.hpp') + '&quot;\n'

    abstracts_typedefs_header_path = os.path.join(gb.boss_output_dir, gb.abstract_typedefs_fname + cfg.header_extension)
    if abstracts_typedefs_header_path not in gb.new_code.keys():
        gb.new_code[abstracts_typedefs_header_path] = {'code_tuples':[], 'add_include_guard':False}

        gb.new_code[abstracts_typedefs_header_path]['code_tuples'].append( (0,  frw_decl_include_statement) ) 
        gb.new_code[abstracts_typedefs_header_path]['code_tuples'].append( (len(frw_decl_include_statement), identification_include_statement) ) 
        gb.new_code[abstracts_typedefs_header_path]['code_tuples'].append( (-1, undef_include_statement) ) 

    gb.new_code[abstracts_typedefs_header_path]['code_tuples'].append( (-len(undef_include_statement), abstr_typedef_code) )

# ====== END: addAbstractTypedefs ========



# ====== addWrapperTypedefs ========

# Add typedef to 'wrappertypdefs.hpp'

def addWrapperTypedefs(class_name, namespaces):

    short_wrapper_class_name = classutils.toWrapperType(class_name['short'])

    indent = ' '*cfg.indent*len(namespaces)

    wrapper_typedef_code  = ''
    wrapper_typedef_code += utils.constrNamespace(namespaces,'open')

    temp_namespace_list = [gb.gambit_backend_namespace] + namespaces
    wrapper_typedef_code += indent + 'typedef ' + '::'.join(temp_namespace_list) + '::' + class_name['short'] + ' ' + short_wrapper_class_name + ';\n'

    wrapper_typedef_code += utils.constrNamespace(namespaces,'close')
    wrapper_typedef_code += '\n'

    frw_decl_include_statement       = '#include &quot;' + os.path.join(gb.backend_types_basedir, gb.gambit_backend_name_full, gb.frwd_decls_wrp_fname + cfg.header_extension) + '&quot;\n'
    identification_include_statement = '#include &quot;' + os.path.join(gb.backend_types_basedir, gb.gambit_backend_name_full, 'identification.hpp') + '&quot;\n\n'
    undef_include_statement          = '#include &quot;' + os.path.join(gb.gambit_backend_incl_dir, 'backend_undefs.hpp') + '&quot;\n'

    wrapper_typedefs_path = os.path.join(gb.boss_output_dir, gb.wrapper_typedefs_fname + cfg.header_extension)

    if wrapper_typedefs_path not in gb.new_code.keys():
        gb.new_code[wrapper_typedefs_path] = {'code_tuples':[], 'add_include_guard':False}

        gb.new_code[wrapper_typedefs_path]['code_tuples'].append( (0,  frw_decl_include_statement) ) 
        gb.new_code[wrapper_typedefs_path]['code_tuples'].append( (len(frw_decl_include_statement), identification_include_statement) ) 
        gb.new_code[wrapper_typedefs_path]['code_tuples'].append( (-1, undef_include_statement) ) 

    gb.new_code[wrapper_typedefs_path]['code_tuples'].append( (-len(undef_include_statement), wrapper_typedef_code) )

# ====== END: addWrapperTypedefs ========
</code></pre><hr><p>Updated on 2022-08-02 at 18:18:39 +0000</p><div class=edit-page><a href=https://github.com/RC1242RC/gambit_gh_pages/blob/master/content/en/documentation/code/ColliderBit_development/Files/classparse_8py.md><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828.0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>Edit this page on GitHub</a></div></main></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Powered by <a class=text-muted href=https://www.netlify.com/>Netlify</a>, <a class=text-muted href=https://gohugo.io/>Hugo</a>, and <a class=text-muted href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline><li class=list-inline-item><a href=/license/>License</a></li></ul></div></div></div></footer><script src=/js/bootstrap.min.54bf0932b8a36d0e152b1635b099a6ef1394d35327e2437550a075c9c8ed1bd8aed5847c21b36fc02ed24014c031d9ca24017b0c78b1639d7e2fa8329898b842.js integrity="sha512-VL8JMrijbQ4VKxY1sJmm7xOU01Mn4kN1UKB1ycjtG9iu1YR8IbNvwC7SQBTAMdnKJAF7DHixY51+L6gymJi4Qg==" crossorigin=anonymous defer></script>
<script src=/js/highlight.min.5b48bc253dc75aeea5fb366ecf700f4925e2b6eb1a1466f2124b722d68148d67bc0a9365d2b8ad9c585161b46372d23b08509a16f1fd518542b894756d4752d0.js integrity="sha512-W0i8JT3HWu6l+zZuz3APSSXitusaFGbyEktyLWgUjWe8CpNl0ritnFhRYbRjctI7CFCaFvH9UYVCuJR1bUdS0A==" crossorigin=anonymous defer></script>
<script src=/main.min.40265e9a032aeba5eaf67baac3cbbc22667a7533215d326eeb3e9f4d5e4be40f9ff4dcd22949db73ae527ca26a19d7998091a8973c82af760b2c0daa335190ed.js integrity="sha512-QCZemgMq66Xq9nuqw8u8ImZ6dTMhXTJu6z6fTV5L5A+f9NzSKUnbc65SfKJqGdeZgJGolzyCr3YLLA2qM1GQ7Q==" crossorigin=anonymous defer></script>
<script src=https://rc1242rc.github.io/index.min.bf15e814991a9d3ef02f52a26d135d3cd0a098afc407e971daad9f276d437236be129db79cd96bd09f86d0730d8272253cdaff9edd528739d4fc2013efa8d4ba.js integrity="sha512-vxXoFJkanT7wL1KibRNdPNCgmK/EB+lx2q2fJ21Dcja+Ep23nNlr0J+G0HMNgnIlPNr/nt1ShznU/CAT76jUug==" crossorigin=anonymous defer></script></body></html>