<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=https://rc1242rc.github.io/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://rc1242rc.github.io/fonts/vendor/jost/jost-v4-latin-500.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://rc1242rc.github.io/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><script>(()=>{var e=localStorage.getItem("theme");e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><link rel=stylesheet href=https://rc1242rc.github.io/main.1fa2debdf0a1b20e7268d11906902449af896197928a5bdae9dca95b629cdd73746db3d8c6afacb7320d9deb149a318c764669d08a1ddfd34a657ab2aeab866a.css integrity="sha512-H6LevfChsg5yaNEZBpAkSa+JYZeSilva6dypW2Kc3XN0bbPYxq+stzINnesUmjGMdkZp0Iod39NKZXqyrquGag==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>file src/Axions.cpp - GAMBIT</title><meta name=description content="[No description available]"><link rel=canonical href=https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/axions_8cpp/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="file src/Axions.cpp"><meta property="og:description" content="[No description available]"><meta property="og:url" content="https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/axions_8cpp/"><meta property="og:site_name" content="GAMBIT"><meta property="og:image" content="https://rc1242rc.github.io/gambit_logo.png"><meta property="og:image:alt" content="GAMBIT"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content><meta name=twitter:creator content><meta name=twitter:title content="file src/Axions.cpp"><meta name=twitter:description content="[No description available]"><meta name=twitter:image content="https://rc1242rc.github.io/gambit_logo.png"><meta name=twitter:image:alt content="file src/Axions.cpp"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://rc1242rc.github.io/#/schema/organization/1","name":"Doks","url":"https://rc1242rc.github.io/","sameAs":["https://github.com/GambitBSM"],"logo":{"@type":"ImageObject","@id":"https://rc1242rc.github.io/#/schema/image/1","url":"https://rc1242rc.github.io/logo-doks.png","width":450,"height":416,"caption":"Doks"},"image":{"@id":"https://rc1242rc.github.io/#/schema/image/1"}},{"@type":"WebSite","@id":"https://rc1242rc.github.io/#/schema/website/1","url":"https://rc1242rc.github.io/","name":"GAMBIT","description":"Documentation for the Global And Modular BSM Inference Tool","publisher":{"@id":"https://rc1242rc.github.io/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/axions_8cpp/","url":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/axions_8cpp/","name":"file src\/Axions.cpp","description":"[No description available]","isPartOf":{"@id":"https://rc1242rc.github.io/#/schema/website/1"},"about":{"@id":"https://rc1242rc.github.io/#/schema/organization/1"},"datePublished":"0001-01-01T00:00:00CET","dateModified":"0001-01-01T00:00:00CET","breadcrumb":{"@id":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/axions_8cpp/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/axions_8cpp/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/axions_8cpp/"]}]},{"@type":"BreadcrumbList","@id":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/axions_8cpp/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/","url":"https://rc1242rc.github.io/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/documentation/","url":"https://rc1242rc.github.io/documentation/","name":"Documentation"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/documentation/code/","url":"https://rc1242rc.github.io/documentation/code/","name":"Code"}},{"@type":"ListItem","position":4,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/","url":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/","name":"Gambit Sphinx"}},{"@type":"ListItem","position":5,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/","url":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/","name":"Files"}},{"@type":"ListItem","position":6,"item":{"@id":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/axions_8cpp/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/axions_8cpp/#/schema/image/2","url":"https://rc1242rc.github.io/gambit_logo.png","contentUrl":"https://rc1242rc.github.io/gambit_logo.png","caption":"file src\/Axions.cpp"}]}]}</script><meta name=theme-color content="#fff"><link rel=icon href=https://rc1242rc.github.io/favicon.ico sizes=any><link rel=icon type=image/svg+xml href=https://rc1242rc.github.io/favicon.svg><link rel=apple-touch-icon sizes=180x180 href=https://rc1242rc.github.io/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://rc1242rc.github.io/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://rc1242rc.github.io/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://rc1242rc.github.io/site.webmanifest></head><body class="documentation single light"><div class=sticky-top><div class=header-bar></div><header class="navbar navbar-expand-md navbar-light doks-navbar"><nav class="container-xxl flex-wrap flex-md-nowrap" aria-label="Main navigation"><a class="navbar-brand p-0 me-auto" href=https://rc1242rc.github.io/ aria-label=GAMBIT><img class=logo-light src=https://rc1242rc.github.io//images/gambit_logo.png width=50px>
<img class="logo-dark d-none" src=https://rc1242rc.github.io//images/gambit_logo.png width=50px>
GAMBIT</a>
<button class="btn btn-menu order-2 d-block d-lg-none" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasDoks aria-controls=offcanvasDoks aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><div class="offcanvas offcanvas-end border-0 py-lg-1" tabindex=-1 id=offcanvasDoks data-bs-backdrop=true aria-labelledby=offcanvasDoksLabel><div class="header-bar d-lg-none"></div><div class="offcanvas-header d-lg-none"><h2 class="h5 offcanvas-title ps-2" id=offcanvasDoksLabel><a class=text-dark href=/>GAMBIT</a></h2><button type=button class="btn-close text-reset me-2" data-bs-dismiss=offcanvas aria-label="Close main menu"></button></div><div class="offcanvas-body p-4 p-lg-0"><ul class="nav flex-column flex-lg-row align-items-lg-center mt-2 mt-lg-0 ms-lg-2 me-lg-auto"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Documentation
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/documentation/installation/introduction/>Installation</a></li><li><a class=dropdown-item href=/documentation/examples/colliderbit>Examples</a></li><li><a class=dropdown-item href=/documentation/help/faqs/>Help</a></li><li><a class=dropdown-item href=/documentation/code/index_classes>Code Reference</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Community
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/community/publications/>Publications</a></li><li><a class=dropdown-item href=/community/talks/>Talks</a></li><li><a class=dropdown-item href=/community/members/>Members</a></li><li><a class=dropdown-item href=/community/code_of_conduct/>Code of Conduct</a></li><li><a class=dropdown-item href=/community/contact/>Contact</a></li></ul></li></ul><hr class="text-black-50 my-4 d-lg-none"><form class="doks-search position-relative flex-grow-1 ms-lg-auto me-lg-2"><input id=search class="form-control is-search" type=search placeholder="Search site..." aria-label="Search site..." autocomplete=off><div id=suggestions class="shadow bg-white rounded d-none"></div></form><hr class="text-black-50 my-4 d-lg-none"><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=https://github.com/GambitBSM><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><small class="ms-2 d-lg-none">GitHub</small></a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn btn-doks-light dropdown-toggle" id=doks-versions data-bs-toggle=dropdown aria-expanded=false data-bs-display=static aria-label="Toggle version menu">
<span class=d-none>Doks</span>
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=doks-versions></ul></div></div></div></nav></header></div><div class="wrap container-xxl" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class=docs-links aria-label="Main navigation"><ul class="list-unstyled collapsible-sidebar"><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-installation aria-expanded=false>
Installation</button><div class=collapse id=section-installation><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/installation/introduction/>Getting Started</a></li><li><a class="docs-link rounded" href=/documentation/installation/docker_usage/>Docker Usage</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_linux/>Installation for Linux</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_windows/>Installation for Windows</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_macos/>Installation for macOS</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-examples aria-expanded=false>
Examples</button><div class=collapse id=section-examples><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/examples/colliderbit/>ColliderBit</a></li><li><a class="docs-link rounded" href=/documentation/examples/anotherbit/>AnotherBit</a></li><li><a class="docs-link rounded" href=/documentation/examples/anotherbit2/>AnotherBit2</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-help aria-expanded=false>
Help</button><div class=collapse id=section-help><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/help/faqs/>FAQs</a></li><li><a class="docs-link rounded" href=/documentation/help/compiler_matrix/>Compiler Matrix</a></li><li><a class="docs-link rounded" href=/documentation/help/known_issues/>Known Issues</a></li><li><a class="docs-link rounded" href=/documentation/help/configuration_examples/>Configuration Examples</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-code aria-expanded=false>
Code Reference</button><div class=collapse id=section-code><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/code/darkbit_development/index_classes/>Classes</a></li><li><a class="docs-link rounded" href=/documentation/code/darkbit_development/index_files/>Files</a></li><li><a class="docs-link rounded" href=/documentation/code/darkbit_development/index_pages/>Pages</a></li><li><a class="docs-link rounded" href=/documentation/code/darkbit_development/index_namespaces/>Namespaces</a></li></ul></div></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=d-xl-none><button class="btn btn-outline-primary btn-sm doks-toc-toggle collapsed" type=button data-bs-toggle=collapse data-bs-target=#onThisPage aria-controls=doks-docs-nav aria-expanded=false aria-label="Toggle On this page navigation">
<span>On this page</span>
<span><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"/><polyline points="7 6 12 11 17 6"/></svg><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"/><polyline points="17 18 12 13 7 18"/></svg></span></button><div class=collapse id=onThisPage><div class="card card-body mt-3 py-1"><div class=page-links><nav id=TableOfContents><ul><li><ul><li><a href=#namespaces>Namespaces</a></li><li><a href=#classes>Classes</a></li><li><a href=#detailed-description>Detailed Description</a></li><li><a href=#source-code>Source code</a></li></ul></li></ul></nav></div></div></div></div><div class="page-links d-none d-xl-block"><h3>On this page</h3><nav id=TableOfContents><ul><li><ul><li><a href=#namespaces>Namespaces</a></li><li><a href=#classes>Classes</a></li><li><a href=#detailed-description>Detailed Description</a></li><li><a href=#source-code>Source code</a></li></ul></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9 mx-xl-auto"><h1>file src/Axions.cpp</h1><p class=lead></p><p>[No description available] <a href=#detailed-description>More&mldr;</a></p><h2 id=namespaces>Namespaces <a href=#namespaces class=anchor aria-hidden=true>#</a></h2><table><thead><tr><th>Name</th></tr></thead><tbody><tr><td><strong><a href=/documentation/code/namespaces/namespacegambit/>Gambit</a></strong><br>TODO: see if we can use this one:</td></tr><tr><td><strong><a href=/documentation/code/namespaces/namespacegambit_1_1darkbit/>Gambit::DarkBit</a></strong></td></tr></tbody></table><h2 id=classes>Classes <a href=#classes class=anchor aria-hidden=true>#</a></h2><table><thead><tr><th></th><th>Name</th></tr></thead><tbody><tr><td>class</td><td><strong><a href=/documentation/code/classes/classgambit_1_1darkbit_1_1axioninterpolator/>Gambit::DarkBit::AxionInterpolator</a></strong></td></tr><tr><td>class</td><td><strong><a href=/documentation/code/classes/classgambit_1_1darkbit_1_1axioninterpolator2d/>Gambit::DarkBit::AxionInterpolator2D</a></strong></td></tr><tr><td>class</td><td><strong><a href=/documentation/code/classes/classgambit_1_1darkbit_1_1hess__interpolator/>Gambit::DarkBit::HESS_Interpolator</a></strong></td></tr><tr><td>class</td><td><strong><a href=/documentation/code/classes/classgambit_1_1darkbit_1_1solarmodel/>Gambit::DarkBit::SolarModel</a></strong></td></tr><tr><td>struct</td><td><strong><a href=/documentation/code/classes/structgambit_1_1darkbit_1_1solarmodel__params1/>Gambit::DarkBit::SolarModel_params1</a></strong></td></tr><tr><td>struct</td><td><strong><a href=/documentation/code/classes/structgambit_1_1darkbit_1_1solarmodel__params2/>Gambit::DarkBit::SolarModel_params2</a></strong></td></tr><tr><td>struct</td><td><strong><a href=/documentation/code/classes/structgambit_1_1darkbit_1_1solarmodel__params3/>Gambit::DarkBit::SolarModel_params3</a></strong></td></tr><tr><td>struct</td><td><strong><a href=/documentation/code/classes/structgambit_1_1darkbit_1_1solarmodel__params4/>Gambit::DarkBit::SolarModel_params4</a></strong></td></tr><tr><td>class</td><td><strong><a href=/documentation/code/classes/classgambit_1_1darkbit_1_1cast__solarmodel__interpolator/>Gambit::DarkBit::CAST_SolarModel_Interpolator</a></strong></td></tr><tr><td>struct</td><td><strong><a href=/documentation/code/classes/structgambit_1_1darkbit_1_1axionedt__params/>Gambit::DarkBit::AxionEDT_params</a></strong></td></tr><tr><td>class</td><td><strong><a href=/documentation/code/classes/classgambit_1_1darkbit_1_1wdinterpolator/>Gambit::DarkBit::WDInterpolator</a></strong></td></tr><tr><td>struct</td><td><strong><a href=/documentation/code/classes/structgambit_1_1darkbit_1_1drde__params/>Gambit::DarkBit::dRdE_params</a></strong></td></tr></tbody></table><h2 id=detailed-description>Detailed Description <a href=#detailed-description class=anchor aria-hidden=true>#</a></h2><p><strong>Author</strong>: Sebastian Hoof (<a href=mailto:hoof@uni-goettingen.de>hoof@uni-goettingen.de</a>)</p><p><strong>Date</strong>:</p><ul><li>2016 Oct</li><li>2017 Jan, Feb, June, July, Sept - Dec</li><li>2018 Jan, Mar - May, Sept</li><li>2019 Feb, May - July</li><li>2020 Sept, Dec</li><li>2021 Jan</li><li>2022 May</li></ul><p>GAMBIT: Global and Modular BSM Inference Tool</p><hr><p>Axion-specific module functions for DarkBit.</p><hr><p>Authors (add name and date if you modify):</p><hr><h2 id=source-code>Source code <a href=#source-code class=anchor aria-hidden=true>#</a></h2><pre><code>

#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;

#include &quot;gambit/Utils/begin_ignore_warnings_eigen.hpp&quot;
#include &lt;Eigen/Core&gt;
#include &quot;gambit/Utils/end_ignore_warnings.hpp&quot;

#include &lt;gsl/gsl_math.h&gt;
#include &lt;gsl/gsl_sf.h&gt;
#include &lt;gsl/gsl_sf_trig.h&gt;
#include &lt;gsl/gsl_sf_erf.h&gt;
#include &lt;gsl/gsl_spline.h&gt;
#include &lt;gsl/gsl_interp2d.h&gt;
#include &lt;gsl/gsl_spline2d.h&gt;
#include &lt;gsl/gsl_histogram.h&gt;
#include &lt;gsl/gsl_roots.h&gt;
#include &lt;gsl/gsl_matrix.h&gt;
#include &lt;gsl/gsl_errno.h&gt;
#include &lt;gsl/gsl_odeiv2.h&gt;

#include &quot;gambit/Elements/gambit_module_headers.hpp&quot;
#include &quot;gambit/Utils/util_functions.hpp&quot;
#include &quot;gambit/Utils/ascii_table_reader.hpp&quot;
#include &quot;gambit/Utils/statistics.hpp&quot;
#include &quot;gambit/Utils/numerical_constants.hpp&quot;
#include &quot;gambit/DarkBit/DarkBit_rollcall.hpp&quot;
#include &quot;gambit/DarkBit/DarkBit_utils.hpp&quot;

//#define AXION_DEBUG_MODE
//#define AXION_OMP_DEBUG_MODE

namespace Gambit
{
  namespace DarkBit
  {
    //                                                                //
    //            General Functions and Classes for Axions            //
    //                                                                //

     const double gagg_conversion = 1.0E-9;
     const double gaee_conversion = 1.0E+13;

    //      Auxillary functions and classes for interpolation      //

    enum class InterpolationOptions1D { linear, cspline };
    const std::map&lt;InterpolationOptions1D, std::string&gt; int_type_name = { { InterpolationOptions1D::linear, &quot;linear&quot; }, { InterpolationOptions1D::cspline, &quot;cspline&quot;} };
    // AxionInterpolator class: Provides a general 1-D interpolation container based on the gsl library.
    // Can be declared static for efficiency &amp; easy one-time initialisation of interpolating functions.
    class AxionInterpolator
    {
      public:
        // Overloaded class creators for the AxionInterpolator class using the init function below.
        AxionInterpolator();
        AxionInterpolator(const std::vector&lt;double&gt; x, const std::vector&lt;double&gt; y, InterpolationOptions1D type = InterpolationOptions1D::linear);
        AxionInterpolator(std::string file, InterpolationOptions1D type = InterpolationOptions1D::linear);
        AxionInterpolator&amp; operator=(AxionInterpolator&amp;&amp;);
        // Destructor.
        ~AxionInterpolator();
        // Delete copy constructor and assignment operator to avoid shallow copies.
        AxionInterpolator(const AxionInterpolator&amp;) = delete;
        AxionInterpolator operator=(const AxionInterpolator&amp;) = delete;
        // Routine to access interpolated values.
        double interpolate(double x);
        // Routine to access upper and lower boundaries of available data.
        double lower();
        double upper();
      private:
        // Initialiser for the AxionInterpolator class.
        void init(std::string file, InterpolationOptions1D type);
        void init(const std::vector&lt;double&gt; x, const std::vector&lt;double&gt; y, InterpolationOptions1D type);
        // The gsl objects for the interpolating functions.
        gsl_interp_accel *acc;
        gsl_spline *spline;
        // Upper and lower boundaries available for the interpolating function.
        double lo;
        double up;
    };

    // Default constructor.
    AxionInterpolator::AxionInterpolator()
    {
      acc = gsl_interp_accel_alloc();
      spline = gsl_spline_alloc(gsl_interp_linear, 2);
    }

    // Initialiser for the AxionInterpolator class.
    void AxionInterpolator::init(const std::vector&lt;double&gt; x, const std::vector&lt;double&gt; y, InterpolationOptions1D type)
    {
      int pts = x.size();
      // Get first and last value of the &quot;x&quot; component.
      lo = x.front();
      up = x.back();
      acc = gsl_interp_accel_alloc();
      if (type == InterpolationOptions1D::cspline)
      {
        spline = gsl_spline_alloc(gsl_interp_cspline, pts);
      }
      else if (type == InterpolationOptions1D::linear)
      {
        spline = gsl_spline_alloc(gsl_interp_linear, pts);
      }
      else
      {
        DarkBit_error().raise(LOCAL_INFO, &quot;ERROR! Interpolation type not known to class AxionInterpolator.&quot;);
      }

      gsl_spline_init(spline, &amp;x[0], &amp;y[0], pts);
    }

    AxionInterpolator::AxionInterpolator(const std::vector&lt;double&gt; x, const std::vector&lt;double&gt; y, InterpolationOptions1D type) { init(x, y, type); }

    // Initialiser for the AxionInterpolator class.
    void AxionInterpolator::init(std::string file, InterpolationOptions1D type)
    {
      // Check if file exists.
      if (not(Utils::file_exists(file)))
      {
        DarkBit_error().raise(LOCAL_INFO, &quot;ERROR! File '&quot;+file+&quot;' not found!&quot;);
      } else {
        logger() &lt;&lt; LogTags::debug &lt;&lt; &quot;Reading data from file '&quot;+file+&quot;' and interpolating it with '&quot;+int_type_name.at(type)+&quot;' method.&quot; &lt;&lt; EOM;
      }
      // Read numerical values from data file.
      ASCIItableReader tab (file);
      tab.setcolnames(&quot;x&quot;, &quot;y&quot;);

      init(tab[&quot;x&quot;], tab[&quot;y&quot;], type);
    }

    AxionInterpolator::AxionInterpolator(std::string file, InterpolationOptions1D type) { init(file, type); }

    // Move assignment operator
    AxionInterpolator&amp; AxionInterpolator::operator=(AxionInterpolator&amp;&amp; interp)
    {
      if(this != &amp;interp)
      {
        std::swap(acc,interp.acc);
        std::swap(spline,interp.spline);
        std::swap(lo,interp.lo);
        std::swap(up,interp.up);
      }
      return *this;
    }

    // Destructor
    AxionInterpolator::~AxionInterpolator()
    {
      gsl_spline_free(spline);
      gsl_interp_accel_free(acc);
    }

    // Routine to access interpolated values.
    double AxionInterpolator::interpolate(double x) { return gsl_spline_eval(spline, x, acc); }

    // Routines to return upper and lower boundaries of interpolating function
    double AxionInterpolator::lower() { return lo; }
    double AxionInterpolator::upper() { return up; }


     enum class InterpolationOptions2D { bilinear, bicubic };
     const std::map&lt;InterpolationOptions2D, std::string&gt; int_2d_type_name = { { InterpolationOptions2D::bilinear, &quot;bilinear&quot; }, { InterpolationOptions2D::bicubic, &quot;bicubic&quot;} };
    // AxionInterpolator2D class: Provides a 2-D interpolation container based on the gsl library.
    // Can be declared static for efficiency &amp; easy one-time initialisation of interpolating functions.
    class AxionInterpolator2D
    {
      public:
        // Overloaded class creators for the AxionInterpolator class using the init function below.
        AxionInterpolator2D();
        AxionInterpolator2D(std::string file, InterpolationOptions2D type = InterpolationOptions2D::bilinear);
        AxionInterpolator2D&amp; operator=(AxionInterpolator2D&amp;&amp;);
        // Destructor.
        ~AxionInterpolator2D();
        // Delete copy constructor and assignment operator to avoid shallow copies.
        AxionInterpolator2D(const AxionInterpolator2D&amp;) = delete;
        AxionInterpolator2D operator=(const AxionInterpolator2D&amp;) = delete;
        // Routine to access interpolated values.
        double interpolate(double x, double y);
        // Routine to check if a point is inside the interpolating box.
        bool is_inside_box(double x, double y);
      private:
        // Initialiser for the AxionInterpolator2D class.
        void init(std::string file, InterpolationOptions2D type);
        // The gsl objects for the interpolating functions that need to be available to the class routines.
        gsl_interp_accel *x_acc;
        gsl_interp_accel *y_acc;
        gsl_spline2d *spline;
        double* z;
        // Upper and lower &quot;x&quot; and &quot;y&quot; values available to the interpolating function.
        double x_lo, y_lo, x_up, y_up;
    };

    // Move assignment operator
    AxionInterpolator2D&amp; AxionInterpolator2D::operator=(AxionInterpolator2D&amp;&amp; interp)
    {
      if(this != &amp;interp)
      {
        std::swap(x_acc,interp.x_acc);
        std::swap(y_acc,interp.y_acc);
        std::swap(spline,interp.spline);
        std::swap(x_lo,interp.x_lo);
        std::swap(x_up,interp.x_up);
        std::swap(y_lo,interp.y_lo);
        std::swap(y_up,interp.y_up);
        std::swap(z,interp.z);
      }
      return *this;
    }

    // Destructor
    AxionInterpolator2D::~AxionInterpolator2D()
    {
      gsl_spline2d_free (spline);
      gsl_interp_accel_free (x_acc);
      gsl_interp_accel_free (y_acc);
      free(z);
    }

    // Initialiser for the AxionInterpolator class.
    void AxionInterpolator2D::init(std::string file, InterpolationOptions2D type)
    {
      // Check if file exists.
      if (not(Utils::file_exists(file)))
      {
        DarkBit_error().raise(LOCAL_INFO, &quot;ERROR! File '&quot;+file+&quot;' not found!&quot;);
      } else {
        logger() &lt;&lt; LogTags::debug &lt;&lt; &quot;Reading data from file '&quot;+file+&quot;' and interpolating it with '&quot;+int_2d_type_name.at(type)+&quot;' method.&quot; &lt;&lt; EOM;
      }
      // Read numerical values from data file.
      ASCIItableReader tab (file);
      tab.setcolnames(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;);
      // Initialise gsl interpolation routine.
      // Get unique entries of &quot;x&quot; and &quot;y&quot; for the grid and grid size.
      std::vector&lt;double&gt; x_vec = tab[&quot;x&quot;];
      sort(x_vec.begin(), x_vec.end());
      x_vec.erase(unique(x_vec.begin(), x_vec.end()), x_vec.end());
      int nx = x_vec.size();
      std::vector&lt;double&gt; y_vec = tab[&quot;y&quot;];
      sort(y_vec.begin(), y_vec.end());
      y_vec.erase(unique(y_vec.begin(), y_vec.end()), y_vec.end());
      int ny = y_vec.size();
      int n_grid_pts = tab[&quot;z&quot;].size();

      if (nx*ny != n_grid_pts)
      {
        DarkBit_error().raise(LOCAL_INFO, &quot;ERROR! The number of grid points (&quot;+std::to_string(n_grid_pts)+&quot;) for AxionInterpolator2D does not equal the number of unique 'x' and 'y' values (&quot;+std::to_string(nx)+&quot; and &quot;+std::to_string(ny)+&quot;)!\n       Check formatting of the file: '&quot;+file+&quot;'.&quot;);
      }

      const double* x = &amp;x_vec[0];
      const double* y = &amp;y_vec[0];
      // Allocate memory for &quot;z&quot; values array in gsl format
      z = (double*) malloc(nx * ny * sizeof(double));

      if (type == InterpolationOptions2D::bicubic)
      {
        spline = gsl_spline2d_alloc(gsl_interp2d_bicubic, nx, ny);
      }
      else if (type == InterpolationOptions2D::bilinear)
      {
        spline = gsl_spline2d_alloc(gsl_interp2d_bilinear, nx, ny);
      }
      else
      {
        DarkBit_error().raise(LOCAL_INFO, &quot;ERROR! Interpolation type not known to class AxionInterpolator2D.&quot;);
      }

      x_acc = gsl_interp_accel_alloc();
      y_acc = gsl_interp_accel_alloc();

      // Determine first and last &quot;x&quot; and &quot;y&quot; values and grid step size.
      x_lo = x_vec.front();
      x_up = x_vec.back();
      y_lo = y_vec.front();
      y_up = y_vec.back();
      double x_delta = (x_up-x_lo) / (nx-1);
      double y_delta = (y_up-y_lo) / (ny-1);

      // Intialise grid.
      for (int i = 0; i &lt; n_grid_pts; i++)
      {
        // Determine appropriate indices for the grid points.
        double temp = (tab[&quot;x&quot;][i]-x_lo) / x_delta;
        int ind_x = (int) (temp+0.5);
        temp = (tab[&quot;y&quot;][i]-y_lo) / y_delta;
        int ind_y = (int) (temp+0.5);

        //std::cout &lt;&lt; ind_x &lt;&lt; &quot;/&quot; &lt;&lt; nx-1 &lt;&lt; &quot; &quot; &lt;&lt; tab[&quot;x&quot;][i] &lt;&lt; &quot; vs &quot; &lt;&lt; x[ind_x] &lt;&lt; &quot; &quot; &lt;&lt; ind_y &lt;&lt; &quot;/&quot; &lt;&lt; ny-1 &lt;&lt; &quot; &quot; &lt;&lt; tab[&quot;y&quot;][i] &lt;&lt; &quot; vs &quot; &lt;&lt; y[ind_y] &lt;&lt; std::endl;

        gsl_spline2d_set(spline, z, ind_x, ind_y, tab[&quot;z&quot;][i]);
      }
      gsl_spline2d_init (spline, x, y, z, nx, ny);
    }

    // Default creator with dummy entries for the objects w/ memory allocation
    AxionInterpolator2D::AxionInterpolator2D()
    {
      x_acc = gsl_interp_accel_alloc();
      y_acc = gsl_interp_accel_alloc();
      spline = gsl_spline2d_alloc(gsl_interp2d_bilinear, 2, 2);
      z = (double*) malloc(2 * 2 * sizeof(double));
    }
    // Overloaded class creators for the AxionInterpolator class using the init function above.
    AxionInterpolator2D::AxionInterpolator2D(std::string file, InterpolationOptions2D type) { init(file, type); }

    // Routine to access interpolated values.
    double AxionInterpolator2D::interpolate(double x, double y) { return gsl_spline2d_eval(spline, x, y, x_acc, y_acc); }

    // Routine to check if a point is inside the interpolating box.
    bool AxionInterpolator2D::is_inside_box(double x, double y) { return ((x &gt;= x_lo) &amp;&amp; (x &lt;= x_up) &amp;&amp; (y &gt;= y_lo) &amp;&amp; (y &lt;= y_up)); }

    // Auxillary function for a parabola (needed for H.E.S.S. likelihood approximation).
    double parabola(double x, const double params[]) { return params[0]*x*x + params[1]*x + params[2]; }

    // Auxillary function to return the appropriate intersection between a parabola and a line (needed for H.E.S.S. likelihood).
    double intersect_parabola_line(double a, double b, double sign, const double pparams[])
    {
      const double x1 = -3.673776;
      const double y1 = 0.4;
      double x2    = a - pparams[1];
      double temp1 = a*a + 4.0*b*pparams[0] - 2.0*a*pparams[1] + pparams[1]*pparams[1] - 4.0*pparams[0]*pparams[2];
      x2 = x2 - sign*sqrt(temp1);
      x2 = x2/(2.0*pparams[0]);
      double y2 = parabola(x2, pparams);
      temp1 = x1 - x2;
      double temp2 = y1 - y2;
      return sqrt(temp1*temp1 + temp2*temp2);
    }

    // HESS_Interpolator class: Provides a customised interpolation container for the H.E.S.S. likelihood.
    class HESS_Interpolator
    {
      public:
        // Class creator.
        HESS_Interpolator(std::string file);
        // Class destructor
        ~HESS_Interpolator();
        // Delete copy constructor and assignment operator to avoid shallow copies
        HESS_Interpolator(const HESS_Interpolator&amp;) = delete;
        HESS_Interpolator operator=(const HESS_Interpolator&amp;) = delete;
        // Container for the tabulated data.
        ASCIItableReader interp_lnL;
        // Routine to return interpolated log-likelihood values.
        double lnL(double epsilon, double gamma);
      private:
        gsl_interp_accel *acc[17];
        gsl_spline *spline[17];
    };

    // Class creator. Needs path to tabulated H.E.S.S. data.
    HESS_Interpolator::HESS_Interpolator(std::string file)
    {
      // Initialise upper part of the likelihood interpolation (i.e. higher axion-photon coupling).
      interp_lnL = ASCIItableReader(file);
      interp_lnL.setcolnames(&quot;lnL16&quot;, &quot;lnL15&quot;, &quot;lnL14&quot;, &quot;lnL13&quot;, &quot;lnL12&quot;, &quot;lnL11&quot;, &quot;lnL10&quot;, &quot;lnL9&quot;, &quot;lnL8&quot;, &quot;lnL7&quot;, &quot;lnL6&quot;, &quot;lnL5&quot;, &quot;lnL4&quot;, &quot;lnL3&quot;, &quot;lnL2&quot;, &quot;lnL1&quot;, &quot;lnL0&quot;);
      for (int i = 16; i &gt;= 0; i--)
      {
        int pts = interp_lnL[&quot;lnL&quot;+std::to_string(i)].size();
        acc[i] = gsl_interp_accel_alloc ();
        spline[i] = gsl_spline_alloc (gsl_interp_cspline, pts);
        const double* epsvals = &amp;interp_lnL[&quot;lnL&quot;+std::to_string(i)][0];
        if (pts==8) {
          const double lnLvals [8] = {0., -2.30259, -2.99573, -4.60517, -4.60517, -2.99573, -2.30259, 0.};
          gsl_spline_init (spline[i], epsvals, lnLvals, pts);
        } else {
          const double lnLvals [7] = {0., -2.30259, -2.99573, -4.60517, -2.99573, -2.30259, 0.};
          gsl_spline_init (spline[i], epsvals, lnLvals, pts);
        }
      }
    }

    // Destructor
    HESS_Interpolator::~HESS_Interpolator()
    {
        for (auto spl : spline)
          gsl_spline_free (spl);
        for (auto ac : acc)
          gsl_interp_accel_free (ac);
    }

    // Rotuine to interpolate the H.E.S.S. log-likelihood values.
    double HESS_Interpolator::lnL(double epsilon, double gamma)
    {
      // Parameters for the parabolae.
      const double ppars00 [3] = {0.553040458173831, 3.9888540782199913, 6.9972958867687565};
      const double ppars90 [3] = {1.2852894785722664, 9.42311266504736, 17.49643049277964};
      const double ppars95 [3] = {1.4501115909461886, 10.647792383304218, 19.811978366687622};
      double result = 0.0;

      // Check if we are inside the constrained region.
      if ((gamma &gt; parabola(epsilon, ppars00)) &amp;&amp; (gamma &lt; 1.2) &amp;&amp; (epsilon &gt; -4.64) &amp;&amp; (epsilon &lt; -2.57))
      {
        // Check if we are in the upper part (higher coupling; interpolation using linear and cubic splines).
        if (gamma &gt; 0.4)
        {
          // Cubic interpolation in Epsilon.
          int index_lo = floor((gamma-0.4)/0.05);
          int index_hi = index_lo + 1;
          double z_lo = 0.0, z_hi = 0.0;
          // Only use interpolating function where needed.
          if ( (epsilon &gt; interp_lnL[&quot;lnL&quot;+std::to_string(index_lo)].front()) &amp;&amp; (epsilon &lt; interp_lnL[&quot;lnL&quot;+std::to_string(index_lo)].back()) )
          {
            z_lo = gsl_spline_eval (spline[index_lo], epsilon, acc[index_lo]);
          }

          if ( (epsilon &gt; interp_lnL[&quot;lnL&quot;+std::to_string(index_hi)].front()) &amp;&amp; (epsilon &lt; interp_lnL[&quot;lnL&quot;+std::to_string(index_hi)].back()) )
          {
            z_hi = gsl_spline_eval (spline[index_hi], epsilon, acc[index_hi]);
          }

          // Linear interpolation in Gamma.
          double a = static_cast&lt;double&gt;(index_hi) - (gamma-0.4)/0.05;
          double b = 1.0 - a;

          result = a*z_lo + b*z_hi;

        // If not in the upper part, we must be in the lower part.
        } else {
          const double loglikevals [4] = {-4.60517, -2.99573, -2.30259, 0.0};
          // Gamma values belonging to the likelihood values along symmetry line (in terms of distance to 0.4).
          double gammavals [4] = {0.0, 0.134006, 0.174898, 0.592678};
          double distance = 0.4 - gamma;
          // Check if point is on a vertical line with the 99% C.L. point
          if (fabs(epsilon + 3.673776) &gt; 1e-6)
          {
            // Calculate distance of point
            double a = -3.673776 - epsilon;
            double b = (-3.673776*gamma - 0.4*epsilon)/a;
            double temp1 = distance;
            distance = sqrt(a*a + temp1*temp1);
            a = temp1/a;
            temp1 = GSL_SIGN(-3.673776 - epsilon);
            double temp2 = intersect_parabola_line(a, b, temp1, ppars00);
            // CAVE: There used to be problems with distance &gt; 1.0; these should be fixed now. Otherwise: replace by min(dist,1).
            distance = distance/temp2;
            gammavals[3] = 1.0;
            gammavals[2] = intersect_parabola_line(a, b, temp1, ppars90)/temp2;
            gammavals[1] = intersect_parabola_line(a, b, temp1, ppars95)/temp2;
          }
            gsl_interp_accel *acc = gsl_interp_accel_alloc ();
            gsl_spline *spline = gsl_spline_alloc (gsl_interp_cspline, 4);
            gsl_spline_init (spline, gammavals, loglikevals, 4);
            result = gsl_spline_eval (spline, distance, acc);
            gsl_spline_free (spline);
            gsl_interp_accel_free (acc);
          }
        }
      // CAVE: There used to be a bug with log-likelihood &gt; 0.0; this is fixed now, but still safeguard the result against roundoff errors.
      return std::min(result,0.0);
    }


    //      Solar model and integration routines to calculate the expected Helioscope signals      //

    // SolarModel class: Provides a container to store a (tabulated) Solar model and functions to return its properties.
    class SolarModel
    {
      public:
        SolarModel();
        SolarModel(std::string file);
        ~SolarModel();
        SolarModel&amp; operator=(SolarModel&amp;&amp;);
        // Delete copy constructor and assignment operator to avoid shallow copies
        SolarModel(const SolarModel&amp;) = delete;
        SolarModel operator=(const SolarModel&amp;) = delete;
        // Min. and max. radius of the solar model file (distance r from the centre of the Sun in units of the solar radius)
        double r_lo, r_hi;
        // Routine to return the screening parameter kappa^2 (kappa^-1 = Debye-Hueckel radius).
        double kappa_squared(double r);
        // Routine to return the temperature in keV.
        double temperature_in_keV(double r);
        // Routine to return the plasma frequency squared.
        double omega_pl_squared(double r);
      private:
        ASCIItableReader data;
        gsl_interp_accel *accel[3];
        gsl_spline *linear_interp[3];
    };

    SolarModel::SolarModel() {}
    SolarModel::SolarModel(std::string file)
    {
      data = ASCIItableReader(file);
      int pts = data.getnrow();
      // Terminate GAMBIT is number of columns is wrong; i.e. the wrong solar model file format.
      if (data.getncol() != 35)
      {
        DarkBit_error().raise(LOCAL_INFO, &quot;ERROR! Solar model file '&quot;+file+&quot;' not compatible with GAMBIT!\n&quot;
                                          &quot;       See [arXiv:1810.07192] or example file in 'DarkBit/data/' for the correct format.&quot;);
      }
      data.setcolnames(&quot;mass&quot;, &quot;radius&quot;, &quot;temperature&quot;, &quot;rho&quot;, &quot;Pressure&quot;, &quot;Luminosity&quot;, &quot;X_H1&quot;, &quot;X_He4&quot;, &quot;X_He3&quot;, &quot;X_C12&quot;, &quot;X_C13&quot;, &quot;X_N14&quot;, &quot;X_N15&quot;, &quot;X_O16&quot;, &quot;X_O17&quot;, &quot;X_O18&quot;, &quot;X_Ne&quot;, &quot;X_Na&quot;, &quot;X_Mg&quot;, &quot;X_Al&quot;, &quot;X_Si&quot;, &quot;X_P&quot;, &quot;X_S&quot;, &quot;X_Cl&quot;, &quot;X_Ar&quot;,
                       &quot;X_K&quot;, &quot;X_Ca&quot;, &quot;X_Sc&quot;, &quot;X_Ti&quot;, &quot;X_V&quot;, &quot;X_Cr&quot;, &quot;X_Mn&quot;, &quot;X_Fe&quot;, &quot;X_Co&quot;, &quot;X_Ni&quot;);

      // Extract the radius from the files (in units of the solar radius).
      const double* radius = &amp;data[&quot;radius&quot;][0];
      r_lo = data[&quot;radius&quot;][0];
      r_hi = data[&quot;radius&quot;][pts-1];

      // Extract the temperature from the files (has to be converted into keV) &amp; calculate the screening scale kappa_s_squared.
      // Initialise necessary variables for the screening scale calculation.
      std::vector&lt;double&gt; temperature;
      std::vector&lt;double&gt; kappa_s_sq;
      std::vector&lt;double&gt; w_pl_sq;
      // Multiplicative factor: (4 pi alpha_EM / atomic_mass_unit) x (1 g/cm^3) in units of keV^3
      const double factor = 4.0*pi*alpha_EM*gsl_pow_3(1.0E+6*gev2cm)/((1.0E+9*eV2g)*atomic_mass_unit);
      // Atomic weight of species i (exact weight if isotope is known OR estimate from average solar abundance from data if available OR estimate from natural terrestrial abundance).
      const double A_vals [29] = {1.007825, 4.002603, 3.016029, 12.000000, 13.003355, 14.003074, 15.000109, 15.994915, 16.999132, 17.999160,
                                  20.1312812, 22.989769, 24.3055, 26.9815385, 28.085, 30.973762, 32.0675, 35.4515, 36.275403, 39.0983, 40.078, 44.955908, 47.867, 50.9415, 51.9961, 54.938044, 55.845, 58.933194, 58.6934};
      // Ionisation of species i assuming full ionisation.
      const double Z_vals [29] = {1.0,      2.0,      2.0,       6.0,       6.0,       7.0,       7.0,       8.0,       8.0,       8.0,
                                  10.0,       11.0,      12.0,    13.0,       14.0,   15.0,      16.0,    17.0,    18.0,      19.0,    20.0,   21.0,      22.0,   23.0,    24.0,    25.0,      26.0,   27.0,      28.0};

      #ifdef AXION_DEBUG_MODE
        std::cout &lt;&lt; &quot;DEBUGGING INFO for solar models:\nradius/Rsol T/K kappa_s^2/keV^2 omega_pl^2/keV^2&quot; &lt;&lt; std::endl;
      #endif

      // Linearly extrapolate the data in the solar model file to r = 0 if necessary.
      if (r_lo &gt; 0)
      {
        double r0 = data[&quot;radius&quot;][0], r1 = data[&quot;radius&quot;][1];
        double t_intercept = (1.0E-3*K2eV)*(r0*data[&quot;temperature&quot;][1]-r1*data[&quot;temperature&quot;][0])/(r0-r1);
        temperature.push_back(t_intercept);
        double rho_intercept = (r0*data[&quot;rho&quot;][1]-r1*data[&quot;rho&quot;][0])/(r0-r1);
        double sum = 0.0;
        double ne = 0.0;
        for (int j = 0; j &lt; 29; j++)
        {
          double x_intercept = (r0* data[j+6][1]-r1* data[j+6][0])/(r0-r1);
          double temp = x_intercept*Z_vals[j]/A_vals[j];
          ne += temp;
          sum += temp*(1.0 + Z_vals[j]);
        }
        double kss = factor*sum*rho_intercept/t_intercept;
        kappa_s_sq.push_back(kss);
        double wpls = factor*ne*rho_intercept/(1.0E+6*m_electron);
        w_pl_sq.push_back(wpls);
        #ifdef AXION_DEBUG_MODE
          printf(&quot;%5.4f %1.6e %1.6e %1.6e\n&quot;, 0.0, t_intercept, kss, wpls);
        #endif
      }
      // Calculate the necessary quantities -- T(r), kappa_s^2(r) and omega_pl^2(r) -- and store them internally.
      for (int i = 0; i &lt; pts; i++)
      {
        double sum = 0.0;
        double ne = 0.0;
        temperature.push_back((1.0E-3*K2eV)*data[&quot;temperature&quot;][i]);
        for (int j = 0; j &lt; 29; j++)
        {
          double temp = data[j+6][i]*Z_vals[j]/A_vals[j];
          ne += temp;
          sum += temp*(1.0 + Z_vals[j]);
        }
        double kss = factor*sum*data[&quot;rho&quot;][i]/temperature[i];
        kappa_s_sq.push_back(kss);
        double wpls = factor*ne*data[&quot;rho&quot;][i]/(1.0E+6*m_electron);
        w_pl_sq.push_back(wpls);
        #ifdef AXION_DEBUG_MODE
          printf(&quot;%5.4f %1.6e %1.6e %1.6e\n&quot;, data[&quot;radius&quot;][i], temperature[i], kss, wpls);
        #endif
      }
      // Set up the interpolating functions for temperature and screening scale.
      accel[0] = gsl_interp_accel_alloc ();
      linear_interp[0] = gsl_spline_alloc (gsl_interp_linear, pts);
      const double* temp_vals = &amp;temperature[0];
      gsl_spline_init (linear_interp[0], radius, temp_vals, pts);
      accel[1] = gsl_interp_accel_alloc ();
      linear_interp[1] = gsl_spline_alloc (gsl_interp_linear, pts);
      const double* kappa_squared_vals = &amp;kappa_s_sq[0];
      gsl_spline_init (linear_interp[1], radius, kappa_squared_vals, pts);
      accel[2] = gsl_interp_accel_alloc ();
      linear_interp[2] = gsl_spline_alloc (gsl_interp_linear, pts);
      const double* omega_pl_squared_vals = &amp;w_pl_sq[0];
      gsl_spline_init (linear_interp[2], radius, omega_pl_squared_vals, pts);

      logger() &lt;&lt; LogTags::info &lt;&lt; &quot;Initialisation of solar model from file '&quot;+file+&quot;' complete!&quot; &lt;&lt; std::endl;
      logger() &lt;&lt; LogTags::debug &lt;&lt; &quot;Entries in model file: &quot; &lt;&lt; pts &lt;&lt; &quot; for solar radius in [&quot; &lt;&lt; data[&quot;radius&quot;][0] &lt;&lt; &quot;, &quot; &lt;&lt; data[&quot;radius&quot;][pts-1] &lt;&lt; &quot;].&quot; &lt;&lt; EOM;
    }

    // Move assignment operator
    SolarModel&amp; SolarModel::operator=(SolarModel &amp;&amp;model)
    {
      if (this != &amp;model)
      {
        std::swap(data,model.data);
        std::swap(accel,model.accel);
        std::swap(linear_interp, model.linear_interp);
      }
      return *this;
    }

    // Class destructor
    SolarModel::~SolarModel()
    {
      for (auto interp : linear_interp)
        gsl_spline_free (interp);
      for (auto acc : accel)
        gsl_interp_accel_free (acc);
    }

    // Routine to return the temperature (in keV) of the zone around the distance r from the centre of the Sun.
    double SolarModel::temperature_in_keV(double r) { return gsl_spline_eval(linear_interp[0], r, accel[0]); }

    // Routine to return the screening paramter kappa^2 in units of keV^2 (kappa^-1 = Debye-Hueckel radius).
    double SolarModel::kappa_squared(double r)
    {
      // Interpolated value, directly from the Solar model.
      return gsl_spline_eval(linear_interp[1], r, accel[1]);
    }

    // Routine to return the plasma freqeuency squared (in keV^2) of the zone around the distance r from the centre of the Sun.
    double SolarModel::omega_pl_squared(double r) { return gsl_spline_eval(linear_interp[2], r, accel[2]); }

    // Constant numbers for precision etc.
    const double abs_prec = 1.0E-1, rel_prec = 1.0E-6;
    const int method = 5;
    // Auxillary structure for passing the model parameters to the gsl solver.
    struct SolarModel_params1 {double erg; double rad; SolarModel* sol;};
    struct SolarModel_params2 {double erg; double rs; SolarModel* sol;};
    struct SolarModel_params3 {double rs; double ma0; SolarModel* sol; AxionInterpolator* eff_exp;};
    struct SolarModel_params4 {double ma0; AxionInterpolator* eff_exp; AxionInterpolator* gaee_flux;};

    double rho_integrand (double rho, void * params)
    {
      // Retrieve parameters and other integration variables.
      struct SolarModel_params1 * p1 = (struct SolarModel_params1 *)params;
      double erg = (p1-&gt;erg);
      double r = (p1-&gt;rad);
      SolarModel* sol = (p1-&gt;sol);

      // Get kappa_s^2, omega_plasma^2 and the temperature.
      double ks_sq = sol-&gt;kappa_squared(rho);
      double w_pl_sq = sol-&gt;omega_pl_squared(rho);
      double T_in_keV = sol-&gt;temperature_in_keV(rho);

      // Calculate the flux.
      double x = 4.0*(erg*erg)/ks_sq;
      double cylinder = rho*rho - r*r;
      cylinder = rho/sqrt(cylinder);
      double energy_factor = erg*sqrt(erg*erg - w_pl_sq)/gsl_expm1(erg/T_in_keV);
      double rate = (ks_sq*T_in_keV)*((1.0 + 1.0/x)*gsl_log1p(x) - 1.0);

      return cylinder*energy_factor*rate;
    }

    double rad_integrand(double rad, void * params)
    {
      // Retrieve and pass on parameters.
      struct SolarModel_params2 * p2 = (struct SolarModel_params2 *)params;
      SolarModel* sol = (p2-&gt;sol);
      double rmax = std::min(1.0, sol-&gt;r_hi);
      SolarModel_params1 p1 = {p2-&gt;erg, rad, sol};

      gsl_integration_workspace * w = gsl_integration_workspace_alloc(1E6);
      double result, error;

      gsl_function F;
      F.function = &amp;rho_integrand;
      F.params = &amp;p1;

      //gsl_set_error_handler_off();
      gsl_integration_qag (&amp;F, rad, rmax, 1e-2*abs_prec, 1e-2*rel_prec, 1E6, method, w, &amp;result, &amp;error);
      //printf (&quot;GSL status: %s\n&quot;, gsl_strerror (status));
      //gsl_integration_qags(&amp;F, rad, rmax, 1e-1*abs_prec, 1e-1*rel_prec, 1E6, w, &amp;result, &amp;error);
      gsl_integration_workspace_free (w);

      result = rad*result;
      return result;
    }

    double erg_integrand(double erg, void * params)
    {
      const double eVm = gev2cm*1E7;
      const double L = 9.26/eVm;
      struct SolarModel_params3 * p3 = (struct SolarModel_params3 *)params;
      SolarModel* sol = p3-&gt;sol;
      double m_ax = p3-&gt;ma0;
      double rs = p3-&gt;rs;

      double argument = 0.25*1.0E-3*L*m_ax*m_ax/erg;
      double temp = gsl_pow_2(gsl_sf_sinc(argument/pi));
      double exposure = p3-&gt;eff_exp-&gt;interpolate(erg);
      //std::cout &lt;&lt; &quot;Energy: &quot; &lt;&lt; erg &lt;&lt; &quot;, expoure = &quot; &lt;&lt; exposure &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;
      SolarModel_params2 p2 = {erg, rs, sol};

      gsl_integration_workspace * w = gsl_integration_workspace_alloc(1E6);
      double result, error;

      gsl_function F;
      F.function = &amp;rad_integrand;
      F.params = &amp;p2;

      // Max. and min. integration radius
      double rmin = sol-&gt;r_lo, rmax = std::min(rs, sol-&gt;r_hi);

      gsl_integration_qag (&amp;F, rmin, rmax, 1e-1*abs_prec, 1e-1*rel_prec, 1E6, method, w, &amp;result, &amp;error);
      gsl_integration_workspace_free (w);

      return temp*exposure*result;
    }

    double alt_erg_integrand(double erg, void * params)
    {
      const double eVm = gev2cm*1E7;
      const double L = 9.26/eVm;
      struct SolarModel_params4 * p4 = (struct SolarModel_params4 *)params;
      double m_ax = p4-&gt;ma0;

      double argument = 0.25*1.0E-3*L*m_ax*m_ax/erg;
      double temp = gsl_pow_2(gsl_sf_sinc(argument/pi));
      double exposure = p4-&gt;eff_exp-&gt;interpolate(erg);
      double gaee_flux = p4-&gt;gaee_flux-&gt;interpolate(erg);

      return temp*exposure*gaee_flux;
    }

    // Provides a customised interpolation container for the CAST likelihoods.
    class CAST_SolarModel_Interpolator
    {
      public:
        CAST_SolarModel_Interpolator(std::string solar_model_gagg, std::string solar_model_gaee, std::string data_set);
        CAST_SolarModel_Interpolator(CAST_SolarModel_Interpolator&amp;&amp;);
        ~CAST_SolarModel_Interpolator();
        // Delete copy constructor and assignment operator to avoid shallow copies
        CAST_SolarModel_Interpolator(const CAST_SolarModel_Interpolator&amp;) = delete;
        CAST_SolarModel_Interpolator operator=(const CAST_SolarModel_Interpolator&amp;) = delete;
        std::vector&lt;double&gt; evaluate_gagg_contrib(double m_ax);
        std::vector&lt;double&gt; evaluate_gaee_contrib(double m_ax);
     private:
        int n_bins;
        ASCIItableReader gagg_data;
        ASCIItableReader gaee_data;
        ASCIItableReader eff_exp_data;
        std::vector&lt;gsl_interp_accel*&gt; gagg_acc;
        std::vector&lt;gsl_interp_accel*&gt; gaee_acc;
        std::vector&lt;gsl_spline*&gt; gagg_linear_interp;
        std::vector&lt;gsl_spline*&gt; gaee_linear_interp;
    };

    // Class creators for CAST_SolarModel_Interpolator
    // Needs path to pre-claculated data for the &quot;default&quot; option.
    CAST_SolarModel_Interpolator::CAST_SolarModel_Interpolator(std::string solar_model_gagg, std::string solar_model_gaee, std::string data_set)
    {
      const std::string darkbitdata_path = GAMBIT_DIR &quot;/DarkBit/data/&quot;;
      bool user_gagg_file_missing = true, user_gaee_file_missing = true;
      logger() &lt;&lt; LogTags::info &lt;&lt; &quot;Using solar models '&quot;+solar_model_gagg+&quot;' (axion-photon int.) and '&quot;+solar_model_gaee+&quot;' (axion-electron int.) for experiment '&quot;+data_set+&quot;'.&quot; &lt;&lt; EOM;

      // Check if a pre-computed a file for a given model exists.
      user_gagg_file_missing = not(Utils::file_exists(darkbitdata_path+&quot;CAST/&quot;+data_set+&quot;_ReferenceCounts_&quot;+solar_model_gagg+&quot;_gagg.dat&quot;));
      user_gaee_file_missing = not(Utils::file_exists(darkbitdata_path+&quot;CAST/&quot;+data_set+&quot;_ReferenceCounts_&quot;+solar_model_gaee+&quot;_gaee.dat&quot;));
      if (not(user_gagg_file_missing)) { logger() &lt;&lt; LogTags::info &lt;&lt; &quot;Found pre-calculated axion-photon counts file for experiment '&quot;+data_set+&quot;' and solar model '&quot;+solar_model_gagg+&quot;'. Skipping calculation step...&quot; &lt;&lt; EOM; }
      if (not(user_gaee_file_missing)) { logger() &lt;&lt; LogTags::info &lt;&lt; &quot;Found pre-calculated axion-electron counts file for experiment '&quot;+data_set+&quot;' and solar model '&quot;+solar_model_gaee+&quot;'. Skipping calculation step...&quot; &lt;&lt; EOM; }

      // If either file does not exists, compute it.
      if (user_gagg_file_missing || user_gaee_file_missing)
      {
        // Define the list of logarithmic masses log10(m_ax/keV) for the interpolating tables.
        const int n_mass_bins = 183;
        const double log_masses [n_mass_bins] = {-3., -2.8, -2.6, -2.4, -2.2, -2.15, -2.1, -2.05, -2., -1.95, -1.9, -1.85, -1.8475, -1.84, -1.8325, -1.825, -1.8175, -1.81, -1.8025, -1.795, -1.7875, -1.78, -1.7725, -1.765, -1.7575, -1.75,
                                                 -1.7425, -1.735, -1.7275, -1.72, -1.7125, -1.705, -1.6975, -1.69, -1.6825, -1.675, -1.6675, -1.66, -1.6525, -1.645, -1.6375, -1.63, -1.6225, -1.615, -1.6075, -1.6, -1.5925, -1.585, -1.5775, -1.57,
                                                 -1.5625, -1.555, -1.5475, -1.54, -1.5325, -1.525, -1.5175, -1.51, -1.5025, -1.495, -1.4875, -1.48, -1.4725, -1.465, -1.4575, -1.45, -1.4425, -1.435, -1.4275, -1.42, -1.4125, -1.405, -1.3975,
                                                 -1.39, -1.3825, -1.375, -1.3675, -1.36, -1.3525, -1.345, -1.3375, -1.33, -1.3225, -1.315, -1.3075, -1.3, -1.2925, -1.285, -1.2775, -1.27, -1.2625, -1.255, -1.2475, -1.24, -1.2325, -1.225, -1.2175,
                                                 -1.21, -1.2025, -1.195, -1.1875, -1.18, -1.1725, -1.165, -1.1575, -1.15, -1.1425, -1.135, -1.1275, -1.12, -1.1125, -1.105, -1.0975, -1.09, -1.0825, -1.075, -1.0675, -1.06, -1.0525, -1.045,
                                                 -1.0375, -1.03, -1.0225, -1.015, -1.0075, -1., -0.9925, -0.985, -0.9775, -0.97, -0.9625, -0.955, -0.9475, -0.94, -0.9325, -0.925, -0.9175, -0.91, -0.9025, -0.895, -0.8875, -0.88, -0.8725, -0.865,
                                                 -0.8575, -0.85, -0.8425, -0.835, -0.8275, -0.82, -0.8125, -0.805, -0.7975, -0.79, -0.7825, -0.775, -0.7675, -0.76, -0.7525, -0.745, -0.7375, -0.73, -0.7225, -0.715, -0.7075, -0.7, -0.65, -0.6,
                                                 -0.55, -0.5, -0.4, -0.2, 0., 0.2, 0.4, 0.6, 0.8, 1., 1.2, 1.4, 1.6, 1.8, 2.};

        // Define quantities specific to CAST and the data set.
        // prefactor_gagg = (keV/eV)^6 * (1 cm^2/eVcm^2) * (1 day/eVs) * (10^10 cm/eVcm) * (10^-19 eV^-1)^4 * ((9.26 m/eVm) * (9.0 T/(T/eV^2) ))^2 / (128 pi^3)
        const double prefactor_gagg = 29302.30262;
        // prefactor_gaee = 10^13 * (10^-19 eV^-1)^2 * ((9.26 m/eVm) * (9.0 T/(T/eV^2) ))^2 / 4
        // 10^13 = normalisation factor of files
        const double prefactor_gaee = 1.701818353e-4;
        // Lowest energy bin (in keV), bin size (in keV), and max. integration radius.
        double bin_lo = 2.0, bin_delta = 0.5, rs = 1.0;
        // Number of bins
        int n_bins = 10;
        if (data_set==&quot;CAST2007&quot;) { bin_lo = 0.8; bin_delta = 0.3; rs = 0.231738; n_bins = 20; }

        // Arrays to store the results in.
        double gagg_counts [n_bins*n_mass_bins];
        double gaee_counts [n_bins*n_mass_bins];

        // Load the solar model.
        // Solar radius R_Sol and D_Sol (= 1 a.u.) in 10^10 cm.
        const double radius_sol = 6.9598, distance_sol = 1495.978707;
        double temp = prefactor_gagg*gsl_pow_2(radius_sol/distance_sol)*radius_sol;

        SolarModel model_gagg;
        if (user_gagg_file_missing)
        {
          if (Utils::file_exists(darkbitdata_path+&quot;SolarModel_&quot;+solar_model_gagg+&quot;.dat&quot;))
          {
            model_gagg = SolarModel(darkbitdata_path+&quot;SolarModel_&quot;+solar_model_gagg+&quot;.dat&quot;);
          } else {
            DarkBit_error().raise(LOCAL_INFO, &quot;ERROR! No solar model file found for '&quot;+solar_model_gagg+&quot;'.\n&quot;
                                              &quot;       Check 'DarkBit/data' for files named 'SolarModel_*.dat' for available options *.&quot;);
          }
        }

        // Load and interpolate effective exposure and the data for the axion-electron spectrum (with its nasty peaks).
        AxionInterpolator eff_exposure (darkbitdata_path+&quot;CAST/&quot;+data_set+&quot;_EffectiveExposure.dat&quot;);
        AxionInterpolator gaee_spectrum;
        if (user_gaee_file_missing)
        {
          if (Utils::file_exists(darkbitdata_path+&quot;CAST/&quot;+&quot;Axion_Spectrum_&quot;+solar_model_gaee+&quot;_gaee.dat&quot;))
          {
            gaee_spectrum = AxionInterpolator(darkbitdata_path+&quot;CAST/&quot;+&quot;Axion_Spectrum_&quot;+solar_model_gaee+&quot;_gaee.dat&quot;);
          } else {
            DarkBit_error().raise(LOCAL_INFO, &quot;ERROR! No spectrum file found for axion-electron interactions and model '&quot;+solar_model_gaee+&quot;'.\n&quot;
                                              &quot;       Check 'DarkBit/data' for files named 'Axion_Spectrum_*_gaee.dat' for available options *.&quot;);
          }
        }
        double all_peaks [32] = {0.653029, 0.779074, 0.920547, 0.956836, 1.02042, 1.05343, 1.3497, 1.40807, 1.46949, 1.59487, 1.62314, 1.65075, 1.72461, 1.76286, 1.86037, 2.00007, 2.45281, 2.61233, 3.12669, 3.30616, 3.88237, 4.08163, 5.64394,
                                 5.76064, 6.14217, 6.19863, 6.58874, 6.63942, 6.66482, 7.68441, 7.74104, 7.76785};

        // Prepare integration routine by defining the gsl functions etc.
        gsl_function F;
        F.function = &amp;erg_integrand;
        gsl_function G;
        G.function = &amp;alt_erg_integrand;

        double erg_lo = bin_lo, erg_hi = bin_lo;

        logger() &lt;&lt; LogTags::info &lt;&lt; &quot;Calculating reference counts for dataset '&quot;+data_set+&quot;'...&quot; &lt;&lt; EOM;
        #ifdef AXION_DEBUG_MODE
          std::cout &lt;&lt; &quot;DEBUGGING INFO for solar model integration:\n&quot;
                       &quot;Using model '&quot;+solar_model_gagg+&quot;' for axion-photon interactions,&quot;
                       &quot;and model '&quot;+solar_model_gaee+&quot;' for axion-electron interactions.\n\n&quot;
                       &quot;coupling log10(m/eV) [erg_low/keV, erg_high/keV] log10(counts)&quot; &lt;&lt; std::endl;
        #endif
        for (int bin = 0; bin &lt; n_bins; bin++)
        {
          erg_lo = erg_hi;
          erg_hi += bin_delta;
          gsl_integration_workspace * v = gsl_integration_workspace_alloc (1E6);
          gsl_integration_workspace * w = gsl_integration_workspace_alloc (1E6);
          // Only take into account the peaks relevant for the current energy bin.
          std::vector&lt;double&gt; relevant_peaks;
          relevant_peaks.push_back(erg_lo);
          for (int i = 0; i &lt; 32; i++)
          {
            double temp = all_peaks[i];
            if ( (erg_lo &lt; temp) &amp;&amp; (temp &lt; erg_hi) ) { relevant_peaks.push_back(temp); }
          }
          relevant_peaks.push_back(erg_hi);

          for (int i = 0; i &lt; n_mass_bins; i++)
          {
            double gagg_result, gagg_error, gaee_result, gaee_error;
            double m_ax = pow(10,log_masses[i]);
            // Only perform integration if axion-photon counts file does not exist.
            if (user_gagg_file_missing)
            {
              SolarModel_params3 p3 = {rs, m_ax, &amp;model_gagg, &amp;eff_exposure};
              F.params = &amp;p3;
              gsl_integration_qag (&amp;F, erg_lo, erg_hi, abs_prec, rel_prec, 1E6, method, v, &amp;gagg_result, &amp;gagg_error);

              #ifdef AXION_OMP_DEBUG_MODE
                printf(&quot;gagg | % 6.4f [%3.2f, %3.2f] % 4.3e\n&quot;, log10(m_ax), erg_lo, erg_hi, log10(temp*gagg_result));
              #endif

              gagg_counts[bin*n_mass_bins+i] = log10(temp*gagg_result);
            }
            // Only perform integration if axion-electron counts file does not exist.
            if (user_gaee_file_missing)
            {
              SolarModel_params4 p4 = {m_ax, &amp;eff_exposure, &amp;gaee_spectrum};
              G.params = &amp;p4;
              gsl_integration_qagp(&amp;G, &amp;relevant_peaks[0], relevant_peaks.size(), abs_prec, rel_prec, 1E6, w, &amp;gaee_result, &amp;gaee_error);

              #ifdef AXION_OMP_DEBUG_MODE
                printf(&quot;gaee | % 6.4f [%3.2f, %3.2f] % 4.3e\n&quot;, log10(m_ax), erg_lo, erg_hi, log10(0.826*prefactor_gaee*gaee_result));
              #endif

              // Include efficiency factor from not integrating over the full Solar disc in CAST2007 here:
              if (data_set==&quot;CAST2007&quot;) { gaee_result = 0.826*gaee_result; }
              gaee_counts[bin*n_mass_bins+i] = log10(prefactor_gaee*gaee_result);
            }
          }
          gsl_integration_workspace_free (v);
          gsl_integration_workspace_free (w);
        }


        // Write the results to a file (if the file does not yet exist).
        if (user_gagg_file_missing)
        {
          std::string header = &quot;########################################################################\n&quot;
                               &quot;# Reference Counts for Solar Model &quot;+solar_model_gagg+std::string(std::max(0,36-static_cast&lt;int&gt;(solar_model_gagg.length())),' ')+&quot;#\n&quot;
                               &quot;# Column 1: log10(Axion mass in eV)                                    #\n&quot;
                               &quot;#        n&gt;1: log10(Reference photon counts in energy bin n-1)         #\n&quot;
                               &quot;########################################################################\n&quot;;
          std::ofstream gagg_file (darkbitdata_path+&quot;CAST/&quot;+data_set+&quot;_ReferenceCounts_&quot;+solar_model_gagg+&quot;_gagg.dat&quot;);
          gagg_file &lt;&lt; header;
          gagg_file &lt;&lt; std::fixed &lt;&lt; std::scientific &lt;&lt; std::setprecision(7);
          for (int i = 0; i &lt; n_mass_bins; i++)
          {
            gagg_file &lt;&lt; log_masses[i];
            for (int j = 0; j &lt; n_bins; j++) { gagg_file &lt;&lt; &quot; &quot; &lt;&lt; gagg_counts[j*n_mass_bins+i]; }
            if (i &lt; n_mass_bins-1) { gagg_file &lt;&lt; &quot;\n&quot;; }
          }
          gagg_file.close();
          logger() &lt;&lt; LogTags::info &lt;&lt; &quot;Output file '&quot;+darkbitdata_path+&quot;CAST/&quot;+data_set+&quot;_ReferenceCounts_&quot;+solar_model_gagg+&quot;_gagg.dat&quot;+&quot;' written for axion-photon interactions.&quot; &lt;&lt; EOM;
        }

        if (user_gaee_file_missing)
        {
          std::string header = &quot;########################################################################\n&quot;
                               &quot;# Reference Counts for Solar Model &quot;+solar_model_gaee+std::string(std::max(0,36-static_cast&lt;int&gt;(solar_model_gaee.length())),' ')+&quot;#\n&quot;
                               &quot;# Column 1: log10(Axion mass in eV)                                    #\n&quot;
                               &quot;#        n&gt;1: log10(Reference photon counts in energy bin n-1)         #\n&quot;
                               &quot;########################################################################\n&quot;;
          std::ofstream gaee_file (darkbitdata_path+&quot;CAST/&quot;+data_set+&quot;_ReferenceCounts_&quot;+solar_model_gaee+&quot;_gaee.dat&quot;);
          gaee_file &lt;&lt; header;
          gaee_file &lt;&lt; std::fixed &lt;&lt; std::scientific &lt;&lt; std::setprecision(7);
          for (int i = 0; i &lt; n_mass_bins; i++)
          {
            gaee_file &lt;&lt; log_masses[i];
            for (int j = 0; j &lt; n_bins; j++) { gaee_file &lt;&lt; &quot; &quot; &lt;&lt; gaee_counts[j*n_mass_bins+i]; }
            if (i &lt; n_mass_bins-1) { gaee_file &lt;&lt; &quot;\n&quot;; }
          }
          gaee_file.close();
          logger() &lt;&lt; LogTags::info &lt;&lt; &quot;Output file '&quot;+darkbitdata_path+&quot;CAST/&quot;+data_set+&quot;_ReferenceCounts_&quot;+solar_model_gaee+&quot;_gagg.dat&quot;+&quot;' written for axion-electron interactions.&quot; &lt;&lt; EOM;
        }
      }

      // Read in pre-integrated fluxes for the chosen models.
      // 0-entry = mass values; remaining entries = counts in bins.
      gagg_data = ASCIItableReader(darkbitdata_path+&quot;CAST/&quot;+data_set+&quot;_ReferenceCounts_&quot;+solar_model_gagg+&quot;_gagg.dat&quot;);
      gaee_data = ASCIItableReader(darkbitdata_path+&quot;CAST/&quot;+data_set+&quot;_ReferenceCounts_&quot;+solar_model_gaee+&quot;_gaee.dat&quot;);
      n_bins = gagg_data.getncol() - 1;

      // Point to the address of the first entry of masses.
      const double* mass_gagg = &amp;gagg_data[0][0];
      const double* mass_gaee = &amp;gaee_data[0][0];

      for (int bin = 0; bin &lt; n_bins; bin++)
      {
        // Determine the number of interpolated mass values.
        int gagg_pts = gagg_data[bin+1].size();
        int gaee_pts = gaee_data[bin+1].size();
        gagg_acc.push_back( gsl_interp_accel_alloc () );
        gaee_acc.push_back( gsl_interp_accel_alloc () );
        gagg_linear_interp.push_back( gsl_spline_alloc (gsl_interp_linear, gagg_pts) );
        gaee_linear_interp.push_back( gsl_spline_alloc (gsl_interp_linear, gaee_pts) );
        // Get flux values and initialise splines.
        const double* flux_gagg = &amp;gagg_data[bin+1][0];
        const double* flux_gaee = &amp;gaee_data[bin+1][0];
        gsl_spline_init (gagg_linear_interp[bin], mass_gagg, flux_gagg, gagg_pts);
        gsl_spline_init (gaee_linear_interp[bin], mass_gaee, flux_gaee, gaee_pts);
      }
    }

    // Move constructor
    CAST_SolarModel_Interpolator::CAST_SolarModel_Interpolator(CAST_SolarModel_Interpolator &amp;&amp;interp) :
      n_bins(std::move(interp.n_bins)),
      gagg_data(std::move(interp.gagg_data)),
      gaee_data(std::move(interp.gaee_data)),
      eff_exp_data(std::move(interp.eff_exp_data)),
      gagg_acc(std::move(interp.gagg_acc)),
      gaee_acc(std::move(interp.gaee_acc)),
      gagg_linear_interp(std::move(interp.gagg_linear_interp)),
      gaee_linear_interp(std::move(interp.gaee_linear_interp))
    {}

    // Class destructor
    CAST_SolarModel_Interpolator::~CAST_SolarModel_Interpolator()
    {
      for(auto gagg_li : gagg_linear_interp)
        gsl_spline_free (gagg_li);
      for(auto gagg_ac : gagg_acc)
        gsl_interp_accel_free (gagg_ac);
      for(auto gaee_li : gaee_linear_interp)
        gsl_spline_free (gaee_li);
      for(auto gaee_ac : gaee_acc)
        gsl_interp_accel_free (gaee_ac);

    }

    // Returns reference value counts for the photon-axion contribution.
    std::vector&lt;double&gt; CAST_SolarModel_Interpolator::evaluate_gagg_contrib(double m_ax)
    {
      std::vector&lt;double&gt; result;
      double lgm = log10(m_ax);
      // If m &lt; 0.001 eV, just return the result for the result for the coherent limit.
      lgm = std::max(-3.0, lgm);
      // Only perform a calculation for valid masses.
      if (lgm &lt; 2.0)
      {
        for (int i = 0; i &lt; n_bins; i++) { result.push_back(gsl_spline_eval(gagg_linear_interp[i], lgm, gagg_acc[i])); }
      } else {
        for (int i = 0; i &lt; n_bins; i++) { result.push_back(0.0); }
      }

      return result;
    }

    // Returns reference value counts for the photon-axion contribution.
    std::vector&lt;double&gt; CAST_SolarModel_Interpolator::evaluate_gaee_contrib(double m_ax)
    {
      std::vector&lt;double&gt; result;
      double lgm = log10(m_ax);
      // If m &lt; 0.001 eV, just return the result for the result for the coherent limit.
      lgm = std::max(-3.0, lgm);
      // Only perform a calculation for valid masses.
      if (lgm &lt; 2.0)
      {
        for (int i = 0; i &lt; n_bins; i++) { result.push_back(gsl_spline_eval(gaee_linear_interp[i], lgm, gaee_acc[i])); }
      } else {
        for (int i = 0; i &lt; n_bins; i++) { result.push_back(0.0); }
      }

      return result;
    }

    // Use simplified version of Gaussian likelihood from GAMBIT Utils.
    double gaussian_nuisance_lnL(double theo, double obs, double sigma) { return Stats::gaussian_loglikelihood(theo, obs, 0, sigma, false); }

    //                                                    //
    //            Miscellaneous Theory Results            //
    //                                                    //

    //      Effective relatvistic degrees of freedom      //

    // Function to provide the effective relativistic degrees of freedom (for the Standard Model).
    double gStar(double T)
    {
      // Needs log10(T/GeV) for interpolation.
      double lgT = log10(T) - 3.0;
      // Interpolated effective relatvistic d.o.f. based on 0910.1066, deviations &lt; 0.5%
      // Tabulated data: x = log10(T/GeV), y = gStar
      static AxionInterpolator gR (GAMBIT_DIR &quot;/DarkBit/data/gR_WantzShellard.dat&quot;, InterpolationOptions1D::cspline);
      double res;
      if (lgT &gt; 3.0) {
        res = gR.interpolate (2.99);
      } else if (lgT &lt; -5.0) {
        res = gR.interpolate (-4.99);
      } else {
        res = gR.interpolate (lgT);
      }

      return res;
    }

    // Function to provide the effective relativistic entropic degrees of freedom (for the Standard Model).
    double gStar_S(double T)
    {
      // Need log10(T/GeV) for interpolation.
      double lgT = log10(T) - 3.0;
      // Interpolated effective relatvistic d.o.f. based on 0910.1066, deviations &lt; 0.5%
      // Tabulated data: x = log10(T/GeV), y = gStar
      static AxionInterpolator gS (GAMBIT_DIR &quot;/DarkBit/data/gS_WantzShellard.dat&quot;, InterpolationOptions1D::cspline);
      double res;
      if (lgT &gt; 3.0) {
        res = gS.interpolate (2.99);
      } else if (lgT &lt; -5.0) {
        res = gS.interpolate (-4.99);
      } else {
        res = gS.interpolate (lgT);
      }

      return res;
    }

    //      QCD-axion mass relation      //

    // Capability function to provide a simple Gaussian nuisance likelihood for
    // the zero-termperature mass of QCD axions.
    void QCDAxion_ZeroTemperatureMass_Nuisance_lnL(double &amp;result)
    {
      using namespace Pipes::QCDAxion_ZeroTemperatureMass_Nuisance_lnL;
      double LambdaChi = *Param[&quot;LambdaChi&quot;];

      // Results from NLO calculations (1511.02867).
      const double Lmu = 75.5;
      const double Lsigma = 0.5;

      result = gaussian_nuisance_lnL(Lmu, LambdaChi, Lsigma);
    }

    // Capability function to provide a simple Gaussian nuisance likelihood for
    // the model-independent contribution to the axion-photon coupling for QCD axions.
    void QCDAxion_AxionPhotonConstant_Nuisance_lnL(double &amp;result)
    {
      using namespace Pipes::QCDAxion_AxionPhotonConstant_Nuisance_lnL;
      double CaggQCD = *Param[&quot;CaggQCD&quot;];

      // Results from NLO calculations (1511.02867).
      const double CaggQCDmu = 1.92;
      const double CaggQCDsigma = 0.04;

      result = gaussian_nuisance_lnL(CaggQCDmu, CaggQCD, CaggQCDsigma);
    }

    // Auxillary function for QCD nuisance likelihood below.
    double log_chi (double T, double beta, double Tchi)
    {
      double result = 0.0;
      if (T &gt; Tchi) { result = -beta*log10(T/Tchi); }

      return result;
    }

     // Capability function to provide a lieklihood for the temperature dependence of the QCD axion mass (doi:10.1038/nature20115).
     void QCDAxion_TemperatureDependence_Nuisance_lnL(double &amp;result)
     {
       using namespace Pipes::QCDAxion_TemperatureDependence_Nuisance_lnL;
       double Tchi = *Param[&quot;Tchi&quot;];
       double beta = *Param[&quot;beta&quot;];

       // Results from lattice QCD (doi:10.1038/nature20115, Supplementary Material).
       // We normalised their findings by dividing out their value for chi(T=0) and removed its contribution to the error.
       const double temp_vals [20] = {100, 120, 140, 170, 200, 240, 290, 350, 420, 500, 600, 720, 860, 1000, 1200, 1500, 1800, 2100, 2500, 3000};
       const double log_chi_vals [20] = {0.00554625, 0.0255462, -0.0844538, -0.484454, -1.00445, -1.75445, -2.45445, -3.07445, -3.66445, -4.22445, -4.80445, -5.39445, -5.96445, -6.45445, -7.05445, -7.79445, -8.40445, -8.93445, -9.53445, -10.1545};
       const double log_chi_err_vals [20] = {0.014468, 0.0361846, 0.014468, 0.014468, 0.064104, 0.064104, 0.0510815, 0.0361846, 0.0510815, 0.064104, 0.0878027, 0.110042, 0.142159, 0.163124, 0.183873, 0.224965, 0.255557, 0.286023, 0.316401, 0.356804};

       double dummy = 0.0;
       for (int i = 0; i &lt; 20; i++) { dummy = dummy + gaussian_nuisance_lnL(log_chi_vals[i], log_chi(temp_vals[i],beta,Tchi), log_chi_err_vals[i]); }

       result = dummy;
     }

    //                                         //
    //            Axion Experiments            //
    //                                         //

    //      ALPS 1 experiment      //

    // Generic functions to calculate the expected signal per frame(!) for any data run.
    // Input: laser power, gas coefficient nm1 = n-1; result in no. of photons.
    double ALPS1_signal_general(double power, double nm1, double m_ax, double gagg)
    {
      const double eVm = gev2cm*1E7;
      // Photon energy in eV.
      const double erg = 2.0*pi*eVm/532.0E-9;
      const double len = 4.2;
      // We include the uncertainty of the detection efficiency eff = 0.82(5) in the likelihood.
      const double eff = 0.82;

      double result = 0.0;

      // CAVE: Approximations/conversion only valid/possible for m_ax &lt;&lt; 2.33 eV (532 nm).
      if (m_ax &lt; 1.0)
      {
        // Effective photon mass and momentum transfer.
        double m_ph_sq = 2.0*erg*erg*nm1;
        double q = 0.5*(m_ax*m_ax+m_ph_sq)/(eVm*erg);
        double factor = gsl_pow_4((gagg*1E17)*gsl_sf_sinc(0.5*q*len/pi));

        // Prefactor: 1096 W * 1 h * (10^-17/eV * 4.98 T * 4.2 m)^4 / 16.
        result = 0.00282962979*eff*factor*(power/1096.0)/erg;
      }

      return result;
    }

    // Specific capability to provide the expected signal from data run 1 (5 data frames).
    void calc_ALPS1_signal_vac(double &amp;result)
    {
      using namespace Pipes::calc_ALPS1_signal_vac;
      double m_ax = *Param[&quot;ma0&quot;];
      double gagg = gagg_conversion*std::fabs(*Param[&quot;gagg&quot;]); // gagg needs to be in eV^-1.

      result = ALPS1_signal_general(1096.0, 0.0, m_ax, gagg);
    }

    // Specific capability to provide the expected signal from data run 3 (8 data frames; 0.18 mbar).
    void calc_ALPS1_signal_gas(double &amp;result)
    {
      using namespace Pipes::calc_ALPS1_signal_gas;
      double m_ax = *Param[&quot;ma0&quot;];
      double gagg = gagg_conversion*std::fabs(*Param[&quot;gagg&quot;]); // gagg needs to be in eV^-1.

      result = ALPS1_signal_general(1044.0, 5.0E-8, m_ax, gagg);
    }

    // General likelihood function for the ALPS 1 experiment (given expected signal s = obs - bkg).
    double ALPS1_lnL_general(double s, double mu, double sigma)
    {
      // Propagate uncertainty from efficiency in chi^2-likelihood.
      const double rel_error = 0.05/0.82;
      return -0.5*gsl_pow_2(s-mu)/(gsl_pow_2(rel_error*s)+gsl_pow_2(sigma));
    }

    // Capability to provide joint liklihood for all three data runs.
    void calc_lnL_ALPS1(double &amp;result)
    {
      using namespace Pipes::calc_lnL_ALPS1;
      double s1 = *Dep::ALPS1_signal_vac;
      double s2 = *Dep::ALPS1_signal_gas;

      // ALPS Collaboration results (limits from this data published in 1004.1313).
      // ALPS Collaboration results, vacuum, 5 frames.
      const double exp_sig_mu_v1 = -4.01, exp_sig_std_v1 = 3.01;
      // ALPS Collaboration results, vacuum, 6 frames.
      const double exp_sig_mu_v2 = -2.35, exp_sig_std_v2 = 3.44;
      // ALPS Collaboration results, vacuum combined(!), 11 frames (we keep them seperated).
      //const double exp_sig_mu_vc = -3.29, exp_sig_std_vc = 2.27;
      // ALPS Collaboration results, gas, 8 frames (P = 0.18 mbar).
      const double exp_sig_mu_g = 3.98, exp_sig_std_g = 2.45;

      double l1 = ALPS1_lnL_general(s1, exp_sig_mu_v1, exp_sig_std_v1);
      double l2 = ALPS1_lnL_general(s1, exp_sig_mu_v2, exp_sig_std_v2);
      double l3 = ALPS1_lnL_general(s2, exp_sig_mu_g, exp_sig_std_g);

      result = l1 + l2 + l3;
    }

    //      CAST experiment (vacuum runs only)      //

    // Calculates the signal prediction for the CAST experiment (CCD detector 2004).
    void calc_CAST2007_signal_vac(std::vector&lt;double&gt; &amp;result)
    {
      using namespace Pipes::calc_CAST2007_signal_vac;
      double m_ax = *Param[&quot;ma0&quot;];
      double gagg = gagg_conversion*std::fabs(*Param[&quot;gagg&quot;]); // gagg needs to be in eV^-1.
      double gaee = std::fabs(*Param[&quot;gaee&quot;]);

      // Initialise the Solar model calculator and get the reference counts for a given mass.
      // Get Solar model we are working with; set default value here
      static std::string solar_model_gagg = runOptions-&gt;getValueOrDef&lt;std::string&gt; (&quot;AGSS09met&quot;, &quot;solar_model_gagg&quot;);
      static std::string solar_model_gaee = runOptions-&gt;getValueOrDef&lt;std::string&gt; (&quot;AGSS09met_old&quot;, &quot;solar_model_gaee&quot;);
      static CAST_SolarModel_Interpolator lg_ref_counts (solar_model_gagg, solar_model_gaee, &quot;CAST2007&quot;);
      std::vector&lt;double&gt; lg_ref_counts_gagg = lg_ref_counts.evaluate_gagg_contrib(m_ax);
      std::vector&lt;double&gt; lg_ref_counts_gaee = lg_ref_counts.evaluate_gaee_contrib(m_ax);
      static int n_bins = lg_ref_counts_gagg.size();

      std::vector&lt;double&gt; counts;
      double dummy;
      for (int i = 0; i &lt; n_bins; i++)
      {
        dummy = gsl_pow_2(gagg*1E19)*pow(10,lg_ref_counts_gagg[i]) + gsl_pow_2(gaee*gaee_conversion)*pow(10,lg_ref_counts_gaee[i]);
        counts.push_back(gsl_pow_2(gagg*1E19)*dummy);
      }

      result = counts;
    }

    // Calculates the signal prediction for the CAST experiment (all detectors in 1705.02290)
    void calc_CAST2017_signal_vac(std::vector&lt;std::vector&lt;double&gt;&gt; &amp;result)
    {
      using namespace Pipes::calc_CAST2017_signal_vac;
      double m_ax = *Param[&quot;ma0&quot;];
      double gagg = gagg_conversion*std::fabs(*Param[&quot;gagg&quot;]); // gagg needs to be in eV^-1.
      double gaee = std::fabs(*Param[&quot;gaee&quot;]);
      std::vector&lt;std::vector&lt;double&gt;&gt; res;

      // Initialise the Solar model calculator and get the reference counts for a given mass.
      // Get Solar model we are working with; set default value here
      static std::string solar_model_gagg = runOptions-&gt;getValueOrDef&lt;std::string&gt; (&quot;AGSS09met&quot;, &quot;solar_model_gagg&quot;);
      static std::string solar_model_gaee = runOptions-&gt;getValueOrDef&lt;std::string&gt; (&quot;AGSS09met_old&quot;, &quot;solar_model_gaee&quot;);

      const int n_exps = 12;
      const int n_bins = 10;
      const std::string exp_names [n_exps] = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;};
      static std::vector&lt;CAST_SolarModel_Interpolator&gt; lg_ref_counts;
      static bool lg_ref_counts_not_calculated = true;
      if (lg_ref_counts_not_calculated)
      {
        for (int e = 0; e &lt; n_exps; e++)
        {
          CAST_SolarModel_Interpolator dummy (solar_model_gagg, solar_model_gaee, &quot;CAST2017_&quot;+exp_names[e]);
          lg_ref_counts.push_back(std::move(dummy));
        }
      }
      lg_ref_counts_not_calculated = false;

      for (int e = 0; e &lt; n_exps; e++)
      {
        std::vector&lt;double&gt; lg_ref_counts_gagg = lg_ref_counts[e].evaluate_gagg_contrib(m_ax);
        std::vector&lt;double&gt; lg_ref_counts_gaee = lg_ref_counts[e].evaluate_gaee_contrib(m_ax);

        std::vector&lt;double&gt; counts;
        double dummy;
        for (int bin = 0; bin &lt; n_bins; bin++)
        {
          dummy = gsl_pow_2(gagg*1E19)*pow(10,lg_ref_counts_gagg[bin]) + gsl_pow_2(gaee*gaee_conversion)*pow(10,lg_ref_counts_gaee[bin]);
          counts.push_back(gsl_pow_2(gagg*1E19)*dummy);
        }

        res.push_back(counts);
      }

      result = res;
    }

    // General binned Poisson likelihood for the CAST experiment.
    double CAST_lnL_general(std::vector&lt;double&gt; s, const std::vector&lt;double&gt; bkg_counts, const std::vector&lt;int&gt; sig_counts)
    {
      double result = 0.0;
      int n_bins = s.size();

      for (int i = 0; i &lt; n_bins; i++)
      {
        double mu = s[i] + bkg_counts[i];
        result += sig_counts[i]*gsl_sf_log(mu) - mu;
      }

      return result;
    }

    // Capability to provide CAST likelihood for hep-ex/0702006 .
    void calc_lnL_CAST2007(double &amp;result)
    {
      using namespace Pipes::calc_lnL_CAST2007;
      std::vector&lt;double&gt; sig_vac = *Dep::CAST2007_signal_vac;

      // CAST CCD 2004 vacuum data (based on hep-ex/0702006).
      const int n_bins = 20;
      const std::vector&lt;int&gt; dat_vac {1, 3, 1, 1, 1, 2, 1, 2, 0, 2, 0, 1, 0, 2, 2, 0, 2, 1, 2, 2};
      const std::vector&lt;double&gt; bkg_vac {2.286801272, 1.559182673, 2.390746817, 1.559182673, 2.598637835, 1.039455092, 0.727618599, 1.559182673, 1.247346181, 1.455237199, 1.871019235, 0.831564073, 1.663128217, 1.247346181, 1.143400636, 1.663128217,
                                         1.247346181, 1.247346181, 2.286801272, 1.247346181};

      // Only calculate norm once.
      static double norm = 0.0;
      static bool norm_not_calculated = true;
      if (norm_not_calculated)
      {
        for (int i = 0; i &lt; n_bins; i++) { norm += gsl_sf_lnfact(dat_vac[i]); }
      }
      norm_not_calculated = false;

      result = CAST_lnL_general(sig_vac, bkg_vac, dat_vac) - norm;
    }

    // Capability to provide CAST likelihood for 1705.02290 .
    void calc_lnL_CAST2017(double &amp;result)
    {
      using namespace Pipes::calc_lnL_CAST2017;
      std::vector&lt;std::vector&lt;double&gt;&gt; sig_vac = *Dep::CAST2017_signal_vac;

      // CAST 2017 vacuum data (naming scheme based on the 10 data sets published in 1705.02290).
      const int n_bins = 10;
      const int n_exps = 12;

      const std::vector&lt;std::vector&lt;int&gt;&gt; dat_vac_all { {0, 3, 3, 0, 0, 1, 3, 3, 3, 3},
                                                        {5, 5, 5, 3, 3, 0, 5, 2, 2, 1},
                                                        {3, 3, 1, 2, 2, 2, 4, 5, 4, 3},
                                                        {1, 5, 5, 2, 1, 2, 2, 5, 4, 0},
                                                        {2, 3, 2, 2, 2, 1, 0, 2, 1, 1},
                                                        {3, 5, 1, 4, 1, 2, 0, 3, 2, 2},
                                                        {3, 4, 4, 5, 1, 2, 3, 2, 3, 2},
                                                        {2, 1, 0, 1, 3, 2, 2, 3, 0, 1},
                                                        {1, 2, 2, 1, 3, 0, 0, 1, 4, 0},
                                                        {2, 1, 3, 1, 1, 0, 1, 1, 5, 5},
                                                        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                                        {0, 2, 1, 0, 0, 0, 0, 0, 0, 0} };

      const std::vector&lt;std::vector&lt;double&gt;&gt; bkg_vac_all { {0.926256, 1.96148, 1.79803, 1.30766, 1.30766, 1.96148, 2.61531, 2.77877, 2.94223, 2.07045},
                                                           {3.68151, 4.86486, 4.99634, 3.55003, 2.49817, 3.28707, 2.89262, 3.68151, 3.48429, 3.41855},
                                                           {2.54573, 3.18216, 4.45502, 2.86394, 2.29116, 2.29116, 3.30945, 3.75495, 3.62766, 3.56402},
                                                           {2.72482, 5.5794, 3.95748, 2.40044, 2.27069, 2.33556, 3.37359, 3.43847, 3.24384, 3.11408},
                                                           {1.44613, 2.30066, 2.43213, 1.70906, 1.97199, 1.24893, 1.24893, 2.23493, 2.16919, 2.23493},
                                                           {1.30963, 2.94666, 2.35733, 2.55377, 2.02992, 1.50607, 2.16088, 2.75022, 2.29185, 2.29185},
                                                           {2.33334, 2.74167, 2.21667, 2.80001, 2.21667, 1.75001, 2.62501, 2.21667, 2.80001, 2.33334},
                                                           {1.74724, 2.37125, 2.68326, 1.62243, 2.05924, 1.74724, 1.49763, 1.74724, 1.18563, 2.24645},
                                                           {1.72998, 3.45995, 1.79405, 1.72998, 1.9222, 1.72998, 2.69107, 2.24256, 1.98627, 2.11442},
                                                           {1.89627, 2.25182, 2.96292, 1.4222, 1.65924, 1.65924, 1.95553, 2.1333, 1.71849, 2.07404},
                                                           {0.0150685, 0.0568493, 0.060274, 0.0150685, 0.0150685, 0.00753425, 0.0267123, 0.0150685, 0.0267123, 0.0116438},
                                                           {0.0409574, 0.226904, 0.243287, 0.0532447, 0.0188404, 0.0344043, 0.0417766, 0.0409574, 0.0409574, 0.0286702} };

      // Only calculate norm once.
      static double norm = 0.0;
      static bool norm_not_calculated = true;
      if (norm_not_calculated)
      {
        for (int bin = 0; bin &lt; n_bins; bin++)
        {
          for (int e = 0; e &lt; n_exps; e++) { norm += gsl_sf_lnfact(dat_vac_all[e][bin]); }
        }
      }
      norm_not_calculated = false;

      result = 0.0;
      for (int e = 0; e &lt; n_exps; e++) { result = result + CAST_lnL_general(sig_vac[e], bkg_vac_all[e], dat_vac_all[e]); }
      result = result - norm;
    }

    //      Various haloscope experiments      //

    // Capability to provide generic haloscope &quot;signal&quot; prediction.
    // All current haloscope likelihoods are approximated. We only need the predicted signal power up to a constant of proportionality.
    void calc_Haloscope_signal(double &amp;result)
    {
      using namespace Pipes::calc_Haloscope_signal;
      double gagg = gagg_conversion*std::fabs(*Param[&quot;gagg&quot;]); // gagg needs to be in eV^-1.
      // Get the DM fraction in axions and the local DM density.
      double fraction = *Dep::RD_fraction;
      LocalMaxwellianHalo LocalHaloParameters = *Dep::LocalHalo;
      double rho0 = LocalHaloParameters.rho0;

      // Signal relative to a reference coupling and local DM density.
      double s = gsl_pow_2(gagg/1.0E-24) * fraction * (rho0/0.45);

      result = s;
    }

    // ADMX approximated likelihood function for data from publications from 1998 to 2009.
    void calc_lnL_Haloscope_ADMX1(double &amp;result)
    {
      using namespace Pipes::calc_lnL_Haloscope_ADMX1;
      double m_ax = *Param[&quot;ma0&quot;];
      // Calculate equivalent frequency in MHz.
      const double eV_to_MHz = 1.0E-15/(2.0*pi*hbar);
      double freq = m_ax*eV_to_MHz;
      double l = 0.0;
      // Initialise GSL histogram and flag.
      static gsl_histogram *h = gsl_histogram_alloc(89);
      static bool init_flag = false;

      // Unless initialised already, read in digitised limits from 0910.5914.
      if (not(init_flag))
      {
        FILE * f = fopen(GAMBIT_DIR &quot;/DarkBit/data/ADMXLimitsHistogram.dat&quot;, &quot;r&quot;);
        gsl_histogram_fscanf (f, h);
        fclose(f);
        init_flag = true;
      }

      // Likelihood shape parameters based on limits from astro-ph/9801286.
      const double a = 0.013060890;
      const double b = 0.455482976;

      if ((freq &gt; gsl_histogram_min(h)) &amp;&amp; (freq &lt; gsl_histogram_max(h)))
      {
        size_t index;
        gsl_histogram_find(h, freq, &amp;index);
        double s     = *Dep::Haloscope_signal;
        double s_ref = gsl_pow_2(gsl_histogram_get(h, index));
        double s_rel = s/s_ref;
        // Only apply contraints for a signal &gt; threshold a.
        if (s_rel &gt; a) { l = -0.5 * gsl_pow_2( (s_rel - a)/b ); }
      }

      result = l;
    }

    // ADMX approximated likelihood function for data from 2018 paper (1804.05750).
    void calc_lnL_Haloscope_ADMX2(double &amp;result)
    {
      using namespace Pipes::calc_lnL_Haloscope_ADMX2;
      // Rescale the axion mass to ueV.
      double m_ax = 1.0E+6*(*Param[&quot;ma0&quot;]);
      double l = 0.0;

      // ADMX 2018 90% C.L. exclusion limits; digitised from Fig. 4, 1804.05750.
      static AxionInterpolator g_limits (GAMBIT_DIR &quot;/DarkBit/data/ADMX2018Limits.dat&quot;);

      // If we are within the avialable data range, calculate the limit.
      if ( (m_ax &gt; g_limits.lower()) &amp;&amp; (m_ax &lt; g_limits.upper()) )
      {
        double s = *Dep::Haloscope_signal;
        // Get limit and rescale it to 1 sigma from the appropriate number of sigmas for 90% C.L. (1 d.o.f.).
        double sigma_exp = gsl_pow_2(g_limits.interpolate(m_ax))/1.644817912489;
        // Add systematics of 13% according to 1804.05750.
        double var_exp = gsl_pow_2(sigma_exp);
        double var_theo = gsl_pow_2(0.13*s);
        double var_tot = var_exp + var_theo;
        l = -0.5*gsl_pow_2(s)/var_tot;
      }

      result = l;
    }

    // University of Florida (UF) approximated likelihood function; Hagmann+ Phys. Rev. D 42, 1297(R) (1990).
    void calc_lnL_Haloscope_UF(double &amp;result)
    {
      using namespace Pipes::calc_lnL_Haloscope_UF;
      // Rescale the axion mass to ueV.
      double m = 1.0E+6*(*Param[&quot;ma0&quot;]);
      double l = 0.0;

      // There are only limits between 5.4 and 5.9 ueV.
      if ((m &gt; 5.4) &amp;&amp; (m &lt; 5.9)) {
        // Likelihood parameters based on information from Phys. Rev. D 42, 1297(R) (1990); correspond to power in 10^-22 W.
        const double sigma = 2.859772;
        // The &quot;signal&quot; needs to be rescaled to 0.2804 GeV/cm^3 (their reference value)
        // and also to the reference DFSZ coupling strength gDFSZ^2 = 0.6188 x 10^-30 GeV^-2
        // const double PowerDFSZ = 6.92;
        //double s = (0.45/0.2804)*(PowerDFSZ/0.6188)*(*Dep::Haloscope_signal);
        //double s = 0.035083106*(0.45/0.2804)*(*Dep::Haloscope_signal);
        double s = 0.0273012*(*Dep::Haloscope_signal);
        l = -0.5 * gsl_pow_2(s/sigma);
      }

      result = l;
    }

    // Rochester-Brookhaven-Fermi (RBF) approximated likelihood function; Phys. Rev. D 40, 3153 (1989).
    void calc_lnL_Haloscope_RBF(double &amp;result)
    {
      using namespace Pipes::calc_lnL_Haloscope_RBF;
      // Rescale the axion mass to ueV.
      double m = 1.0E+6*(*Param[&quot;ma0&quot;]);
      double l = 0.0;
      // Results from Phys. Rev. D 40, 3153 (1989)
      // The bins and results below (from Table I) appear to be inconsitent with Figure 14.
      //const std::vector&lt;double&gt; bins = {4.507875, 5.037241, 5.459079, 5.851967, 5.996715, 6.257262, 6.617065, 6.976868, 7.113345, 7.295314, 7.857765, 8.631134, 8.684898, 9.259755, 9.760171, 10.173737,
      //                                  11.298638, 11.583999, 12.845377, 13.234130, 15.301962, 16.2655809};
      // N_sigma values as defined in the paper.
      //const double N_sigma [21] = {5.0, 5.0, 5.0, 4.0, 4.0, 4.0, 4.0, 4.0, 4.0, 4.0, 4.0, 4.0, 4.0, 4.0, 4.0, 0.0, 5.0, 4.0, 4.0, 4.0, 4.0};
      // Proportionality factors (&quot;sigma&quot;) inferred from Table I in in units of GeV^-1/cm^3.
      //const double eff_sigma [21] = {8.3030524510E+01, 3.5789241789E+02, 5.3457189090E+02, 8.3673921774E+02, 7.3205267295E+02, 7.1850356207E+02, 7.0099211538E+02, 9.3243407987E+02, 1.3132694610E+03, 1.9447760075E+03, 2.4028734743E+03,
      //                               3.5992849457E+03, 5.8433323192E+03, 1.2415907565E+03, 1.1487509033E+03, 1.0000000000E+99, 2.6768234439E+03, 9.1546564260E+04, 1.7208310692E+04, 4.2462784870E+04, 2.8794160844E+04};
      // The results below are derived from Fig. 14 (assuming N_sigma = 4 for all values).
      const std::vector&lt;double&gt; bins = {4.400841, 4.960600, 5.209095, 5.668611, 6.934590, 7.445686, 8.041207, 8.898392, 9.570607, 10.067396, 11.213613, 11.626834, 12.773085, 13.450179, 14.704884, 16.170394};
      const double N_sigma = 4.0;
      const double eff_sigma [15] = {7.794388E+01, 3.808827E+02, 5.328136E+02, 6.765588E+02, 1.772892E+03, 2.752458E+03, 5.945156E+03, 2.025315E+03, 1.546855E+03, 1.022957E+13, 5.464075E+03, 9.621171E+04, 2.023187E+04, 5.201449E+04, 3.597168E+04};

      // Likelihood shape parameters based on information from PRD 40 (1989) 3153.
      // Note that there are no limits between 10.1 and 11.2 ueV; the tabulated value in that bin is just a placeholder, which is never used.
      if ( ((m &gt; bins.front()) &amp;&amp; (m &lt; 10.067396)) || ((m &gt; 11.213613) &amp;&amp; (m &lt; bins.back())))
      {
        // Use the standard search algorthim to identify the bin index and use the appropriate values for the likelihood.
        auto index = upper_bound(bins.begin(), bins.end(), m);
        double sigma = eff_sigma[index-bins.begin()-1];
        // Uncomment and comment out lines below to swap between implementations using Table I and Figure 14, respectively.
        //double offset = sigma*N_sigma[index-bins.begin()-1];
        double offset = sigma*N_sigma;
        // The &quot;signal&quot; needs to be rescaled to 0.3 GeV/cm^3, which is their reference value.
        double s = (0.45/0.3)*(*Dep::Haloscope_signal);
        if (s &gt; offset) {
          l = -0.5 * gsl_pow_2( (s - offset)/sigma );
        }
      }

      result = l;
    }

    //                                       //
    //            Axion Cosmology            //
    //                                       //

    //      Energy density in realignment axions today      //

    /* Some auxillary functions for solving the  necessary differential equations
     */

    // Provides function F1 for the change in variables time -&gt; temperature (see 1810.07192).
    double SpecialFun1(double T)
    {
      // log10(T/GeV) required for interpolation.
      double lgT = log10(T) - 3.0;
      // Tabulated data: x = log10(T/GeV), y = F1(T); gR and gS from 0910.1066 .
      static AxionInterpolator F1 (GAMBIT_DIR &quot;/DarkBit/data/Axion_DiffEqnFun1.dat&quot;, InterpolationOptions1D::linear);
      double res = -1.0;
      if ((lgT &gt; 3.0) &amp;&amp; (lgT &lt; -5.0)) { res = F1.interpolate (lgT); }
      return res;
    }

    // Provides function F3 for the change in variables time -&gt; temperature (see 1810.07192).
    double SpecialFun3(double T)
    {
      // log10(T/GeV) required for interpolation.
      double lgT = log10(T) - 3.0;
      // Tabulated data: x = log10(T/GeV), y = F3(T); gR and gS from 0910.1066 .
      static AxionInterpolator F3 (GAMBIT_DIR &quot;/DarkBit/data/Axion_DiffEqnFun3.dat&quot;, InterpolationOptions1D::linear);
      double res = 0.0;
      if ((lgT &gt; 3.0) &amp;&amp; (lgT &lt; -5.0)) { res = F3.interpolate (lgT); }
      return res;
    }

    // Auxillary function to calculate the Hubble parameter in a radiation-dominated universe.
    double hubble_rad_dom(double T)
    {
      // H(T)/eV, T/MeV, m_pl/10^12eV = m_pl/10^3 GeV
      const double m_pl = m_planck_red*1.0E-3;
      return 0.331153*sqrt(gStar(T))*T*T/m_pl;
    }

    // General form of the temperature-dependent axion mass.
    double axion_mass_temp(double T, double beta, double Tchi)
    {
      double res = 1.0;
      if (T &gt; Tchi) { res = pow(T/Tchi,-0.5*beta); }
      return res;
    }

    // Auxillary structure for passing the model parameters to the gsl solver.
    struct AxionEDT_params {double ma0; double beta; double Tchi; double thetai; double Tosc;};

    // Auxillary function with root Tosc, the temperature where the axion field oscillations start (defined by mA = 3H).
    // Note that this is only to set the temperature scale of the problem. The differential equation is solved numerically around
    // this point and the numerical factor in the definition is pure convention.
    double equation_Tosc(double T, void *params)
    {
      // T/MeV, ma0/eV, m_pl/10^12eV = m_pl/10^3 GeV
      const double m_pl = m_planck_red*1.0E-3;
      struct AxionEDT_params * p1 = (struct AxionEDT_params *)params;
      double ma0 = (p1-&gt;ma0);
      double beta = (p1-&gt;beta);
      double Tchi = (p1-&gt;Tchi);

      double result = 1.0 - gStar(T)*gsl_pow_2(T*T*pi/(ma0*m_pl*axion_mass_temp(T, beta, Tchi)))/10.0;

      return result;
    }

    // Capability function to solve equation_Tosc for Tosc.
    void calc_AxionOscillationTemperature(double &amp;result)
    {
      using namespace Pipes::calc_AxionOscillationTemperature;

      double ma0 = *Param[&quot;ma0&quot;];
      double beta = *Param[&quot;beta&quot;];
      double Tchi = *Param[&quot;Tchi&quot;];
      // m_pl/10^12 eV = m_pl/10^3 GeV
      const double m_pl = m_planck_red*1.0E-3;

      // Initialising the parameter structure with known and dummy values.
      AxionEDT_params params = {ma0, beta, Tchi, 0.0, 0.0};

      // Use gsl implementation Brent's method to determine the oscillation temperature.
      gsl_function F;
      F.function = &amp;equation_Tosc;
      F.params = &amp;params;

      // Set counters and initialise equation solver.
      int status;
      int iter = 0, max_iter = 1E6;
      gsl_root_fsolver *s;
      s = gsl_root_fsolver_alloc(gsl_root_fsolver_brent);
      double r, r_up, r_lo;

      // Calculate first estimate for the root bracketing [r_lo, r_up].
      // Calculate best estimate for comparison. g(Tchi)^-0.25 = 0.49, g(Tchi)^-...=0.76
      r = 0.49*pow((10.0/(pi*pi)) * gsl_pow_2(m_pl*ma0), 0.25);
      // Compare to decide which branch of the equation is valid; T1 &gt; Tchi or T1 &lt; Tchi
      if ( (r &gt; Tchi) &amp;&amp; (beta &gt; 1.0E-10) )
      {
        r = 0.76*pow((10.0/(pi*pi)) * gsl_pow_2(m_pl*ma0) * pow(Tchi, beta), 1.0/(4.0+beta));
      }
      // Find appropriate values for r_lo and r_up
      r_up = r;
      r_lo = r;
      while (GSL_FN_EVAL(&amp;F,r_up) &gt; 0.0) { r_up = 2.0*r_up; }
      while (GSL_FN_EVAL(&amp;F,r_lo) &lt; 0.0) { r_lo = 0.5*r_lo; }

      // Execute equation solver until we reach 10^-6 absolute precision.
      gsl_root_fsolver_set(s, &amp;F, r_lo, r_up);
      do
      {
        iter++;
        status = gsl_root_fsolver_iterate (s);
        r = gsl_root_fsolver_root (s);
        r_lo = gsl_root_fsolver_x_lower (s);
        r_up = gsl_root_fsolver_x_upper (s);
        status = gsl_root_test_interval (r_lo, r_up, 1.0E-6, 0.0);
      } while (status == GSL_CONTINUE &amp;&amp; iter &lt; max_iter);

      gsl_root_fsolver_free (s);

      result = r;
    }

    /* Differential equation solver to calculate the axion energy density today */

    // Initialise the quantities needed for the ODE solver from the gsl library.
    // Define the system of differential equations as a function of relative temperature.
    int scal_field_eq(double tau, const double y[], double f[], void *params)
    {
      struct AxionEDT_params * p = (struct AxionEDT_params *)params;
      double ma0 = (p-&gt;ma0);
      double beta = (p-&gt;beta);
      double Tchi= (p-&gt;Tchi);
      double Tosc = (p-&gt;Tosc);
      double thetai = (p-&gt;thetai);
      // f stores derivatives, y stores functions.
      f[0] = y[1];
      f[1] = -gsl_pow_2(SpecialFun1(-tau*Tosc) * ma0*axion_mass_temp(-tau*Tosc,beta,Tchi) / (hubble_rad_dom(-tau*Tosc) * (-tau))) * gsl_sf_sin(y[0]*thetai)/thetai;

      return GSL_SUCCESS;
    }

    // Define the Jacobian for the system of differential equations.
    int scal_field_eq_jac(double tau, const double y[], double *dfdy, double dfdt[], void *params)
    {
      //(void)(t); // avoid unused parameter warning.
      struct AxionEDT_params * p = (struct AxionEDT_params *)params;
      double ma0 = (p-&gt;ma0);
      double beta = (p-&gt;beta);
      double Tchi = (p-&gt;Tchi);
      double Tosc = (p-&gt;Tosc);
      double thetai = (p-&gt;thetai);
      gsl_matrix_view dfdy_mat  = gsl_matrix_view_array (dfdy, 2, 2);
      gsl_matrix * m = &amp;dfdy_mat.matrix;
      // (i, j) entries for matrix m; last entry = df[i]/df[j].
      gsl_matrix_set (m, 0, 0, 0);
      gsl_matrix_set (m, 0, 1, 1);
      gsl_matrix_set (m, 1, 0, -gsl_pow_2(SpecialFun1(-tau*Tosc) * ma0*axion_mass_temp(-tau*Tosc,beta,Tchi) / (hubble_rad_dom(-tau*Tosc) * (-tau))) * gsl_sf_cos(y[0]*thetai));
      gsl_matrix_set (m, 1, 1, -SpecialFun3(-tau*Tosc) / (-tau));
      dfdt[0] = 0.0;
      dfdt[1] = 0.0;

      return GSL_SUCCESS;
    }

    // Capability function to solve the differential equation for the energy density in axions today (in terms of the critical density).
    void RD_oh2_Axions(double &amp;result)
    {
      using namespace Pipes::RD_oh2_Axions;
      double ma0 = *Param[&quot;ma0&quot;];
      double beta = *Param[&quot;beta&quot;];
      double Tchi = *Param[&quot;Tchi&quot;];
      double thetai = *Param[&quot;thetai&quot;];
      double fa = *Param[&quot;fa&quot;];
      double Tosc = *Dep::AxionOscillationTemperature;

      if ( (thetai&lt;-pi) || (thetai&gt;3.0*pi) ) { DarkBit_error().raise(LOCAL_INFO, &quot;ERROR! The parameter 'thetai' should be chosen from the interval [-pi,3pi].&quot;); }

      // If thetai in (pi,3pi): map it back to its equivalent value in (-pi,pi]. This is to allow sampling around pi and easier averaging.
      if (thetai&gt;pi) { thetai = thetai - 2.0*pi; }

      // Only do computations if thetai &gt; 0.
      result = 0.0;
      if (fabs(thetai) &gt; 0)
      {
        // TCMB in MeV.
        const double TCMB = *Dep::T_cmb*K2eV*1.0E-6;
        // Critical energy density today * h^2 (in eV^4).
        const double ede_crit_today = 3.0*2.69862E-11;

        struct AxionEDT_params p = {ma0, beta, Tchi, thetai, Tosc};

        // Function, Jacobian, number of dimensions + pointer to params.
        gsl_odeiv2_system sys = {scal_field_eq, scal_field_eq_jac, 2, &amp;p};
        // Evolution from Temp = 1e5 x Tosc to Temp = 0.001 x Tosc.
        double tau2 = -0.001, tau1 = -1E5;
        // Initial conditions for (u and v = u') as functions of temperature:
        double y[2] = {1.0, 0.0};
        // Settings for the driver: pointer to the ODE system sys, the gsl method, initial step size,
        // absolute accuracy in y[0] and y[1], relative accuracy in y[0] and y[1].
        // Other possible choices: gsl_odeiv2_step_rk4 (classic), gsl_odeiv2_step_rk8pd, gsl_odeiv2_step_rkf45 (standard choices).
        gsl_odeiv2_driver * d = gsl_odeiv2_driver_alloc_y_new (&amp;sys, gsl_odeiv2_step_bsimp, -0.1*tau1, 1E-8, 1E-8);

        // Numerically solve ODE by continuing the integration well into the harmonic and adiabatic regime (stopping conditions
        // via check1 = |hat(theta)| and check2 = 3H/m need to be satisfied).
        double new_step;
        double check1 = 1.0, check2 = 1.0;
        int i = 0;

        #ifdef AXION_DEBUG_MODE
          std::cout &lt;&lt; &quot;DEBUGGING INFO for relic density calculation:\n&quot;
                       &quot;#'temperature' theta dtheta/dtau&quot; &lt;&lt; std::endl;
        #endif

        do
        {
          i++;
          new_step = -pow(10.0, 1.0 + (log10(-tau2)-1.0)*i/1000.0);
          int status = gsl_odeiv2_driver_apply (d, &amp;tau1, new_step, y);
          if (status != GSL_SUCCESS) { std::cout &lt;&lt; &quot;Error, return value = &quot; &lt;&lt; d &lt;&lt; std::endl; }
          check1 = fabs(thetai)*sqrt(gsl_pow_2( fabs(y[0]) ) + gsl_pow_2( fabs((-new_step)*y[1]*hubble_rad_dom(-new_step*Tosc)/(ma0*axion_mass_temp(-new_step*Tosc,beta,Tchi))) ));
          check2 = 3.0*hubble_rad_dom(-new_step*Tosc)/(ma0*axion_mass_temp(-new_step*Tosc,beta,Tchi));

          #ifdef AXION_DEBUG_MODE
            std::cout &lt;&lt; -new_step &lt;&lt; &quot; &quot; &lt;&lt; thetai*y[0] &lt;&lt; &quot; &quot; &lt;&lt; -tau2*thetai*y[1] &lt;&lt; std::endl;
          #endif

        } while ( ((check1&gt;1.0E-2) || (check2&gt;1.0E-3)) &amp;&amp; (i&lt;1E3) );

        i++;
        if (i&gt;=1E+3)
        {
          std::ostringstream buffer;
          buffer &lt;&lt; &quot;T_end: &quot; &lt;&lt; -new_step &lt;&lt; &quot; | theta_hat_val: &quot; &lt;&lt; check1 &lt;&lt; &quot;, theta_der: &quot;&lt;&lt; -tau2*y[1]*thetai &lt;&lt; &quot;, 3H/m_osc: &quot; &lt;&lt; 3.0*hubble_rad_dom(Tosc)/(ma0*axion_mass_temp(-new_step*Tosc,beta,Tchi)) &lt;&lt; &quot;, 3H/m: &quot; &lt;&lt; check2 &lt;&lt; &quot; .\n&quot;;
          DarkBit_warning().raise(LOCAL_INFO, &quot;WARNING! Maximum number of integration steps reached for energy density calculator!\n         &quot;+buffer.str());
        }

        // Calculate the axion energy density at the stopping point.
        double ede = 1E+18*gsl_pow_2(fa)*(0.5*gsl_pow_2(y[1]*thetai*hubble_rad_dom(-new_step*Tosc)*(-new_step)) + gsl_pow_2(ma0*axion_mass_temp(-new_step*Tosc,beta,Tchi))*(1.0 - gsl_sf_cos(y[0]*thetai)));
        // Use conservation of entropy to scale the axion energy density to its present value (relative to the critical energy density).
        double OmegaAh2 = ede*gsl_pow_3(TCMB/(-new_step*Tosc))*(gStar_S(TCMB)/gStar_S(-new_step*Tosc))*(1.0/axion_mass_temp(-new_step*Tosc,beta,Tchi))/ede_crit_today;

        gsl_odeiv2_driver_free (d);

        result = OmegaAh2;
      }
    }

    //                                          //
    //            Axion Astrophysics            //
    //                                          //

     //      R-parameter      //

     // Capability function to calculate the R-parameter (1512.08108).
     // Based and extending on Refs [11, 12, 13, 75] and 10.3204/DESY-PROC-2015-02/straniero_oscar in 1512.08108 .
     void calc_RParameter(double &amp;result)
     {
       using namespace Pipes::calc_RParameter;
       double ma0 = *Param[&quot;ma0&quot;];
       double gaee2 = gsl_pow_2(gaee_conversion*std::fabs(*Param[&quot;gaee&quot;]));
       double gagg = 1.0E+10*std::fabs(*Param[&quot;gagg&quot;]); // gagg needs to be in 10^-10 GeV^-1.
       // Value for He-abundance Y from 1503.08146: &lt;Y&gt; = 0.2515(17).
       const double Y = 0.2515;
       // Use interpolation for the finite-mass correction.
       static AxionInterpolator correction (GAMBIT_DIR &quot;/DarkBit/data/Axions_RParameterCorrection.dat&quot;, InterpolationOptions1D::linear);
       // Initialise an effective axion-photon coupling, valid for low masses.
       double geff = gagg;
       // Apply correction for higher mass values...
       static double m_min = pow(10,correction.lower());
       static double m_max = pow(10,correction.upper());
       if ((ma0 &gt; m_min) &amp;&amp; (ma0 &lt; m_max)) { geff *= pow(10, 0.5*correction.interpolate(log10(ma0))); }
       // ... or set to zero if mass is too high.
       if (ma0 &gt;= m_max) { geff = 0.0; }
       // Expressions only valid for gaee2 &lt; 35.18 but limits should become stronger for gaee2 &gt; 35.18 (but perhaps not gaee2 &gt;&gt; 35.18).
       // Conservative approach: Constrain gaee2 &gt; 35.18 at the level of gaee2 = 35.18.
       if (gaee2 &gt; 35.18) { gaee2 = 35.18; }

       result = -0.421824 - 0.0948659*(-4.675 + sqrt(21.8556 + 21.0824*geff)) - 0.00533169*gaee2 - 0.0386834*(-1.23 - 0.137991*pow(gaee2,0.75) + sqrt(1.5129 + gaee2)) + 7.3306*Y;
     }

     // Capability function to calculate the likelihood for the R-parameter.
     void calc_lnL_RParameter(double &amp;result)
     {
       using namespace Pipes::calc_lnL_RParameter;
       double Rtheo = *Dep::RParameter;

       // Observed R values from astro-ph/0403600.
       const double Robs = 1.39;
       const double RobsErr = 0.03;
       // Value for He-abundance Y from 1503.08146: &lt;Y&gt; = 0.2515(17).
       const double YobsErrContrib = 7.3306*0.0017;

       result = -0.5*gsl_pow_2(Rtheo - Robs)/(RobsErr*RobsErr+YobsErrContrib*YobsErrContrib);
     }

    //      White Dwarf cooling hints      //

    // White Dwarf interpolator class
    class WDInterpolator
    {
      public:
        // Constructor
        WDInterpolator(const std::vector&lt;double&gt; x, const std::vector&lt;double&gt; y, std::string correction_file, InterpolationOptions1D type = InterpolationOptions1D::linear)
        {
          period_change = AxionInterpolator(x, y, type);
          correction = AxionInterpolator(correction_file, type);
        }

        // Evaluation function
        double evaluate(double mrel, double x2)
        {
          double res = x2;
          // For higher masses, reduce the effective coupling accordingly:
          if (mrel &gt; 100.0)
          {
            res *= 15.0 * exp(-mrel) * pow(mrel,2.5)/(M_SQRT2 * pow(pi,3.5));
          } else if (mrel &gt; 0.01) {
            res *= pow(10,correction.interpolate(log10(mrel)));
          }
          // We only have predictions up to x2 = max value. Limits should get stronger for x2 &gt; max value, so
          // it is conservative to use the prediction for x2 = max value for x2 &gt; max value.
          res = std::min(res, period_change.upper());
          res = period_change.interpolate(res);
          return res;
        }

      private:
        AxionInterpolator period_change;
        AxionInterpolator correction;
    };

    // Capability function to compute the cooling likelihood of G117-B15A (1205.6180; observations from Kepler+ (2011)).
    void calc_lnL_WDVar_G117B15A(double &amp;result)
    {
      using namespace Pipes::calc_lnL_WDVar_G117B15A;
      // Rescale coupling to be used in their model prediction.
      double x2 = (1.0e+14 * std::fabs(*Param[&quot;gaee&quot;]))/2.8;
      x2 = x2*x2;

      // Values for the model prediction provided by the authors.
      const std::vector&lt;double&gt; x2vals  = {0.0, 1.0, 6.25, 25.0, 56.25, 100.0, 156.25, 225.0, 306.25, 404.0, 506.25, 625.0, 756.25, 900.0};
      const std::vector&lt;double&gt; dPidts  = {1.235687, 1.244741, 1.299579, 1.470017, 1.796766, 2.260604, 2.795575, 3.484570, 4.232738, 5.056075, 6.113390, 7.342085, 8.344424, 9.775156};
      const double err2 = 0.09*0.09;
      const double obs = 4.19;
      const double obs_err2 = 0.73*0.73;

      static WDInterpolator dPidt (x2vals, dPidts, GAMBIT_DIR &quot;/DarkBit/data/Axions_WDCorrection_G117B15A.dat&quot;);

      // Use interpolation for the finite-mass correction.
      const double internal_temperature_keV = 1.19698;
      double mrel = 0.001 * (*Param[&quot;ma0&quot;]) / internal_temperature_keV;

      double pred = dPidt.evaluate(mrel, x2);

      result = -0.5 * gsl_pow_2(obs - pred) / (obs_err2 + err2);
    }

    // Capability function to compute the cooling likelihood of R548 (1211.3389 using T = 11630 K; observations from Mukadam+ (2012)).
    void calc_lnL_WDVar_R548(double &amp;result)
    {
      using namespace Pipes::calc_lnL_WDVar_R548;
      // Rescale coupling to be used in their model prediction.
      double x2 = (1.0E+14 * std::fabs(*Param[&quot;gaee&quot;]))/2.8;
      x2 = x2*x2;

      // Values for the model prediction provided by the authors.
      const std::vector&lt;double&gt; x2vals   = {0.0, 1.0, 6.25, 25.0, 56.25, 100.0, 156.25, 225.0, 306.25, 400.0, 506.25, 625.0, 756.25, 900.0};
      const std::vector&lt;double&gt; dPidts  = {1.075373, 1.095319, 1.123040, 1.289434, 1.497666, 1.869437, 2.300523, 2.844954, 3.379978, 4.086028, 4.847149, 5.754807, 6.714841, 7.649140};
      const double err2 = 0.09*0.09;
      const double obs = 3.3;
      const double obs_err2 = 1.1*1.1;

      static WDInterpolator dPidt (x2vals, dPidts, GAMBIT_DIR &quot;/DarkBit/data/Axions_WDCorrection_R548.dat&quot;);

      // Use interpolation for the finite-mass correction.
      const double internal_temperature_keV = 1.11447;
      double mrel = 0.001 * (*Param[&quot;ma0&quot;]) / internal_temperature_keV;

      double pred = dPidt.evaluate(mrel, x2);

      result = -0.5 * gsl_pow_2(obs - pred) / (obs_err2 + err2);
    }

    // Capability function to compute the cooling likelihood of PG1351+489 (1605.07668 &amp; 1406.6034; using observations from Redaelli+ (2011)).
    void calc_lnL_WDVar_PG1351489(double &amp;result)
    {
      using namespace Pipes::calc_lnL_WDVar_PG1351489;
      // Rescale coupling to be used in their model prediction.
      double x2 = (1.0E+14 * std::fabs(*Param[&quot;gaee&quot;]))/2.8;
      x2 = x2*x2;

      // Values for the model prediction provided by the authors.
      const std::vector&lt;double&gt; x2vals = {0.0, 4.0, 16.0, 36.0, 64.0, 100.0, 144.0, 196.0, 256.0, 324.0, 400.0};
      const std::vector&lt;double&gt; dPidts = {0.90878126, 0.96382008, 1.2022906, 1.5712931, 2.1220619, 2.8002354, 3.6172605, 4.5000560, 5.5256592, 6.5055283, 7.5341296};
      const double err2 = 0.5*0.5;
      const double obs = 2.0;
      const double obs_err2 = 0.9*0.9;

      static WDInterpolator dPidt (x2vals, dPidts, GAMBIT_DIR &quot;/DarkBit/data/Axions_WDCorrection_PG1351489.dat&quot;);

      // Use interpolation for the finite-mass correction.
      const double internal_temperature_keV = 2.64273;
      double mrel = 0.001 * (*Param[&quot;ma0&quot;]) / internal_temperature_keV;

      double pred = dPidt.evaluate(mrel, x2);

      result = -0.5 * gsl_pow_2(obs - pred) / (obs_err2 + err2);
    }

    // Capability function to compute the cooling likelihood of L192 (1605.06458  using l=1 &amp; k=2; observations from Sullivan+Chote (2015)).
    void calc_lnL_WDVar_L192 (double &amp;result)
    {
      using namespace Pipes::calc_lnL_WDVar_L192;
      // Rescale coupling to be used in their model prediction.
      double x2 = (1.0E+14 * std::fabs(*Param[&quot;gaee&quot;]))/2.8;
      x2 = x2*x2;

      // Values for the model prediction provided by the authors.
      const std::vector&lt;double&gt; x2vals = {0.0, 1.0, 4.0, 9.0, 16.0, 25.0, 36.0, 49.0, 64.0, 81.0, 100.0, 121.0, 144.0, 169.0, 196.0, 225.0, 256.0, 289.0, 324.0, 361.0, 400.0, 441.0, 484.0, 529.0, 576.0, 625.0, 676.0, 729.0, 784.0, 841.0, 900.0};
      const std::vector&lt;double&gt; dPidts = {2.41, 2.40, 2.44, 2.42, 2.50, 2.57, 2.63, 2.74, 2.83, 2.99, 3.15, 3.32, 3.52, 3.70, 3.90, 4.08, 4.42, 4.69, 4.98, 5.34, 5.62, 6.02, 6.27, 6.62, 7.04, 7.38, 7.89, 8.09, 8.65, 9.16, 9.62};
      const double err2 = 0.85*0.85;
      const double obs = 3.0;
      const double obs_err2 = 0.6*0.6;

      static WDInterpolator dPidt (x2vals, dPidts, GAMBIT_DIR &quot;/DarkBit/data/Axions_WDCorrection_L192.dat&quot;);

      // Use interpolation for the finite-mass correction.
      const double internal_temperature_keV = 1.04931;
      double mrel = 0.001 * (*Param[&quot;ma0&quot;]) / internal_temperature_keV;

      double pred = dPidt.evaluate(mrel, x2);

      result = -0.5 * gsl_pow_2(obs - pred) / (obs_err2 + err2);
    }

    //      SN 1987A limits (from axion-photon conversion in the B-field of the Milky Way or axion-photon decay)      //

    // Capability function to calculate the likelihood for SN 1987A (based on data from 25 to 100 MeV photons, interpreted
    // by Chupp et al., Phys. Rev. Lett. 62, 505 (1989). Use 10 sec of data for conversion and 223 sec for decay.
    void calc_lnL_SN1987A (double &amp;result)
    {
      using namespace Pipes::calc_lnL_SN1987A;
      double f_10s = *Dep::PhotonFluence_SN1987A_Conversion;
      double f_223s = *Dep::PhotonFluence_SN1987A_Decay;

      // Standard devations of the null observation.
      const double sigma_10s = 0.2;
      const double sigma_223s = 0.59333;

      // Conversion and decay constraints are based on the same data but never apply at the same time.
      // Pick the larger value of the ratio/stronger of the two constraints, as this will always be the relevant one.
      double ratio = std::max(f_10s/sigma_10s, f_223s/sigma_223s);

      result = -0.5*ratio*ratio;
    }

    //      SN 1987A photon fluence (from axion-photon conversion in the B-field of the Milky Way)      //

    // Capability function to calculate the photon fluence from SN 1987A as a result of axion-photon
    // conversion in the B-field of the Milky Way (based on arXiv:1410.3747).
    void calc_PhotonFluence_SN1987A_Conversion (double &amp;result)
    {
      using namespace Pipes::calc_PhotonFluence_SN1987A_Conversion;
      double m = (1.0E+10*(*Param[&quot;ma0&quot;]))/5.433430;
      double g = (1.0E+12*std::fabs(*Param[&quot;gagg&quot;]))/5.339450;

      result = 0.570589*gsl_pow_4(g);
      if (m &gt; 1.0) { result = result*pow(m, -4.021046); }
    }

    //       SN 1987A photon fluence (from axion decay into photons)      //

    // Capability function to calculate the photon fluence from SN 1987A as a result of axion decay.
    // Based on MC simulations by Marie Lecroq &amp; Sebastian Hoof (following arXiv:1702.02964).
    void calc_PhotonFluence_SN1987A_Decay (double &amp;result)
    {
      using namespace Pipes::calc_PhotonFluence_SN1987A_Decay;
      double lgg = log10(std::fabs(*Param[&quot;gagg&quot;]));
      double lgm = log10(*Param[&quot;ma0&quot;]);
      result = 0.0;

      // Initialise interpolation class with MC data from file.
      static AxionInterpolator2D fluence (GAMBIT_DIR &quot;/DarkBit/data/SN1987A_DecayFluence.dat&quot;);

      if (fluence.is_inside_box(lgm,lgg)) { result = fluence.interpolate(lgm,lgg); };
    }

    //      Spectral distortions (H.E.S.S. telescope searches)      //

    // Calculate the likelihood for H.E.S.S. data assuming conversion in the galaxy cluster magnetic field (GCMF, &quot;Conservative&quot; limits, 1311.3148).
    void calc_lnL_HESS_GCMF (double &amp;result)
    {
      using namespace Pipes::calc_lnL_HESS_GCMF;
      double m_ax = *Param[&quot;ma0&quot;];
      double gagg = gagg_conversion*std::fabs(*Param[&quot;gagg&quot;]); // gagg needs to be in eV^-1.

      // Compute the domensionless parameters Epsilon and Gamma from the axion mass and axion-photon coupling (see 1311.3148).
      const double c_epsilon = 0.071546787;
      const double c_gamma = 0.015274036*370.0/sqrt(37.0);
      double epsilon = log10(m_ax*c_epsilon) + 5.0;
      double gamma = log10(gagg*c_gamma) + 20.0;

      // Initialise the interpolation and extrapolation routies for the H.E.S.S. results.
      static HESS_Interpolator interp (GAMBIT_DIR &quot;/DarkBit/data/HESS_GCMF_Table.dat&quot;);

      result = interp.lnL(epsilon, gamma);
    }

    void calc_lnL_XENON1T_Anomaly(double &amp;result)
    {
      using namespace Pipes::calc_lnL_XENON1T_Anomaly;

      // Rescale couplings and 3H abundance to the reference values used in 2006.10035 for convenience.
      double gae = std::fabs(*Param[&quot;gaee&quot;]) / 5.0e-12;
      double gagamma = std::fabs(*Param[&quot;gagg&quot;]) / 2.0e-10;
      double gaN = std::fabs(*Param[&quot;gaN&quot;]) / 1.0e-6;
      double x_3H = *Param[&quot;x_3H&quot;] / 6.2e-25;
      double bkg_scale = 1.0 + *Param[&quot;delta_bkg&quot;];
      double eff = 1.0 + *Param[&quot;delta_eff&quot;];

      static bool include_inverse_Primakoff = runOptions-&gt;getValueOrDef&lt;bool&gt; (true, &quot;include_inverse_Primakoff&quot;);

      // XENON1T 2020 data (based on 2006.10035 and using an exposure of 0.65 tonne-years)
      static const Eigen::ArrayXd observed = (Eigen::ArrayXd(29) &lt;&lt;
        26., 61., 55., 47., 49.,
        47., 44., 41., 40., 37.,
        51., 41., 42., 51., 47.,
        48., 24., 43., 42., 34.,
        42., 40., 38., 53., 41.,
        57., 39., 46., 35.).finished();

      static const Eigen::ArrayXd bkg_tritium = (Eigen::ArrayXd(29) &lt;&lt;
        4.54543769e+00, 8.60509728e+00, 8.94256482e+00, 8.61684767e+00, 8.02464466e+00,
        7.29168481e+00, 6.48068011e+00, 5.65037508e+00, 4.81438779e+00, 3.97835836e+00,
        3.17827210e+00, 2.43987288e+00, 1.78022901e+00, 1.21426641e+00, 7.54437371e-01,
        4.13276721e-01, 1.95253807e-01, 7.58276424e-02, 2.37741495e-02, 1.17262241e-02,
        4.76851304e-03, 1.65434695e-04, 5.42752619e-05, 5.22947241e-05, 5.03141863e-05,
        4.83336485e-05, 4.63531107e-05, 4.43725729e-05, 4.23920351e-05).finished();

      static const Eigen::ArrayXd bkg_other = (Eigen::ArrayXd(29) &lt;&lt;
        22.07404375, 39.45186703, 41.83417331, 42.46968003, 42.78761694, 42.96532578,
        43.13847573, 43.56505579, 44.1162301 , 44.04330642, 43.60594679, 43.40248223,
        43.45031774, 43.49263918, 43.57084528, 43.66270961, 43.75990478, 43.85453193,
        43.95159076, 44.04782058, 44.14510208, 44.24450247, 44.3406822 , 44.43638726,
        44.5331988, 44.62865958, 44.72654689, 44.82382807, 44.91842725).finished();

      static const Eigen::ArrayXd signal_ref_ABC = (Eigen::ArrayXd(29) &lt;&lt;
        7.46283683e+01, 9.11300502e+01, 4.91874199e+01, 3.53433982e+01, 3.97196350e+01,
        3.57128137e+01, 2.27540737e+01, 1.19536450e+01, 6.29278747e+00, 3.30948412e+00,
        1.61495065e+00, 6.21479171e-01, 1.55434142e-01, 2.13046184e-02, 1.63362970e-03,
        5.94631877e-05, 6.22346656e-07, 0, 0, 0,
        0, 0, 0, 0, 0,
        0, 0, 0, 0).finished();

      static const Eigen::ArrayXd signal_ref_primakoff = (Eigen::ArrayXd(29) &lt;&lt;
        8.52269995e+00, 2.00539997e+01, 1.92433543e+01, 2.22113223e+01, 2.89487211e+01,
        2.48618807e+01, 1.56554086e+01, 8.76011034e+00, 4.77088790e+00, 2.59966792e+00,
        1.43054774e+00, 7.84191139e-01, 4.15162321e-01, 2.10029374e-01, 1.02847245e-01,
        5.27333566e-02, 2.93001979e-02, 1.70759274e-02, 1.08781046e-02, 7.76743790e-03,
        6.24916022e-03, 5.51837192e-03, 5.15693524e-03, 4.97968515e-03, 4.88717867e-03,
        4.84242242e-03, 4.82038071e-03, 2.38442778e-03, 0).finished();

      static const Eigen::ArrayXd signal_ref_fe57 = (Eigen::ArrayXd(29) &lt;&lt;
        4.64697658e-22, 1.14417236e-18, 1.48421451e-15, 1.01555196e-12, 3.67061998e-10,
        7.02067458e-08, 7.12116995e-06, 3.84028003e-04, 1.10431167e-02, 1.69885040e-01,
        1.40292258e+00, 6.23942228e+00, 1.49856121e+01, 1.94718769e+01, 1.36959639e+01,
        5.21070939e+00, 1.07020697e+00, 1.18324090e-01, 7.01902932e-03, 2.22639151e-04,
        3.76396817e-06, 3.38186408e-08, 1.61083936e-10, 4.05908328e-13, 5.40175385e-16,
        3.79105023e-19, 1.40152641e-22, 2.72678128e-26, 2.78978087e-30).finished();

      static const Eigen::ArrayXd signal_ref_ABC_inv_p = (Eigen::ArrayXd(29) &lt;&lt;
        6.90095435e+00, 1.39022260e+01, 1.15151093e+01, 7.97641672e+00, 5.52073353e+00,
        4.15542096e+00, 2.85016524e+00, 1.77391643e+00, 1.07580666e+00, 6.28453363e-01,
        3.26090878e-01, 1.31638303e-01, 3.77207469e-02, 7.52278937e-03, 1.06834615e-03,
        1.12228106e-04, 9.07094259e-06, 5.85004243e-07, 3.10665723e-08, 1.39581067e-09,
        5.42752207e-11, 1.86190569e-12, 5.72719620e-14, 1.60150437e-15, 4.11906863e-17,
        9.84235043e-19, 2.20372014e-20, 4.65786516e-22, 9.35349973e-24).finished();

      static const Eigen::ArrayXd signal_ref_primakoff_inv_p = (Eigen::ArrayXd(29) &lt;&lt;
        8.80070525e-01, 3.29923191e+00, 4.56900949e+00, 4.56444853e+00, 3.82216381e+00,
        2.86024934e+00, 1.98175269e+00, 1.29748018e+00, 8.13307028e-01, 4.92544613e-01,
        2.90070188e-01, 1.66927792e-01, 9.42159402e-02, 5.23046562e-02, 2.86265445e-02,
        1.54743414e-02, 8.27421198e-03, 4.38184245e-03, 2.30069622e-03, 1.19872791e-03,
        6.20254770e-04, 3.18925270e-04, 1.63051423e-04, 8.29261227e-05, 4.19736901e-05,
        2.11518187e-05, 1.06157318e-05, 5.30780091e-06, 2.64457315e-06).finished();

      static const Eigen::ArrayXd signal_ref_fe57_inv_p = (Eigen::ArrayXd(29) &lt;&lt;
        2.68534579e-23, 1.02403478e-19, 1.64401745e-16, 1.34346994e-13, 5.65333857e-11,
        1.23357889e-08, 1.40118942e-06, 8.30825834e-05, 2.57975431e-03, 4.20954642e-02,
        3.62322333e-01, 1.65087221e+00, 3.99391811e+00, 5.14060546e+00, 3.52226638e+00,
        1.28362583e+00, 2.48258237e-01, 2.54009765e-02, 1.36995132e-03, 3.88033329e-05,
        5.75235843e-07, 4.44951177e-09, 1.79118821e-11, 3.74451860e-14, 4.05797696e-17,
        2.27644923e-20, 6.60289329e-24, 9.89294778e-28, 7.65058090e-32).finished();

      static const double asimov = (observed * observed.log() - observed).sum();

      const Eigen::ArrayXd bkg = x_3H * bkg_tritium + bkg_other;
      Eigen::ArrayXd signal = gae * gae * (
                              signal_ref_ABC * gae * gae +
                              signal_ref_primakoff * gagamma * gagamma +
                              signal_ref_fe57 * gaN * gaN);

      if (include_inverse_Primakoff)
      {
        signal = signal + gagamma * gagamma * (
                 signal_ref_ABC_inv_p * gae * gae +
                 signal_ref_primakoff_inv_p * gagamma * gagamma +
                 signal_ref_fe57_inv_p * gaN * gaN);
      }

      const Eigen::ArrayXd expected = eff * (bkg_scale * bkg + signal);

      result = (observed * expected.log() - expected).sum() - asimov;
    }

    struct dRdE_params { double m; double sigma; };

    double dRdE (double E, void * params)
    {
      struct dRdE_params * par = (struct dRdE_params *)params;
      // Efficiency of the Xenon1T experiment from arXiv:2006.09721
      // Columns: Energy [keV] | Efficiency [dimensionless]
      static AxionInterpolator efficiency (GAMBIT_DIR &quot;/DarkBit/data/XENON1T/efficiency.txt&quot;, InterpolationOptions1D::cspline);
      return std::exp(-0.5*pow((E - par-&gt;m)/par-&gt;sigma,2))*efficiency.interpolate(E);
    }

    void calc_lnL_XENON1T_DM_Anomaly(double &amp;result)
    {
      using namespace Pipes::calc_lnL_XENON1T_DM_Anomaly;

      result = 0;

      // Rescale couplings and 3H abundance to the reference values used in 2006.10035 for convenience.
      double gae = std::fabs(*Param[&quot;gaee&quot;]);
      double ma = *Param[&quot;ma0&quot;] / 1.0e3;
      double x_3H = *Param[&quot;x_3H&quot;] / 6.2e-25;
      double bkg_scale = 1.0 + *Param[&quot;delta_bkg&quot;];
      double rel_eff = 1.0 + *Param[&quot;delta_eff&quot;];
      double dm_fraction = *Param[&quot;eta&quot;];
      LocalMaxwellianHalo LocalHaloParameters = *Dep::LocalHalo;
      double rho0 = LocalHaloParameters.rho0;

      // XENON1T 2020 data (based on 2006.10035 and using an exposure of 0.65 tonne-years)
      static const Eigen::ArrayXd observed = (Eigen::ArrayXd(29) &lt;&lt;
        26., 61., 55., 47., 49.,
        47., 44., 41., 40., 37.,
        51., 41., 42., 51., 47.,
        48., 24., 43., 42., 34.,
        42., 40., 38., 53., 41.,
        57., 39., 46., 35.).finished();

      static const Eigen::ArrayXd bkg_tritium = (Eigen::ArrayXd(29) &lt;&lt;
        4.54543769e+00, 8.60509728e+00, 8.94256482e+00, 8.61684767e+00, 8.02464466e+00,
        7.29168481e+00, 6.48068011e+00, 5.65037508e+00, 4.81438779e+00, 3.97835836e+00,
        3.17827210e+00, 2.43987288e+00, 1.78022901e+00, 1.21426641e+00, 7.54437371e-01,
        4.13276721e-01, 1.95253807e-01, 7.58276424e-02, 2.37741495e-02, 1.17262241e-02,
        4.76851304e-03, 1.65434695e-04, 5.42752619e-05, 5.22947241e-05, 5.03141863e-05,
        4.83336485e-05, 4.63531107e-05, 4.43725729e-05, 4.23920351e-05).finished();

      static const Eigen::ArrayXd bkg_other = (Eigen::ArrayXd(29) &lt;&lt;
        22.07404375, 39.45186703, 41.83417331, 42.46968003, 42.78761694,
        42.96532578, 43.13847573, 43.56505579, 44.1162301 , 44.04330642,
        43.60594679, 43.40248223, 43.45031774, 43.49263918, 43.57084528,
        43.66270961, 43.75990478, 43.85453193, 43.95159076, 44.04782058,
        44.14510208, 44.24450247, 44.3406822 , 44.43638726, 44.5331988 ,
        44.62865958, 44.72654689, 44.82382807, 44.91842725).finished();

      // Photoelectric cross section for Xe from https://dx.doi.org/10.18434/T48G6X
      // Columns: Photon energy [MeV] | Photoelectric absorption [10^-28 m^2/atom]
      static AxionInterpolator sigma_pe (GAMBIT_DIR &quot;/DarkBit/data/XENON1T/photoelectric.txt&quot;);

      gsl_integration_workspace * w = gsl_integration_workspace_alloc(1000);
      if ( (ma &gt;= 1.0) &amp;&amp; (ma &lt;= 30.0) )
      {
        // Energy resolution from 2003.03825
        double energy_resolution = 0.15 + 31.71/sqrt(ma);
        double sigma = ma * energy_resolution / 100.0;
        const double exposure = 0.647309514*1000.0*365.0;
        const double photoel_eff_conversion = 1.5e19/131.0;
        double amplitude = dm_fraction * (rho0/0.3) * exposure * gae*gae * ma * photoel_eff_conversion*sigma_pe.interpolate(ma/1000.0);
        gsl_function f;
        struct dRdE_params params = {ma, sigma};
        f.function = &amp;dRdE;
        f.params = &amp;params;
        double dRdE_result, error;
        std::vector&lt;double&gt; signal_vec;
        for (int i = 0; i &lt; 29; i++)
        {
          gsl_integration_qags (&amp;f, 1.+i, 2.+i, 0, 1e-7, 1000, w, &amp;dRdE_result, &amp;error);
          double s = amplitude * 1/sqrt(2*pi)/sigma * dRdE_result;
          signal_vec.push_back(s);
        }
        gsl_integration_workspace_free (w);

        static const double asimov = (observed * observed.log() - observed).sum();

        const Eigen::ArrayXd bkg = x_3H * bkg_tritium + bkg_other;
        const Eigen::ArrayXd signal = Eigen::ArrayXd::Map(signal_vec.data(), signal_vec.size());
        const Eigen::ArrayXd expected = rel_eff * (bkg_scale * bkg + signal);

        result = (observed * expected.log() - expected).sum() - asimov;
      }
    }

    void calc_lnL_XENON1T_Anomaly_NuisanceParameters(double &amp;result)
    {
      using namespace Pipes::calc_lnL_XENON1T_Anomaly_NuisanceParameters;

      result = -0.5 * ( gsl_pow_2(*Param[&quot;delta_bkg&quot;]/0.026) + gsl_pow_2(*Param[&quot;delta_eff&quot;]/0.030) );
    }

  }  // namespace DarkBit
}  // namespace Gambit
</code></pre><hr><p>Updated on 2022-08-01 at 17:02:35 +0000</p><div class=edit-page><a href=https://github.com/RC1242RC/gambit_gh_pages/blob/master/content/en/documentation/code/gambit_sphinx/Files/Axions_8cpp.md><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828.0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>Edit this page on GitHub</a></div></main></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Powered by <a class=text-muted href=https://www.netlify.com/>Netlify</a>, <a class=text-muted href=https://gohugo.io/>Hugo</a>, and <a class=text-muted href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline><li class=list-inline-item><a href=/license/>License</a></li></ul></div></div></div></footer><script src=/js/bootstrap.min.54bf0932b8a36d0e152b1635b099a6ef1394d35327e2437550a075c9c8ed1bd8aed5847c21b36fc02ed24014c031d9ca24017b0c78b1639d7e2fa8329898b842.js integrity="sha512-VL8JMrijbQ4VKxY1sJmm7xOU01Mn4kN1UKB1ycjtG9iu1YR8IbNvwC7SQBTAMdnKJAF7DHixY51+L6gymJi4Qg==" crossorigin=anonymous defer></script>
<script src=/js/highlight.min.5b48bc253dc75aeea5fb366ecf700f4925e2b6eb1a1466f2124b722d68148d67bc0a9365d2b8ad9c585161b46372d23b08509a16f1fd518542b894756d4752d0.js integrity="sha512-W0i8JT3HWu6l+zZuz3APSSXitusaFGbyEktyLWgUjWe8CpNl0ritnFhRYbRjctI7CFCaFvH9UYVCuJR1bUdS0A==" crossorigin=anonymous defer></script>
<script src=/main.min.40265e9a032aeba5eaf67baac3cbbc22667a7533215d326eeb3e9f4d5e4be40f9ff4dcd22949db73ae527ca26a19d7998091a8973c82af760b2c0daa335190ed.js integrity="sha512-QCZemgMq66Xq9nuqw8u8ImZ6dTMhXTJu6z6fTV5L5A+f9NzSKUnbc65SfKJqGdeZgJGolzyCr3YLLA2qM1GQ7Q==" crossorigin=anonymous defer></script>
<script src=https://rc1242rc.github.io/index.min.8de8ea9ff8c668ecf31dbf247b94193c399781a13d3aec3324d2fb783797867753dc1c4a2bfbe668bc6f3d6dc508842b1ae16a71c1bf62d0434771ba31cc559b.js integrity="sha512-jejqn/jGaOzzHb8ke5QZPDmXgaE9OuwzJNL7eDeXhndT3BxKK/vmaLxvPW3FCIQrGuFqccG/YtBDR3G6McxVmw==" crossorigin=anonymous defer></script></body></html>