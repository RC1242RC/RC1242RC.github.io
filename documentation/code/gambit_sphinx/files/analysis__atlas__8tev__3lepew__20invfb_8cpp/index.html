<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=https://rc1242rc.github.io/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://rc1242rc.github.io/fonts/vendor/jost/jost-v4-latin-500.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://rc1242rc.github.io/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><script>(()=>{var e=localStorage.getItem("theme");e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><link rel=stylesheet href=https://rc1242rc.github.io/main.1fa2debdf0a1b20e7268d11906902449af896197928a5bdae9dca95b629cdd73746db3d8c6afacb7320d9deb149a318c764669d08a1ddfd34a657ab2aeab866a.css integrity="sha512-H6LevfChsg5yaNEZBpAkSa+JYZeSilva6dypW2Kc3XN0bbPYxq+stzINnesUmjGMdkZp0Iod39NKZXqyrquGag==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>file analyses/Analysis_ATLAS_8TeV_3LEPEW_20invfb.cpp - GAMBIT</title><meta name=description content="[No description available]"><link rel=canonical href=https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/analysis__atlas__8tev__3lepew__20invfb_8cpp/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="file analyses/Analysis_ATLAS_8TeV_3LEPEW_20invfb.cpp"><meta property="og:description" content="[No description available]"><meta property="og:url" content="https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/analysis__atlas__8tev__3lepew__20invfb_8cpp/"><meta property="og:site_name" content="GAMBIT"><meta property="og:image" content="https://rc1242rc.github.io/gambit_logo.png"><meta property="og:image:alt" content="GAMBIT"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content><meta name=twitter:creator content><meta name=twitter:title content="file analyses/Analysis_ATLAS_8TeV_3LEPEW_20invfb.cpp"><meta name=twitter:description content="[No description available]"><meta name=twitter:image content="https://rc1242rc.github.io/gambit_logo.png"><meta name=twitter:image:alt content="file analyses/Analysis_ATLAS_8TeV_3LEPEW_20invfb.cpp"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://rc1242rc.github.io/#/schema/organization/1","name":"Doks","url":"https://rc1242rc.github.io/","sameAs":["https://github.com/GambitBSM"],"logo":{"@type":"ImageObject","@id":"https://rc1242rc.github.io/#/schema/image/1","url":"https://rc1242rc.github.io/logo-doks.png","width":450,"height":416,"caption":"Doks"},"image":{"@id":"https://rc1242rc.github.io/#/schema/image/1"}},{"@type":"WebSite","@id":"https://rc1242rc.github.io/#/schema/website/1","url":"https://rc1242rc.github.io/","name":"GAMBIT","description":"Documentation for the Global And Modular BSM Inference Tool","publisher":{"@id":"https://rc1242rc.github.io/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/analysis__atlas__8tev__3lepew__20invfb_8cpp/","url":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/analysis__atlas__8tev__3lepew__20invfb_8cpp/","name":"file analyses\/Analysis_ATLAS_8TeV_3LEPEW_20invfb.cpp","description":"[No description available]","isPartOf":{"@id":"https://rc1242rc.github.io/#/schema/website/1"},"about":{"@id":"https://rc1242rc.github.io/#/schema/organization/1"},"datePublished":"0001-01-01T00:00:00CET","dateModified":"0001-01-01T00:00:00CET","breadcrumb":{"@id":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/analysis__atlas__8tev__3lepew__20invfb_8cpp/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/analysis__atlas__8tev__3lepew__20invfb_8cpp/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/analysis__atlas__8tev__3lepew__20invfb_8cpp/"]}]},{"@type":"BreadcrumbList","@id":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/analysis__atlas__8tev__3lepew__20invfb_8cpp/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/","url":"https://rc1242rc.github.io/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/documentation/","url":"https://rc1242rc.github.io/documentation/","name":"Documentation"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/documentation/code/","url":"https://rc1242rc.github.io/documentation/code/","name":"Code"}},{"@type":"ListItem","position":4,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/","url":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/","name":"Gambit Sphinx"}},{"@type":"ListItem","position":5,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/","url":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/","name":"Files"}},{"@type":"ListItem","position":6,"item":{"@id":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/analysis__atlas__8tev__3lepew__20invfb_8cpp/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/analysis__atlas__8tev__3lepew__20invfb_8cpp/#/schema/image/2","url":"https://rc1242rc.github.io/gambit_logo.png","contentUrl":"https://rc1242rc.github.io/gambit_logo.png","caption":"file analyses\/Analysis_ATLAS_8TeV_3LEPEW_20invfb.cpp"}]}]}</script><meta name=theme-color content="#fff"><link rel=icon href=https://rc1242rc.github.io/favicon.ico sizes=any><link rel=icon type=image/svg+xml href=https://rc1242rc.github.io/favicon.svg><link rel=apple-touch-icon sizes=180x180 href=https://rc1242rc.github.io/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://rc1242rc.github.io/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://rc1242rc.github.io/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://rc1242rc.github.io/site.webmanifest></head><body class="documentation single light"><div class=sticky-top><div class=header-bar></div><header class="navbar navbar-expand-md navbar-light doks-navbar"><nav class="container-xxl flex-wrap flex-md-nowrap" aria-label="Main navigation"><a class="navbar-brand p-0 me-auto" href=https://rc1242rc.github.io/ aria-label=GAMBIT><img class=logo-light src=https://rc1242rc.github.io//images/gambit_logo.png width=50px>
<img class="logo-dark d-none" src=https://rc1242rc.github.io//images/gambit_logo.png width=50px>
GAMBIT</a>
<button class="btn btn-menu order-2 d-block d-lg-none" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasDoks aria-controls=offcanvasDoks aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><div class="offcanvas offcanvas-end border-0 py-lg-1" tabindex=-1 id=offcanvasDoks data-bs-backdrop=true aria-labelledby=offcanvasDoksLabel><div class="header-bar d-lg-none"></div><div class="offcanvas-header d-lg-none"><h2 class="h5 offcanvas-title ps-2" id=offcanvasDoksLabel><a class=text-dark href=/>GAMBIT</a></h2><button type=button class="btn-close text-reset me-2" data-bs-dismiss=offcanvas aria-label="Close main menu"></button></div><div class="offcanvas-body p-4 p-lg-0"><ul class="nav flex-column flex-lg-row align-items-lg-center mt-2 mt-lg-0 ms-lg-2 me-lg-auto"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Documentation
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/documentation/installation/introduction/>Installation</a></li><li><a class=dropdown-item href=/documentation/examples/colliderbit>Examples</a></li><li><a class=dropdown-item href=/documentation/help/faqs/>Help</a></li><li><a class=dropdown-item href=/documentation/code/index_classes>Code Reference</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Community
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/community/publications/>Publications</a></li><li><a class=dropdown-item href=/community/talks/>Talks</a></li><li><a class=dropdown-item href=/community/members/>Members</a></li><li><a class=dropdown-item href=/community/code_of_conduct/>Code of Conduct</a></li><li><a class=dropdown-item href=/community/contact/>Contact</a></li></ul></li></ul><hr class="text-black-50 my-4 d-lg-none"><form class="doks-search position-relative flex-grow-1 ms-lg-auto me-lg-2"><input id=search class="form-control is-search" type=search placeholder="Search site..." aria-label="Search site..." autocomplete=off><div id=suggestions class="shadow bg-white rounded d-none"></div></form><hr class="text-black-50 my-4 d-lg-none"><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=https://github.com/GambitBSM><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><small class="ms-2 d-lg-none">GitHub</small></a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn btn-doks-light dropdown-toggle" id=doks-versions data-bs-toggle=dropdown aria-expanded=false data-bs-display=static aria-label="Toggle version menu">
<span class=d-none>Doks</span>
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=doks-versions></ul></div></div></div></nav></header></div><div class="wrap container-xxl" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class=docs-links aria-label="Main navigation"><ul class="list-unstyled collapsible-sidebar"><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-installation aria-expanded=false>
Installation</button><div class=collapse id=section-installation><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/installation/introduction/>Getting Started</a></li><li><a class="docs-link rounded" href=/documentation/installation/docker_usage/>Docker Usage</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_linux/>Installation for Linux</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_windows/>Installation for Windows</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_macos/>Installation for macOS</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-examples aria-expanded=false>
Examples</button><div class=collapse id=section-examples><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/examples/colliderbit/>ColliderBit</a></li><li><a class="docs-link rounded" href=/documentation/examples/anotherbit/>AnotherBit</a></li><li><a class="docs-link rounded" href=/documentation/examples/anotherbit2/>AnotherBit2</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-help aria-expanded=false>
Help</button><div class=collapse id=section-help><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/help/faqs/>FAQs</a></li><li><a class="docs-link rounded" href=/documentation/help/compiler_matrix/>Compiler Matrix</a></li><li><a class="docs-link rounded" href=/documentation/help/known_issues/>Known Issues</a></li><li><a class="docs-link rounded" href=/documentation/help/configuration_examples/>Configuration Examples</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-code aria-expanded=false>
Code Reference</button><div class=collapse id=section-code><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/code/darkbit_development/index_classes/>Classes</a></li><li><a class="docs-link rounded" href=/documentation/code/darkbit_development/index_files/>Files</a></li><li><a class="docs-link rounded" href=/documentation/code/darkbit_development/index_pages/>Pages</a></li><li><a class="docs-link rounded" href=/documentation/code/darkbit_development/index_namespaces/>Namespaces</a></li></ul></div></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=d-xl-none><button class="btn btn-outline-primary btn-sm doks-toc-toggle collapsed" type=button data-bs-toggle=collapse data-bs-target=#onThisPage aria-controls=doks-docs-nav aria-expanded=false aria-label="Toggle On this page navigation">
<span>On this page</span>
<span><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"/><polyline points="7 6 12 11 17 6"/></svg><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"/><polyline points="17 18 12 13 7 18"/></svg></span></button><div class=collapse id=onThisPage><div class="card card-body mt-3 py-1"><div class=page-links><nav id=TableOfContents><ul><li><ul><li><a href=#namespaces>Namespaces</a></li><li><a href=#classes>Classes</a></li><li><a href=#source-code>Source code</a></li></ul></li></ul></nav></div></div></div></div><div class="page-links d-none d-xl-block"><h3>On this page</h3><nav id=TableOfContents><ul><li><ul><li><a href=#namespaces>Namespaces</a></li><li><a href=#classes>Classes</a></li><li><a href=#source-code>Source code</a></li></ul></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9 mx-xl-auto"><h1>file analyses/Analysis_ATLAS_8TeV_3LEPEW_20invfb.cpp</h1><p class=lead></p><p>[No description available]</p><h2 id=namespaces>Namespaces <a href=#namespaces class=anchor aria-hidden=true>#</a></h2><table><thead><tr><th>Name</th></tr></thead><tbody><tr><td><strong><a href=/documentation/code/gambit_sphinxnamespaces/namespacegambit/>Gambit</a></strong><br>TODO: see if we can use this one:</td></tr><tr><td><strong><a href=/documentation/code/gambit_sphinxnamespaces/namespacegambit_1_1colliderbit/>Gambit::ColliderBit</a></strong></td></tr></tbody></table><h2 id=classes>Classes <a href=#classes class=anchor aria-hidden=true>#</a></h2><table><thead><tr><th></th><th>Name</th></tr></thead><tbody><tr><td>class</td><td><strong><a href=/documentation/code/gambit_sphinxclasses/classgambit_1_1colliderbit_1_1analysis__atlas__8tev__3lepew__20invfb/>Gambit::ColliderBit::Analysis_ATLAS_8TeV_3LEPEW_20invfb</a></strong></td></tr></tbody></table><h2 id=source-code>Source code <a href=#source-code class=anchor aria-hidden=true>#</a></h2><pre><code>#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;memory&gt;
#include &lt;iomanip&gt;

#include &quot;gambit/ColliderBit/analyses/Analysis.hpp&quot;
#include &quot;gambit/ColliderBit/ATLASEfficiencies.hpp&quot;
#include &quot;gambit/ColliderBit/mt2_bisect.h&quot;

/* The ATLAS 3 lepton EW analysis (20fb^-1)

   based on: arXiv: 1402.7029

   Code by Martin White

   Known features: Signal leptons in the paper have certain isolation plus ID cuts (these are ignored here by default)

   a) Should probably try and reproduce the ATLAS lepton ID. For now I could multiply all yields by 0.85^3, assuming that lepton ID efficiency is roughly 85%. In fact numbers look ok without this.

   b) tau effiiency was taken to be DELPHES default (40%)

   c) I don't sign the tau for SR1tau (it should have opposite sign to the two leptons). This is because the sign is assigned randomly in DELPHES I think). The cutflow agrees pretty well without this.

*/

namespace Gambit {
  namespace ColliderBit {

    using namespace std;

    class Analysis_ATLAS_8TeV_3LEPEW_20invfb : public Analysis {
    private:

      // Numbers passing cuts
      double _num_SR0tau_a_bin_1, _num_SR0tau_a_bin_2, _num_SR0tau_a_bin_3, _num_SR0tau_a_bin_4;
      double _num_SR0tau_a_bin_5, _num_SR0tau_a_bin_6, _num_SR0tau_a_bin_7, _num_SR0tau_a_bin_8;
      double _num_SR0tau_a_bin_9, _num_SR0tau_a_bin_10, _num_SR0tau_a_bin_11, _num_SR0tau_a_bin_12;
      double _num_SR0tau_a_bin_13, _num_SR0tau_a_bin_14, _num_SR0tau_a_bin_15, _num_SR0tau_a_bin_16;
      double _num_SR0tau_a_bin_17, _num_SR0tau_a_bin_18, _num_SR0tau_a_bin_19, _num_SR0tau_a_bin_20;
      double _num_SR0tau_b;
      double _num_SR1tau;
      double _num_SR2tau_a;
      double _num_SR2tau_b;
      vector&lt;int&gt; cutFlowVector;
      vector&lt;string&gt; cutFlowVector_str;
      const static int NCUTS=55;

    public:

      // Required detector sim
      static constexpr const char* detector = &quot;ATLAS&quot;;

      Analysis_ATLAS_8TeV_3LEPEW_20invfb() {

        set_analysis_name(&quot;ATLAS_8TeV_3LEPEW_20invfb&quot;);
        set_luminosity(20.3);

        _num_SR0tau_a_bin_1=0;
        _num_SR0tau_a_bin_2=0;
        _num_SR0tau_a_bin_3=0;
        _num_SR0tau_a_bin_4=0;
        _num_SR0tau_a_bin_5=0;
        _num_SR0tau_a_bin_6=0;
        _num_SR0tau_a_bin_7=0;
        _num_SR0tau_a_bin_8=0;
        _num_SR0tau_a_bin_9=0;
        _num_SR0tau_a_bin_10=0;
        _num_SR0tau_a_bin_11=0;
        _num_SR0tau_a_bin_12=0;
        _num_SR0tau_a_bin_13=0;
        _num_SR0tau_a_bin_14=0;
        _num_SR0tau_a_bin_15=0;
        _num_SR0tau_a_bin_16=0;
        _num_SR0tau_a_bin_17=0;
        _num_SR0tau_a_bin_18=0;
        _num_SR0tau_a_bin_19=0;
        _num_SR0tau_a_bin_20=0;
        _num_SR0tau_b=0;
        _num_SR1tau=0;
        _num_SR2tau_a=0;
        _num_SR2tau_b=0;

        for(int i=0;i&lt;NCUTS;i++){
          cutFlowVector.push_back(0);
          cutFlowVector_str.push_back(&quot;&quot;);
        }

      }

      void EleEleOverlapRemoval(vector&lt;const HEPUtils::Particle*&gt; &amp;vec1, vector&lt;const HEPUtils::Particle*&gt; &amp;vec2, double DeltaRMax) {
        //Routine to do electron-electron overlap check
        //Discard lowest energy electron if two are found overlapping
        vector&lt;const HEPUtils::Particle*&gt; Survivors;

        for(unsigned int it1 = 0; it1 &lt; vec1.size(); it1++) {
          bool overlap = false;
          HEPUtils::P4 lep1mom=vec1.at(it1)-&gt;mom();
          for(unsigned int it2 = 0; it2 &lt; vec2.size(); it2++) {
            if(it1==it2)continue;
            HEPUtils::P4 lep2mom=vec2.at(it2)-&gt;mom();
            double dR;

            dR=lep1mom.deltaR_eta(lep2mom);

            if(fabs(dR) &lt;= DeltaRMax &amp;&amp; lep1mom.E()&lt;lep2mom.E()) overlap=true;
          }
          if(overlap) continue;
          Survivors.push_back(vec1.at(it1));
        }
        vec1=Survivors;

        return;
      }


      void LepLepOverlapRemoval(vector&lt;const HEPUtils::Particle*&gt; &amp;vec1, vector&lt;const HEPUtils::Particle*&gt; &amp;vec2, double DeltaRMax) {

        vector&lt;const HEPUtils::Particle*&gt; Survivors;

        for(unsigned int it1 = 0; it1 &lt; vec1.size(); it1++) {
          bool overlap = false;
          HEPUtils::P4 lep1mom=vec1.at(it1)-&gt;mom();
          for(unsigned int it2 = 0; it2 &lt; vec2.size(); it2++) {
            if(it1==it2)continue;
            HEPUtils::P4 lep2mom=vec2.at(it2)-&gt;mom();
            double dR;

            dR=lep1mom.deltaR_eta(lep2mom);

            if(fabs(dR) &lt;= DeltaRMax) overlap=true;
          }
          if(overlap) continue;
          Survivors.push_back(vec1.at(it1));
        }
        vec1=Survivors;

        return;
      }

      void JetLeptonOverlapRemoval(vector&lt;const HEPUtils::Jet*&gt; &amp;jetvec, vector&lt;const HEPUtils::Particle*&gt; &amp;lepvec, double DeltaRMax) {
        //Routine to do jet-lepton check
        //Discards jets if they are within DeltaRMax of a lepton

        vector&lt;const HEPUtils::Jet*&gt; Survivors;

        for(unsigned int itjet = 0; itjet &lt; jetvec.size(); itjet++) {
          bool overlap = false;
          HEPUtils::P4 jetmom=jetvec.at(itjet)-&gt;mom();
          for(unsigned int itlep = 0; itlep &lt; lepvec.size(); itlep++) {
            HEPUtils::P4 lepmom=lepvec.at(itlep)-&gt;mom();
            double dR;

            dR=jetmom.deltaR_eta(lepmom);

            if(fabs(dR) &lt;= DeltaRMax) overlap=true;
          }
          if(overlap) continue;
          Survivors.push_back(jetvec.at(itjet));
        }
        jetvec=Survivors;

        return;
      }

      void LeptonJetOverlapRemoval(vector&lt;const HEPUtils::Particle*&gt; &amp;lepvec, vector&lt;const HEPUtils::Jet*&gt; &amp;jetvec, double DeltaRMax) {
        //Routine to do lepton-jet check
        //Discards leptons if they are within DeltaRMax of a jet

        vector&lt;const HEPUtils::Particle*&gt; Survivors;

        for(unsigned int itlep = 0; itlep &lt; lepvec.size(); itlep++) {
          bool overlap = false;
          HEPUtils::P4 lepmom=lepvec.at(itlep)-&gt;mom();
          for(unsigned int itjet= 0; itjet &lt; jetvec.size(); itjet++) {
            HEPUtils::P4 jetmom=jetvec.at(itjet)-&gt;mom();
            double dR;

            dR=jetmom.deltaR_eta(lepmom);

            if(fabs(dR) &lt;= DeltaRMax) overlap=true;
          }
          if(overlap) continue;
          Survivors.push_back(lepvec.at(itlep));
        }
        lepvec=Survivors;

        return;
      }


      void run(const HEPUtils::Event* event) {

        // Missing energy
        HEPUtils::P4 ptot = event-&gt;missingmom();
        double met = event-&gt;met();

        // Now define vector of baseline electrons
        vector&lt;const HEPUtils::Particle*&gt; signalElectrons;
        for (const HEPUtils::Particle* electron : event-&gt;electrons()) {
          if (electron-&gt;pT() &gt; 10. &amp;&amp; fabs(electron-&gt;eta()) &lt; 2.47) signalElectrons.push_back(electron);
        }

        // Apply electron efficiency
        ATLAS::applyElectronEff(signalElectrons);

        // Now define vector of baseline muons
        vector&lt;const HEPUtils::Particle*&gt; signalMuons;
        for (const HEPUtils::Particle* muon : event-&gt;muons()) {
          if (muon-&gt;pT() &gt; 10. &amp;&amp; fabs(muon-&gt;eta()) &lt; 2.4) signalMuons.push_back(muon);
        }

        // Apply muon efficiency
        ATLAS::applyMuonEff(signalMuons);

        vector&lt;const HEPUtils::Jet*&gt; signalJets;
        vector&lt;const HEPUtils::Jet*&gt; bJets;

        for (const HEPUtils::Jet* jet : event-&gt;jets()) {
          if (jet-&gt;pT() &gt; 20. &amp;&amp; fabs(jet-&gt;eta()) &lt; 2.5) signalJets.push_back(jet);
          //if(jet-&gt;btag() &amp;&amp; fabs(jet-&gt;eta()) &lt; 2.5 &amp;&amp; jet-&gt;pT() &gt; 20.) bJets.push_back(jet);
        }

        vector&lt;const HEPUtils::Particle*&gt; signalTaus;
        for (const HEPUtils::Particle* tau : event-&gt;taus()) {
          if (tau-&gt;pT() &gt; 20. &amp;&amp; fabs(tau-&gt;eta()) &lt; 2.47) signalTaus.push_back(tau);
        }
        ATLAS::applyTauEfficiencyR1(signalTaus);

        // Overlap removal

        //Note that ATLAS use |eta|&lt;10 for removing jets close to electrons
        //Then 2.8 is used for the rest of the overlap process
        //Then the signal cut is applied for signal jets
        //cout &lt;&lt; &quot;BEFORE REMOVAL nele nmuo njet &quot; &lt;&lt; baselineElectrons.size() &lt;&lt; &quot; &quot; &lt;&lt; baselineMuons.size() &lt;&lt; &quot; &quot; &lt;&lt; signalJets.size() &lt;&lt; endl;

        EleEleOverlapRemoval(signalElectrons,signalElectrons,0.1);
        JetLeptonOverlapRemoval(signalJets,signalElectrons,0.2);
        LepLepOverlapRemoval(signalTaus,signalElectrons,0.2);
        LepLepOverlapRemoval(signalTaus,signalMuons,0.2);
        LeptonJetOverlapRemoval(signalElectrons,signalJets,0.4);
        LeptonJetOverlapRemoval(signalMuons,signalJets,0.4);
        //Note have not bothered with close-by electron and muon pairs (bremsstrahlung probably not significant in signal MC)
        JetLeptonOverlapRemoval(signalJets,signalTaus,0.2);

        //cout &lt;&lt; &quot;AFTER REMOVAL nele nmuo njet &quot; &lt;&lt; signalElectrons.size() &lt;&lt; &quot; &quot; &lt;&lt; signalMuons.size() &lt;&lt; &quot; &quot; &lt;&lt; signalJets.size() &lt;&lt; endl;

        //Now apply the tight electron selection
        ATLAS::applyTightIDElectronSelection(signalElectrons);

        int numElectrons=signalElectrons.size();
        int numMuons=signalMuons.size();
        int numTaus=signalTaus.size();

        //Search for at least one SFOS pair
        //m_SFOS must be &gt; 12 GeV

        bool mSFOS12Cut=true;

        vector&lt;double&gt; massesOfSFOSPairs;
        for(int iEl1=0;iEl1&lt;numElectrons;iEl1++){
          for(int iEl2=iEl1;iEl2&lt;numElectrons;iEl2++){
            if(signalElectrons.at(iEl1)-&gt;pid()==-1*signalElectrons.at(iEl2)-&gt;pid()){
              HEPUtils::P4 elVec1=signalElectrons.at(iEl1)-&gt;mom();
              HEPUtils::P4 elVec2=signalElectrons.at(iEl2)-&gt;mom();
              double invMass=(elVec1+elVec2).m();

              if(invMass&gt;12.){
                massesOfSFOSPairs.push_back(invMass);
              }
              else {
                mSFOS12Cut=false;
              }
            }
          }
        }


        for(int iMu1=0;iMu1&lt;numMuons;iMu1++){
          for(int iMu2=iMu1;iMu2&lt;numMuons;iMu2++){
            if(signalMuons.at(iMu1)-&gt;pid()==-1*signalMuons.at(iMu2)-&gt;pid()){
              HEPUtils::P4 muVec1=signalMuons.at(iMu1)-&gt;mom();
              HEPUtils::P4 muVec2=signalMuons.at(iMu2)-&gt;mom();
              double invMass=(muVec1+muVec2).m();

              if(invMass&gt;12.){
                massesOfSFOSPairs.push_back(invMass);
              }
              else {
                mSFOS12Cut=false;
              }
            }
          }
        }

        //Make b jet container
        const std::vector&lt;double&gt; a = {0,10.};
        const std::vector&lt;double&gt; b = {0,10000.};
        const std::vector&lt;double&gt; c = {0.8};
        HEPUtils::BinnedFn2D&lt;double&gt; _eff2d(a,b,c);

        for (const HEPUtils::Jet* jet : signalJets) {
          bool hasTag=has_tag(_eff2d, jet-&gt;abseta(), jet-&gt;pT());
          if(jet-&gt;btag() &amp;&amp; hasTag)bJets.push_back(jet);
        }

        bool leptonCut=((numElectrons+numMuons)==3 &amp;&amp; massesOfSFOSPairs.size()&gt;0);

        //Leptons must be separated from each other by at least deltaR=0.3
        bool separationCut=true;
        if(leptonCut){
          //Check electrons against electrons
          for(int iEl1=0;iEl1&lt;numElectrons;iEl1++){
            for(int iEl2=iEl1;iEl2&lt;numElectrons;iEl2++){
              if(iEl1!=iEl2){
                HEPUtils::P4 elVec1=signalElectrons.at(iEl1)-&gt;mom();
                HEPUtils::P4 elVec2=signalElectrons.at(iEl2)-&gt;mom();
                double dR=elVec1.deltaR_eta(elVec2);
                if(fabs(dR)&lt;=0.3){
                  separationCut=false;
                }
              }
            }
          }

          //Check electrons against muons
          for(int iEl1=0;iEl1&lt;numElectrons;iEl1++){
            for(int iMu1=0;iMu1&lt;numMuons;iMu1++){
              HEPUtils::P4 elVec1=signalElectrons.at(iEl1)-&gt;mom();
              HEPUtils::P4 muVec1=signalMuons.at(iMu1)-&gt;mom();
              double dR=elVec1.deltaR_eta(muVec1);
              if(fabs(dR)&lt;=0.3){
                separationCut=false;
              }
            }
          }

          //Check muons against muons
          for(int iMu1=0;iMu1&lt;numMuons;iMu1++){
            for(int iMu2=iMu1;iMu2&lt;numMuons;iMu2++){
              if(iMu1!=iMu2){
                HEPUtils::P4 muVec1=signalMuons.at(iMu1)-&gt;mom();
                HEPUtils::P4 muVec2=signalMuons.at(iMu2)-&gt;mom();
                double dR=muVec1.deltaR_eta(muVec2);
                if(fabs(dR)&lt;=0.3){
                  separationCut=false;
                }
              }
            }
          }
        }


        //Lepton pT trigger cuts
        bool triggerE=false;
        bool triggerMU=false;
        bool triggerMUMU_Sym=false;
        bool triggerMUMU_ASym=false;
        bool triggerEE_Sym=false;
        bool triggerEE_ASym=false;
        bool triggerEMU=false;
        bool triggerMUE=false;

        for(const HEPUtils::Particle* ele : signalElectrons){
          if(ele-&gt;pT()&gt;25.)triggerE=true;
        }

        for(const HEPUtils::Particle* muo : signalMuons){
          if(muo-&gt;pT()&gt;25.)triggerMU=true;
        }

        int numMuonsGt14=0;
        int numMuonsGt18=0;

        for(const HEPUtils::Particle* muo : signalMuons){
          if(muo-&gt;pT()&gt;14.)numMuonsGt14++;
          if(muo-&gt;pT()&gt;18.)numMuonsGt18++;
        }

        if(numMuonsGt14&gt;=2)triggerMUMU_Sym=true;
        if(numMuons&gt;=2 &amp;&amp; numMuonsGt18&gt;=1)triggerMUMU_ASym=true;

        int numEleGt14=0;
        int numEleGt25=0;

        for(const HEPUtils::Particle* ele : signalElectrons){
          if(ele-&gt;pT()&gt;14.)numEleGt14++;
          if(ele-&gt;pT()&gt;25.)numEleGt25++;

        }

        if(numEleGt14&gt;=2)triggerEE_Sym=true;
        if(numElectrons&gt;=2 &amp;&amp; numEleGt25&gt;=1)triggerEE_ASym=true;

        if(numElectrons&gt;0 &amp;&amp; numMuons&gt;0 &amp;&amp; numEleGt14&gt;0)triggerEMU=true;
        if(numElectrons&gt;0 &amp;&amp; numMuons&gt;0 &amp;&amp; numMuonsGt18&gt;0)triggerMUE=true;

        bool trigger=false;
        if(triggerE || triggerMU || triggerMUMU_Sym || triggerMUMU_ASym || triggerEE_Sym || triggerEE_ASym || triggerEMU || triggerMUE )trigger=true;

        bool atLeastOneEorMu=false;
        if(numElectrons&gt;0 || numMuons&gt;0)atLeastOneEorMu=true;

        //Start the signal regions here

        //SR0tau_a: 20 bins!

        //Find m_SFOS that is closest to the Z mass
        double smallestDiff=9999;
        double mSFOS=0;
        for(double mass : massesOfSFOSPairs){
          if(fabs(mass-91.2)&lt;smallestDiff){
            smallestDiff=fabs(mass-91.2);
            mSFOS=mass;
          }
        }

        //Now find the lepton that isn't in that invariant mass
        vector&lt;const HEPUtils::Particle*&gt; signalLeptons;

        for (const HEPUtils::Particle* ele : signalElectrons) {
          signalLeptons.push_back(ele);
        }

        for (const HEPUtils::Particle* muo : signalMuons) {
          signalLeptons.push_back(muo);
        }

        int extralepID=-1;
        int lep1ID=-1;
        int lep2ID=-1;
        for(unsigned int iLep=0;iLep&lt;signalLeptons.size();iLep++){
          for(unsigned int jLep=iLep;jLep&lt;signalLeptons.size();jLep++){
            HEPUtils::P4 lepVec1=signalLeptons.at(iLep)-&gt;mom();
            HEPUtils::P4 lepVec2=signalLeptons.at(jLep)-&gt;mom();
            double invMass=(lepVec1+lepVec2).m();
            //cout &lt;&lt; &quot;INV MASS &quot; &lt;&lt; iLep &lt;&lt; &quot; &quot; &lt;&lt; jLep &lt;&lt; &quot; &quot; &lt;&lt; invMass &lt;&lt; endl;
            if(invMass==mSFOS){
              lep1ID=iLep;
              lep2ID=jLep;
            }
          }
        }

        if(lep1ID!=-1 &amp;&amp; lep1ID!=0 &amp;&amp; lep2ID!=-1 &amp;&amp; lep2ID!=0)extralepID=0;
        if(lep1ID!=-1 &amp;&amp; lep1ID!=1 &amp;&amp; lep2ID!=-1 &amp;&amp; lep2ID!=1)extralepID=1;
        if(lep1ID!=-1 &amp;&amp; lep1ID!=2 &amp;&amp; lep2ID!=-1 &amp;&amp; lep2ID!=2)extralepID=2;


        //if(leptonCut)cout &lt;&lt; &quot;extralepID &quot; &lt;&lt; extralepID &lt;&lt; endl;
        double mT=0;
        if(signalLeptons.size()==3 &amp;&amp; extralepID!=-1){
          HEPUtils::P4 extralepVec=signalLeptons.at(extralepID)-&gt;mom();
          mT=sqrt(2.*extralepVec.pT()*met*(1. - cos(extralepVec.deltaPhi(ptot))));

        }


        //Now calculate trilepton invariant mass
        double m3l=0;
        if(signalLeptons.size()==3)m3l=(signalLeptons.at(0)-&gt;mom()+signalLeptons.at(1)-&gt;mom()+signalLeptons.at(2)-&gt;mom()).m();
        bool threelZVeto=false;
        if(fabs(m3l-91.2)&lt;10.)threelZVeto=true;

        //Now apply the actual cuts for SR0tau_a


        if(trigger &amp;&amp; signalLeptons.size()==3 &amp;&amp; mSFOS12Cut &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; bJets.size()==0 &amp;&amp; signalTaus.size()==0){

          if(mSFOS&gt;12. &amp;&amp; mSFOS &lt; 40. &amp;&amp; mT&gt;0. &amp;&amp; mT&lt;80. &amp;&amp; met&gt;50. &amp;&amp; met&lt;90.) _num_SR0tau_a_bin_1 += event-&gt;weight();
          if(mSFOS&gt;12. &amp;&amp; mSFOS &lt; 40. &amp;&amp; mT&gt;0. &amp;&amp; mT&lt;80. &amp;&amp; met&gt;90.) _num_SR0tau_a_bin_2 += event-&gt;weight();
          if(mSFOS&gt;12. &amp;&amp; mSFOS &lt; 40. &amp;&amp; mT&gt;80. &amp;&amp; met&gt;50. &amp;&amp; met&lt;75.) _num_SR0tau_a_bin_3 += event-&gt;weight();
          if(mSFOS&gt;12. &amp;&amp; mSFOS &lt; 40. &amp;&amp; mT&gt;80. &amp;&amp; met&gt;75.) _num_SR0tau_a_bin_4 += event-&gt;weight();

          if(mSFOS&gt;40. &amp;&amp; mSFOS &lt; 60. &amp;&amp; mT&gt;0. &amp;&amp; mT&lt;80. &amp;&amp; met&gt;50. &amp;&amp; met&lt;75. &amp;&amp; !threelZVeto) _num_SR0tau_a_bin_5 += event-&gt;weight();
          if(mSFOS&gt;40. &amp;&amp; mSFOS &lt; 60. &amp;&amp; mT&gt;0. &amp;&amp; mT&lt;80. &amp;&amp; met&gt;75.) _num_SR0tau_a_bin_6 += event-&gt;weight();
          if(mSFOS&gt;40. &amp;&amp; mSFOS &lt; 60. &amp;&amp; mT&gt;80. &amp;&amp; met&gt;50. &amp;&amp; met&lt;135.) _num_SR0tau_a_bin_7 += event-&gt;weight();
          if(mSFOS&gt;40. &amp;&amp; mSFOS &lt; 60. &amp;&amp; mT&gt;80. &amp;&amp; met&gt;135.) _num_SR0tau_a_bin_8 += event-&gt;weight();

          if(mSFOS&gt;60. &amp;&amp; mSFOS &lt; 81.2 &amp;&amp; mT&gt;0. &amp;&amp; mT&lt;80. &amp;&amp; met&gt;50. &amp;&amp; met&lt;75. &amp;&amp; !threelZVeto) _num_SR0tau_a_bin_9 += event-&gt;weight();
          if(mSFOS&gt;60. &amp;&amp; mSFOS &lt; 81.2 &amp;&amp; mT&gt;80. &amp;&amp; met&gt;50. &amp;&amp; met&lt;75.) _num_SR0tau_a_bin_10 += event-&gt;weight();
          if(mSFOS&gt;60. &amp;&amp; mSFOS &lt; 81.2 &amp;&amp; mT&gt;0. &amp;&amp; mT&lt;110. &amp;&amp; met&gt;75.) _num_SR0tau_a_bin_11 += event-&gt;weight();
          if(mSFOS&gt;60. &amp;&amp; mSFOS &lt; 81.2 &amp;&amp; mT&gt;110. &amp;&amp; met&gt;75.) _num_SR0tau_a_bin_12 += event-&gt;weight();

          if(mSFOS&gt;81.2 &amp;&amp; mSFOS &lt; 101.2 &amp;&amp; mT&gt;0. &amp;&amp; mT&lt;110. &amp;&amp; met&gt;50. &amp;&amp; met&lt;90. &amp;&amp; !threelZVeto) _num_SR0tau_a_bin_13 += event-&gt;weight();
          if(mSFOS&gt;81.2 &amp;&amp; mSFOS &lt; 101.2 &amp;&amp; mT&gt;0. &amp;&amp; mT &lt; 110. &amp;&amp; met&gt;90.) _num_SR0tau_a_bin_14 += event-&gt;weight();
          if(mSFOS&gt;81.2 &amp;&amp; mSFOS &lt; 101.2 &amp;&amp; mT&gt;110. &amp;&amp; met&gt;50. &amp;&amp; met &lt; 135.) _num_SR0tau_a_bin_15 += event-&gt;weight();
          if(mSFOS&gt;81.2 &amp;&amp; mSFOS &lt; 101.2 &amp;&amp; mT&gt;110. &amp;&amp; met&gt;135.) _num_SR0tau_a_bin_16 += event-&gt;weight();

          if(mSFOS &gt; 101.2 &amp;&amp; mT&gt;0. &amp;&amp; mT&lt;180. &amp;&amp; met&gt;50. &amp;&amp; met&lt;210.) _num_SR0tau_a_bin_17 += event-&gt;weight();
          if(mSFOS &gt; 101.2 &amp;&amp; mT &gt; 180. &amp;&amp; met&gt;50. &amp;&amp; met&lt;210.) _num_SR0tau_a_bin_18 += event-&gt;weight();
          if(mSFOS &gt; 101.2 &amp;&amp; mT&gt;0. &amp;&amp; mT&lt;120. &amp;&amp; met&gt;210.) _num_SR0tau_a_bin_19 += event-&gt;weight();
          if(mSFOS &gt; 101.2 &amp;&amp; mT&gt;120. &amp;&amp; met&gt;210.) _num_SR0tau_a_bin_20 += event-&gt;weight();
        }
        //Now do SR0tau_b
        //Need either two electrons or two muons, and they must have the same sign
        //The remaining lepton must have different flavour and the opposite sign
        //NEEDS CHECKING
        bool leptonTypeCut_SR0taub=false;
        double dPhiLLMin=9999;
        if(numElectrons==2 &amp;&amp; numMuons==1){
          if((signalElectrons[0]-&gt;pid()==signalElectrons[1]-&gt;pid()) &amp;&amp;
             (signalElectrons[0]-&gt;pid()*signalMuons[0]-&gt;pid())&lt;0)leptonTypeCut_SR0taub=true;

          double dPhiLL1=signalElectrons[0]-&gt;mom().deltaPhi(signalMuons[0]-&gt;mom());
          double dPhiLL2=signalElectrons[1]-&gt;mom().deltaPhi(signalMuons[0]-&gt;mom());

          if(dPhiLL1&lt;dPhiLL2){
            dPhiLLMin=dPhiLL1;
          }
          else {
            dPhiLLMin=dPhiLL2;
          }
        }

        if(numElectrons==1 &amp;&amp; numMuons==2){
          if((signalMuons[0]-&gt;pid()==signalMuons[1]-&gt;pid()) &amp;&amp;
             (signalElectrons[0]-&gt;pid()*signalMuons[0]-&gt;pid())&lt;0)leptonTypeCut_SR0taub=true;

          double dPhiLL1=signalMuons[0]-&gt;mom().deltaPhi(signalElectrons[0]-&gt;mom());
          double dPhiLL2=signalMuons[1]-&gt;mom().deltaPhi(signalElectrons[0]-&gt;mom());

          if(dPhiLL1&lt;dPhiLL2){
            dPhiLLMin=dPhiLL1;
          }
          else {
            dPhiLLMin=dPhiLL2;
          }
        }


        bool leptonPTCut_SR0taub=true;
        for(unsigned int iLep=0;iLep&lt;signalLeptons.size();iLep++){
          if(signalLeptons[iLep]-&gt;pT()&lt;20.)leptonPTCut_SR0taub=false;
        }

        if(trigger &amp;&amp; signalLeptons.size()==3 &amp;&amp; mSFOS12Cut &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; leptonTypeCut_SR0taub &amp;&amp; bJets.size()==0 &amp;&amp; signalTaus.size()==0){

          if(met &gt; 50. &amp;&amp; leptonPTCut_SR0taub &amp;&amp; dPhiLLMin &lt; 1.) _num_SR0tau_b += event-&gt;weight();

        }

        //Now do SR1tau
        //We need one tau and two light leptons with opposite sign to the tau
        bool leptonTypeCut_SR1tau=false;
        double mltau=9999;

        if(numTaus==1 &amp;&amp; (numElectrons+numMuons)==2 &amp;&amp; (signalLeptons[0]-&gt;pid() * signalLeptons[1]-&gt;pid())&gt;0){
          leptonTypeCut_SR1tau=true;

          //Find the lepton and tau combination that has mltau closest to the Higgs mass
          double mltau1=(signalLeptons[0]-&gt;mom()+signalTaus[0]-&gt;mom()).m();
          double mltau2=(signalLeptons[1]-&gt;mom()+signalTaus[0]-&gt;mom()).m();
          if(fabs(mltau1-125)&lt;fabs(mltau2-125)){
            mltau=mltau1;
          }
          else {
            mltau=mltau2;
          }
        }
        //Electron pair veto
        bool eePairVeto=false;
        if(leptonTypeCut_SR1tau &amp;&amp; numElectrons==2){
          double mEE=(signalElectrons[0]-&gt;mom()+signalElectrons[1]-&gt;mom()).m();
          if(mEE&gt;81.2 &amp;&amp; mEE&lt;101.2)eePairVeto=true;
        }

        //Lepton pT cuts (assumes leptons are pT ordered: NEEDS CHECKING)
        bool leptonPTCut_SR1tau=false;
        if(leptonTypeCut_SR1tau &amp;&amp; signalLeptons[1]-&gt;pT()&gt;30. &amp;&amp; (signalLeptons[0]-&gt;pT()+signalLeptons[1]-&gt;pT())&gt;70.)leptonPTCut_SR1tau=true;

        if(trigger &amp;&amp; mSFOS12Cut &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; leptonTypeCut_SR1tau &amp;&amp; bJets.size()==0){
          if(met&gt;50. &amp;&amp; leptonPTCut_SR1tau &amp;&amp; mltau &lt; 120. &amp;&amp; !eePairVeto) _num_SR1tau += event-&gt;weight();
        }

        //Now do SR2taua
        double mT2max=0;

        if(numTaus==2 &amp;&amp; (numElectrons + numMuons)==1){

          //Calculate MT2 for all pairs of leptonsand take the largest
          vector&lt;const HEPUtils::Particle*&gt; mt2Leptons;

          for (const HEPUtils::Particle* ele : signalElectrons) {
            mt2Leptons.push_back(ele);
          }

          for (const HEPUtils::Particle* muo : signalMuons) {
            mt2Leptons.push_back(muo);
          }

          for (const HEPUtils::Particle* tau : signalTaus) {
            mt2Leptons.push_back(tau);
          }

          for(unsigned int iLep1=0;iLep1 &lt; 3;iLep1++){
            for(unsigned int iLep2=iLep1;iLep2 &lt; 3;iLep2++){

              double pa_b[3] = { 0, mt2Leptons[iLep1]-&gt;mom().px(), mt2Leptons[iLep1]-&gt;mom().py() };
              double pb_b[3] = { 0, mt2Leptons[iLep2]-&gt;mom().px(), mt2Leptons[iLep2]-&gt;mom().py() };
              double pmiss_b[3] = { 0, ptot.px(), ptot.py() };
              double mn_b = 0.;

              mt2_bisect::mt2 mt2_calc;

              mt2_calc.set_momenta(pa_b,pb_b,pmiss_b);
              mt2_calc.set_mn(mn_b);
              double mt2 = mt2_calc.get_mt2();
              if(mt2&gt;mT2max)mT2max=mt2;
            }
          }
        }

        if(numTaus==2 &amp;&amp; (numElectrons + numMuons)==1 &amp;&amp; trigger &amp;&amp; mSFOS12Cut &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; bJets.size()==0 &amp;&amp; met &gt; 50. &amp;&amp; mT2max &gt; 100.) _num_SR2tau_a += event-&gt;weight();

        //Finally do SR2taub
        double mtautau=0;
        if(numTaus==2)mtautau=(signalTaus[0]-&gt;mom()+signalTaus[1]-&gt;mom()).m();

        if(numTaus==2 &amp;&amp; (numElectrons + numMuons)==1 &amp;&amp; trigger &amp;&amp; mSFOS12Cut &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; (signalTaus[0]-&gt;pid() == -1*signalTaus[1]-&gt;pid()) &amp;&amp; bJets.size()==0 &amp;&amp; met &gt; 60 &amp;&amp; (signalTaus[0]-&gt;mom().pT() + signalTaus[1]-&gt;mom().pT())&gt;110. &amp;&amp; mtautau&gt;70. &amp;&amp; mtautau &lt; 120.) _num_SR2tau_b += event-&gt;weight();

        //Now do cutflow (for debugging)

        cutFlowVector_str[0] = &quot;No cuts &quot;;
        cutFlowVector_str[1] = &quot;3 signal leptons &quot;;
        cutFlowVector_str[2] = &quot;Trigger &quot;;
        cutFlowVector_str[3] = &quot;At least one e or mu &quot;;
        cutFlowVector_str[4] = &quot;Separation of leptons &quot;;
        cutFlowVector_str[5] = &quot;mSFOS &gt; 12 cut &quot;;
        cutFlowVector_str[6] = &quot;Lepton requirement (no taus) &quot;;
        cutFlowVector_str[7] = &quot;SFOS &quot;;
        cutFlowVector_str[8] = &quot;b-tagged jet veto &quot;;
        cutFlowVector_str[9] = &quot;ETmiss &quot;;
        cutFlowVector_str[10] = &quot;mT &quot;;
        cutFlowVector_str[11] = &quot;SR0tau_a_bin_1 &quot;;
        cutFlowVector_str[12] = &quot;SR0tau_a_bin_2 &quot;;
        cutFlowVector_str[13] = &quot;SR0tau_a_bin_3 &quot;;
        cutFlowVector_str[14] = &quot;SR0tau_a_bin_4 &quot;;
        cutFlowVector_str[15] = &quot;SR0tau_a_bin_5 &quot;;
        cutFlowVector_str[16] = &quot;SR0tau_a_bin_6 &quot;;
        cutFlowVector_str[17] = &quot;SR0tau_a_bin_7 &quot;;
        cutFlowVector_str[18] = &quot;SR0tau_a_bin_8 &quot;;
        cutFlowVector_str[19] = &quot;SR0tau_a_bin_9 &quot;;
        cutFlowVector_str[20] = &quot;SR0tau_a_bin_10 &quot;;
        cutFlowVector_str[21] = &quot;SR0tau_a_bin_11 &quot;;
        cutFlowVector_str[22] = &quot;SR0tau_a_bin_12 &quot;;
        cutFlowVector_str[23] = &quot;SR0tau_a_bin_13 &quot;;
        cutFlowVector_str[24] = &quot;SR0tau_a_bin_14 &quot;;
        cutFlowVector_str[25] = &quot;SR0tau_a_bin_15 &quot;;
        cutFlowVector_str[26] = &quot;SR0tau_a_bin_16 &quot;;
        cutFlowVector_str[27] = &quot;SR0tau_a_bin_17 &quot;;
        cutFlowVector_str[28] = &quot;SR0tau_a_bin_18 &quot;;
        cutFlowVector_str[29] = &quot;SR0tau_a_bin_19 &quot;;
        cutFlowVector_str[30] = &quot;SR0tau_a_bin_20 &quot;;
        cutFlowVector_str[31] = &quot;SR0taub: Lepton multiplicity &quot;;
        cutFlowVector_str[32] = &quot;SR0taub: b veto &quot;;
        cutFlowVector_str[33] = &quot;SR0taub: met &quot;;
        cutFlowVector_str[34] = &quot;SR0taub: pT 3rd lepton &quot;;
        cutFlowVector_str[35] = &quot;SR0taub: dPhiLL &quot;;
        cutFlowVector_str[36] = &quot;SR1tau: Lepton multiplicity &quot;;
        cutFlowVector_str[37] = &quot;SR1tau: Z veto &quot;;
        cutFlowVector_str[38] = &quot;SR1tau: b-tagged veto &quot;;
        cutFlowVector_str[39] = &quot;SR1tau: MET &quot;;
        cutFlowVector_str[40] = &quot;SR1tau: Lepton pT cuts &quot;;
        cutFlowVector_str[41] = &quot;SR1tau: mltau &quot;;
        cutFlowVector_str[42] = &quot;SR2taua: Lepton multiplicity &quot;;
        cutFlowVector_str[43] = &quot;SR2taua: b veto &quot;;
        cutFlowVector_str[44] = &quot;SR2taua: MET &quot;;
        cutFlowVector_str[45] = &quot;SR2taua: MT2max &quot;;
        cutFlowVector_str[46] = &quot;SR2taub: Lepton multiplicity &quot;;
        cutFlowVector_str[47] = &quot;SR2taub: b jet veto &quot;;
        cutFlowVector_str[48] = &quot;SR2taub: met &quot;;
        cutFlowVector_str[49] = &quot;SR2taub: mtautau &quot;;
        cutFlowVector_str[50] = &quot;SR2taub: Sum of tau pT &quot;;

        //if(signalLeptons.size()==3 &amp;&amp; trigger &amp;&amp; atLeastOneEorMu)std::cout &lt;&lt; &quot;LEPTONID &quot; &lt;&lt; signalLeptons[0]-&gt;pid() &lt;&lt; &quot; &quot; &lt;&lt; signalLeptons[1]-&gt;pid() &lt;&lt; &quot; &quot; &lt;&lt; signalLeptons[2]-&gt;pid() &lt;&lt; &quot; mSFOS12Cut &quot; &lt;&lt; mSFOS12Cut &lt;&lt; &quot; LEPTONTYPE &quot; &lt;&lt; leptonTypeCut_SR0taub &lt;&lt; std::endl;

        for(int j=0;j&lt;NCUTS;j++){
          if( (j==0) ||

              (j==1 &amp;&amp; signalLeptons.size()==3) ||

              (j==2 &amp;&amp; signalLeptons.size()==3 &amp;&amp; trigger) ||

              (j==3 &amp;&amp; signalLeptons.size()==3 &amp;&amp; trigger &amp;&amp; atLeastOneEorMu) ||

              (j==4 &amp;&amp; signalLeptons.size()==3 &amp;&amp; trigger &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut) ||

              (j==5 &amp;&amp; signalLeptons.size()==3 &amp;&amp; trigger &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; mSFOS12Cut) ||

              (j==6 &amp;&amp; trigger &amp;&amp; signalLeptons.size()==3 &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; mSFOS12Cut &amp;&amp; signalTaus.size()==0) || //lepton requirement

              (j==7 &amp;&amp; trigger &amp;&amp; signalLeptons.size()==3 &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; mSFOS12Cut &amp;&amp; signalTaus.size()==0 &amp;&amp; massesOfSFOSPairs.size()&gt;0) || //SFOS

              (j==8 &amp;&amp; trigger &amp;&amp; signalLeptons.size()==3 &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; mSFOS12Cut &amp;&amp; signalTaus.size()==0 &amp;&amp; massesOfSFOSPairs.size()&gt;0 &amp;&amp; bJets.size()==0) || //b jet veto

              (j==9 &amp;&amp; trigger &amp;&amp; signalLeptons.size()==3 &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; mSFOS12Cut &amp;&amp; signalTaus.size()==0 &amp;&amp; massesOfSFOSPairs.size()&gt;0 &amp;&amp; bJets.size()==0 &amp;&amp; met&gt;50. &amp;&amp; met&lt;90.) || //MET

              (j==10 &amp;&amp; trigger &amp;&amp; signalLeptons.size()==3 &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; mSFOS12Cut &amp;&amp; signalTaus.size()==0 &amp;&amp; massesOfSFOSPairs.size()&gt;0 &amp;&amp; bJets.size()==0 &amp;&amp; met&gt;50. &amp;&amp; met&lt;90. &amp;&amp; mT&gt;0. &amp;&amp; mT&lt;80.) || //mT

              (j==11 &amp;&amp; trigger &amp;&amp; signalLeptons.size()==3 &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; mSFOS12Cut &amp;&amp; signalTaus.size()==0 &amp;&amp; massesOfSFOSPairs.size()&gt;0 &amp;&amp; bJets.size()==0 &amp;&amp; mSFOS&gt;12. &amp;&amp; mSFOS &lt; 40. &amp;&amp; mT&gt;0. &amp;&amp; mT&lt;80. &amp;&amp; met&gt;50. &amp;&amp; met&lt;90.) ||

              (j==12 &amp;&amp; trigger &amp;&amp; signalLeptons.size()==3 &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; mSFOS12Cut &amp;&amp; signalTaus.size()==0 &amp;&amp; massesOfSFOSPairs.size()&gt;0 &amp;&amp; bJets.size()==0 &amp;&amp; mSFOS&gt;12. &amp;&amp; mSFOS &lt; 40. &amp;&amp; mT&gt;0. &amp;&amp; mT&lt;80. &amp;&amp; met&gt;90.) ||

              (j==13 &amp;&amp; trigger &amp;&amp; signalLeptons.size()==3 &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; mSFOS12Cut &amp;&amp; signalTaus.size()==0 &amp;&amp; massesOfSFOSPairs.size()&gt;0 &amp;&amp; bJets.size()==0 &amp;&amp; mSFOS&gt;12. &amp;&amp; mSFOS &lt; 40. &amp;&amp; mT&gt;80. &amp;&amp; met&gt;50. &amp;&amp; met&lt;75.) ||

              (j==14 &amp;&amp; trigger &amp;&amp; signalLeptons.size()==3 &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; mSFOS12Cut &amp;&amp; signalTaus.size()==0 &amp;&amp; massesOfSFOSPairs.size()&gt;0 &amp;&amp; bJets.size()==0 &amp;&amp; mSFOS&gt;12. &amp;&amp; mSFOS &lt; 40. &amp;&amp; mT&gt;80. &amp;&amp; met&gt;75.) ||

              (j==15 &amp;&amp; trigger &amp;&amp; signalLeptons.size()==3 &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; mSFOS12Cut &amp;&amp; signalTaus.size()==0 &amp;&amp; massesOfSFOSPairs.size()&gt;0 &amp;&amp; bJets.size()==0 &amp;&amp; mSFOS&gt;40. &amp;&amp; mSFOS &lt; 60. &amp;&amp; mT&gt;0. &amp;&amp; mT&lt;80. &amp;&amp; met&gt;50. &amp;&amp; met&lt;75. &amp;&amp; !threelZVeto) ||

              (j==16 &amp;&amp; trigger &amp;&amp; signalLeptons.size()==3 &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; mSFOS12Cut &amp;&amp; signalTaus.size()==0 &amp;&amp; massesOfSFOSPairs.size()&gt;0 &amp;&amp; bJets.size()==0 &amp;&amp; mSFOS&gt;40. &amp;&amp; mSFOS &lt; 60. &amp;&amp; mT&gt;0. &amp;&amp; mT&lt;80. &amp;&amp; met&gt;75.) ||

              (j==17 &amp;&amp; trigger &amp;&amp; signalLeptons.size()==3 &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; mSFOS12Cut &amp;&amp; signalTaus.size()==0 &amp;&amp; massesOfSFOSPairs.size()&gt;0 &amp;&amp; bJets.size()==0 &amp;&amp; mSFOS&gt;40. &amp;&amp; mSFOS &lt; 60. &amp;&amp; mT&gt;80. &amp;&amp; met&gt;50. &amp;&amp; met&lt;135.) ||

              (j==18 &amp;&amp; trigger &amp;&amp; signalLeptons.size()==3 &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; mSFOS12Cut &amp;&amp; signalTaus.size()==0 &amp;&amp; massesOfSFOSPairs.size()&gt;0 &amp;&amp; bJets.size()==0 &amp;&amp; mSFOS&gt;40. &amp;&amp; mSFOS &lt; 60. &amp;&amp; mT&gt;80. &amp;&amp; met&gt;135.) ||

              (j==19 &amp;&amp; trigger &amp;&amp; signalLeptons.size()==3 &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; mSFOS12Cut &amp;&amp; signalTaus.size()==0 &amp;&amp; massesOfSFOSPairs.size()&gt;0 &amp;&amp; bJets.size()==0 &amp;&amp; mSFOS&gt;60. &amp;&amp; mSFOS &lt; 81.2 &amp;&amp; mT&gt;0. &amp;&amp; mT&lt;80. &amp;&amp; met&gt;50. &amp;&amp; met&lt;75. &amp;&amp; !threelZVeto) ||

              (j==20 &amp;&amp; trigger &amp;&amp; signalLeptons.size()==3 &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; mSFOS12Cut &amp;&amp; signalTaus.size()==0 &amp;&amp; massesOfSFOSPairs.size()&gt;0 &amp;&amp; bJets.size()==0 &amp;&amp; mSFOS&gt;60. &amp;&amp; mSFOS &lt; 81.2 &amp;&amp; mT&gt;80. &amp;&amp; met&gt;50. &amp;&amp; met&lt;75.) ||

              (j==21 &amp;&amp; trigger &amp;&amp; signalLeptons.size()==3 &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; mSFOS12Cut &amp;&amp; signalTaus.size()==0 &amp;&amp; massesOfSFOSPairs.size()&gt;0 &amp;&amp; bJets.size()==0 &amp;&amp; mSFOS&gt;60. &amp;&amp; mSFOS &lt; 81.2 &amp;&amp; mT&gt;0. &amp;&amp; mT&lt;110. &amp;&amp; met&gt;75.) ||

              (j==22 &amp;&amp; trigger &amp;&amp; signalLeptons.size()==3 &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; mSFOS12Cut &amp;&amp; signalTaus.size()==0 &amp;&amp; massesOfSFOSPairs.size()&gt;0 &amp;&amp; bJets.size()==0 &amp;&amp; mSFOS&gt;60. &amp;&amp; mSFOS &lt; 81.2 &amp;&amp; mT&gt;110. &amp;&amp; met&gt;75.) ||

              (j==23 &amp;&amp; trigger &amp;&amp; signalLeptons.size()==3 &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; mSFOS12Cut &amp;&amp; signalTaus.size()==0 &amp;&amp; massesOfSFOSPairs.size()&gt;0 &amp;&amp; bJets.size()==0 &amp;&amp; mSFOS&gt;81.2 &amp;&amp; mSFOS &lt; 101.2 &amp;&amp; mT&gt;0. &amp;&amp; mT&lt;110. &amp;&amp; met&gt;50. &amp;&amp; met&lt;90. &amp;&amp; !threelZVeto) ||

              (j==24 &amp;&amp; trigger &amp;&amp; signalLeptons.size()==3 &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; mSFOS12Cut &amp;&amp; signalTaus.size()==0 &amp;&amp; massesOfSFOSPairs.size()&gt;0 &amp;&amp; bJets.size()==0 &amp;&amp; mSFOS&gt;81.2 &amp;&amp; mSFOS &lt; 101.2 &amp;&amp; mT&gt;0. &amp;&amp; mT &lt; 110. &amp;&amp; met&gt;90.) ||

              (j==25 &amp;&amp; trigger &amp;&amp; signalLeptons.size()==3 &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; mSFOS12Cut &amp;&amp; signalTaus.size()==0 &amp;&amp; massesOfSFOSPairs.size()&gt;0 &amp;&amp; bJets.size()==0 &amp;&amp; mSFOS&gt;81.2 &amp;&amp; mSFOS &lt; 101.2 &amp;&amp; mT&gt;110. &amp;&amp; met&gt;50. &amp;&amp; met &lt; 135.) ||

              (j==26 &amp;&amp; trigger &amp;&amp; signalLeptons.size()==3 &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; mSFOS12Cut &amp;&amp; signalTaus.size()==0 &amp;&amp; massesOfSFOSPairs.size()&gt;0 &amp;&amp; bJets.size()==0 &amp;&amp; mSFOS&gt;81.2 &amp;&amp; mSFOS &lt; 101.2 &amp;&amp; mT&gt;110. &amp;&amp; met&gt;135.) ||

              (j==27 &amp;&amp; trigger &amp;&amp; signalLeptons.size()==3 &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; mSFOS12Cut &amp;&amp; signalTaus.size()==0 &amp;&amp; massesOfSFOSPairs.size()&gt;0 &amp;&amp; bJets.size()==0 &amp;&amp; mSFOS &gt; 101.2 &amp;&amp; mT&gt;0. &amp;&amp; mT&lt;180. &amp;&amp; met&gt;50. &amp;&amp; met&lt;210.) ||

              (j==28 &amp;&amp; trigger &amp;&amp; signalLeptons.size()==3 &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; mSFOS12Cut &amp;&amp; signalTaus.size()==0 &amp;&amp; massesOfSFOSPairs.size()&gt;0 &amp;&amp; bJets.size()==0 &amp;&amp; mSFOS &gt; 101.2 &amp;&amp; mT &gt; 180. &amp;&amp; met&gt;50. &amp;&amp; met&lt;210.) ||

              (j==29 &amp;&amp; trigger &amp;&amp; signalLeptons.size()==3 &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; mSFOS12Cut &amp;&amp; signalTaus.size()==0 &amp;&amp; massesOfSFOSPairs.size()&gt;0 &amp;&amp; bJets.size()==0 &amp;&amp; mSFOS &gt; 101.2 &amp;&amp; mT&gt;0. &amp;&amp; mT&lt;120. &amp;&amp; met&gt;210.) ||

              (j==30 &amp;&amp; trigger &amp;&amp; signalLeptons.size()==3 &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; mSFOS12Cut &amp;&amp; signalTaus.size()==0 &amp;&amp; massesOfSFOSPairs.size()&gt;0 &amp;&amp; bJets.size()==0 &amp;&amp; mSFOS &gt; 101.2 &amp;&amp; mT&gt;120. &amp;&amp; met&gt;210.) ||

              //Start SR0taub

              (j==31 &amp;&amp; trigger &amp;&amp; signalLeptons.size()==3 &amp;&amp; mSFOS12Cut &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; leptonTypeCut_SR0taub &amp;&amp; signalTaus.size()==0) ||

              (j==32 &amp;&amp; trigger &amp;&amp; signalLeptons.size()==3 &amp;&amp; mSFOS12Cut &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; leptonTypeCut_SR0taub &amp;&amp; signalTaus.size()==0 &amp;&amp; bJets.size()==0) ||

              (j==33 &amp;&amp; trigger &amp;&amp; signalLeptons.size()==3 &amp;&amp; mSFOS12Cut &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; leptonTypeCut_SR0taub &amp;&amp; signalTaus.size()==0 &amp;&amp; bJets.size()==0 &amp;&amp; met &gt; 50.) ||

              (j==34 &amp;&amp; trigger &amp;&amp; signalLeptons.size()==3 &amp;&amp; mSFOS12Cut &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; leptonTypeCut_SR0taub &amp;&amp; signalTaus.size()==0 &amp;&amp; bJets.size()==0 &amp;&amp; met &gt; 50. &amp;&amp; leptonPTCut_SR0taub) ||

              (j==35 &amp;&amp; trigger &amp;&amp; signalLeptons.size()==3 &amp;&amp; mSFOS12Cut &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; leptonTypeCut_SR0taub &amp;&amp; signalTaus.size()==0 &amp;&amp; bJets.size()==0 &amp;&amp; met &gt; 50. &amp;&amp; leptonPTCut_SR0taub &amp;&amp; dPhiLLMin &lt; 1.) ||

              //SR1tau

              (j==36 &amp;&amp; trigger &amp;&amp; mSFOS12Cut &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; leptonTypeCut_SR1tau) ||

              (j==37 &amp;&amp; trigger &amp;&amp; mSFOS12Cut &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; leptonTypeCut_SR1tau &amp;&amp; !eePairVeto) ||

              (j==38 &amp;&amp; trigger &amp;&amp; mSFOS12Cut &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; leptonTypeCut_SR1tau &amp;&amp; !eePairVeto &amp;&amp; bJets.size()==0) ||

              (j==39 &amp;&amp; trigger &amp;&amp; mSFOS12Cut &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; leptonTypeCut_SR1tau &amp;&amp; !eePairVeto &amp;&amp; bJets.size()==0 &amp;&amp; met&gt;50.) ||

              (j==40 &amp;&amp; trigger &amp;&amp; mSFOS12Cut &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; leptonTypeCut_SR1tau &amp;&amp; !eePairVeto &amp;&amp; bJets.size()==0 &amp;&amp; met&gt;50. &amp;&amp; leptonPTCut_SR1tau) ||

              (j==41 &amp;&amp; trigger &amp;&amp; mSFOS12Cut &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; leptonTypeCut_SR1tau &amp;&amp; !eePairVeto &amp;&amp; bJets.size()==0 &amp;&amp; met&gt;50. &amp;&amp; leptonPTCut_SR1tau &amp;&amp; mltau &lt; 120.) ||

              //SR2taua

              (j==42 &amp;&amp;numTaus==2 &amp;&amp; (numElectrons + numMuons)==1 &amp;&amp; trigger &amp;&amp; mSFOS12Cut &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut) ||

              (j==43 &amp;&amp;numTaus==2 &amp;&amp; (numElectrons + numMuons)==1 &amp;&amp; trigger &amp;&amp; mSFOS12Cut &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; bJets.size()==0) ||

              (j==44 &amp;&amp;numTaus==2 &amp;&amp; (numElectrons + numMuons)==1 &amp;&amp; trigger &amp;&amp; mSFOS12Cut &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; bJets.size()==0 &amp;&amp; met &gt; 50.) ||

              (j==45 &amp;&amp; numTaus==2 &amp;&amp; (numElectrons + numMuons)==1 &amp;&amp; trigger &amp;&amp; mSFOS12Cut &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; bJets.size()==0 &amp;&amp; met &gt; 50. &amp;&amp; mT2max &gt; 100.) ||

              //SR2taub
              (j==46 &amp;&amp; numTaus==2 &amp;&amp; (numElectrons + numMuons)==1 &amp;&amp; trigger &amp;&amp; mSFOS12Cut &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; (signalTaus[0]-&gt;pid() == -1*signalTaus[1]-&gt;pid())) ||

              (j==47 &amp;&amp; numTaus==2 &amp;&amp; (numElectrons + numMuons)==1 &amp;&amp; trigger &amp;&amp; mSFOS12Cut &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; (signalTaus[0]-&gt;pid() == -1*signalTaus[1]-&gt;pid()) &amp;&amp; bJets.size()==0) ||

              (j==48 &amp;&amp; numTaus==2 &amp;&amp; (numElectrons + numMuons)==1 &amp;&amp; trigger &amp;&amp; mSFOS12Cut &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; (signalTaus[0]-&gt;pid() == -1*signalTaus[1]-&gt;pid()) &amp;&amp; bJets.size()==0 &amp;&amp; met &gt; 60) ||

              (j==49 &amp;&amp; numTaus==2 &amp;&amp; (numElectrons + numMuons)==1 &amp;&amp; trigger &amp;&amp; mSFOS12Cut &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; (signalTaus[0]-&gt;pid() == -1*signalTaus[1]-&gt;pid()) &amp;&amp; bJets.size()==0 &amp;&amp; met &gt; 60 &amp;&amp; mtautau&gt;70. &amp;&amp; mtautau &lt; 120.) ||

              (j==50 &amp;&amp; numTaus==2 &amp;&amp; (numElectrons + numMuons)==1 &amp;&amp; trigger &amp;&amp; mSFOS12Cut &amp;&amp; atLeastOneEorMu &amp;&amp; separationCut &amp;&amp; (signalTaus[0]-&gt;pid() == -1*signalTaus[1]-&gt;pid()) &amp;&amp; bJets.size()==0 &amp;&amp; met &gt; 60 &amp;&amp; mtautau&gt;70. &amp;&amp; mtautau &lt; 120. &amp;&amp; (signalTaus[0]-&gt;mom().pT() + signalTaus[1]-&gt;mom().pT())&gt;110.)


              )cutFlowVector[j]++;
        }
        return;
      }

      void combine(const Analysis* other)
      {
        const Analysis_ATLAS_8TeV_3LEPEW_20invfb* specificOther
          = dynamic_cast&lt;const Analysis_ATLAS_8TeV_3LEPEW_20invfb*&gt;(other);

        for (int j=0; j&lt;NCUTS; j++)
        {
          cutFlowVector[j] += specificOther-&gt;cutFlowVector[j];
          cutFlowVector_str[j] = specificOther-&gt;cutFlowVector_str[j];
        }

        _num_SR0tau_a_bin_1 += specificOther-&gt;_num_SR0tau_a_bin_1;
        _num_SR0tau_a_bin_2 += specificOther-&gt;_num_SR0tau_a_bin_2;
        _num_SR0tau_a_bin_3 += specificOther-&gt;_num_SR0tau_a_bin_3;
        _num_SR0tau_a_bin_4 += specificOther-&gt;_num_SR0tau_a_bin_4;
        _num_SR0tau_a_bin_5 += specificOther-&gt;_num_SR0tau_a_bin_5;
        _num_SR0tau_a_bin_6 += specificOther-&gt;_num_SR0tau_a_bin_6;
        _num_SR0tau_a_bin_7 += specificOther-&gt;_num_SR0tau_a_bin_7;
        _num_SR0tau_a_bin_8 += specificOther-&gt;_num_SR0tau_a_bin_8;
        _num_SR0tau_a_bin_9 += specificOther-&gt;_num_SR0tau_a_bin_9;
        _num_SR0tau_a_bin_10 += specificOther-&gt;_num_SR0tau_a_bin_10;
        _num_SR0tau_a_bin_11 += specificOther-&gt;_num_SR0tau_a_bin_11;
        _num_SR0tau_a_bin_12 += specificOther-&gt;_num_SR0tau_a_bin_12;
        _num_SR0tau_a_bin_13 += specificOther-&gt;_num_SR0tau_a_bin_13;
        _num_SR0tau_a_bin_14 += specificOther-&gt;_num_SR0tau_a_bin_14;
        _num_SR0tau_a_bin_15 += specificOther-&gt;_num_SR0tau_a_bin_15;
        _num_SR0tau_a_bin_16 += specificOther-&gt;_num_SR0tau_a_bin_16;
        _num_SR0tau_a_bin_17 += specificOther-&gt;_num_SR0tau_a_bin_17;
        _num_SR0tau_a_bin_18 += specificOther-&gt;_num_SR0tau_a_bin_18;
        _num_SR0tau_a_bin_19 += specificOther-&gt;_num_SR0tau_a_bin_19;
        _num_SR0tau_a_bin_20 += specificOther-&gt;_num_SR0tau_a_bin_20;
        _num_SR0tau_b += specificOther-&gt;_num_SR0tau_b;
        _num_SR1tau += specificOther-&gt;_num_SR1tau;
        _num_SR2tau_a += specificOther-&gt;_num_SR2tau_a;
        _num_SR2tau_b += specificOther-&gt;_num_SR2tau_b;
      }


      void collect_results() {

        // add_result(SignalRegionData(&quot;SR label&quot;, n_obs, {n_sig_MC, n_sig_MC_sys}, {n_bkg, n_bkg_err}));

        add_result(SignalRegionData(&quot;SR0tau_a_bin_1&quot;, 36., {_num_SR0tau_a_bin_1, 0.}, { 23., 4. }));
        add_result(SignalRegionData(&quot;SR0tau_a_bin_2&quot;, 5., {_num_SR0tau_a_bin_2, 0.}, { 4.2,  1.5}));
        add_result(SignalRegionData(&quot;SR0tau_a_bin_3&quot;, 9., {_num_SR0tau_a_bin_3, 0.}, { 10.6,  1.8}));
        add_result(SignalRegionData(&quot;SR0tau_a_bin_4&quot;, 9., {_num_SR0tau_a_bin_4, 0.}, { 8.5,  1.7}));
        add_result(SignalRegionData(&quot;SR0tau_a_bin_5&quot;, 11., {_num_SR0tau_a_bin_5, 0.}, { 12.9,  2.4}));
        add_result(SignalRegionData(&quot;SR0tau_a_bin_6&quot;, 13., {_num_SR0tau_a_bin_6, 0.}, { 6.6,  1.9}));
        add_result(SignalRegionData(&quot;SR0tau_a_bin_7&quot;, 15., {_num_SR0tau_a_bin_7, 0.}, { 14.1,  2.2}));
        add_result(SignalRegionData(&quot;SR0tau_a_bin_8&quot;, 1., {_num_SR0tau_a_bin_8, 0.}, { 1.1,  0.4}));
        add_result(SignalRegionData(&quot;SR0tau_a_bin_9&quot;, 28., {_num_SR0tau_a_bin_9, 0.}, { 22.4,  3.6}));
        add_result(SignalRegionData(&quot;SR0tau_a_bin_10&quot;, 24., {_num_SR0tau_a_bin_10, 0.}, { 16.4,  2.8}));
        add_result(SignalRegionData(&quot;SR0tau_a_bin_11&quot;, 29., {_num_SR0tau_a_bin_11, 0.}, { 27., 5. }));
        add_result(SignalRegionData(&quot;SR0tau_a_bin_12&quot;, 8., {_num_SR0tau_a_bin_12, 0.}, { 5.5,  1.5}));
        add_result(SignalRegionData(&quot;SR0tau_a_bin_13&quot;, 714., {_num_SR0tau_a_bin_13, 0.}, { 715., 70. }));
        add_result(SignalRegionData(&quot;SR0tau_a_bin_14&quot;, 214., {_num_SR0tau_a_bin_14, 0.}, { 219., 33. }));
        add_result(SignalRegionData(&quot;SR0tau_a_bin_15&quot;, 63., {_num_SR0tau_a_bin_15, 0.}, { 65., 13. }));
        add_result(SignalRegionData(&quot;SR0tau_a_bin_16&quot;, 3., {_num_SR0tau_a_bin_16, 0.}, { 4.6,  1.7}));
        add_result(SignalRegionData(&quot;SR0tau_a_bin_17&quot;, 60., {_num_SR0tau_a_bin_17, 0.}, { 69., 9. }));
        add_result(SignalRegionData(&quot;SR0tau_a_bin_18&quot;, 1., {_num_SR0tau_a_bin_18, 0.}, { 3.4,  1.4}));
        add_result(SignalRegionData(&quot;SR0tau_a_bin_19&quot;, 0., {_num_SR0tau_a_bin_19, 0.}, { 1.2,  0.4}));
        add_result(SignalRegionData(&quot;SR0tau_a_bin_20&quot;, 0., {_num_SR0tau_a_bin_20, 0.}, { 0.29,  0.18}));
        add_result(SignalRegionData(&quot;SR1tau&quot;, 13., {_num_SR1tau, 0.}, { 10.3,  1.2}));
        add_result(SignalRegionData(&quot;SR2tau_a&quot;, 6., {_num_SR2tau_a, 0.}, { 6.9,  0.8}));
        add_result(SignalRegionData(&quot;SR2tau_b&quot;, 5., {_num_SR2tau_b, 0.}, { 7.2,  0.8}));

        return;
      }


    protected:
      void analysis_specific_reset() {
        _num_SR0tau_a_bin_1=0;
        _num_SR0tau_a_bin_2=0;
        _num_SR0tau_a_bin_3=0;
        _num_SR0tau_a_bin_4=0;
        _num_SR0tau_a_bin_5=0;
        _num_SR0tau_a_bin_6=0;
        _num_SR0tau_a_bin_7=0;
        _num_SR0tau_a_bin_8=0;
        _num_SR0tau_a_bin_9=0;
        _num_SR0tau_a_bin_10=0;
        _num_SR0tau_a_bin_11=0;
        _num_SR0tau_a_bin_12=0;
        _num_SR0tau_a_bin_13=0;
        _num_SR0tau_a_bin_14=0;
        _num_SR0tau_a_bin_15=0;
        _num_SR0tau_a_bin_16=0;
        _num_SR0tau_a_bin_17=0;
        _num_SR0tau_a_bin_18=0;
        _num_SR0tau_a_bin_19=0;
        _num_SR0tau_a_bin_20=0;
        _num_SR0tau_b=0;
        _num_SR1tau=0;
        _num_SR2tau_a=0;
        _num_SR2tau_b=0;

        std::fill(cutFlowVector.begin(), cutFlowVector.end(), 0);
      }

    };


    DEFINE_ANALYSIS_FACTORY(ATLAS_8TeV_3LEPEW_20invfb)


  }
}
</code></pre><hr><p>Updated on 2022-08-01 at 17:31:49 +0000</p><div class=edit-page><a href=https://github.com/RC1242RC/gambit_gh_pages/blob/master/content/en/documentation/code/gambit_sphinx/Files/Analysis__ATLAS__8TeV__3LEPEW__20invfb_8cpp.md><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828.0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>Edit this page on GitHub</a></div></main></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Powered by <a class=text-muted href=https://www.netlify.com/>Netlify</a>, <a class=text-muted href=https://gohugo.io/>Hugo</a>, and <a class=text-muted href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline><li class=list-inline-item><a href=/license/>License</a></li></ul></div></div></div></footer><script src=/js/bootstrap.min.54bf0932b8a36d0e152b1635b099a6ef1394d35327e2437550a075c9c8ed1bd8aed5847c21b36fc02ed24014c031d9ca24017b0c78b1639d7e2fa8329898b842.js integrity="sha512-VL8JMrijbQ4VKxY1sJmm7xOU01Mn4kN1UKB1ycjtG9iu1YR8IbNvwC7SQBTAMdnKJAF7DHixY51+L6gymJi4Qg==" crossorigin=anonymous defer></script>
<script src=/js/highlight.min.5b48bc253dc75aeea5fb366ecf700f4925e2b6eb1a1466f2124b722d68148d67bc0a9365d2b8ad9c585161b46372d23b08509a16f1fd518542b894756d4752d0.js integrity="sha512-W0i8JT3HWu6l+zZuz3APSSXitusaFGbyEktyLWgUjWe8CpNl0ritnFhRYbRjctI7CFCaFvH9UYVCuJR1bUdS0A==" crossorigin=anonymous defer></script>
<script src=/main.min.40265e9a032aeba5eaf67baac3cbbc22667a7533215d326eeb3e9f4d5e4be40f9ff4dcd22949db73ae527ca26a19d7998091a8973c82af760b2c0daa335190ed.js integrity="sha512-QCZemgMq66Xq9nuqw8u8ImZ6dTMhXTJu6z6fTV5L5A+f9NzSKUnbc65SfKJqGdeZgJGolzyCr3YLLA2qM1GQ7Q==" crossorigin=anonymous defer></script>
<script src=https://rc1242rc.github.io/index.min.ce44f6e5f0bdb9c5095744a1780684199908cc39877fab7f65dc16af9ecaf70559085ca2435c1013cd4c4e5445a1bfd74fa91b9ae55c1db737cc8557ad7bf689.js integrity="sha512-zkT25fC9ucUJV0SheAaEGZkIzDmHf6t/ZdwWr57K9wVZCFyiQ1wQE81MTlRFob/XT6kbmuVcHbc3zIVXrXv2iQ==" crossorigin=anonymous defer></script></body></html>