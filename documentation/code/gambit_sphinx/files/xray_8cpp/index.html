<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=https://rc1242rc.github.io/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://rc1242rc.github.io/fonts/vendor/jost/jost-v4-latin-500.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://rc1242rc.github.io/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><script>(()=>{var e=localStorage.getItem("theme");e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><link rel=stylesheet href=https://rc1242rc.github.io/main.1fa2debdf0a1b20e7268d11906902449af896197928a5bdae9dca95b629cdd73746db3d8c6afacb7320d9deb149a318c764669d08a1ddfd34a657ab2aeab866a.css integrity="sha512-H6LevfChsg5yaNEZBpAkSa+JYZeSilva6dypW2Kc3XN0bbPYxq+stzINnesUmjGMdkZp0Iod39NKZXqyrquGag==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>file src/Xray.cpp - GAMBIT</title><meta name=description content="[No description available]"><link rel=canonical href=https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/xray_8cpp/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="file src/Xray.cpp"><meta property="og:description" content="[No description available]"><meta property="og:url" content="https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/xray_8cpp/"><meta property="og:site_name" content="GAMBIT"><meta property="og:image" content="https://rc1242rc.github.io/gambit_logo.png"><meta property="og:image:alt" content="GAMBIT"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content><meta name=twitter:creator content><meta name=twitter:title content="file src/Xray.cpp"><meta name=twitter:description content="[No description available]"><meta name=twitter:image content="https://rc1242rc.github.io/gambit_logo.png"><meta name=twitter:image:alt content="file src/Xray.cpp"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://rc1242rc.github.io/#/schema/organization/1","name":"Doks","url":"https://rc1242rc.github.io/","sameAs":["https://github.com/GambitBSM"],"logo":{"@type":"ImageObject","@id":"https://rc1242rc.github.io/#/schema/image/1","url":"https://rc1242rc.github.io/logo-doks.png","width":450,"height":416,"caption":"Doks"},"image":{"@id":"https://rc1242rc.github.io/#/schema/image/1"}},{"@type":"WebSite","@id":"https://rc1242rc.github.io/#/schema/website/1","url":"https://rc1242rc.github.io/","name":"GAMBIT","description":"Documentation for the Global And Modular BSM Inference Tool","publisher":{"@id":"https://rc1242rc.github.io/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/xray_8cpp/","url":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/xray_8cpp/","name":"file src\/Xray.cpp","description":"[No description available]","isPartOf":{"@id":"https://rc1242rc.github.io/#/schema/website/1"},"about":{"@id":"https://rc1242rc.github.io/#/schema/organization/1"},"datePublished":"0001-01-01T00:00:00CET","dateModified":"0001-01-01T00:00:00CET","breadcrumb":{"@id":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/xray_8cpp/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/xray_8cpp/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/xray_8cpp/"]}]},{"@type":"BreadcrumbList","@id":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/xray_8cpp/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/","url":"https://rc1242rc.github.io/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/documentation/","url":"https://rc1242rc.github.io/documentation/","name":"Documentation"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/documentation/code/","url":"https://rc1242rc.github.io/documentation/code/","name":"Code"}},{"@type":"ListItem","position":4,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/","url":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/","name":"Gambit Sphinx"}},{"@type":"ListItem","position":5,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/","url":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/","name":"Files"}},{"@type":"ListItem","position":6,"item":{"@id":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/xray_8cpp/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/xray_8cpp/#/schema/image/2","url":"https://rc1242rc.github.io/gambit_logo.png","contentUrl":"https://rc1242rc.github.io/gambit_logo.png","caption":"file src\/Xray.cpp"}]}]}</script><meta name=theme-color content="#fff"><link rel=icon href=https://rc1242rc.github.io/favicon.ico sizes=any><link rel=icon type=image/svg+xml href=https://rc1242rc.github.io/favicon.svg><link rel=apple-touch-icon sizes=180x180 href=https://rc1242rc.github.io/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://rc1242rc.github.io/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://rc1242rc.github.io/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://rc1242rc.github.io/site.webmanifest></head><body class="documentation single light"><div class=sticky-top><div class=header-bar></div><header class="navbar navbar-expand-md navbar-light doks-navbar"><nav class="container-xxl flex-wrap flex-md-nowrap" aria-label="Main navigation"><a class="navbar-brand p-0 me-auto" href=https://rc1242rc.github.io/ aria-label=GAMBIT><img class=logo-light src=https://rc1242rc.github.io//images/gambit_logo.png width=50px>
<img class="logo-dark d-none" src=https://rc1242rc.github.io//images/gambit_logo.png width=50px>
GAMBIT</a>
<button class="btn btn-menu order-2 d-block d-lg-none" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasDoks aria-controls=offcanvasDoks aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><div class="offcanvas offcanvas-end border-0 py-lg-1" tabindex=-1 id=offcanvasDoks data-bs-backdrop=true aria-labelledby=offcanvasDoksLabel><div class="header-bar d-lg-none"></div><div class="offcanvas-header d-lg-none"><h2 class="h5 offcanvas-title ps-2" id=offcanvasDoksLabel><a class=text-dark href=/>GAMBIT</a></h2><button type=button class="btn-close text-reset me-2" data-bs-dismiss=offcanvas aria-label="Close main menu"></button></div><div class="offcanvas-body p-4 p-lg-0"><ul class="nav flex-column flex-lg-row align-items-lg-center mt-2 mt-lg-0 ms-lg-2 me-lg-auto"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Documentation
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/documentation/installation/introduction/>Installation</a></li><li><a class=dropdown-item href=/documentation/examples/colliderbit>Examples</a></li><li><a class=dropdown-item href=/documentation/help/faqs/>Help</a></li><li><a class=dropdown-item href=/documentation/code/index_classes>Code Reference</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Community
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/community/publications/>Publications</a></li><li><a class=dropdown-item href=/community/talks/>Talks</a></li><li><a class=dropdown-item href=/community/members/>Members</a></li><li><a class=dropdown-item href=/community/code_of_conduct/>Code of Conduct</a></li><li><a class=dropdown-item href=/community/contact/>Contact</a></li></ul></li></ul><hr class="text-black-50 my-4 d-lg-none"><form class="doks-search position-relative flex-grow-1 ms-lg-auto me-lg-2"><input id=search class="form-control is-search" type=search placeholder="Search site..." aria-label="Search site..." autocomplete=off><div id=suggestions class="shadow bg-white rounded d-none"></div></form><hr class="text-black-50 my-4 d-lg-none"><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=https://github.com/GambitBSM><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><small class="ms-2 d-lg-none">GitHub</small></a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn btn-doks-light dropdown-toggle" id=doks-versions data-bs-toggle=dropdown aria-expanded=false data-bs-display=static aria-label="Toggle version menu">
<span class=d-none>Doks</span>
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=doks-versions></ul></div></div></div></nav></header></div><div class="wrap container-xxl" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class=docs-links aria-label="Main navigation"><ul class="list-unstyled collapsible-sidebar"><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-installation aria-expanded=false>
Installation</button><div class=collapse id=section-installation><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/installation/introduction/>Getting Started</a></li><li><a class="docs-link rounded" href=/documentation/installation/docker_usage/>Docker Usage</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_linux/>Installation for Linux</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_windows/>Installation for Windows</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_macos/>Installation for macOS</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-examples aria-expanded=false>
Examples</button><div class=collapse id=section-examples><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/examples/colliderbit/>ColliderBit</a></li><li><a class="docs-link rounded" href=/documentation/examples/anotherbit/>AnotherBit</a></li><li><a class="docs-link rounded" href=/documentation/examples/anotherbit2/>AnotherBit2</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-help aria-expanded=false>
Help</button><div class=collapse id=section-help><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/help/faqs/>FAQs</a></li><li><a class="docs-link rounded" href=/documentation/help/compiler_matrix/>Compiler Matrix</a></li><li><a class="docs-link rounded" href=/documentation/help/known_issues/>Known Issues</a></li><li><a class="docs-link rounded" href=/documentation/help/configuration_examples/>Configuration Examples</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-code aria-expanded=false>
Code Reference</button><div class=collapse id=section-code><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/code/darkbit_development/index_classes/>Classes</a></li><li><a class="docs-link rounded" href=/documentation/code/darkbit_development/index_files/>Files</a></li><li><a class="docs-link rounded" href=/documentation/code/darkbit_development/index_pages/>Pages</a></li><li><a class="docs-link rounded" href=/documentation/code/darkbit_development/index_namespaces/>Namespaces</a></li></ul></div></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=d-xl-none><button class="btn btn-outline-primary btn-sm doks-toc-toggle collapsed" type=button data-bs-toggle=collapse data-bs-target=#onThisPage aria-controls=doks-docs-nav aria-expanded=false aria-label="Toggle On this page navigation">
<span>On this page</span>
<span><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"/><polyline points="7 6 12 11 17 6"/></svg><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"/><polyline points="17 18 12 13 7 18"/></svg></span></button><div class=collapse id=onThisPage><div class="card card-body mt-3 py-1"><div class=page-links><nav id=TableOfContents><ul><li><ul><li><a href=#detailed-description>Detailed Description</a></li><li><a href=#source-code>Source code</a></li></ul></li></ul></nav></div></div></div></div><div class="page-links d-none d-xl-block"><h3>On this page</h3><nav id=TableOfContents><ul><li><ul><li><a href=#detailed-description>Detailed Description</a></li><li><a href=#source-code>Source code</a></li></ul></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9 mx-xl-auto"><h1>file src/Xray.cpp</h1><p class=lead></p><p>[No description available] <a href=#detailed-description>More&mldr;</a></p><h2 id=detailed-description>Detailed Description <a href=#detailed-description class=anchor aria-hidden=true>#</a></h2><p><strong>Author</strong>:</p><ul><li>Patrick Stöcker (<a href=mailto:stoecker@physik.rwth-aachen.de>stoecker@physik.rwth-aachen.de</a>)</li><li>Iñigo Saez Casares (<a href=mailto:inigo.saez_casares@ens-paris-saclay.fr>inigo.saez_casares@ens-paris-saclay.fr</a>)</li></ul><p><strong>Date</strong>:</p><ul><li>2019 Sep</li><li>2021 April, May</li></ul><p>GAMBIT: Global and Modular BSM Inference Tool</p><hr><p>Xray likelihoods for DarkBit.</p><hr><p>Authors (add name and date if you modify):</p><hr><h2 id=source-code>Source code <a href=#source-code class=anchor aria-hidden=true>#</a></h2><pre><code>

// TODO: Temporarily disabled until project is ready
/*
#include &lt;gsl/gsl_math.h&gt;
#include &lt;gsl/gsl_spline.h&gt;
#include &lt;gsl/gsl_errno.h&gt;
#include &lt;gsl/gsl_monte_plain.h&gt;
#include &lt;gsl/gsl_rng.h&gt;
#include &lt;gsl/gsl_min.h&gt;

#include &quot;gambit/Elements/gambit_module_headers.hpp&quot;
#include &quot;gambit/Utils/ascii_table_reader.hpp&quot;
#include &quot;gambit/Utils/statistics.hpp&quot;

#include &quot;gambit/DarkBit/DarkBit_rollcall.hpp&quot;
#include &quot;gambit/DarkBit/DarkBit_utils.hpp&quot;

namespace Gambit
{
  namespace DarkBit
  {
    //      Auxillary functions and classes for interpolation      //

    // \brief Generic one-dimensional integration container for linear interpolation and cubic splines.

    // XrayInterpolator class: Provides a general 1-D interpolation container based on the gsl library.
    // Can be declared static for efficiency &amp; easy one-time initialisation of interpolating functions.
    // (This is the twin sibling of AxionInterpolator in DarkBit/src/Axions.cpp)
    class XrayInterpolator
    {
      public:
        // Overloaded class creators for the XrayInterpolator class using the init function below.
        XrayInterpolator();
        XrayInterpolator(const std::vector&lt;double&gt; x, const std::vector&lt;double&gt; y, std::string type);
        XrayInterpolator(const std::vector&lt;double&gt; x, const std::vector&lt;double&gt; y);
        XrayInterpolator(std::string file, std::string type);
        XrayInterpolator(std::string file);
        XrayInterpolator&amp; operator=(XrayInterpolator&amp;&amp;);
        // Destructor.
        ~XrayInterpolator();
        // Delete copy constructor and assignment operator to avoid shallow copies.
        XrayInterpolator(const XrayInterpolator&amp;) = delete;
        XrayInterpolator operator=(const XrayInterpolator&amp;) = delete;
        // Routine to access interpolated values.
        double interpolate(double x);
        // Routine to access upper and lower boundaries of available data.
        double lower();
        double upper();
      private:
        // Initialiser for the XrayInterpolator class.
        void init(std::string file, std::string type);
        void init(const std::vector&lt;double&gt; x, const std::vector&lt;double&gt; y, std::string type);
        // The gsl objects for the interpolating functions.
        gsl_interp_accel *acc;
        gsl_spline *spline;
        // Upper and lower boundaries available for the interpolating function.
        double lo;
        double up;
    };

    // Default constructor.
    XrayInterpolator::XrayInterpolator() {};

    // Initialiser for the XrayInterpolator class.
    void XrayInterpolator::init(const std::vector&lt;double&gt; x, const std::vector&lt;double&gt; y, std::string type)
    {
      int pts = x.size();
      // Get first and last value of the &quot;x&quot; component.
      lo = x.front();
      up = x.back();
      acc = gsl_interp_accel_alloc ();
      if (type == &quot;cspline&quot;)
      {
        spline = gsl_spline_alloc (gsl_interp_cspline, pts);
      }
      else if (type == &quot;linear&quot;)
      {
        spline = gsl_spline_alloc (gsl_interp_linear, pts);
      }
      else
      {
        DarkBit_error().raise(LOCAL_INFO, &quot;ERROR! Interpolation type '&quot;+type+&quot;' not known to class XrayInterpolator.\n       Available types: 'linear' and 'cspline'.&quot;);
      };

      gsl_spline_init (spline, &amp;x[0], &amp;y[0], pts);
    };

    // Overloaded class creators for the XrayInterpolator class using the init function above.
    XrayInterpolator::XrayInterpolator(const std::vector&lt;double&gt; x, const std::vector&lt;double&gt; y, std::string type) { init(x, y, type); };
    XrayInterpolator::XrayInterpolator(const std::vector&lt;double&gt; x, const std::vector&lt;double&gt; y) { init(x, y, &quot;linear&quot;); };

    // Initialiser for the XrayInterpolator class.
    void XrayInterpolator::init(std::string file, std::string type)
    {
      // Check if file exists.
      if (not(Utils::file_exists(file)))
      {
        DarkBit_error().raise(LOCAL_INFO, &quot;ERROR! File '&quot;+file+&quot;' not found!&quot;);
      } else {
        logger() &lt;&lt; LogTags::debug &lt;&lt; &quot;Reading data from file '&quot;+file+&quot;' and interpolating it with '&quot;+type+&quot;' method.&quot; &lt;&lt; EOM;
      };
      // Read numerical values from data file.
      ASCIItableReader tab (file);
      tab.setcolnames(&quot;x&quot;, &quot;y&quot;);

      // for (int idx=1; idx &lt; tab[&quot;x&quot;].size(); idx++)
      // {
      //   std::cout &lt;&lt; &quot;x[&quot; &lt;&lt; idx &lt;&lt; &quot;] = &quot; &lt;&lt; tab[&quot;x&quot;][idx] &lt;&lt; &quot;; dx = &quot; &lt;&lt; tab[&quot;x&quot;][idx] -tab[&quot;x&quot;][idx-1] &lt;&lt; std::endl;
      //   if (tab[&quot;x&quot;][idx] -tab[&quot;x&quot;][idx-1] &lt;= 0.0) std::cout &lt;&lt; &quot;OH NO&quot; &lt;&lt; std::endl;
      // }

      init(tab[&quot;x&quot;],tab[&quot;y&quot;],type);
    };

    // Overloaded class creators for the XrayInterpolator class using the init function above.
    XrayInterpolator::XrayInterpolator(std::string file, std::string type) { init(file, type); };
    XrayInterpolator::XrayInterpolator(std::string file) { init(file, &quot;linear&quot;); };

    // Move assignment operator
    XrayInterpolator&amp; XrayInterpolator::operator=(XrayInterpolator&amp;&amp; interp)
    {
      if(this != &amp;interp)
      {
        std::swap(acc,interp.acc);
        std::swap(spline,interp.spline);
        std::swap(lo,interp.lo);
        std::swap(up,interp.up);
      }
      return *this;
    }

    // Destructor
    XrayInterpolator::~XrayInterpolator()
    {
      gsl_spline_free (spline);
      gsl_interp_accel_free (acc);
    }

    // Routine to access interpolated values.
    double XrayInterpolator::interpolate(double x) { return gsl_spline_eval(spline, x, acc); };

    // Routines to return upper and lower boundaries of interpolating function
    double XrayInterpolator::lower() { return lo; };
    double XrayInterpolator::upper() { return up; };

    //               Xray likelihoods                 //
    // -- based on likehoods for sterile neutrinos -- //

    void compute_lnL_Xray_WISPy(double&amp; result)
    {
      using namespace Pipes::compute_lnL_Xray_WISPy;

      static XrayInterpolator WISPy_bound;
      static bool first = true;
      static std::pair&lt;double,double&gt; xlim;

      if (first)
      {
        WISPy_bound = std::move(XrayInterpolator(GAMBIT_DIR &quot;/DarkBit/data/WISPy_bound.dat&quot;,&quot;linear&quot;));
        xlim.first = WISPy_bound.lower();
        xlim.second = WISPy_bound.upper();
        first = false;
      }

      double t_universe = *Dep::age_universe; // Age of the Universe in seconds

      double logm = log10(*Param[&quot;mass&quot;]) + 9; // In &quot;DecayingDM_mixture&quot;, the mass is given in GeV. Need to convert it into eV
      double tau = *Param[&quot;lifetime&quot;];   // lifetime is already in untis of s. No tranformation needed.
      double frac = *Param[&quot;fraction&quot;];
      double BR_ph = *Param[&quot;BR_ph&quot;];

      if (logm &lt;= xlim.first || logm &gt;= xlim.second)
      {
        // Bound can only be applied if log10(mass) is within the range of the table.
        result = 0.0;
      }
      else
      {
        double tau_bound = pow(10.,WISPy_bound.interpolate(logm));
        bool excluded = ((1./frac)*exp(t_universe/tau)*BR_ph*tau &lt; tau_bound);
        result = (excluded ? -9.0 : 0.0);
      }
    }

    void compute_lnL_Xray_Integral_SPI_sterile_nu(double&amp; result)
    {
      using namespace Pipes::compute_lnL_Xray_Integral_SPI_sterile_nu;

      static XrayInterpolator sin2_2t_bound;
      static bool first = true;
      static std::pair&lt;double,double&gt; xlim;

      if (first)
      {
        sin2_2t_bound = std::move(XrayInterpolator(GAMBIT_DIR &quot;/DarkBit/data/Integral_sterile_nu_bound.dat&quot;,&quot;linear&quot;));
        xlim.first = sin2_2t_bound.lower();
        xlim.second = sin2_2t_bound.upper();
        first = false;
      }

      double t_universe = *Dep::age_universe; // Age of the Universe in seconds

      double mass = *Param[&quot;mass&quot;] * 1e6; // In &quot;DecayingDM_mixture&quot;, the mass is given in GeV. Need to convert it into keV
      double tau = *Param[&quot;lifetime&quot;];   // lifetime is already in untis of s. No tranformation needed.
      double frac = *Param[&quot;fraction&quot;];
      double BR_ph = *Param[&quot;BR_ph&quot;];

      if (mass &lt;= xlim.first || mass &gt;= xlim.second)
      {
        // Bound can only be applied if the mass is within the range of the table.
        result = 0.0;
      }
      else
      {
        double sin2_2t = sin2_2t_bound.interpolate(mass);
        double tau_bound = 2./1.36038e-32 * pow(1e10*sin2_2t,-1.)*pow(mass,-5.);
        bool excluded = ((1./frac)*exp(t_universe/tau)*BR_ph*tau &lt; tau_bound);
        result = (excluded ? -9.0 : 0.0);
      }
    }

    void compute_lnL_Xray_M31_sterile_nu(double&amp; result)
    {
      using namespace Pipes::compute_lnL_Xray_M31_sterile_nu;

      static XrayInterpolator sin2_2t_bound;
      static bool first = true;
      static std::pair&lt;double,double&gt; xlim;

      if (first)
      {
        sin2_2t_bound = std::move(XrayInterpolator(GAMBIT_DIR &quot;/DarkBit/data/M31_sterile_nu_bound.dat&quot;,&quot;linear&quot;));
        xlim.first = sin2_2t_bound.lower();
        xlim.second = sin2_2t_bound.upper();
        first = false;
      }

      double t_universe = *Dep::age_universe; // Age of the Universe in seconds

      double mass = *Param[&quot;mass&quot;] * 1e6; // In &quot;DecayingDM_mixture&quot;, the mass is given in GeV. Need to convert it into keV
      double tau = *Param[&quot;lifetime&quot;];   // lifetime is already in untis of s. No tranformation needed.
      double frac = *Param[&quot;fraction&quot;];
      double BR_ph = *Param[&quot;BR_ph&quot;];

      if (mass &lt;= xlim.first || mass &gt;= xlim.second)
      {
        // Bound can only be applied if the mass is within the range of the table.
        result = 0.0;
      }
      else
      {
        double sin2_2t = sin2_2t_bound.interpolate(mass);
        double tau_bound = 2./1.36038e-32 * pow(1e10*sin2_2t,-1.)*pow(mass,-5.);
        bool excluded = ((1./frac)*exp(t_universe/tau)*BR_ph*tau &lt; tau_bound);
        result = (excluded ? -9.0 : 0.0);
      }
    }

    void compute_lnL_Xray_NuSTAR_sterile_nu(double&amp; result)
    {
      using namespace Pipes::compute_lnL_Xray_NuSTAR_sterile_nu;

      static XrayInterpolator sin2_2t_bound;
      static bool first = true;
      static std::pair&lt;double,double&gt; xlim;

      if (first)
      {
        sin2_2t_bound = std::move(XrayInterpolator(GAMBIT_DIR &quot;/DarkBit/data/NuSTAR_sterile_nu_bound.dat&quot;,&quot;linear&quot;));
        xlim.first = sin2_2t_bound.lower();
        xlim.second = sin2_2t_bound.upper();
        first = false;
      }

      double t_universe = *Dep::age_universe; // Age of the Universe in seconds

      double mass = *Param[&quot;mass&quot;] * 1e6; // In &quot;DecayingDM_mixture&quot;, the mass is given in GeV. Need to convert it into keV
      double tau = *Param[&quot;lifetime&quot;];   // lifetime is already in untis of s. No tranformation needed.
      double frac = *Param[&quot;fraction&quot;];
      double BR_ph = *Param[&quot;BR_ph&quot;];

      if (mass &lt;= xlim.first || mass &gt;= xlim.second)
      {
        // Bound can only be applied if the mass is within the range of the table.
        result = 0.0;
      }
      else
      {
        double sin2_2t = sin2_2t_bound.interpolate(mass);
        double tau_bound = 2./1.36038e-32 * pow(1e10*sin2_2t,-1.)*pow(mass,-5.);
        bool excluded = ((1./frac)*exp(t_universe/tau)*BR_ph*tau &lt; tau_bound);
        result = (excluded ? -9.0 : 0.0);
      }
    }

    //------------- Numerical constants and other useful things -------------//

    // masses
    const double Mp = Gambit::m_planck; // Planck mass [GeV]

    // mathematical constants
    const double pi=Gambit::pi;

    // physical constants
    const double hbar_GeV = Gambit::hbar; // reduced Planck constant [GeV.s]
    const double cs = Gambit::s2cm; // speed of light [cm/s]
    const double Mpc_2_km = 3.0857e19; // Mpc to km

    // Minimum finite result returnable from log(double x);
    const double logmin = log(std::numeric_limits&lt;double&gt;::min());

    //         Support class to handle X-ray experiments              //

    //------------- Class declaration -------------//

    class Xray
    {
      public:

        Xray(std::string experiment, double J_factor);
        double solidAngle(std::vector&lt;double&gt; lRange, std::vector&lt;double&gt; bRange);
        void set_deltaOmega();
        double getDeltaOmega() const;
        double getJ() const;
        double getEmin() const;
        double getEmax() const;
        double getDeltaE() const;
        int getFluxOrigin() const;

        double flux(double const&amp; E);
        double sigma(double const&amp; E);
        double fluxIntegrated(double const&amp; E);
        double sigmaIntegrated(double const&amp; E);
        double deltaE(double const&amp; E);
        ~Xray();

      protected:

        double m_J; // astrophysical factor for the predicted photon flux from decaying DM
        double m_Emin; // minimum energy of the observations
        double m_Emax; // maximum energy of the observations
        double m_deltaOmega; // total solid angle of observation
        double m_deltaE; // energy resolution in percentage of the energy scale
        int m_fluxOrigin; // origin of observed flux: galactic (1), extra-galactic (2) or both (3)
        std::vector&lt;std::vector&lt;double&gt; &gt; m_lRange; // observation region in galactic coordinates (degrees)
        std::vector&lt;std::vector&lt;double&gt; &gt; m_bRange;
        std::string m_experiment;
        std::map&lt;std::string, int&gt; m_experimentMap;
    };

    // constructor
    Xray::Xray(std::string experiment, double J_factor) : m_J(J_factor), m_experiment(experiment), m_experimentMap({{&quot;INTEGRAL&quot;, 1}, {&quot;HEAO&quot;, 2}})
    {
      switch(m_experimentMap[m_experiment])
      {
        case 1 :
          m_Emin = 20e3;
          m_Emax = 2e6;
          m_lRange = { {-30., 30.} };
          m_bRange = { {-15., 15.} };
          m_deltaE = 8e3;
          m_deltaOmega = 0.542068;
          m_fluxOrigin = 1;
          break;

        case 2 :
          m_Emin = 3e3;
          m_Emax = 60e3;
          m_lRange = { {58., 109.}, {238., 289.} };
          m_bRange = { {-90., -20.}, {20., 90.} };
          m_deltaE = 0.3;
          m_deltaOmega = 1.17135;
          m_fluxOrigin = 3;
          break;

        default :
          throw std::runtime_error(&quot;Wrong experiment name in Xray object&quot;);
          break;
      }
      //set_deltaOmega();
    }

    //------------- Function returning the energy dispersion of the instrument -------------//

    double Xray::deltaE (double const&amp; E)
    {
      switch(m_experimentMap[m_experiment])
      {
        case 1 :
          return m_deltaE;
          break;

        case 2 :
          return m_deltaE*E;
          break;

        default :
          return 1.;
          break;
      }
    }

    // ----------- Functions to compute the solid angle of observation -------------//

    // auxiliary function for gsl integration
    double deltaOmega (double x[], size_t dim, void *p)
    {
      (void)(p);
      (void)(dim);
      return cos(x[1]);
    }

    // computes the solide angle for a given galactic coordinates range (in degrees)
    double Xray::solidAngle(std::vector&lt;double&gt; lRange, std::vector&lt;double&gt; bRange)
    {
      const size_t dim = 2, calls = 1e8;
      const double xl[dim] = {lRange[0]*pi/180., bRange[0]*pi/180.}, xu[dim] = {lRange[1]*pi/180., bRange[1]*pi/180.};
      double result, abserr;

      gsl_monte_plain_state *s = gsl_monte_plain_alloc(dim);
      gsl_monte_plain_init(s);
      gsl_rng *r = gsl_rng_alloc(gsl_rng_taus2);

      gsl_monte_function F;

      F.f = &amp;deltaOmega;
      F.dim = dim;
      F.params = 0;

      gsl_monte_plain_integrate(&amp;F, xl, xu, dim, calls, r, s, &amp;result, &amp;abserr);

      gsl_monte_plain_free(s);  

      return result;
    }

    // sets the total solid angle of observation for the experiment
    void Xray::set_deltaOmega()
    {
      double result(0);
      for (size_t i=0; i&lt;m_lRange.size(); ++i)
      {
        result += solidAngle(m_lRange[i], m_bRange[i]);
      }
      m_deltaOmega = result;
    }

    //------------- Functions to compute the photon flux and its standard deviation -------------//

    // differential photon flux [photons/keV/cm²/s]
    double Xray::flux(double const&amp; E)
    {
      switch(m_experimentMap[m_experiment])
      {
        case 1 :
          // return 4.8e-8*pow(E/100e3,-1.55) + 6.6e-8*exp(-(E-50e3)/7.5e3);
          return 1.6e-7*exp(-(E-50e3)/7.7e3) + 0.92e-7*pow(E/100e3, -1.79) + 0.34e-7*pow(E/100e3, -0.95)*exp(-(E-100e3)/3411e3) + 67.3e-7/E;
          break;

        case 2 :
          return 7.877*pow(10., 0.87)*pow(E, -0.29)*exp(-(E/41.13e3))/E*m_deltaOmega;
          break;

        default :
          return 0.;
          break;
      }
    }

    // auxiliary function for gsl integration
    double flux_gsl(double x, void *p)
    {
      Xray *experiment = static_cast&lt;Xray*&gt;(p);
      return experiment-&gt;flux(x);
    }

    const double int_factor(1.1); // integration range = int_factor*energy dispersion instrument

    double Xray::fluxIntegrated(double const&amp; E)
    {
      size_t n = 1e4;

      gsl_integration_workspace *w = gsl_integration_workspace_alloc(n);

      double epsabs = 0.;
      double epsrel = 1e-2;
      size_t limit = 1e3;
      double result, abserr;
      int key = 6;
      double delta = int_factor*deltaE(E);

      gsl_function F;
      F.function = &amp;flux_gsl;
      F.params = this;

      gsl_integration_qag(&amp;F, E-delta/2., E+delta/2., epsabs, epsrel, limit, key, w, &amp;result, &amp;abserr);

      gsl_integration_workspace_free(w);

      return result;
    }

    // standard deviation of the differential photon flux [photons/keV/cm²/s]
    double Xray::sigma(double const&amp; E)
    {

      switch(m_experimentMap[m_experiment])
      {
        case 1 :
          // return sqrt(pow(pow(E/100e3,-1.55),2)*pow(0.6e-5,2) + pow(4.8e-8*1.55*pow(E/100e3,-2.55),2)*pow(0.25,2) + exp(-2*(E-50e3)/7.5e3)*pow(0.5e-8, 2.) + pow(6.6e-8, 2.)*pow((E-50e3)/pow(7.5e3, 2.), 2.)*exp(-2*(E-50e3)/7.5e3)*pow(1e3, 2.));
          return sqrt( pow(14.6e-4/E, 2) + pow(1.6e-7*(E-50e3)/7.7e3, 2) * pow(0.7e3, 2) * exp(-2.*(E-50e3)/7.7e3) + pow(0.4e-7, 2) * exp(-2.*(E-50e3)/7.7e3) + pow(0.34e-7*pow(E/100e3, -0.95), 2) * pow((E-100e3)/3411e3, 2) * exp(-(E-100e3)/3411e3) * pow(2371e3, 2));
          break;

        case 2 :
          return (flux(E)*E/m_deltaOmega)*0.02*m_deltaOmega/E;
          break;

        default :
          return 0.;
          break;
      }
    }

    // auxiliary function for gsl integration
    double sigma_gsl (double x, void *p)
    {
      Xray *experiment = static_cast&lt;Xray*&gt;(p);
      return pow(experiment-&gt;sigma(x), 2.);
    }


    double Xray::sigmaIntegrated(double const&amp; E)
    {
      size_t n = 1e4;

      gsl_integration_workspace *w = gsl_integration_workspace_alloc(n);

      double epsabs = 0.;
      double epsrel = 1e-2;
      size_t limit = 1e3;
      double result, abserr;
      int key = 6;
      double delta = int_factor*deltaE(E);

      gsl_function F;
      F.function = &amp;sigma_gsl;
      F.params = this;

      gsl_integration_qag(&amp;F, E-delta/2., E+delta/2., epsabs, epsrel, limit, key, w, &amp;result, &amp;abserr);

      gsl_integration_workspace_free(w);

      return result;
    }

    //------------- Elevator functions -------------// 

    double Xray::getDeltaOmega() const { return m_deltaOmega; }

    double Xray::getJ() const { return m_J; }

    double Xray::getEmin() const { return m_Emin; }

    double Xray::getEmax() const { return m_Emax; }

    double Xray::getDeltaE() const { return m_deltaE; }

    int Xray::getFluxOrigin() const { return m_fluxOrigin; }

    // destructor
    Xray::~Xray() { }

    //------------- Functions to compute the age of the Universe at a given redshift -------------//

    // useful structure
    struct cosmology_params {double OmegaM; double OmegaR; double OmegaLambda; double H0;};

    // auxiliary function for gsl integration
    double age_f (double x, void *p)
    {
      cosmology_params *params = static_cast&lt;cosmology_params*&gt;(p);
      double OmegaM = params-&gt;OmegaM;
      double OmegaLambda = params-&gt;OmegaLambda;
      double OmegaR = params-&gt;OmegaR;
      double OmegaK = 0.;

      return 1./sqrt( OmegaM*pow(1+x, 5.) + OmegaLambda*pow(1+x, 2.) + OmegaK*pow(1+x, 4.) + OmegaR*pow(1+x, 6.) );
    }

    // computes the age of the Universe at a given redshift ([0] age, [1] abserr)
    std::vector&lt;double&gt; ageUniverse (double redshift, double OmegaM, double OmegaR, double OmegaLambda, double H0)
    {
      size_t n = 1e4; 

      gsl_integration_workspace *w =  gsl_integration_workspace_alloc(n);

      double epsabs = 0.;
      double epsrel = 1e-3;
      size_t limit = 1e3;
      double result, abserr;

      cosmology_params params = {OmegaM, OmegaR, OmegaLambda, H0};

      gsl_function F;
      F.function = &amp;age_f;
      F.params = &amp;params;

      gsl_integration_qagiu(&amp;F, redshift, epsabs, epsrel, limit, w, &amp;result, &amp;abserr);

      gsl_integration_workspace_free(w);

      return {result/H0, abserr/H0};
    }

    //------------- Functions to compute X-ray likelihoods -------------//


    // useful structure
    struct XrayLikelihood_params {double mass; double tau; double gamma_ph; double fraction; Xray experiment; double OmegaDM; daFunk::Funk H_z; daFunk::Funk t_z; double ageUniverse;};

    // extra-galactic contribution to the differential photon flux [photons/eV/cm²/s]
    double dPhiEG(double const&amp; E, XrayLikelihood_params *params)
    {
      double mass = params-&gt;mass; 
      double x = mass/2./E;
      double z = x - 1.;

      if (z&lt;0) { return 0.; }

      else
      {
      Xray experiment = params-&gt;experiment;

      double tau = params-&gt;tau, gamma_ph = params-&gt;gamma_ph, fraction = params-&gt;fraction;
      double OmegaDM = params-&gt;OmegaDM;

      daFunk::Funk H_z = params-&gt;H_z;
      boost::shared_ptr&lt;daFunk::FunkBound&gt; H_z_bound = H_z-&gt;bind(&quot;z&quot;);

      double H0 = H_z_bound-&gt;eval(0)/Mpc_2_km; // H0 in 1/s
      double rhoC = 3*pow(H0, 2)*pow(Mp, 2)/(8*pi)/hbar_GeV/pow(cs, 3)*1e9; // critical density un ev/cm^3
      double density = fraction*OmegaDM*rhoC;
      double H = H_z_bound-&gt;eval(x)/Mpc_2_km; // H(x) in 1/s

      daFunk::Funk t_z = params-&gt;t_z;
      boost::shared_ptr&lt;daFunk::FunkBound&gt; t_z_bound = t_z-&gt;bind(&quot;z&quot;);

      double t = t_z_bound-&gt;eval(z);

      return experiment.getDeltaOmega()*2.*1./(4*pi)*(gamma_ph*density*cs*exp(-t/tau))/(mass*E)/H;
      }
    }

    const double s(1./3.); // standard deviation of the gaussian for the galactic emission line = s*energy dispersion instrument

    // galactic (Milky Way) contribution to the differential photon flux [photons/eV/cm²/s]
    double dPhiG(double const&amp; E, XrayLikelihood_params *params)
    {
      double mass = params-&gt;mass, tau = params-&gt;tau, gamma_ph = params-&gt;gamma_ph, fraction = params-&gt;fraction;
      Xray experiment = params-&gt;experiment;

      double J = experiment.getJ();

      double t0 = params-&gt;ageUniverse;

      double sigma = s*experiment.deltaE(E); // standard deviation of the gaussian modelling the enery dispersion of the instrument

      return 2.*(gamma_ph*J*fraction*exp(-t0/tau))/(4.*pi*mass)/sqrt(2*pi*sigma*sigma)*exp(-pow(E-mass/2.,2)/(2*sigma*sigma));
    }

    // total predicted differential photon flux for a given X-ray experiment [photons/eV/cm²/s]
    double XrayPrediction(double const&amp; E, XrayLikelihood_params *params)
    {
      Xray experiment = params-&gt;experiment;
      switch(experiment.getFluxOrigin())
      {
        case 1 :
          return dPhiG(E, params);

        case 2 :
          return dPhiEG(E, params);

        case 3 :
          return dPhiG(E, params) + dPhiEG(E, params);

        default :
          throw std::runtime_error(&quot;Wrong value for m_fluxOrigin in Xray class, allowed values are 1 (galactic flux), 2 (extra-galactic flux) and 3 (both)&quot;);
          break;
      }
    }

    // auxiliary function for gsl integration
    double XrayPredictionIntegrated_gsl(double x, void *p)
    {
      XrayLikelihood_params *params = static_cast&lt;XrayLikelihood_params*&gt;(p);

      return XrayPrediction(x, params);
    }

    // total predicted photon flux integrated over an interval deltaE, centered around E [photons/cm²/s]
    double XrayPredictionIntegrated(double const&amp; E, XrayLikelihood_params *params)
    {
      size_t n = 1e4;

      gsl_integration_workspace *w =  gsl_integration_workspace_alloc(n);

      double epsabs = 0.;
      double epsrel = 1e-2;
      size_t limit = 1e3;
      double result, abserr;
      int key = 6;
      Xray experiment = params-&gt;experiment;
      double delta = int_factor*experiment.deltaE(E);

      gsl_function F;
      F.function = &amp;XrayPredictionIntegrated_gsl;
      F.params = params;

      gsl_integration_qag(&amp;F, E-delta/2., E+delta/2., epsabs, epsrel, limit, key, w, &amp;result, &amp;abserr);

      gsl_integration_workspace_free(w);

      return result;
    }

    // auxiliary function for gsl minimization returning the log-likelihood for a given X-ray experiment
    double XrayLogLikelihood(double E, void *p)
    {
      XrayLikelihood_params *params = static_cast&lt;XrayLikelihood_params*&gt;(p);
      Xray experiment = params-&gt;experiment;

      double data = experiment.fluxIntegrated(E);
      double sigma = experiment.sigmaIntegrated(E);
      double prediction = XrayPredictionIntegrated(E, params);

      return (prediction&gt;=data) ? -pow(data-prediction,2.)/(2.*sigma*sigma) : 0.;
    }

    // computes the energy E which minimizes the log-likelihood
    double minimizeLogLikelihood(XrayLikelihood_params *params)
    {
      int status;
      int iter = 0, max_iter = 100;
      const gsl_min_fminimizer_type *T;
      gsl_min_fminimizer *s;
      Xray experiment = params-&gt;experiment;
      double mass = params-&gt;mass;
      double Emin = experiment.getEmin(), Emax = experiment.getEmax();
      double a = Emin+experiment.deltaE(Emin), b = fmin(mass/2., Emax-experiment.deltaE(Emax));
      double m = (a+b)/2.;
      gsl_function F;

      F.function = &amp;XrayLogLikelihood;
      F.params = params;
      T = gsl_min_fminimizer_brent;
      s = gsl_min_fminimizer_alloc(T);
      gsl_min_fminimizer_set (s, &amp;F, m, a, b);

      do
      {
        iter++;
        status = gsl_min_fminimizer_iterate (s);

        m = gsl_min_fminimizer_x_minimum (s);
        a = gsl_min_fminimizer_x_lower (s);
        b = gsl_min_fminimizer_x_upper (s);

        status = gsl_min_test_interval (a, b, 0.1, 0);
      } while (status == GSL_CONTINUE &amp;&amp; iter &lt; max_iter);

      gsl_min_fminimizer_free (s);

      return m;
    }

    // Linear interpolation in lin-log space.
    double interpolate(double x, const std::vector&lt;double&gt; &amp; xlist,
            const std::vector&lt;double&gt; &amp; ylist, bool zerobound)
    {
        double x0, x1, y0, y1;
        int i = 1;
        if (zerobound)
        {
            if (x&lt;xlist.front()) return 0;
            if (x&gt;xlist.back()) return 0;
        }
        else
        {
            if (x&lt;xlist.front()) return ylist.front();
            if (x&gt;xlist.back()) return ylist.back();
        }
        // Find min i such that xlist[i]&gt;=x.
        for (; xlist[i] &lt; x; i++) {};
        x0 = xlist[i-1];
        x1 = xlist[i];
        y0 = ylist[i-1];
        y1 = ylist[i];
        // lin-vs-log interpolation for lnL vs flux
        return y0 + (y1-y0) * log(x/x0) / log(x1/x0);
    }

    void get_J_factor_INTEGRAL_CO (double &amp;result)
    {
      using namespace Pipes::get_J_factor_INTEGRAL_CO;

      GalacticHaloProperties halo = *Dep::GalacticHalo;

      daFunk::Funk profile = halo.DensityProfile;

      std::vector&lt;double&gt; rho;
      auto r = daFunk::logspace(-3, 2, 100);
      double r_sun = halo.r_sun;

      for ( size_t i = 0; i&lt;r.size(); i++ )
      {
        rho.push_back(profile-&gt;bind(&quot;r&quot;)-&gt;eval(r[i]));
      }

      std::vector&lt;double&gt; phi_pre;
      std::vector&lt;double&gt; intensity;

      BEreq::los_integral(byVal(r), byVal(rho), byVal(r_sun), phi_pre, intensity);

      auto emission = std::pair&lt; std::vector&lt;double&gt;, std::vector&lt;double&gt; &gt; (phi_pre, intensity);

      ASCIItableReader ROI = ASCIItableReader(GAMBIT_DIR &quot;/DarkBit/data/INTEGRAL/ROI_CO.txt&quot;);
      ROI.setcolnames({&quot;phi&quot;, &quot;weight&quot;});
      std::vector&lt;double&gt; phi = ROI[&quot;phi&quot;], weight = ROI[&quot;weight&quot;];

      double J = 0;
      for ( size_t i = 0; i &lt; phi.size(); i++ )
      {
        J += interpolate(phi[i], emission.first, emission.second, true)*weight[i]*3.0856775814913684e21;// J in Gev/cm^2
      }

      result = J;
    }

    // gsl error handler
    void handler (const char * reason, const char * file, int line, int gsl_errno)
    {
      if (gsl_errno == 4)
      {
        throw gsl_errno;
      }
      else { std::cerr &lt;&lt; &quot;gsl: &quot; &lt;&lt; file &lt;&lt; &quot;:&quot; &lt;&lt; line &lt;&lt; &quot;: ERROR: &quot; &lt;&lt; reason &lt;&lt; std::endl; abort(); }
    }

    // capability function to compute the X-ray log-likelihood from the INTEGRAL experiment
    void calc_lnL_INTEGRAL_CO(double &amp;result)
    {
      using namespace Pipes::calc_lnL_INTEGRAL_CO;

      double tau = *Param[&quot;lifetime&quot;];

      double gamma_ph = 1/tau * *Param[&quot;BR_ph&quot;];

      double mass = *Param[&quot;mass&quot;]*1e9; // mass in eV

      double fraction = *Param[&quot;fraction&quot;];

      double t0 = *Dep::age_universe;

      double J_factor = *Dep::J_factor_INTEGRAL_CO*1e9; //J in eV/cm^2

      static Xray experiment = Xray(&quot;INTEGRAL&quot;, J_factor);

      XrayLikelihood_params params = {mass, tau, gamma_ph, fraction, experiment, 0., daFunk::zero(&quot;z&quot;), daFunk::zero(&quot;z&quot;), t0};

      double Emin = experiment.getEmin(), Emax = experiment.getEmax(), E, lik1, lik2;

      // no constraints available above the electron threshold, we need to take into account the decay into charged particles
      if (mass &gt;= 1e6) { result = 0; }

      else if (mass &gt; 2.*Emin)
      {
        // modifies the gsl error handler and stores the default one
        gsl_error_handler_t *old_handler = gsl_set_error_handler (&amp;handler);
        try
        {
          E = minimizeLogLikelihood(&amp;params);
          result = XrayLogLikelihood(E, &amp;params);
        }

        catch (int gsl_errno)
        {
          lik1 = XrayLogLikelihood(Emin+experiment.deltaE(Emin), &amp;params);
          lik2 = XrayLogLikelihood(fmin(mass/2., Emax-experiment.deltaE(Emax)), &amp;params);
          result = fmin(lik1, lik2);
        }
        // restores the default gsl error handler
        gsl_set_error_handler (old_handler);
      }

      else { result = 0; }
    }

    // function returning the decay photon flux in [photons/cm²/s] (assuming DM decays into a monochromatic line)
    // only used for the INTEGRAL_ang_b/l likelihoods
    double DecayFluxG (double gamma_ph, double fraction, double mass, double tau, double t0, double J_factor)
    {
      return 2.*(gamma_ph*fraction*exp(-t0/tau))/(4.*pi*mass)*J_factor;
    }

    void get_J_factor_INTEGRAL_ang_b (std::vector&lt;double&gt; &amp;result)
    {
      using namespace Pipes::get_J_factor_INTEGRAL_ang_b;

      GalacticHaloProperties halo = *Dep::GalacticHalo;

      daFunk::Funk profile = halo.DensityProfile;

      std::vector&lt;double&gt; rho;
      auto r = daFunk::logspace(-3, 2, 100);
      double r_sun = halo.r_sun;

      for ( size_t i = 0; i&lt;r.size(); i++ )
      {
        rho.push_back(profile-&gt;bind(&quot;r&quot;)-&gt;eval(r[i]));
      }

      std::vector&lt;double&gt; phi_pre;
      std::vector&lt;double&gt; intensity;

      BEreq::los_integral(byVal(r), byVal(rho), byVal(r_sun), phi_pre, intensity);

      auto emission = std::pair&lt; std::vector&lt;double&gt;, std::vector&lt;double&gt; &gt; (phi_pre, intensity);

      ASCIItableReader ROI_1 = ASCIItableReader(GAMBIT_DIR &quot;/DarkBit/data/INTEGRAL/ROI_ang_b_1.txt&quot;);
      ASCIItableReader ROI_2 = ASCIItableReader(GAMBIT_DIR &quot;/DarkBit/data/INTEGRAL/ROI_ang_b_2.txt&quot;);

      ROI_1.setcolnames({&quot;phi&quot;, &quot;weight&quot;});
      ROI_2.setcolnames({&quot;phi&quot;, &quot;weight&quot;});

      std::vector&lt;double&gt; phi_1 = ROI_1[&quot;phi&quot;], weight_1 = ROI_1[&quot;weight&quot;];
      std::vector&lt;double&gt; phi_2 = ROI_2[&quot;phi&quot;], weight_2 = ROI_2[&quot;weight&quot;];

      double J_1 = 0, J_2 = 0;

      for ( size_t i = 0; i &lt; phi_1.size(); i++ )
      {
        J_1 += interpolate(phi_1[i], emission.first, emission.second, true)*weight_1[i]*3.0856775814913684e21; // J in Gev/cm^2
      }

      for ( size_t i = 0; i &lt; phi_2.size(); i++ )
      {
        J_2 += interpolate(phi_2[i], emission.first, emission.second, true)*weight_2[i]*3.0856775814913684e21; // J in Gev/cm^2
      }

      result = {J_1, J_2};
    }

    void calc_lnL_INTEGRAL_ang_b (double &amp;result)
    {
      using namespace Pipes::calc_lnL_INTEGRAL_ang_b;

      double tau = *Param[&quot;lifetime&quot;];

      double gamma_ph = 1/tau * *Param[&quot;BR_ph&quot;];

      double mass = *Param[&quot;mass&quot;]; // mass in GeV

      double mass_keV = mass*1e6; // mass in keV

      double fraction = *Param[&quot;fraction&quot;];

      double t0 = *Dep::age_universe; // Age of the Universe in seconds

      std::vector&lt;double&gt; J_factor = *Dep::J_factor_INTEGRAL_ang_b;

      double FluxG = DecayFluxG(gamma_ph, fraction, mass, tau, t0, J_factor[0]);

      static ASCIItableReader INTEGRAL = ASCIItableReader(GAMBIT_DIR &quot;/DarkBit/data/INTEGRAL/INTEGRAL_b.dat&quot;);

      INTEGRAL.setcolnames({&quot;Emin&quot;, &quot;Emax&quot;, &quot;Flux&quot;, &quot;Sigma&quot;});

      static std::vector&lt;double&gt; Emin = INTEGRAL[&quot;Emin&quot;], Emax = INTEGRAL[&quot;Emax&quot;], Flux = INTEGRAL[&quot;Flux&quot;], Sigma = INTEGRAL[&quot;Sigma&quot;];

      std::vector&lt;double&gt; Omega = {1.6119, 4.1858};

      // no constraints available above the electron threshold, we need to take into account the decay into charged particles
      if (mass_keV &gt;= 1e3) { result = 0; }

      else if (mass_keV &lt; 2.**std::min_element(Emin.begin(), Emin.end())) { result = 0; }

      else
      {
        double loglik = 0.;

        double PredictedFlux, ObservedFlux, Error;

        for (size_t i = 0; i &lt; Emin.size()-1; ++i)
        {
          PredictedFlux = ( (mass_keV &gt;= 2*Emin[i]) &amp;&amp; (mass_keV &lt; 2*Emax[i]) ) ? FluxG/Omega[0] : 0;
          ObservedFlux = Flux[i];
          Error = Sigma[i];
          loglik += (PredictedFlux &lt; ObservedFlux) ? 0 : -pow(ObservedFlux - PredictedFlux, 2)/(2.*pow(Error, 2));
        }

        result = loglik;
      }
    }

    void get_J_factor_INTEGRAL_ang_l (std::vector&lt;double&gt; &amp;result)
    {
      using namespace Pipes::get_J_factor_INTEGRAL_ang_l;

      GalacticHaloProperties halo = *Dep::GalacticHalo;

      daFunk::Funk profile = halo.DensityProfile;

      std::vector&lt;double&gt; rho;
      auto r = daFunk::logspace(-3, 2, 100);
      double r_sun = halo.r_sun;

      for ( size_t i = 0; i&lt;r.size(); i++ )
      {
        rho.push_back(profile-&gt;bind(&quot;r&quot;)-&gt;eval(r[i]));
      }

      std::vector&lt;double&gt; phi_pre;
      std::vector&lt;double&gt; intensity;

      BEreq::los_integral(byVal(r), byVal(rho), byVal(r_sun), phi_pre, intensity);

      auto emission = std::pair&lt; std::vector&lt;double&gt;, std::vector&lt;double&gt; &gt; (phi_pre, intensity);

      ASCIItableReader ROI_1 = ASCIItableReader(GAMBIT_DIR &quot;/DarkBit/data/INTEGRAL/ROI_ang_l_1.txt&quot;);
      ASCIItableReader ROI_2 = ASCIItableReader(GAMBIT_DIR &quot;/DarkBit/data/INTEGRAL/ROI_ang_l_2.txt&quot;);

      ROI_1.setcolnames({&quot;phi&quot;, &quot;weight&quot;});
      ROI_2.setcolnames({&quot;phi&quot;, &quot;weight&quot;});

      std::vector&lt;double&gt; phi_1 = ROI_1[&quot;phi&quot;], weight_1 = ROI_1[&quot;weight&quot;];
      std::vector&lt;double&gt; phi_2 = ROI_2[&quot;phi&quot;], weight_2 = ROI_2[&quot;weight&quot;];

      double J_1 = 0, J_2 = 0;

      for ( size_t i = 0; i &lt; phi_1.size(); i++ )
      {
        J_1 += interpolate(phi_1[i], emission.first, emission.second, true)*weight_1[i]*3.0856775814913684e21; // J in Gev/cm^2
      }

      for ( size_t i = 0; i &lt; phi_2.size(); i++ )
      {
        J_2 += interpolate(phi_2[i], emission.first, emission.second, true)*weight_2[i]*3.0856775814913684e21; // J in Gev/cm^2
      }

      result = {J_1, J_2};
    }

    void calc_lnL_INTEGRAL_ang_l (double &amp;result)
    {
      using namespace Pipes::calc_lnL_INTEGRAL_ang_l;

      double tau = *Param[&quot;lifetime&quot;];

      double gamma_ph = 1/tau * *Param[&quot;BR_ph&quot;];

      double mass = *Param[&quot;mass&quot;]; // mass in GeV

      double mass_keV = mass*1e6; // mass in keV

      double fraction = *Param[&quot;fraction&quot;];

      double t0 = *Dep::age_universe; // Age of the Universe in seconds

      std::vector&lt;double&gt; J_factor = *Dep::J_factor_INTEGRAL_ang_l;

      double FluxG = DecayFluxG(gamma_ph, fraction, mass, tau, t0, J_factor[0]);

      static ASCIItableReader INTEGRAL = ASCIItableReader(GAMBIT_DIR &quot;/DarkBit/data/INTEGRAL/INTEGRAL_l.dat&quot;);

      INTEGRAL.setcolnames({&quot;Emin&quot;, &quot;Emax&quot;, &quot;Flux&quot;, &quot;Sigma&quot;});

      static std::vector&lt;double&gt; Emin = INTEGRAL[&quot;Emin&quot;], Emax = INTEGRAL[&quot;Emax&quot;], Flux = INTEGRAL[&quot;Flux&quot;], Sigma = INTEGRAL[&quot;Sigma&quot;];

      std::vector&lt;double&gt; Omega = {1.4224, 1.7919};

      // no constraints available above the electron threshold, we need to take into account the decay into charged particles
      if (mass_keV &gt;= 1e3) { result = 0; }

      else if (mass_keV &lt; 2.**std::min_element(Emin.begin(), Emin.end())) { result = 0; }

      else
      {
        double loglik = 0.;

        double PredictedFlux, ObservedFlux, Error;

        for (size_t i = 0; i &lt; Emin.size()-1; ++i)
        {
          PredictedFlux = ( (mass_keV &gt;= 2*Emin[i]) &amp;&amp; (mass_keV &lt; 2*Emax[i]) ) ? FluxG/Omega[0] : 0;
          ObservedFlux = Flux[i];
          Error = Sigma[i];
          loglik += (PredictedFlux &lt; ObservedFlux) ? 0 : -pow(ObservedFlux - PredictedFlux, 2)/(2.*pow(Error, 2));
        }

        result = loglik;
      }
    }

    // for some reason this is not giving the correct value of J, need to fix it!
    void get_J_factor_HEAO (double &amp;result)
    {
      using namespace Pipes::get_J_factor_HEAO;

      GalacticHaloProperties halo = *Dep::GalacticHalo;

      daFunk::Funk profile = halo.DensityProfile;

      std::vector&lt;double&gt; rho;
      auto r = daFunk::logspace(-3, 2, 100);
      double r_sun = halo.r_sun;

      for ( size_t i = 0; i&lt;r.size(); i++ )
      {
        rho.push_back(profile-&gt;bind(&quot;r&quot;)-&gt;eval(r[i]));
        // rho.push_back(pow(profile-&gt;bind(&quot;r&quot;)-&gt;eval(r[i]), 2));
      }

      std::vector&lt;double&gt; phi_pre;
      std::vector&lt;double&gt; intensity;

      BEreq::los_integral(byVal(r), byVal(rho), byVal(r_sun), phi_pre, intensity);

      auto emission = std::pair&lt; std::vector&lt;double&gt;, std::vector&lt;double&gt; &gt; (phi_pre, intensity);

      ASCIItableReader ROI = ASCIItableReader(GAMBIT_DIR &quot;/DarkBit/data/HEAO/ROI.txt&quot;);
      ROI.setcolnames({&quot;phi&quot;, &quot;weight&quot;});
      std::vector&lt;double&gt; phi = ROI[&quot;phi&quot;], weight = ROI[&quot;weight&quot;];

      double J = 0;
      for ( size_t i = 0; i &lt; phi.size(); i++ )
      {
        J += interpolate(phi[i], emission.first, emission.second, true)*weight[i]*3.0856775814913684e21;// J in Gev/cm^2
      }

      result = J;

      // std::cout &lt;&lt; &quot;J = &quot; &lt;&lt; result/r_sun/rho_sun &lt;&lt; std::endl;
    }

    void calc_lnL_HEAO(double &amp;result)
    {
      using namespace Pipes::calc_lnL_HEAO;

      double OmegaDM = *Dep::Omega0_cdm;
      
      daFunk::Funk H_z = *Dep::H_at_z;
      daFunk::Funk t_z = *Dep::time_at_z;

      double tau = *Param[&quot;lifetime&quot;];

      double gamma_ph = 1/tau * *Param[&quot;BR_ph&quot;];

      double mass = *Param[&quot;mass&quot;]*1e9; // mass in eV

      double fraction = *Param[&quot;fraction&quot;];

      double t0 = *Dep::age_universe;

      static Xray experiment = Xray(&quot;HEAO&quot;, 9.894*1e9*3.0856775814913684e21); // J in ev / cm^2

      XrayLikelihood_params params = {mass, tau, gamma_ph, fraction, experiment, OmegaDM, H_z, t_z, t0};

      const double Emin = experiment.getEmin(), Emax = experiment.getEmax();
      double E, lik1, lik2;

      // no constraints available above the electron threshold, we need to take into account the decay into charged particles
      if (mass &gt;= 1e6) { result = 0; }

      else if (mass &gt; 2.*Emin)
      {
        // modifies the gsl error handler and stores the default one
        gsl_error_handler_t *old_handler = gsl_set_error_handler (&amp;handler);
        try
        {
          E = minimizeLogLikelihood(&amp;params);
          result = XrayLogLikelihood(E, &amp;params);
        }

        catch (int gsl_errno)
        {
          lik1 = XrayLogLikelihood(Emin+experiment.deltaE(Emin), &amp;params);
          lik2 = XrayLogLikelihood(fmin(mass/2., Emax-experiment.deltaE(Emax)), &amp;params);
          result = fmin(lik1, lik2);
        }
        // restores the default gsl error handler
        gsl_set_error_handler (old_handler);
      }

      else { result = 0; }
    }
  }
}
*/
</code></pre><hr><p>Updated on 2022-08-01 at 17:31:49 +0000</p><div class=edit-page><a href=https://github.com/RC1242RC/gambit_gh_pages/blob/master/content/en/documentation/code/gambit_sphinx/Files/Xray_8cpp.md><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828.0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>Edit this page on GitHub</a></div></main></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Powered by <a class=text-muted href=https://www.netlify.com/>Netlify</a>, <a class=text-muted href=https://gohugo.io/>Hugo</a>, and <a class=text-muted href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline><li class=list-inline-item><a href=/license/>License</a></li></ul></div></div></div></footer><script src=/js/bootstrap.min.54bf0932b8a36d0e152b1635b099a6ef1394d35327e2437550a075c9c8ed1bd8aed5847c21b36fc02ed24014c031d9ca24017b0c78b1639d7e2fa8329898b842.js integrity="sha512-VL8JMrijbQ4VKxY1sJmm7xOU01Mn4kN1UKB1ycjtG9iu1YR8IbNvwC7SQBTAMdnKJAF7DHixY51+L6gymJi4Qg==" crossorigin=anonymous defer></script>
<script src=/js/highlight.min.5b48bc253dc75aeea5fb366ecf700f4925e2b6eb1a1466f2124b722d68148d67bc0a9365d2b8ad9c585161b46372d23b08509a16f1fd518542b894756d4752d0.js integrity="sha512-W0i8JT3HWu6l+zZuz3APSSXitusaFGbyEktyLWgUjWe8CpNl0ritnFhRYbRjctI7CFCaFvH9UYVCuJR1bUdS0A==" crossorigin=anonymous defer></script>
<script src=/main.min.40265e9a032aeba5eaf67baac3cbbc22667a7533215d326eeb3e9f4d5e4be40f9ff4dcd22949db73ae527ca26a19d7998091a8973c82af760b2c0daa335190ed.js integrity="sha512-QCZemgMq66Xq9nuqw8u8ImZ6dTMhXTJu6z6fTV5L5A+f9NzSKUnbc65SfKJqGdeZgJGolzyCr3YLLA2qM1GQ7Q==" crossorigin=anonymous defer></script>
<script src=https://rc1242rc.github.io/index.min.ce44f6e5f0bdb9c5095744a1780684199908cc39877fab7f65dc16af9ecaf70559085ca2435c1013cd4c4e5445a1bfd74fa91b9ae55c1db737cc8557ad7bf689.js integrity="sha512-zkT25fC9ucUJV0SheAaEGZkIzDmHf6t/ZdwWr57K9wVZCFyiQ1wQE81MTlRFob/XT6kbmuVcHbc3zIVXrXv2iQ==" crossorigin=anonymous defer></script></body></html>