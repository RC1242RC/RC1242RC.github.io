<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=https://rc1242rc.github.io/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://rc1242rc.github.io/fonts/vendor/jost/jost-v4-latin-500.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://rc1242rc.github.io/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><script>(()=>{var e=localStorage.getItem("theme");e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><link rel=stylesheet href=https://rc1242rc.github.io/main.f12f7e04ea768acebec10c86baf049d74d6a79f24bc0dfb7ed77aa60462432916dd1ce8f41c78b69496adf650b3039a28a210183cce598f09b95d6fecb5ff999.css integrity="sha512-8S9+BOp2is6+wQyGuvBJ101qefJLwN+37XeqYEYkMpFt0c6PQceLaUlq32ULMDmiiiEBg8zlmPCbldb+y1/5mQ==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>file frontends/SPheno_4_0_3.cpp - GAMBIT</title><meta name=description content="[No description available]"><link rel=canonical href=https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/spheno__4__0__3_8cpp/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="file frontends/SPheno_4_0_3.cpp"><meta property="og:description" content="[No description available]"><meta property="og:url" content="https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/spheno__4__0__3_8cpp/"><meta property="og:site_name" content="GAMBIT"><meta property="og:image" content="https://rc1242rc.github.io/gambit_logo.png"><meta property="og:image:alt" content="GAMBIT"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content><meta name=twitter:creator content><meta name=twitter:title content="file frontends/SPheno_4_0_3.cpp"><meta name=twitter:description content="[No description available]"><meta name=twitter:image content="https://rc1242rc.github.io/gambit_logo.png"><meta name=twitter:image:alt content="file frontends/SPheno_4_0_3.cpp"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://rc1242rc.github.io/#/schema/organization/1","name":"Doks","url":"https://rc1242rc.github.io/","sameAs":["https://github.com/GambitBSM"],"logo":{"@type":"ImageObject","@id":"https://rc1242rc.github.io/#/schema/image/1","url":"https://rc1242rc.github.io/logo-doks.png","width":450,"height":416,"caption":"Doks"},"image":{"@id":"https://rc1242rc.github.io/#/schema/image/1"}},{"@type":"WebSite","@id":"https://rc1242rc.github.io/#/schema/website/1","url":"https://rc1242rc.github.io/","name":"GAMBIT","description":"Documentation for the Global And Modular BSM Inference Tool","publisher":{"@id":"https://rc1242rc.github.io/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/spheno__4__0__3_8cpp/","url":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/spheno__4__0__3_8cpp/","name":"file frontends\/SPheno_4_0_3.cpp","description":"[No description available]","isPartOf":{"@id":"https://rc1242rc.github.io/#/schema/website/1"},"about":{"@id":"https://rc1242rc.github.io/#/schema/organization/1"},"datePublished":"0001-01-01T00:00:00CET","dateModified":"0001-01-01T00:00:00CET","breadcrumb":{"@id":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/spheno__4__0__3_8cpp/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/spheno__4__0__3_8cpp/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/spheno__4__0__3_8cpp/"]}]},{"@type":"BreadcrumbList","@id":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/spheno__4__0__3_8cpp/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/","url":"https://rc1242rc.github.io/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/documentation/","url":"https://rc1242rc.github.io/documentation/","name":"Documentation"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/documentation/code/","url":"https://rc1242rc.github.io/documentation/code/","name":"Code"}},{"@type":"ListItem","position":4,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/","url":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/","name":"Gambit Sphinx"}},{"@type":"ListItem","position":5,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/","url":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/","name":"Files"}},{"@type":"ListItem","position":6,"item":{"@id":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/spheno__4__0__3_8cpp/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://rc1242rc.github.io/documentation/code/gambit_sphinx/files/spheno__4__0__3_8cpp/#/schema/image/2","url":"https://rc1242rc.github.io/gambit_logo.png","contentUrl":"https://rc1242rc.github.io/gambit_logo.png","caption":"file frontends\/SPheno_4_0_3.cpp"}]}]}</script><meta name=theme-color content="#fff"><link rel=icon href=https://rc1242rc.github.io/favicon.ico sizes=any><link rel=icon type=image/svg+xml href=https://rc1242rc.github.io/favicon.svg><link rel=apple-touch-icon sizes=180x180 href=https://rc1242rc.github.io/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://rc1242rc.github.io/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://rc1242rc.github.io/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://rc1242rc.github.io/site.webmanifest></head><body class="documentation single light"><div class=sticky-top><div class=header-bar></div><header class="navbar navbar-expand-md navbar-light doks-navbar"><nav class="container-xxl flex-wrap flex-md-nowrap" aria-label="Main navigation"><a class="navbar-brand p-0 me-auto" href=https://rc1242rc.github.io/ aria-label=GAMBIT><img class=logo-light src=https://rc1242rc.github.io//images/gambit_logo.png width=50px>
<img class="logo-dark d-none" src=https://rc1242rc.github.io//images/gambit_logo.png width=50px>
GAMBIT</a>
<button class="btn btn-menu order-2 d-block d-lg-none" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasDoks aria-controls=offcanvasDoks aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><div class="offcanvas offcanvas-end border-0 py-lg-1" tabindex=-1 id=offcanvasDoks data-bs-backdrop=true aria-labelledby=offcanvasDoksLabel><div class="header-bar d-lg-none"></div><div class="offcanvas-header d-lg-none"><h2 class="h5 offcanvas-title ps-2" id=offcanvasDoksLabel><a class=text-dark href=/>GAMBIT</a></h2><button type=button class="btn-close text-reset me-2" data-bs-dismiss=offcanvas aria-label="Close main menu"></button></div><div class="offcanvas-body p-4 p-lg-0"><ul class="nav flex-column flex-lg-row align-items-lg-center mt-2 mt-lg-0 ms-lg-2 me-lg-auto"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Documentation
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/documentation/installation/introduction/>Installation</a></li><li><a class=dropdown-item href=/documentation/examples/colliderbit>Examples</a></li><li><a class=dropdown-item href=/documentation/help/faqs/>Help</a></li><li><a class=dropdown-item href=/documentation/code/index_classes>Code Reference</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Community
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/community/publications/>Publications</a></li><li><a class=dropdown-item href=/community/talks/>Talks</a></li><li><a class=dropdown-item href=/community/members/>Members</a></li><li><a class=dropdown-item href=/community/code_of_conduct/>Code of Conduct</a></li><li><a class=dropdown-item href=/community/contact/>Contact</a></li></ul></li></ul><hr class="text-black-50 my-4 d-lg-none"><form class="doks-search position-relative flex-grow-1 ms-lg-auto me-lg-2"><input id=search class="form-control is-search" type=search placeholder="Search site..." aria-label="Search site..." autocomplete=off><div id=suggestions class="shadow bg-white rounded d-none"></div></form><hr class="text-black-50 my-4 d-lg-none"><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=https://github.com/GambitBSM><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><small class="ms-2 d-lg-none">GitHub</small></a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn btn-doks-light dropdown-toggle" id=doks-versions data-bs-toggle=dropdown aria-expanded=false data-bs-display=static aria-label="Toggle version menu">
<span class=d-none>Doks</span>
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=doks-versions></ul></div></div></div></nav></header></div><div class="wrap container-xxl" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class=docs-links aria-label="Main navigation"><ul class="list-unstyled collapsible-sidebar"><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-installation aria-expanded=false>
Installation</button><div class=collapse id=section-installation><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/installation/introduction/>Getting Started</a></li><li><a class="docs-link rounded" href=/documentation/installation/docker_usage/>Docker Usage</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_linux/>Installation for Linux</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_windows/>Installation for Windows</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_macos/>Installation for macOS</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-examples aria-expanded=false>
Examples</button><div class=collapse id=section-examples><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/examples/colliderbit/>ColliderBit</a></li><li><a class="docs-link rounded" href=/documentation/examples/anotherbit/>AnotherBit</a></li><li><a class="docs-link rounded" href=/documentation/examples/anotherbit2/>AnotherBit2</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-help aria-expanded=false>
Help</button><div class=collapse id=section-help><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/help/faqs/>FAQs</a></li><li><a class="docs-link rounded" href=/documentation/help/compiler_matrix/>Compiler Matrix</a></li><li><a class="docs-link rounded" href=/documentation/help/known_issues/>Known Issues</a></li><li><a class="docs-link rounded" href=/documentation/help/configuration_examples/>Configuration Examples</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-code aria-expanded=false>
Code Reference</button></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section- aria-expanded=false>
GAMBIT_VERSION_HERE</button><div class=collapse id=section-><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/code/colliderbit_development/index_classes/>Classes</a></li><li><a class="docs-link rounded" href=/documentation/code/colliderbit_development/index_files/>Files</a></li><li><a class="docs-link rounded" href=/documentation/code/colliderbit_development/index_pages/>Pages</a></li><li><a class="docs-link rounded" href=/documentation/code/colliderbit_development/index_namespaces/>Namespaces</a></li></ul></div></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=d-xl-none><button class="btn btn-outline-primary btn-sm doks-toc-toggle collapsed" type=button data-bs-toggle=collapse data-bs-target=#onThisPage aria-controls=doks-docs-nav aria-expanded=false aria-label="Toggle On this page navigation">
<span>On this page</span>
<span><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"/><polyline points="7 6 12 11 17 6"/></svg><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"/><polyline points="17 18 12 13 7 18"/></svg></span></button><div class=collapse id=onThisPage><div class="card card-body mt-3 py-1"><div class=page-links><nav id=TableOfContents><ul><li><ul><li><a href=#detailed-description>Detailed Description</a></li><li><a href=#source-code>Source code</a></li></ul></li></ul></nav></div></div></div></div><div class="page-links d-none d-xl-block"><h3>On this page</h3><nav id=TableOfContents><ul><li><ul><li><a href=#detailed-description>Detailed Description</a></li><li><a href=#source-code>Source code</a></li></ul></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9 mx-xl-auto"><h1>file frontends/SPheno_4_0_3.cpp</h1><p class=lead></p><p>[No description available] <a href=#detailed-description>More&mldr;</a></p><h2 id=detailed-description>Detailed Description <a href=#detailed-description class=anchor aria-hidden=true>#</a></h2><p><strong>Author</strong>: Tomas Gonzalo (<a href=mailto:tomas.gonzalo@monash.edu>tomas.gonzalo@monash.edu</a>)</p><p><strong>Date</strong>: 2020 Apr</p><p>Frontend for SPheno 4.3.0 backend (out of the box version)</p><hr><p>Authors (add name and date if you modify):</p><hr><h2 id=source-code>Source code <a href=#source-code class=anchor aria-hidden=true>#</a></h2><pre><code>//   GAMBIT: Global and Modular BSM Inference Tool
//   *********************************************

#include &quot;gambit/Backends/frontend_macros.hpp&quot;
#include &quot;gambit/Backends/frontends/SPheno_4_0_3.hpp&quot;
#include &quot;gambit/Elements/spectrum_factories.hpp&quot;
#include &quot;gambit/Models/SimpleSpectra/MSSMSimpleSpec.hpp&quot;
#include &quot;gambit/Utils/slhaea_helpers.hpp&quot;
#include &quot;gambit/Utils/version.hpp&quot;
#include &quot;gambit/Utils/util_functions.hpp&quot;

// Callback function for error handling
BE_NAMESPACE
{
  // This function will be called from SPheno. Needs C linkage, and thus also
  // a backend-specific name to guard against name clashes.
  extern &quot;C&quot;
  void CAT_4(BACKENDNAME,_,SAFE_VERSION,_ErrorHandler)()
  {
    throw std::runtime_error(&quot;SPheno backend called TerminateProgram.&quot;);
  }
}
END_BE_NAMESPACE

// Convenience functions (definition)
BE_NAMESPACE
{
  // Convenience function to run SPheno and obtain the spectrum
  int run_SPheno(Spectrum &amp;spectrum, const Finputs &amp;inputs)
  {

    try{ Set_All_Parameters_0(); }
    catch(std::runtime_error&amp; e) { invalid_point().raise(e.what()); }

    ReadingData(inputs);

    *epsI = 1.0E-5;
    *deltaM = 1.0E-3;
    *CalcTBD = false;
    *ratioWoM = 0.0;

    try{ SPheno_Main(); }
    catch(std::runtime_error&amp; e) { invalid_point().raise(e.what()); }

    if(*kont != 0)
       ErrorHandling(*kont);

    spectrum = Spectrum_Out(inputs);

    return *kont;

  }

  // Convenience function to convert internal SPheno variables into a Spectrum object
  Spectrum Spectrum_Out(const Finputs &amp;inputs)
  {

    SLHAstruct slha;

    Freal8 Q;
    try{ Q = sqrt(GetRenormalizationScale()); }
    catch(std::runtime_error&amp; e) { invalid_point().raise(e.what()); }

    // TODO: Chi masses are not rotated, I think. Check

    // Spectrum generator information
    SLHAea_add_block(slha, &quot;SPINFO&quot;);
    SLHAea_add(slha, &quot;SPINFO&quot;, 1, &quot;GAMBIT, using &quot;+str(STRINGIFY(BACKENDNAME)));
    SLHAea_add(slha, &quot;SPINFO&quot;, 2, gambit_version()+&quot; (GAMBIT); &quot;+str(STRINGIFY(VERSION))+&quot; (&quot;+str(STRINGIFY(BACKENDNAME))+&quot;);&quot;);

    // Block MODSEL
    SLHAea_add_block(slha, &quot;MODSEL&quot;);
    if(inputs.param.find(&quot;Qin&quot;) != inputs.param.end())
      slha[&quot;MODSEL&quot;][&quot;&quot;] &lt;&lt; 1 &lt;&lt; 0 &lt;&lt; &quot;# SUSY scale input&quot;;
    else
      slha[&quot;MODSEL&quot;][&quot;&quot;] &lt;&lt; 1 &lt;&lt; 1 &lt;&lt; &quot;# GUT scale input&quot;;
    slha[&quot;MODSEL&quot;][&quot;&quot;] &lt;&lt; 5 &lt;&lt; 1 &lt;&lt; &quot;# Switching on CP violations&quot;;
    if(*GenerationMixing)
      slha[&quot;MODSEL&quot;][&quot;&quot;] &lt;&lt; 6 &lt;&lt; 1 &lt;&lt; &quot;# switching on flavour violation&quot;;
    if(inputs.param.find(&quot;Qin&quot;) != inputs.param.end())
      slha[&quot;MODSEL&quot;][&quot;&quot;] &lt;&lt; 12 &lt;&lt; *inputs.param.at(&quot;Qin&quot;) &lt;&lt; &quot;# Qin&quot;;

    // Block MINPAR
    SLHAea_add_block(slha, &quot;MINPAR&quot;);
    if(inputs.param.find(&quot;M0&quot;) != inputs.param.end())
      slha[&quot;MINPAR&quot;][&quot;&quot;] &lt;&lt; 1 &lt;&lt; *inputs.param.at(&quot;M0&quot;) &lt;&lt; &quot;# m0&quot;;
    if(inputs.param.find(&quot;M12&quot;) != inputs.param.end())
      slha[&quot;MINPAR&quot;][&quot;&quot;] &lt;&lt; 2 &lt;&lt; *inputs.param.at(&quot;M12&quot;) &lt;&lt; &quot;# m12&quot;;
    if(inputs.param.find(&quot;TanBeta&quot;) != inputs.param.end())
      slha[&quot;MINPAR&quot;][&quot;&quot;] &lt;&lt; 3 &lt;&lt; *inputs.param.at(&quot;TanBeta&quot;) &lt;&lt; &quot;# tanb at MZ&quot;;
    if(inputs.param.find(&quot;SignMu&quot;) != inputs.param.end())
      slha[&quot;MINPAR&quot;][&quot;&quot;] &lt;&lt; 4 &lt;&lt; *inputs.param.at(&quot;SignMu&quot;) &lt;&lt; &quot;# sign(mu)&quot;;
    if(inputs.param.find(&quot;A0&quot;) != inputs.param.end())
      slha[&quot;MINPAR&quot;][&quot;&quot;] &lt;&lt; 5 &lt;&lt; *inputs.param.at(&quot;A0&quot;) &lt;&lt; &quot;# A0&quot;;

    // Block EXTPAR
    SLHAea_add_block(slha, &quot;EXTPAR&quot;);
    if(inputs.param.find(&quot;Qin&quot;) != inputs.param.end())
      slha[&quot;EXTPAR&quot;][&quot;&quot;] &lt;&lt; 0 &lt;&lt; *inputs.param.at(&quot;Qin&quot;) &lt;&lt; &quot;# scale Q where the parameters below are defined&quot;;
    if(inputs.param.find(&quot;M1&quot;) != inputs.param.end())
      slha[&quot;EXTPAR&quot;][&quot;&quot;] &lt;&lt; 1 &lt;&lt; *inputs.param.at(&quot;M1&quot;) &lt;&lt; &quot;# M_1&quot;;
    if(inputs.param.find(&quot;M2&quot;) != inputs.param.end())
      slha[&quot;EXTPAR&quot;][&quot;&quot;] &lt;&lt; 2 &lt;&lt; *inputs.param.at(&quot;M2&quot;) &lt;&lt; &quot;# M_2&quot;;
    if(inputs.param.find(&quot;M3&quot;) != inputs.param.end())
      slha[&quot;EXTPAR&quot;][&quot;&quot;] &lt;&lt; 3 &lt;&lt; *inputs.param.at(&quot;M3&quot;) &lt;&lt; &quot;# M_3&quot;;
    if(inputs.param.find(&quot;Au_33&quot;) != inputs.param.end())
      slha[&quot;EXTPAR&quot;][&quot;&quot;] &lt;&lt; 11 &lt;&lt; *inputs.param.at(&quot;Au_33&quot;) &lt;&lt; &quot;# A_t&quot;;
    if(inputs.param.find(&quot;Ad_33&quot;) != inputs.param.end())
      slha[&quot;EXTPAR&quot;][&quot;&quot;] &lt;&lt; 12 &lt;&lt; *inputs.param.at(&quot;Ad_33&quot;) &lt;&lt; &quot;# A_b&quot;;
    if(inputs.param.find(&quot;Ae_33&quot;) != inputs.param.end())
      slha[&quot;EXTPAR&quot;][&quot;&quot;] &lt;&lt; 13 &lt;&lt; *inputs.param.at(&quot;Ae_33&quot;) &lt;&lt; &quot;# A_l&quot;;
    if(inputs.param.find(&quot;mHd2&quot;) != inputs.param.end())
      slha[&quot;EXTPAR&quot;][&quot;&quot;] &lt;&lt; 21 &lt;&lt; *inputs.param.at(&quot;mHd2&quot;) &lt;&lt; &quot;# m_Hd^2&quot;;
    if(inputs.param.find(&quot;mHu2&quot;) != inputs.param.end())
      slha[&quot;EXTPAR&quot;][&quot;&quot;] &lt;&lt; 22 &lt;&lt; *inputs.param.at(&quot;mHd2&quot;) &lt;&lt; &quot;# m_Hu^2&quot;;
    if(inputs.param.find(&quot;mu&quot;) != inputs.param.end())
      slha[&quot;EXTPAR&quot;][&quot;&quot;] &lt;&lt; 23 &lt;&lt; *inputs.param.at(&quot;mu&quot;) &lt;&lt; &quot;# mu&quot;;
    if(inputs.param.find(&quot;mA&quot;) != inputs.param.end())
      slha[&quot;EXTPAR&quot;][&quot;&quot;] &lt;&lt; 24 &lt;&lt; pow(*inputs.param.at(&quot;mA&quot;),2) &lt;&lt; &quot;# mA&quot;;
    if(inputs.param.find(&quot;ml2_11&quot;) != inputs.param.end())
      slha[&quot;EXTPAR&quot;][&quot;&quot;] &lt;&lt; 31 &lt;&lt; sqrt(*inputs.param.at(&quot;ml2_11&quot;)) &lt;&lt; &quot;# M_(L,11)&quot;;
    if(inputs.param.find(&quot;ml2_22&quot;) != inputs.param.end())
      slha[&quot;EXTPAR&quot;][&quot;&quot;] &lt;&lt; 32 &lt;&lt; sqrt(*inputs.param.at(&quot;ml2_22&quot;)) &lt;&lt; &quot;# M_(L,22)&quot;;
    if(inputs.param.find(&quot;ml2_33&quot;) != inputs.param.end())
      slha[&quot;EXTPAR&quot;][&quot;&quot;] &lt;&lt; 33 &lt;&lt; sqrt(*inputs.param.at(&quot;ml2_33&quot;)) &lt;&lt; &quot;# M_(L,33)&quot;;
    if(inputs.param.find(&quot;me2_11&quot;) != inputs.param.end())
      slha[&quot;EXTPAR&quot;][&quot;&quot;] &lt;&lt; 34 &lt;&lt; sqrt(*inputs.param.at(&quot;me2_11&quot;)) &lt;&lt; &quot;# M_(E,11)&quot;;
    if(inputs.param.find(&quot;me2_22&quot;) != inputs.param.end())
      slha[&quot;EXTPAR&quot;][&quot;&quot;] &lt;&lt; 35 &lt;&lt; sqrt(*inputs.param.at(&quot;me2_22&quot;)) &lt;&lt; &quot;# M_(E,22)&quot;;
    if(inputs.param.find(&quot;me2_33&quot;) != inputs.param.end())
      slha[&quot;EXTPAR&quot;][&quot;&quot;] &lt;&lt; 36 &lt;&lt; sqrt(*inputs.param.at(&quot;me2_33&quot;)) &lt;&lt; &quot;# M_(E,33)&quot;;
    if(inputs.param.find(&quot;mq2_11&quot;) != inputs.param.end())
      slha[&quot;EXTPAR&quot;][&quot;&quot;] &lt;&lt; 41 &lt;&lt; sqrt(*inputs.param.at(&quot;mq2_11&quot;)) &lt;&lt; &quot;# M_(Q,11)&quot;;
    if(inputs.param.find(&quot;mq2_22&quot;) != inputs.param.end())
      slha[&quot;EXTPAR&quot;][&quot;&quot;] &lt;&lt; 42 &lt;&lt; sqrt(*inputs.param.at(&quot;mq2_22&quot;)) &lt;&lt; &quot;# M_(Q,22)&quot;;
    if(inputs.param.find(&quot;mq2_33&quot;) != inputs.param.end())
      slha[&quot;EXTPAR&quot;][&quot;&quot;] &lt;&lt; 43 &lt;&lt; sqrt(*inputs.param.at(&quot;mq2_33&quot;)) &lt;&lt; &quot;# M_(Q,33)&quot;;
    if(inputs.param.find(&quot;mu2_11&quot;) != inputs.param.end())
      slha[&quot;EXTPAR&quot;][&quot;&quot;] &lt;&lt; 44 &lt;&lt; sqrt(*inputs.param.at(&quot;mu2_11&quot;)) &lt;&lt; &quot;# M_(U,11)&quot;;
    if(inputs.param.find(&quot;mu2_22&quot;) != inputs.param.end())
      slha[&quot;EXTPAR&quot;][&quot;&quot;] &lt;&lt; 45 &lt;&lt; sqrt(*inputs.param.at(&quot;mu2_22&quot;)) &lt;&lt; &quot;# M_(U,22)&quot;;
    if(inputs.param.find(&quot;mu2_33&quot;) != inputs.param.end())
      slha[&quot;EXTPAR&quot;][&quot;&quot;] &lt;&lt; 46 &lt;&lt; sqrt(*inputs.param.at(&quot;mu2_33&quot;)) &lt;&lt; &quot;# M_(U,33)&quot;;
    if(inputs.param.find(&quot;md2_11&quot;) != inputs.param.end())
      slha[&quot;EXTPAR&quot;][&quot;&quot;] &lt;&lt; 47 &lt;&lt; sqrt(*inputs.param.at(&quot;md2_11&quot;)) &lt;&lt; &quot;# M_(D,11)&quot;;
    if(inputs.param.find(&quot;md2_22&quot;) != inputs.param.end())
      slha[&quot;EXTPAR&quot;][&quot;&quot;] &lt;&lt; 48 &lt;&lt; sqrt(*inputs.param.at(&quot;md2_22&quot;)) &lt;&lt; &quot;# M_(D,22)&quot;;
    if(inputs.param.find(&quot;md2_33&quot;) != inputs.param.end())
      slha[&quot;EXTPAR&quot;][&quot;&quot;] &lt;&lt; 49 &lt;&lt; sqrt(*inputs.param.at(&quot;md2_33&quot;)) &lt;&lt; &quot;# M_(D,33)&quot;;

    // Block SMINPUTS
    SLHAea_add_block(slha, &quot;SMINPUTS&quot;);
    slha[&quot;SMINPUTS&quot;][&quot;&quot;] &lt;&lt; 1 &lt;&lt; 1.0 / *Alpha_mZ_MS &lt;&lt; &quot;# alpha_em^-1(MZ)^MSbar&quot;;
    slha[&quot;SMINPUTS&quot;][&quot;&quot;] &lt;&lt; 2 &lt;&lt; *G_F &lt;&lt; &quot;# G_mu [GeV^-2]&quot;;
    slha[&quot;SMINPUTS&quot;][&quot;&quot;] &lt;&lt; 3 &lt;&lt; *AlphaS_mZ &lt;&lt; &quot;# alpha_s(MZ)^MSbar&quot;;
    slha[&quot;SMINPUTS&quot;][&quot;&quot;] &lt;&lt; 4 &lt;&lt; *mZ &lt;&lt; &quot;# m_Z(pole)&quot;;
    slha[&quot;SMINPUTS&quot;][&quot;&quot;] &lt;&lt; 5 &lt;&lt; (*mf_d)(3) &lt;&lt; &quot;# m_b(m_b), MSbar&quot;;
    slha[&quot;SMINPUTS&quot;][&quot;&quot;] &lt;&lt; 6 &lt;&lt; (*mf_u)(3) &lt;&lt; &quot;# m_t(pole)&quot;;
    slha[&quot;SMINPUTS&quot;][&quot;&quot;] &lt;&lt; 7 &lt;&lt; (*mf_l)(3) &lt;&lt; &quot;# m_tau(pole)&quot;;
    slha[&quot;SMINPUTS&quot;][&quot;&quot;] &lt;&lt; 8 &lt;&lt; (*mf_nu)(3) &lt;&lt; &quot;# m_nu_3&quot;;
    slha[&quot;SMINPUTS&quot;][&quot;&quot;] &lt;&lt; 11 &lt;&lt; (*mf_l)(1) &lt;&lt; &quot;# m_e(pole)&quot;;
    slha[&quot;SMINPUTS&quot;][&quot;&quot;] &lt;&lt; 12 &lt;&lt; (*mf_nu)(1) &lt;&lt; &quot;# m_nu_1&quot;;
    slha[&quot;SMINPUTS&quot;][&quot;&quot;] &lt;&lt; 13 &lt;&lt; (*mf_l)(2) &lt;&lt; &quot;# m_muon(pole)&quot;;
    slha[&quot;SMINPUTS&quot;][&quot;&quot;] &lt;&lt; 14 &lt;&lt; (*mf_nu)(2) &lt;&lt; &quot;# m_nu_2&quot;;
    slha[&quot;SMINPUTS&quot;][&quot;&quot;] &lt;&lt; 21 &lt;&lt; (*mf_d)(1) &lt;&lt; &quot;# m_d(2 GeV), MSbar&quot;;
    slha[&quot;SMINPUTS&quot;][&quot;&quot;] &lt;&lt; 22 &lt;&lt; (*mf_u)(1) &lt;&lt; &quot;# m_u(2 GeV), MSbar&quot;;
    slha[&quot;SMINPUTS&quot;][&quot;&quot;] &lt;&lt; 23 &lt;&lt; (*mf_d)(2) &lt;&lt; &quot;# m_s(2 GeV), MSbar&quot;;
    slha[&quot;SMINPUTS&quot;][&quot;&quot;] &lt;&lt; 24 &lt;&lt; (*mf_u)(2) &lt;&lt; &quot;# m_c(m_c), MSbar&quot;;

    // SUSY-HIT requires these blocks to be present, so add them
    SLHAea_add_block(slha, &quot;VCKMIN&quot;);
    slha[&quot;VCKMIN&quot;][&quot;&quot;] &lt;&lt; 1 &lt;&lt; *lam_wolf &lt;&lt; &quot;# lambda&quot;;
    slha[&quot;VCKMIN&quot;][&quot;&quot;] &lt;&lt; 2 &lt;&lt; *A_wolf &lt;&lt; &quot;# A&quot;;
    slha[&quot;VCKMIN&quot;][&quot;&quot;] &lt;&lt; 3 &lt;&lt; *rho_wolf &lt;&lt; &quot;# rho bar&quot;;
    slha[&quot;VCKMIN&quot;][&quot;&quot;] &lt;&lt; 4 &lt;&lt; *eta_wolf &lt;&lt; &quot;# eta bar&quot;;

    SLHAea_add_block(slha, &quot;UPMNSIN&quot;);
    slha[&quot;UPMNSIN&quot;][&quot;&quot;] &lt;&lt; 1 &lt;&lt; *theta_12 &lt;&lt; &quot;# theta_12, solar&quot;;
    slha[&quot;UPMNSIN&quot;][&quot;&quot;] &lt;&lt; 2 &lt;&lt; *theta_23&lt;&lt; &quot;# theta_23, atmospheric&quot;;
    slha[&quot;UPMNSIN&quot;][&quot;&quot;] &lt;&lt; 3 &lt;&lt; *theta_13 &lt;&lt; &quot;# theta_13&quot;;
    slha[&quot;UPMNSIN&quot;][&quot;&quot;] &lt;&lt; 4 &lt;&lt; *delta_nu &lt;&lt; &quot;# delta_nu&quot;;
    slha[&quot;UPMNSIN&quot;][&quot;&quot;] &lt;&lt; 5 &lt;&lt; *alpha_nu1 &lt;&lt; &quot;# alpha_1&quot;;
    slha[&quot;UPMNSIN&quot;][&quot;&quot;] &lt;&lt; 6 &lt;&lt; *alpha_nu2 &lt;&lt; &quot;# alpha_2&quot;;

    Farray&lt;Fcomplex16,1,6,1,6&gt; RDsq_ckm, RUsq_ckm, RSl_pmns;
    Farray&lt;Fcomplex16,1,3,1,3&gt; RSn_pmns, id3C;
    Farray&lt;Fcomplex16,1,3,1,3&gt; CKM_Q, PMNS_Q;
    Farray&lt;Freal8,1,3&gt; Yu, Yd, Yl;
    if(*GenerationMixing)
    {
      Flogical False = false;
      try{ Switch_to_superCKM(*Y_d,*Y_u,*A_d,*A_u,*M2_D,*M2_Q,*M2_U,*Ad_sckm,*Au_sckm,*M2D_sckm,*M2Q_sckm,*M2U_sckm,False,*RSdown,*RSup,RDsq_ckm,RUsq_ckm,CKM_Q,Yd,Yu); }
      catch(std::runtime_error&amp; e) { invalid_point().raise(e.what()); }

      try{ Switch_to_superPMNS(*Y_l,id3C,*A_l,*M2_E,*M2_L,*Al_pmns,*M2E_pmns,*M2L_pmns,False,*RSlepton,*RSneut,RSl_pmns,RSn_pmns,PMNS_Q,Yl); }
      catch(std::runtime_error&amp; e) { invalid_point().raise(e.what()); }

    }
    else
    {
      for(int i=1; i&lt;=3; i++)
      {
        Yu(i) = (*Y_u)(i,i).re;
        Yd(i) = (*Y_d)(i,i).re;
        Yl(i) = (*Y_l)(i,i).re;
      }
      *Al_pmns = *A_l;
      *Ad_sckm = *A_d;
      *Au_sckm = *A_u;

      *M2D_sckm = *M2_D;
      *M2U_sckm = *M2_U;
      *M2Q_sckm = *M2_Q;
      *M2E_pmns = *M2_E;
      *M2L_pmns = *M2_L;

      RUsq_ckm = *RSup;
      RDsq_ckm = *RSdown;

      RSn_pmns = *RSneut;
      RSl_pmns = *RSlepton;

    }

    // Block GAUGE
    SLHAea_add_block(slha, &quot;GAUGE&quot;, Q);
    slha[&quot;GAUGE&quot;][&quot;&quot;] &lt;&lt; 1 &lt;&lt; (*gauge)(1) &lt;&lt; &quot;# g'(Q)^DRbar&quot;;
    slha[&quot;GAUGE&quot;][&quot;&quot;] &lt;&lt; 2 &lt;&lt; (*gauge)(2) &lt;&lt; &quot;# g(Q)^DRbar&quot;;
    slha[&quot;GAUGE&quot;][&quot;&quot;] &lt;&lt; 3 &lt;&lt; (*gauge)(3) &lt;&lt; &quot;# g3(Q)^DRbar&quot;;

    // Blocks Yu, Yd, Ye
    SLHAea_add_block(slha, &quot;Yu&quot;, Q);
    SLHAea_add_block(slha, &quot;Yd&quot;, Q);
    SLHAea_add_block(slha, &quot;Ye&quot;, Q);
    for(int i=1; i&lt;=3; i++)
    {
      slha[&quot;Yu&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; i &lt;&lt; Yu(i) &lt;&lt; &quot;# Yu(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; i &lt;&lt; &quot;)(Q)^DRbar&quot;;
      slha[&quot;Yd&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; i &lt;&lt; Yd(i) &lt;&lt; &quot;# Yd(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; i &lt;&lt; &quot;)(Q)^DRbar&quot;;
      slha[&quot;Ye&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; i &lt;&lt; Yl(i) &lt;&lt; &quot;# Ye(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; i &lt;&lt; &quot;)(Q)^DRbar&quot;;
      for(int j=1; j&lt;=3; j++)
      {
        slha[&quot;Yu&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; 0.0 &lt;&lt; &quot;# Yu(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;)(Q)^DRbar&quot;;
        slha[&quot;Yd&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; 0.0 &lt;&lt; &quot;# Yd(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;)(Q)^DRbar&quot;;
        slha[&quot;Ye&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; 0.0 &lt;&lt; &quot;# Ye(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;)(Q)^DRbar&quot;;
      }
    }

    if(*GenerationMixing)
    {
      // Blocks VKCM and UPMNS
      SLHAea_add_block(slha, &quot;VCKM&quot;, Q);
      SLHAea_add_block(slha, &quot;IMVCKM&quot;, Q);
      SLHAea_add_block(slha, &quot;UPMNS&quot;, Q);
      SLHAea_add_block(slha, &quot;IMUPMNS&quot;, Q);
      for(int i=1; i&lt;=3; i++)
        for(int j=1; j&lt;=3; j++)
        {
          slha[&quot;VCKM&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; CKM_Q(i,j).re &lt;&lt; &quot;# V_&quot; &lt;&lt; i &lt;&lt; j;
          slha[&quot;IMVCKM&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; CKM_Q(i,j).im &lt;&lt; &quot;# Im(V_&quot; &lt;&lt; i &lt;&lt; j &lt;&lt; &quot;)&quot;;
          slha[&quot;UPMNS&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; PMNS_Q(i,j).re &lt;&lt; &quot;# UPMNS_&quot; &lt;&lt; i &lt;&lt; j;
          slha[&quot;IMUPMNS&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; PMNS_Q(i,j).im &lt;&lt; &quot;# Im(UPMNS_&quot; &lt;&lt; i &lt;&lt; j &lt;&lt; &quot;)&quot;;
        }

      // Blocks Te, Tu, Td
      SLHAea_add_block(slha, &quot;Te&quot;, Q);
      SLHAea_add_block(slha, &quot;Tu&quot;, Q);
      SLHAea_add_block(slha, &quot;Td&quot;, Q);
      SLHAea_add_block(slha, &quot;IMTe&quot;, Q);
      SLHAea_add_block(slha, &quot;IMTu&quot;, Q);
      SLHAea_add_block(slha, &quot;IMTd&quot;, Q);
      for(int i=1; i&lt;=3; i++)
        for(int j=1; j&lt;=3; j++)
        {
          slha[&quot;Te&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; (*Al_pmns)(i,j).re &lt;&lt; &quot;# Te(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;)&quot;;
          slha[&quot;Tu&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; (*Au_sckm)(i,j).re &lt;&lt; &quot;# Tu(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;)&quot;;
          slha[&quot;Td&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; (*Ad_sckm)(i,j).re &lt;&lt; &quot;# Td(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;)&quot;;
          slha[&quot;IMTe&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; (*Al_pmns)(i,j).im &lt;&lt; &quot;# Im(Te(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;))&quot;;
          slha[&quot;IMTu&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; (*Au_sckm)(i,j).im &lt;&lt; &quot;# Im(Tu(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;))&quot;;
          slha[&quot;IMTd&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; (*Ad_sckm)(i,j).im &lt;&lt; &quot;# Im(Td(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;))&quot;;
        }

    }

    // Blocks Au, Ad, Ae
    SLHAea_add_block(slha, &quot;Ae&quot;, Q);
    SLHAea_add_block(slha, &quot;Au&quot;, Q);
    SLHAea_add_block(slha, &quot;Ad&quot;, Q);
    SLHAea_add_block(slha, &quot;IMAe&quot;, Q);
    SLHAea_add_block(slha, &quot;IMAu&quot;, Q);
    SLHAea_add_block(slha, &quot;IMAd&quot;, Q);
    for(int i=1; i&lt;=3; i++)
    {
      for(int j=1; j&lt;=3; j++)
      {
        if((*Y_l)(i,j).abs() &gt; 0.0)
        {
          slha[&quot;Ae&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; ((*Al_pmns)(i,j)/(*Y_l)(i,j)).re &lt;&lt; &quot;# Ae(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;)&quot;;
          slha[&quot;IMAe&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; ((*Al_pmns)(i,j)/(*Y_l)(i,j)).im &lt;&lt; &quot;# Im(Ae(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;))&quot;;
        }
        else
        {
          slha[&quot;Ae&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; 0.0 &lt;&lt; &quot;# Ae(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;)&quot;;
          slha[&quot;IMAe&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; 0.0 &lt;&lt; &quot;# Im(Ae(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;))&quot;;
        }
        if((*Y_u)(i,i).abs() &gt; 0.0)
        {
          slha[&quot;Au&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; ((*Au_sckm)(i,j)/(*Y_u)(i,j)).re &lt;&lt; &quot;# Au(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;)&quot;;
          slha[&quot;IMAu&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; ((*Au_sckm)(i,j)/(*Y_u)(i,j)).im &lt;&lt; &quot;# Im(Au(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;))&quot;;
        }
        else
        {
          slha[&quot;Au&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; 0.0 &lt;&lt; &quot;# Au(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;)&quot;;
          slha[&quot;IMAu&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; 0.0 &lt;&lt; &quot;# Im(Au(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;))&quot;;
        }
        if((*Y_d)(i,i).abs() &gt; 0.0)
        {
          slha[&quot;Ad&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; ((*Ad_sckm)(i,i)/(*Y_d)(i,j)).re &lt;&lt; &quot;# Ad(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;)&quot;;
          slha[&quot;IMAd&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; ((*Ad_sckm)(i,i)/(*Y_d)(i,j)).im &lt;&lt; &quot;# Im(Ad(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;))&quot;;
        }
        else
        {
          slha[&quot;Ad&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; 0.0 &lt;&lt; &quot;# Ad(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;)&quot;;
          slha[&quot;IMAd&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; 0.0 &lt;&lt; &quot;# Im(Ad(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;))&quot;;
        }
      }

    }

    // Block MSOFT
    SLHAea_add_block(slha, &quot;MSOFT&quot;, Q);
    slha[&quot;MSOFT&quot;][&quot;&quot;] &lt;&lt; 1 &lt;&lt; (*Mi)(1).re &lt;&lt; &quot;# M_1&quot;;
    slha[&quot;MSOFT&quot;][&quot;&quot;] &lt;&lt; 2 &lt;&lt; (*Mi)(2).re &lt;&lt; &quot;# M_2&quot;;
    slha[&quot;MSOFT&quot;][&quot;&quot;] &lt;&lt; 3 &lt;&lt; (*Mi)(3).re &lt;&lt; &quot;# M_3&quot;;
    slha[&quot;MSOFT&quot;][&quot;&quot;] &lt;&lt; 21 &lt;&lt; (*M2_H)(1) &lt;&lt; &quot;# M^2_(H,d)&quot;;
    slha[&quot;MSOFT&quot;][&quot;&quot;] &lt;&lt; 22 &lt;&lt; (*M2_H)(2) &lt;&lt; &quot;# M^2_(H,u)&quot;;

    slha[&quot;MSOFT&quot;][&quot;&quot;] &lt;&lt; 31 &lt;&lt; Utils::sgn((*M2L_pmns)(1,1).re) * sqrt(abs((*M2L_pmns)(1,1).re)) &lt;&lt; &quot;# M_(L,11)&quot;;
    slha[&quot;MSOFT&quot;][&quot;&quot;] &lt;&lt; 32 &lt;&lt; Utils::sgn((*M2L_pmns)(2,2).re) * sqrt(abs((*M2L_pmns)(2,2).re)) &lt;&lt; &quot;# M_(L,22)&quot;;
    slha[&quot;MSOFT&quot;][&quot;&quot;] &lt;&lt; 33 &lt;&lt; Utils::sgn((*M2L_pmns)(3,3).re) * sqrt(abs((*M2L_pmns)(3,3).re)) &lt;&lt; &quot;# M_(L,33)&quot;;
    slha[&quot;MSOFT&quot;][&quot;&quot;] &lt;&lt; 34 &lt;&lt; Utils::sgn((*M2E_pmns)(1,1).re) * sqrt(abs((*M2E_pmns)(1,1).re)) &lt;&lt; &quot;# M_(E,11)&quot;;
    slha[&quot;MSOFT&quot;][&quot;&quot;] &lt;&lt; 35 &lt;&lt; Utils::sgn((*M2E_pmns)(2,2).re) * sqrt(abs((*M2E_pmns)(2,2).re)) &lt;&lt; &quot;# M_(E,22)&quot;;
    slha[&quot;MSOFT&quot;][&quot;&quot;] &lt;&lt; 36 &lt;&lt; Utils::sgn((*M2E_pmns)(3,3).re) * sqrt(abs((*M2E_pmns)(3,3).re)) &lt;&lt; &quot;# M_(E,33)&quot;;
    slha[&quot;MSOFT&quot;][&quot;&quot;] &lt;&lt; 41 &lt;&lt; Utils::sgn((*M2Q_sckm)(1,1).re) * sqrt(abs((*M2Q_sckm)(1,1).re)) &lt;&lt; &quot;# M_(Q,11)&quot;;
    slha[&quot;MSOFT&quot;][&quot;&quot;] &lt;&lt; 42 &lt;&lt; Utils::sgn((*M2Q_sckm)(2,2).re) * sqrt(abs((*M2Q_sckm)(2,2).re)) &lt;&lt; &quot;# M_(Q,22)&quot;;
    slha[&quot;MSOFT&quot;][&quot;&quot;] &lt;&lt; 43 &lt;&lt; Utils::sgn((*M2Q_sckm)(3,3).re) * sqrt(abs((*M2Q_sckm)(3,3).re)) &lt;&lt; &quot;# M_(Q,33)&quot;;
    slha[&quot;MSOFT&quot;][&quot;&quot;] &lt;&lt; 44 &lt;&lt; Utils::sgn((*M2U_sckm)(1,1).re) * sqrt(abs((*M2U_sckm)(1,1).re)) &lt;&lt; &quot;# M_(U,11)&quot;;
    slha[&quot;MSOFT&quot;][&quot;&quot;] &lt;&lt; 45 &lt;&lt; Utils::sgn((*M2U_sckm)(2,2).re) * sqrt(abs((*M2U_sckm)(2,2).re)) &lt;&lt; &quot;# M_(U,22)&quot;;
    slha[&quot;MSOFT&quot;][&quot;&quot;] &lt;&lt; 46 &lt;&lt; Utils::sgn((*M2U_sckm)(3,3).re) * sqrt(abs((*M2U_sckm)(3,3).re)) &lt;&lt; &quot;# M_(U,33)&quot;;
    slha[&quot;MSOFT&quot;][&quot;&quot;] &lt;&lt; 47 &lt;&lt; Utils::sgn((*M2D_sckm)(1,1).re) * sqrt(abs((*M2D_sckm)(1,1).re)) &lt;&lt; &quot;# M_(D,11)&quot;;
    slha[&quot;MSOFT&quot;][&quot;&quot;] &lt;&lt; 48 &lt;&lt; Utils::sgn((*M2D_sckm)(2,2).re) * sqrt(abs((*M2D_sckm)(2,2).re)) &lt;&lt; &quot;# M_(D,22)&quot;;
    slha[&quot;MSOFT&quot;][&quot;&quot;] &lt;&lt; 49 &lt;&lt; Utils::sgn((*M2D_sckm)(3,3).re) * sqrt(abs((*M2D_sckm)(3,3).re)) &lt;&lt; &quot;# M_(D,33)&quot;;

    if((*Mi)(1).im != 0 or (*Mi)(2).im != 0 or (*Mi)(3).im != 0)
    {
      SLHAea_add_block(slha, &quot;IMMSOFT&quot;, Q);
      slha[&quot;IMMSOFT&quot;][&quot;&quot;] &lt;&lt; 1 &lt;&lt; (*Mi)(1).im &lt;&lt; &quot;# M_1&quot;;
      slha[&quot;IMMSOFT&quot;][&quot;&quot;] &lt;&lt; 2 &lt;&lt; (*Mi)(2).im &lt;&lt; &quot;# M_2&quot;;
      slha[&quot;IMMSOFT&quot;][&quot;&quot;] &lt;&lt; 3 &lt;&lt; (*Mi)(3).im &lt;&lt; &quot;# M_3&quot;;
    }

    // Blocks MSL2, MSE2, MSQ2, MSU2, MSD2
    SLHAea_add_block(slha, &quot;MSL2&quot;, Q);
    SLHAea_add_block(slha, &quot;MSE2&quot;, Q);
    SLHAea_add_block(slha, &quot;MSQ2&quot;, Q);
    SLHAea_add_block(slha, &quot;MSU2&quot;, Q);
    SLHAea_add_block(slha, &quot;MSD2&quot;, Q);
    SLHAea_add_block(slha, &quot;IMMSL2&quot;, Q);
    SLHAea_add_block(slha, &quot;IMMSE2&quot;, Q);
    SLHAea_add_block(slha, &quot;IMMSQ2&quot;, Q);
    SLHAea_add_block(slha, &quot;IMMSU2&quot;, Q);
    SLHAea_add_block(slha, &quot;IMMSD2&quot;, Q);
    for(int i=1; i&lt;=3; i++)
      for(int j=1; j&lt;=3; j++)
      {
        slha[&quot;MSL2&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; (*M2L_pmns)(i,j).re &lt;&lt; &quot;# ml2(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;)&quot;;
        slha[&quot;MSE2&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; (*M2E_pmns)(i,j).re &lt;&lt; &quot;# me2(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;)&quot;;
        slha[&quot;MSQ2&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; (*M2Q_sckm)(i,j).re &lt;&lt; &quot;# mq2(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;)&quot;;
        slha[&quot;MSU2&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; (*M2U_sckm)(i,j).re &lt;&lt; &quot;# mu2(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;)&quot;;
        slha[&quot;MSD2&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; (*M2D_sckm)(i,j).re &lt;&lt; &quot;# md2(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;)&quot;;
        slha[&quot;IMMSL2&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; (*M2L_pmns)(i,j).im &lt;&lt; &quot;# Im(ml2(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;))&quot;;
        slha[&quot;IMMSE2&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; (*M2E_pmns)(i,j).im &lt;&lt; &quot;# Im(me2(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;))&quot;;
        slha[&quot;IMMSQ2&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; (*M2Q_sckm)(i,j).im &lt;&lt; &quot;# Im(mq2(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;))&quot;;
        slha[&quot;IMMSU2&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; (*M2U_sckm)(i,j).im &lt;&lt; &quot;# Im(mu2(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;))&quot;;
        slha[&quot;IMMSD2&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; (*M2D_sckm)(i,j).im &lt;&lt; &quot;# Im(md2(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;))&quot;;
      }


    // Block MASS
    SLHAea_add_block(slha, &quot;MASS&quot;);
    slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 5 &lt;&lt; (*mf_d)(3) &lt;&lt; &quot;# m_b(pole)&quot;;
    slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 6 &lt;&lt; (*mf_u)(3) &lt;&lt; &quot;# m_t(pole)&quot;;
    slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 23 &lt;&lt; *mZ &lt;&lt; &quot;# m_Z(pole)&quot;;
    slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 24 &lt;&lt; *mW &lt;&lt; &quot;# m_W(pole)&quot;;
    slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 15 &lt;&lt; (*mf_l)(3) &lt;&lt; &quot;# m_tau(pole)&quot;;

    slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 25 &lt;&lt; (*S0)(1).m &lt;&lt; &quot;# h0&quot;;
    slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 35 &lt;&lt; (*S0)(2).m &lt;&lt; &quot;# H0&quot;;
    slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 36 &lt;&lt; (*P0)(2).m &lt;&lt; &quot;# A0&quot;;
    slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 37 &lt;&lt; (*Spm)(2).m &lt;&lt; &quot;# H+&quot;;

    if(*GenerationMixing)
    {
      std::vector&lt;int&gt; id_sd = {1000001, 1000003, 1000005,
                                2000001, 2000003, 2000005};
      for(int i=1; i&lt;=6; i++)
        slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; id_sd[i-1] &lt;&lt; (*Sdown)(i).m &lt;&lt; &quot;# ~d_&quot; &lt;&lt; i;

      std::vector&lt;int&gt; id_su = {1000002, 1000004, 1000006,
                                2000002, 2000004, 2000006};
      for(int i=1; i&lt;=6; i++)
        slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; id_su[i-1] &lt;&lt; (*Sup)(i).m &lt;&lt; &quot;# ~u_&quot; &lt;&lt; i;

      std::vector&lt;int&gt; id_snu = {1000012, 1000014, 1000016};
      for(int i=1; i&lt;=3; i++)
        slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; id_snu[i-1] &lt;&lt; (*Sneut)(i).m &lt;&lt; &quot;# ~nu_&quot; &lt;&lt; i;

      std::vector&lt;int&gt; id_sle = {1000011, 1000013, 1000015,
                                 2000011, 2000013, 2000015};
      for(int i=1; i&lt;=6; i++)
        slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; id_sle[i-1] &lt;&lt; (*Slepton)(i).m &lt;&lt; &quot;# ~l_&quot; &lt;&lt; i;

    }
    else
    {
      if((*RSdown)(1,1).abs() &gt; 0.5)
      {
        slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 1000001 &lt;&lt; (*Sdown)(1).m &lt;&lt; &quot;# ~d_L&quot;;
        slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 2000001 &lt;&lt; (*Sdown)(2).m &lt;&lt; &quot;# ~d_R&quot;;
      }
      else
      {
        slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 1000001 &lt;&lt; (*Sdown)(2).m &lt;&lt; &quot;# ~d_L&quot;;
        slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 2000001 &lt;&lt; (*Sdown)(1).m &lt;&lt; &quot;# ~d_R&quot;;
      }
      if((*RSup)(1,1).abs() &gt; 0.5)
      {
        slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 1000002 &lt;&lt; (*Sup)(1).m &lt;&lt; &quot;# ~u_L&quot;;
        slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 2000002 &lt;&lt; (*Sup)(2).m &lt;&lt; &quot;# ~u_R&quot;;
      }
      else
      {
        slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 1000002 &lt;&lt; (*Sup)(2).m &lt;&lt; &quot;# ~u_L&quot;;
        slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 2000002 &lt;&lt; (*Sup)(1).m &lt;&lt; &quot;# ~u_R&quot;;
      }
      if((*RSdown)(3,3).abs() &gt; 0.5)
      {
        slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 1000003 &lt;&lt; (*Sdown)(3).m &lt;&lt; &quot;# ~s_L&quot;;
        slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 2000003 &lt;&lt; (*Sdown)(4).m &lt;&lt; &quot;# ~s_R&quot;;
      }
      else
      {
        slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 1000003 &lt;&lt; (*Sdown)(4).m &lt;&lt; &quot;# ~s_L&quot;;
        slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 2000003 &lt;&lt; (*Sdown)(3).m &lt;&lt; &quot;# ~s_R&quot;;
      }
      if((*RSup)(3,3).abs() &gt; 0.5)
      {
        slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 1000004 &lt;&lt; (*Sup)(3).m &lt;&lt; &quot;# ~c_L&quot;;
        slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 2000004 &lt;&lt; (*Sup)(4).m &lt;&lt; &quot;# ~c_R&quot;;
      }
      else
      {
        slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 1000004 &lt;&lt; (*Sup)(4).m &lt;&lt; &quot;# ~c_L&quot;;
        slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 2000004 &lt;&lt; (*Sup)(3).m &lt;&lt; &quot;# ~c_R&quot;;
      }
      slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 1000005 &lt;&lt; (*Sdown)(5).m &lt;&lt; &quot;# ~b_1&quot;;
      slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 2000005 &lt;&lt; (*Sdown)(6).m &lt;&lt; &quot;# ~b_2&quot;;
      slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 1000006 &lt;&lt; (*Sup)(5).m &lt;&lt; &quot;# ~t_1&quot;;
      slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 2000006 &lt;&lt; (*Sup)(6).m &lt;&lt; &quot;# ~t_2&quot;;

      if((*RSlepton)(1,1).abs() &gt; 0.5)
      {
        slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 1000011 &lt;&lt; (*Slepton)(1).m &lt;&lt; &quot;# ~e_L-&quot;;
        slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 2000011 &lt;&lt; (*Slepton)(2).m &lt;&lt; &quot;# ~e_R-&quot;;
      }
      else
      {
        slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 1000011 &lt;&lt; (*Slepton)(2).m &lt;&lt; &quot;# ~e_L-&quot;;
        slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 2000011 &lt;&lt; (*Slepton)(1).m &lt;&lt; &quot;# ~e_R-&quot;;
      }
      slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 1000012 &lt;&lt; (*Sneut)(1).m &lt;&lt; &quot;# ~nu_eL&quot;;
      if((*RSlepton)(3,3).abs() &gt; 0.5)
      {
        slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 1000013 &lt;&lt; (*Slepton)(3).m &lt;&lt; &quot;# ~mu_L-&quot;;
        slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 2000013 &lt;&lt; (*Slepton)(4).m &lt;&lt; &quot;# ~mu_R-&quot;;
      }
      else
      {
        slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 1000013 &lt;&lt; (*Slepton)(4).m &lt;&lt; &quot;# ~mu_L-&quot;;
        slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 2000013 &lt;&lt; (*Slepton)(3).m &lt;&lt; &quot;# ~mu_R-&quot;;
      }
      slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 1000014 &lt;&lt; (*Sneut)(2).m &lt;&lt; &quot;# ~nu_muL&quot;;
      slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 1000015 &lt;&lt; (*Slepton)(5).m &lt;&lt; &quot;# ~tau_1-&quot;;
      slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 2000015 &lt;&lt; (*Slepton)(6).m &lt;&lt; &quot;# ~tau_2-&quot;;
      slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 1000016 &lt;&lt; (*Sneut)(3).m &lt;&lt; &quot;# ~nu_tauL&quot;;
    }

    slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 1000021 &lt;&lt; Glu-&gt;m &lt;&lt; &quot;# ~g&quot;;

    Farray_Freal8_1_4 mNr;
    Farray_Fcomplex16_1_4_1_4 Nr;

    for(int i=1; i&lt;=4; i++)
    {
      Freal8 sum = 0;
      for(int j=1; j&lt;=4; j++)
        sum += (*N)(i,j).re;
      if(sum == 0)
      {
        mNr(i) = -(*Chi0)(i).m;
        for(int j=1; j&lt;=4; j++)
          Nr(i,j).re = (*N)(i,j).im;
      }
      else
      {
        mNr(i) = (*Chi0)(i).m;
        for(int j=1; j&lt;=4; j++)
          Nr(i,j) = (*N)(i,j);
      }
    }
    slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 1000022 &lt;&lt; mNr(1) &lt;&lt; &quot;# ~chi_10&quot;;
    slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 1000023 &lt;&lt; mNr(2) &lt;&lt; &quot;# ~chi_20&quot;;
    slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 1000025 &lt;&lt; mNr(3) &lt;&lt; &quot;# ~chi_30&quot;;
    slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 1000035 &lt;&lt; mNr(4) &lt;&lt; &quot;# ~chi_40&quot;;
    slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 1000024 &lt;&lt; (*ChiPm)(1).m &lt;&lt; &quot;# ~chi_1+&quot;;
    slha[&quot;MASS&quot;][&quot;&quot;] &lt;&lt; 1000037 &lt;&lt; (*ChiPm)(2).m &lt;&lt; &quot;# ~chi_2+&quot;;


    // Check whether any of the masses is NaN
    auto block = slha[&quot;MASS&quot;];
    for(auto it = block.begin(); it != block.end(); it++)
    {
      if((*it)[0] != &quot;BLOCK&quot; and Utils::isnan(stod((*it)[1])) )
      {
        std::stringstream message;
        message &lt;&lt; &quot;Error in spectrum generator: mass of &quot; &lt;&lt; Models::ParticleDB().long_name(std::pair&lt;int,int&gt;(stoi((*it)[0]),0)) &lt;&lt; &quot; is NaN&quot;;
        logger() &lt;&lt; message.str() &lt;&lt; EOM;
        invalid_point().raise(message.str());
      }
    }

    // Block ALPHA
    SLHAea_add_block(slha, &quot;ALPHA&quot;);
    slha[&quot;ALPHA&quot;][&quot;&quot;] &lt;&lt; -asin((*RS0)(1,1)) &lt;&lt; &quot;# alpha&quot;;

    // BLOCK HMIX
    SLHAea_add_block(slha, &quot;HMIX&quot;, Q);
    slha[&quot;HMIX&quot;][&quot;&quot;] &lt;&lt; 1 &lt;&lt; mu-&gt;re &lt;&lt; &quot;# mu&quot;;
    slha[&quot;HMIX&quot;][&quot;&quot;] &lt;&lt; 2 &lt;&lt; *tanb_Q &lt;&lt; &quot;# tan[beta](Q)&quot;;
    slha[&quot;HMIX&quot;][&quot;&quot;] &lt;&lt; 3 &lt;&lt; *vev_Q &lt;&lt; &quot;# v(Q)&quot;;
    slha[&quot;HMIX&quot;][&quot;&quot;] &lt;&lt; 4 &lt;&lt; *mA2_Q &lt;&lt; &quot;# m^2_A(Q)&quot;;
    slha[&quot;HMIX&quot;][&quot;&quot;] &lt;&lt; 101 &lt;&lt; B-&gt;re &lt;&lt; &quot;# Bmu DRBar&quot;;
    slha[&quot;HMIX&quot;][&quot;&quot;] &lt;&lt; 102 &lt;&lt; (*vevSM)(1) &lt;&lt; &quot;# vd DRBar&quot;;
    slha[&quot;HMIX&quot;][&quot;&quot;] &lt;&lt; 103 &lt;&lt; (*vevSM)(2) &lt;&lt; &quot;# vu DRBar&quot;;

    if(mu-&gt;im != 0)
    {
      SLHAea_add_block(slha, &quot;IMHMIX&quot;, Q);
      slha[&quot;IMHMIX&quot;][&quot;&quot;] &lt;&lt; 1 &lt;&lt; mu-&gt;im &lt;&lt; &quot;# Im(mu)&quot;;
    }

    // Blocks SCALARMIX, PSEUDOSCALARMIX, CHARGEMIX
    SLHAea_add_block(slha, &quot;SCALARMIX&quot;);
    SLHAea_add_block(slha, &quot;PSEUDOSCALARMIX&quot;);
    SLHAea_add_block(slha, &quot;CHARGEMIX&quot;);
    for(int i=1; i&lt;=2; i++)
      for(int j=1; j&lt;=2; j++)
      {
        slha[&quot;SCALARMIX&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; (*RS0)(i,j) &lt;&lt; &quot;# ZH(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;)&quot;;
        slha[&quot;PSEUDOSCALARMIX&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; (*RP0)(i,j) &lt;&lt; &quot;# ZA(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;)&quot;;
        slha[&quot;CHARGEMIX&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; (*RSpm)(i,j).re &lt;&lt; &quot;# ZP(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;)&quot;;
      }

    // Blocks USQMIX, DSQMIX, SELMIX, SNUMIX or STOPMIX, SBOTMIX, STAUMIX
    if(*GenerationMixing)
    {
      SLHAea_add_block(slha, &quot;USQMIX&quot;);
      for(int i=1; i&lt;=6; i++)
        for(int j=1; j&lt;=6; j++)
        {
          slha[&quot;USQMIX&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; RUsq_ckm(i,j).re &lt;&lt; &quot;# R_Su(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;)&quot;;
          if(RUsq_ckm(i,j).im != 0)
          {
            SLHAea_check_block(slha, &quot;IMUSQMIX&quot;, i, true);
            slha[&quot;IMUSQMIX&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; RUsq_ckm(i,j).im &lt;&lt; &quot;# Im(R_Su)(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;)&quot;;
          }
        }

      SLHAea_add_block(slha, &quot;DSQMIX&quot;);
      for(int i=1; i&lt;=6; i++)
        for(int j=1; j&lt;=6; j++)
        {
          slha[&quot;DSQMIX&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; RDsq_ckm(i,j).re &lt;&lt; &quot;# R_Sd(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;)&quot;;
          if(RDsq_ckm(i,j).im != 0)
          {
            SLHAea_check_block(slha, &quot;IMDSQMIX&quot;, i, true);
            slha[&quot;IMDSQMIX&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; RDsq_ckm(i,j).im &lt;&lt; &quot;# Im(R_Sd)(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;)&quot;;
          }
        }

      SLHAea_add_block(slha, &quot;SELMIX&quot;);
      for(int i=1; i&lt;=6; i++)
        for(int j=1; j&lt;=6; j++)
        {
          slha[&quot;SELMIX&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; RSl_pmns(i,j).re &lt;&lt; &quot;# R_Sl(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;)&quot;;
          if(RSl_pmns(i,j).im != 0)
          {
            SLHAea_check_block(slha, &quot;IMSELMIX&quot;, i, true);
            slha[&quot;IMSELMIX&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; RSl_pmns(i,j).im &lt;&lt; &quot;# Im(R_Sl)(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;)&quot;;
          }
        }

      SLHAea_add_block(slha, &quot;SNUMIX&quot;);
      for(int i=1; i&lt;=3; i++)
        for(int j=1; j&lt;=3; j++)
        {
          slha[&quot;SNUMIX&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; RSn_pmns(i,j).re &lt;&lt; &quot;# R_Sn(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;)&quot;;
          if(RSn_pmns(i,j).im != 0)
          {
            SLHAea_check_block(slha, &quot;IMSNUMIX&quot;, i, true);
            slha[&quot;IMSNUMIX&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; RSn_pmns(i,j).im &lt;&lt; &quot;# Im(R_Sn)(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;)&quot;;
          }
        }

    }
    else
    {
      SLHAea_add_block(slha, &quot;STOPMIX&quot;);
      for(int i=1; i&lt;=2; i++)
        for(int j=1; j&lt;=2; j++)
        {
          slha[&quot;STOPMIX&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; RUsq_ckm(i+4,j+4).re &lt;&lt; &quot;# R_st(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;)&quot;;
          if(RUsq_ckm(i+4,j+4).im != 0)
          {
            SLHAea_check_block(slha, &quot;IMSTOPMIX&quot;, i, true);
            slha[&quot;IMSTOPMIX&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; RUsq_ckm(i+4,j+4).im &lt;&lt; &quot;# Im(R_st)(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;)&quot;;
          }
        }

      SLHAea_add_block(slha, &quot;SBOTMIX&quot;);
      for(int i=1; i&lt;=2; i++)
        for(int j=1; j&lt;=2; j++)
        {
          slha[&quot;SBOTMIX&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; RDsq_ckm(i+4,j+4).re &lt;&lt; &quot;# R_sb(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;)&quot;;
          if(RDsq_ckm(i+4,j+4).im != 0)
          {
            SLHAea_check_block(slha, &quot;IMSBOTMIX&quot;, i, true);
            slha[&quot;IMSBOTMIX&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; RDsq_ckm(i+4,j+4).im &lt;&lt; &quot;# Im(R_sb)(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;)&quot;;
          }
        }

      SLHAea_add_block(slha, &quot;STAUMIX&quot;);
      for(int i=1; i&lt;=2; i++)
        for(int j=1; j&lt;=2; j++)
        {
          slha[&quot;STAUMIX&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; RSl_pmns(i+4,j+4).re &lt;&lt; &quot;# R_sta(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;)&quot;;
          if(RSl_pmns(i+4,j+4).im != 0)
          {
            SLHAea_check_block(slha, &quot;IMSTAUMIX&quot;, i, true);
            slha[&quot;IMSTAUMIX&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; RSl_pmns(i+4,j+4).im &lt;&lt; &quot;# Im(R_sta)(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;)&quot;;
          }
        }
    }


    // Blocks NMIX, UMIX, VMIX
    SLHAea_add_block(slha, &quot;NMIX&quot;);
    for(int i=1; i&lt;=4; i++)
      for(int j=1; j&lt;=4; j++)
      {
        slha[&quot;NMIX&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; Nr(i,j).re &lt;&lt; &quot;# N(&quot; &lt;&lt; i &lt;&lt; j &lt;&lt; &quot;)&quot;;
        if(Nr(i,j).im != 0)
        {
          SLHAea_check_block(slha, &quot;IMNMIX&quot;, i, true);
          slha[&quot;IMNMIX&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; Nr(i,j).im &lt;&lt; &quot;# Im(N)(&quot; &lt;&lt; i &lt;&lt; j &lt;&lt; &quot;)&quot;;
        }
      }

    SLHAea_add_block(slha, &quot;UMIX&quot;);
    for(int i=1; i&lt;=2; i++)
      for(int j=1; j&lt;=2; j++)
      {
        slha[&quot;UMIX&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; (*U)(i,j).re &lt;&lt; &quot;# U(&quot; &lt;&lt; i &lt;&lt; j &lt;&lt; &quot;)&quot;;
        if((*U)(i,j).im != 0)
        {
          SLHAea_check_block(slha, &quot;IMUMIX&quot;, i, true);
          slha[&quot;IMUMIX&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; (*U)(i,j).im &lt;&lt; &quot;# Im(U)(&quot; &lt;&lt; i &lt;&lt; j &lt;&lt; &quot;)&quot;;
        }
      }


    SLHAea_add_block(slha, &quot;VMIX&quot;);
    for(int i=1; i&lt;=2; i++)
      for(int j=1; j&lt;=2; j++)
      {
        slha[&quot;VMIX&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; (*V)(i,j).re &lt;&lt; &quot;# V(&quot; &lt;&lt; i &lt;&lt; j &lt;&lt; &quot;)&quot;;
        if((*V)(i,j).im != 0)
        {
          SLHAea_check_block(slha, &quot;IMVMIX&quot;, i, true);
          slha[&quot;IMVMIX&quot;][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; (*V)(i,j).im &lt;&lt; &quot;# Im(V)(&quot; &lt;&lt; i &lt;&lt; j &lt;&lt; &quot;)&quot;;
        }
      }

    //Create Spectrum object
    static const Spectrum::mc_info mass_cut;
    static const Spectrum::mr_info mass_ratio_cut;
    Spectrum spectrum = spectrum_from_SLHAea&lt;MSSMSimpleSpec, SLHAstruct&gt;(slha,slha,mass_cut,mass_ratio_cut);

    // Add the high scale and susy scale variables by hand
    double high_scale;
    if(inputs.param.find(&quot;Qin&quot;) != inputs.param.end())
      high_scale = *inputs.param.at(&quot;Qin&quot;);
    else
      high_scale = *m_GUT;
    double susy_scale = Q;
    spectrum.get_HE().set_override(Par::mass1, high_scale, &quot;high_scale&quot;, true);
    spectrum.get_HE().set_override(Par::mass1, susy_scale, &quot;susy_scale&quot;, true);

    return spectrum;

  }

  // Function to read data from the Gambit inputs and fill SPheno internal variables
  void ReadingData(const Finputs &amp;inputs)
  {

    InitializeStandardModel(inputs.sminputs);
    try{ InitializeLoopFunctions(); }
    catch(std::runtime_error&amp; e) { invalid_point().raise(e.what()); }

    *ErrorLevel = -1;
    *GenerationMixing = false;
    *L_BR = false;
    *L_CS = false;

    try{ Set_All_Parameters_0(); }
    catch(std::runtime_error&amp; e) { invalid_point().raise(e.what()); }

    *TwoLoopRGE = true;

    *kont = 0;

    /****************/
    /* Block MODSEL */
    /****************/

    *GenerationMixing = inputs.options-&gt;getValueOrDef&lt;bool&gt;(false, &quot;GenerationMixing&quot;);

    /******************/
    /* Block SMINPUTS */
    /******************/
    // Already in InitializeStandardModel

    /****************/
    /* Block VCKMIN */
    /****************/
    // Already in SMInputs

    /****************/
    /* Block FCONST */
    /****************/
    // Some hadron constants, not really needed

    /***************/
    /* Block FMASS */
    /***************/
    // Masses of hadrons, not really needed

    /***************/
    /* Block FLIFE */
    /***************/
    // Lifetimes of hadrons, not really needed

    /*******************************/
    /* Block SPHENOINPUT (options) */
    /*******************************/

    // 1, Error_Level
    *ErrorLevel = inputs.options-&gt;getValueOrDef&lt;Finteger&gt;(-1, &quot;ErrorLevel&quot;);

    // 2, SPA_convention
    *SPA_convention = inputs.options-&gt;getValueOrDef&lt;bool&gt;(false, &quot;SPA_convention&quot;);
    if(*SPA_convention)
    {
      Freal8 scale = 1.0E6;  // SPA convention is 1 TeV
      try {SetRGEScale(scale); }
      catch(std::runtime_error&amp; e) { invalid_point().raise(e.what()); }
    }

    // 3, External_Spectrum
    // GAMBIT: no need for external spectrum options
    *External_Spectrum = false;
    *External_Higgs = false;

    // 4, Use_Flavour_States
    // GAMBIT: private variable, cannot import

    // 5, FermionMassResummation
    *FermionMassResummation = inputs.options-&gt;getValueOrDef&lt;bool&gt;(true, &quot;FermionMassResummation&quot;);

    // 6, Ynu_at_MR3, Fixed_Nu_Yukawas
    *Ynu_at_MR3 = false;
    *Fixed_Nu_Yukawas = false;

    // 7, Only_1loop_Higgsmass
    *Only_1loop_Higgsmass = inputs.options-&gt;getValueOrDef&lt;bool&gt;(false, &quot;Only_1loop_Higgsmass&quot;);

    // 8, calculates Masses for extra scales if required
    *Calc_Mass = inputs.options-&gt;getValueOrDef&lt;bool&gt;(false, &quot;Calc_Mass&quot;);

    // 9, use old version of BoundaryEW
    *UseNewBoundaryEW = inputs.options-&gt;getValueOrDef&lt;bool&gt;(true, &quot;UseNewBoundaryEW&quot;);

    // 10, use old version to calculate scale
    *UseNewScale = inputs.options-&gt;getValueOrDef&lt;bool&gt;(true, &quot;UseNewScale&quot;);

    // 11-13, whether to calculate branching ratios or not, L_BR
    *L_BR = false;

    // 21-26, whether to calculate cross sections or not, L_CS
    *L_CS = false;

    // 31, setting a fixed GUT scale, GUTScale
    Freal8 GUTScale = inputs.options-&gt;getValueOrDef&lt;Freal8&gt;(0.0, &quot;GUTScale&quot;);
    if(GUTScale &gt; 0.0)
    {
      try{ SetGUTScale(GUTScale); }
      catch(std::runtime_error&amp; e) { invalid_point().raise(e.what()); }
    }

    // 32, requires strict unification, StrictUnification
    Flogical StrictUnification = inputs.options-&gt;getValueOrDef&lt;bool&gt;(false, &quot;StrictUnification&quot;);
    if(StrictUnification)
    {
      try{ SetStrictUnification(StrictUnification); }
      catch(std::runtime_error&amp; e) { invalid_point().raise(e.what()); }
    }

    // 34, precision of mass calculation, delta_mass
    *delta_mass = inputs.options-&gt;getValueOrDef&lt;Freal8&gt;(0.00001, &quot;delta_mass&quot;);

    // 35, maximal number of iterations, n_run
    *n_run = inputs.options-&gt;getValueOrDef&lt;Finteger&gt;(40, &quot;n_run&quot;);

    // 36 write out debug information
    *WriteOut = false;

    // 37, if = 1 -&gt; CKM through V_u, if = 2 CKM through V_d, YukawaScheme
    Finteger YukawaScheme = inputs.options-&gt;getValueOrDef&lt;Finteger&gt;(1, &quot;YukawaScheme&quot;);
    if(YukawaScheme == 1 or YukawaScheme == 2)
    {
      try{ SetYukawaScheme(YukawaScheme); }
      catch(std::runtime_error&amp; e) { invalid_point().raise(e.what()); }
    }

    // 38, set looplevel of RGEs, TwoLoopRGE
    *TwoLoopRGE = inputs.options-&gt;getValueOrDef&lt;bool&gt;(true, &quot;TwoLoopRGE&quot;);
    if(*TwoLoopRGE)
      *ThreeLoopRGE = inputs.options-&gt;getValueOrDef&lt;bool&gt;(false, &quot;ThreeLoopRGE&quot;);

    // 39, write additional SLHA1 file, Write_SLHA1
    // GAMBIT: Always SLHA2
    *Write_SLHA1 = false;

    // 40, alpha(0), Alpha
    Freal8 alpha = 1.0/137.035999074;
    *Alpha = inputs.options-&gt;getValueOrDef&lt;Freal8&gt;(alpha,&quot;Alpha&quot;);

    // 41, Z-boson width, gamZ
    *gamZ = inputs.options-&gt;getValueOrDef&lt;Freal8&gt;(2.49,&quot;gamZ&quot;);

    // 42, W-boson width, gamW
    *gamW = inputs.options-&gt;getValueOrDef&lt;Freal8&gt;(2.06,&quot;gamW&quot;);

    // 45, in case of large logs for m_h switch to 1-loop calculation
    *Switch_to_1_loop_mh = inputs.options-&gt;getValueOrDef&lt;bool&gt;(false, &quot;Switch_to_1_loop_mh&quot;);

    // 48, switch on NNNL fit formula for m_t and alpha_s values at Q=m_t
    *l_mt_3loop = inputs.options-&gt;getValueOrDef&lt;bool&gt;(false,&quot;l_mt_3loop&quot;);

    // 49, switch on SM decoupling
    *l_SM_decoupling = inputs.options-&gt;getValueOrDef&lt;bool&gt;(true, &quot;l_SM_decoupling&quot;);

    // 80, exit for sure with non-zero value if a problem occurs
    *Non_Zero_Exit = false;

    // 89, quick and dirty way to implement model by Suchita Kulkarni
    *Model_Suchita = false;

    // 90, add R-parity at low energies
    *Add_Rparity = false;

    // 91, fit RP parameters such, that neutrino data are o.k.
    *l_fit_RP_parameters = false;

    // 92, for Pythia input
    // GAMBIT: private variable, cannot import

    // 93, calculates cross section in case of RP, only partially implemented
    *l_CSrp = false;

    // 94, calculates cross section in case of RP, only partially implemented
    // GAMBIT: private variable, cannot import

    // 99, MADGraph output style, some additional information
    // GAMBIT: private variable, cannot import

    // 100, use bsstep instead of rkqs
    Flogical Use_bsstep_instead_of_rkqs = inputs.options-&gt;getValueOrDef&lt;bool&gt;(false, &quot;Use_bsstep_instead_of_rkqs&quot;);
    if(Use_bsstep_instead_of_rkqs)
    {
      try{ Set_Use_bsstep_instead_of_rkqs(Use_bsstep_instead_of_rkqs); }
      catch(std::runtime_error&amp; e) { invalid_point().raise(e.what()); }
    }

    // 101, use rzextr instead of pzextr
    Flogical Use_rzextr_instead_of_pzextr = inputs.options-&gt;getValueOrDef&lt;bool&gt;(false, &quot;Use_rzextr_instead_of_pzextr&quot;);
    if(Use_rzextr_instead_of_pzextr)
    {
      try{ Set_Use_rzextr_instead_of_pzextr(Use_rzextr_instead_of_pzextr); }
      catch(std::runtime_error&amp; e) { invalid_point().raise(e.what()); }
    }

    // 110, write output for LHC observables
    // GAMBIT: private variable, cannot import

    // Silence screen output, added by GAMBIT to SPheno
    *SilenceOutput = inputs.options-&gt;getValueOrDef&lt;bool&gt;(false, &quot;SilenceOutput&quot;);

    /****************/
    // Block MINPAR //
    /****************/
    if(inputs.param.find(&quot;M0&quot;) != inputs.param.end())
    {
      for(int i=1; i&lt;=3; i++)
        (*M2D_0_sckm)(i,i).re = pow(*inputs.param.at(&quot;M0&quot;),2);
      *M2E_0_pmns = *M2D_0_sckm;
      *M2L_0_pmns = *M2D_0_sckm;
      *M2_R_0 = *M2D_0_sckm;
      *M2Q_0_sckm = *M2D_0_sckm;
      *M2U_0_sckm = *M2D_0_sckm;
      for(int i=1; i&lt;=2; i++)
        (*M2_H_0)(i) = pow(*inputs.param.at(&quot;M0&quot;),2);
      *M2_T_0 = *M2_H_0;
    }
    // M12
    if(inputs.param.find(&quot;M12&quot;) != inputs.param.end())
    {
      for(int i=1; i&lt;=3; i++)
        (*Mi_0)(i).re = *inputs.param.at(&quot;M12&quot;);
    }
    // TanBeta (at MZ)
    if(inputs.param.find(&quot;TanBeta&quot;) != inputs.param.end())
    {
      *tanb = *inputs.param.at(&quot;TanBeta&quot;);
      *tanb_mZ = *tanb;
    }
    // SignMu
    if(inputs.param.find(&quot;SignMu&quot;) != inputs.param.end())
    {
      phase_mu-&gt;re = *inputs.param.at(&quot;SignMu&quot;);
    }
    // A0
    if(inputs.param.find(&quot;A0&quot;) != inputs.param.end())
    {
      for(int i=1; i&lt;=3; i++)
        (*AoY_d_0)(i,i).re = *inputs.param.at(&quot;A0&quot;);
      *AoY_l_0 = *AoY_d_0;
      *AoY_u_0 = *AoY_d_0;
      *AoY_nu_0 = *AoY_d_0;
      *AoT_0 = *AoY_d_0;
      for(int i=1; i&lt;=2; i++)
        (*Aolam12_0)(i).re = *inputs.param.at(&quot;A0&quot;);
    }

    /****************/
    /* Block EXTPAR */
    /****************/
    // Q_in
    if(inputs.param.find(&quot;Qin&quot;) != inputs.param.end())
      SetRGEScale(*inputs.param.at(&quot;Qin&quot;));
    // M_1
    if(inputs.param.find(&quot;M1&quot;) != inputs.param.end())
    {
      (*Mi_0)(1).re = *inputs.param.at(&quot;M1&quot;);
      (*Mi)(1).re = *inputs.param.at(&quot;M1&quot;);
    }
    // M_2
    if(inputs.param.find(&quot;M2&quot;) != inputs.param.end())
    {
      (*Mi_0)(2).re = *inputs.param.at(&quot;M2&quot;);
      (*Mi)(2).re = *inputs.param.at(&quot;M2&quot;);
    }
    // M_3
    if(inputs.param.find(&quot;M3&quot;) != inputs.param.end())
    {
      (*Mi_0)(3).re = *inputs.param.at(&quot;M3&quot;);
      (*Mi)(3).re = *inputs.param.at(&quot;M3&quot;);
    }
    // A_t
    if(inputs.param.find(&quot;Au_33&quot;) != inputs.param.end())
    {
      (*AoY_u)(3,3).re = *inputs.param.at(&quot;Au_33&quot;);
      *At_save = (*AoY_u)(3,3);
      *AoY_u_0 = *AoY_u;
    }
    // A_b
    if(inputs.param.find(&quot;Ad_33&quot;) != inputs.param.end())
    {
      (*AoY_d)(3,3).re = *inputs.param.at(&quot;Ad_33&quot;);
      *Ab_save = (*AoY_d)(3,3);
      *AoY_d_0 = *AoY_d;
    }
    // A_tau
    if(inputs.param.find(&quot;Ae_33&quot;) != inputs.param.end())
    {
      (*AoY_l)(3,3).re = *inputs.param.at(&quot;Ae_33&quot;);
      *Atau_save = (*AoY_l)(3,3);
      *AoY_l_0 = *AoY_l;
    }
    // M^2_Hd
    if(inputs.param.find(&quot;mHd2&quot;) != inputs.param.end())
    {
      (*M2_H)(1) = *inputs.param.at(&quot;mHd2&quot;);
      (*M2_H_0)(1) = *inputs.param.at(&quot;mHd2&quot;);
    }
    // M^2_Hu
    if(inputs.param.find(&quot;mHu2&quot;) != inputs.param.end())
    {
      (*M2_H)(2) = *inputs.param.at(&quot;mHu2&quot;);
      (*M2_H_0)(2) = *inputs.param.at(&quot;mHu2&quot;);
    }
    // Mu
    if(inputs.param.find(&quot;mu&quot;) != inputs.param.end())
    {
      mu-&gt;re = *inputs.param.at(&quot;mu&quot;);
    }
    // MA^2
    if(inputs.param.find(&quot;mA&quot;) != inputs.param.end())
    {
      (*mP0)(2) = *inputs.param.at(&quot;mA&quot;);
      (*mP02)(2) = pow((*mP0)(2),2);
    }

    for(int i=1; i&lt;=3; i++)
      for(int j=1; j&lt;=3; j++)
      {
        /********/
        /* TUIN */
        /********/
        std::stringstream parname;
        parname &lt;&lt; &quot;Au_&quot; &lt;&lt; i &lt;&lt; j;
        if(inputs.param.find(parname.str()) != inputs.param.end())
        {
          (*Au_0_sckm)(i,j).re = *inputs.param.at(parname.str());
          // unfortunatly there is a transpose due to the RGE implemenation
          (*Au_sckm)(j,i).re = *inputs.param.at(parname.str());
          *l_Au = true;
        }

        /********/
        /* TDIN */
        /********/
        parname.str(std::string());
        parname &lt;&lt; &quot;Ad_&quot; &lt;&lt; i &lt;&lt; j;
        if(inputs.param.find(parname.str()) != inputs.param.end())
        {
          (*Ad_0_sckm)(i,j).re = *inputs.param.at(parname.str());
          // unfortunatly there is a transpose due to the RGE implemenation
          (*Ad_sckm)(j,i).re = *inputs.param.at(parname.str());
          *l_Ad = true;
        }

        /********/
        /* TEIN */
        /********/
        parname.str(std::string());
        parname &lt;&lt; &quot;Ae_&quot; &lt;&lt; i &lt;&lt; j;
        if(inputs.param.find(parname.str()) != inputs.param.end())
        {
          (*Al_0_pmns)(i,j).re = *inputs.param.at(parname.str());
          // unfortunatly there is a transpose due to the RGE implemenation
          (*Al_pmns)(j,i).re = *inputs.param.at(parname.str());
          *l_Al = true;
        }
      }

    for(int i=1; i&lt;=3; i++)
      for(int j=i; j&lt;=3; j++)
      {
        /**********/
        /* MSL2IN */
        /**********/
        std::stringstream parname;
        parname &lt;&lt; &quot;ml2_&quot; &lt;&lt; i &lt;&lt; j;
        if(inputs.param.find(parname.str()) != inputs.param.end())
        {
          (*M2L_pmns)(i,j).re = *inputs.param.at(parname.str());
          *M2L_0_pmns = *M2L_pmns;
          *l_ML = true;
        }
        /**********/
        /* MSE2IN */
        /**********/
        parname.str(std::string());
        parname &lt;&lt; &quot;me2_&quot; &lt;&lt; i &lt;&lt; j;
        if(inputs.param.find(parname.str()) != inputs.param.end())
        {
          (*M2E_pmns)(i,j).re = *inputs.param.at(parname.str());
          *M2E_0_pmns = *M2E_pmns;
          *l_ME = true;
        }
        /**********/
        /* MSQ2IN */
        /**********/
        parname.str(std::string());
        parname &lt;&lt; &quot;mq2_&quot; &lt;&lt; i &lt;&lt; j;
        if(inputs.param.find(parname.str()) != inputs.param.end())
        {
          (*M2Q_sckm)(i,j).re = *inputs.param.at(parname.str());
          *M2Q_0_sckm = *M2Q_sckm;
          *l_MQ = true;
        }
        /**********/
        /* MSU2IN */
        /**********/
        parname.str(std::string());
        parname &lt;&lt; &quot;mu2_&quot; &lt;&lt; i &lt;&lt; j;
        if(inputs.param.find(parname.str()) != inputs.param.end())
        {
          (*M2U_sckm)(i,j).re = *inputs.param.at(parname.str());
          *M2U_0_sckm = *M2U_sckm;
          *l_MU = true;
        }
        /**********/
        /* MSD2IN */
        /**********/
        parname.str(std::string());
        parname &lt;&lt; &quot;md2_&quot; &lt;&lt; i &lt;&lt; j;
        if(inputs.param.find(parname.str()) != inputs.param.end())
        {
          (*M2D_sckm)(i,j).re = *inputs.param.at(parname.str());
          *M2D_0_sckm = *M2D_sckm;
          *l_MD = true;
        }
      }

    // No other blocks are relevant at this stage

  }

  void InitializeStandardModel(const SMInputs &amp;sminputs)
  {

    *kont = 0;

    // Contributions to alpha(m_Z), based on F. Jegerlehner, hep-ph/0310234 and Fanchiotti, Kniehl, Sirlin PRD 48 (1993) 307
    *Delta_Alpha_Lepton = 0.04020;
    *Delta_Alpha_Hadron = 0.027651;

    // Z-boson
    *mZ = sminputs.mZ;          // mass
    *gamZ = 2.4952;             // width, values henceforth from StandardModel.f90
    (*BrZqq)(1) = 0.156;        // branching ratio in d \bar{d}
    (*BrZqq)(2) = 0.156;        // branching ratio in s \bar{s}
    (*BrZqq)(3) = 0.151;        // branching ratio in b \bar{b}
    (*BrZqq)(4) = 0.116;        // branching ratio in u \bar{u}
    (*BrZqq)(5) = 0.12;         // branching ratio in c \bar{c}
    (*BrZll)(1) = 0.0336;       // branching ratio in e+ e-
    (*BrZll)(2) = 0.0336;       // branching ratio in mu+ mu-
    (*BrZll)(3) = 0.0338;       // branching ratio in tau+ tau-
    *BrZinv = 0.2;              // invisible branching ratio

    *mZ2 = *mZ * *mZ;
    *gamZ2 = *gamZ * *gamZ;
    *gmZ = *gamZ * *mZ;
    *gmZ2 = *gmZ * *gmZ;

    // W-boson
    *mW = 80.385;
    *gamW = 2.085;
    (*BrWqq)(1) = 0.35;
    (*BrWqq)(2) = 0.35;
    for(int i=1; i&lt;=3; i++)
      (*BrWln)(i) = 0.1;

    *mW2 = pow(*mW, 2);
    *gamW2 = pow(*gamW, 2);
    *gmW = *gamW * *mW;
    *gmW2 = pow(*gmW, 2);

    // lepton masses: e, muon, tau
    (*mf_l)(1) = sminputs.mE;
    (*mf_l)(2) = sminputs.mMu;
    (*mf_l)(3) = sminputs.mTau;

    // neutrino masses
    (*mf_nu)(1) = sminputs.mNu1;
    (*mf_nu)(2) = sminputs.mNu2;
    (*mf_nu)(3) = sminputs.mNu3;

    // scale where masses of light quarks are defined [in GeV]
    (*Q_light_quarks) = 2;

    // up-quark masses: u, c, t
    (*mf_u)(1) = sminputs.mU;
    (*mf_u)(2) = sminputs.mCmC;
    (*mf_u)(3) = sminputs.mT;

    // down-quark masses: d, s, b
    (*mf_d)(1) = sminputs.mD;
    (*mf_d)(2) = sminputs.mS;
    (*mf_d)(3) = sminputs.mBmB;

    for(int i=1; i&lt;=3; i++)
    {
       (*mf_l2)(i) = pow((*mf_l)(i),2);
       (*mf_u2)(i) = pow((*mf_u)(i),2);
       (*mf_d2)(i) = pow((*mf_d)(i),2);
    }

   // couplings: Alpha(Q=0), Alpha(mZ), Alpha_S(mZ), Fermi constant G_F
    *Alpha_mZ = 1.0/sminputs.alphainv;
    *Alpha_mZ_MS = *Alpha_mZ; // from SMINPUTS
    *MZ_input = true;
    *AlphaS_mZ = sminputs.alphaS;
    *G_F = sminputs.GF;

    // for ISR correction in e+e- annihilation
    *KFactorLee = 1.0 + (M_PI/3.0 - 1.0/(2*M_PI))*(*Alpha);

    // CKM matrix
    *lam_wolf = sminputs.CKM.lambda;
    *A_wolf = sminputs.CKM.A;
    *rho_wolf = sminputs.CKM.rhobar;
    *eta_wolf = sminputs.CKM.etabar;


    double s12 = sminputs.CKM.lambda;
    double s23 = pow(s12,2) * sminputs.CKM.A;
    double s13 = s23 * sminputs.CKM.lambda * sqrt(pow(sminputs.CKM.etabar,2) + pow(sminputs.CKM.rhobar,2));
    double phase = atan(sminputs.CKM.etabar/sminputs.CKM.rhobar);

    double c12 = sqrt(1.0 - s12*s12);
    double c23 = sqrt(1.0 - s23*s23);
    double c13 = sqrt(1.0 - s13*s13);

    std::complex&lt;double&gt; i = -1;
    i = sqrt(i);

    (*CKM)(1,1) = c12 * c13;
    (*CKM)(1,2) = s12 * c13;
    (*CKM)(1,3) = s13 * exp(-i * phase);
    (*CKM)(2,1) = -s12*c23 -c12*s23*s13 * exp(i * phase);
    (*CKM)(2,2) = c12*c23 -s12*s23*s13 * exp(i * phase );
    (*CKM)(2,3) = s23 * c13;
    (*CKM)(3,1) = s12*s23 -c12*c23*s13 * exp(i * phase );
    (*CKM)(3,2) = -c12*s23 - s12*c23*s13 * exp( i * phase );
    (*CKM)(3,3) = c23 * c13;

    for(int i=1; i&lt;=3; i++)
    {
      (*mf_l_mZ)(i) = 0.0;
      (*mf_d_mZ)(i) = 0.0;
      (*mf_u_mZ)(i) = 0.0;
    }
    try{ CalculateRunningMasses(*mf_l, *mf_d, *mf_u, *Q_light_quarks, *Alpha_mZ, *AlphaS_mZ, *mZ, *mf_l_mZ, *mf_d_mZ, *mf_u_mZ, *kont); }
    catch(std::runtime_error&amp; e) { invalid_point().raise(e.what()); }

    // PMNS matrix
    *theta_12 = sminputs.PMNS.theta12;
    *theta_23 = sminputs.PMNS.theta23;
    *theta_13 = sminputs.PMNS.theta13;
    *delta_nu = sminputs.PMNS.delta13;
    *alpha_nu1 = sminputs.PMNS.alpha1;
    *alpha_nu2 = sminputs.PMNS.alpha2;

    s12 = sin(*theta_12);
    s23 = sin(*theta_23);
    s13 = sin(*theta_13);

    c12 = sqrt(1.0 - pow(s12,2));
    c23 = sqrt(1.0 - pow(s23,2));
    c13 = sqrt(1.0 - pow(s13,2));

    (*Unu)(1,1) = c12 * c13 * exp(-0.5*i * *alpha_nu1);
    (*Unu)(1,2) = s12 * c13 * exp(-0.5*i * *alpha_nu1);
    (*Unu)(1,3) = s13 * exp(-i * *delta_nu) * exp(-0.5*i * *alpha_nu1);
    (*Unu)(2,1) = -s12*c23 - c12*s23*s13 * exp(i * *delta_nu) * exp(-0.5*i * *alpha_nu2);
    (*Unu)(2,2) = c12*c23 - s12*s23*s13 * exp(i * *delta_nu) * exp(-0.5*i * *alpha_nu2);
    (*Unu)(2,3) = s23 * c13 * exp(-0.5*i * *alpha_nu2);
    (*Unu)(3,1) = s12*s23 - c12*c23*s13 * exp(i * *delta_nu);
    (*Unu)(3,2) = -c12*s23 - s12*c23*s13 * exp(i * *delta_nu);
    (*Unu)(3,3) = c23 * c13;

    if(*kont != 0)
      ErrorHandling(*kont);
  }

  // Function that handles errors
  void ErrorHandling(const int &amp;kont)
  {

    str message;

    if (kont &gt; 0 and kont &lt;= 31)
      message = (*Math_Error)(kont).str();
    else if (kont &gt; 100 and kont &lt;= 102)
      message = (*SM_Error)(kont-100).str();
    else if (kont &gt; 200 and kont &lt;= 233)
      message = (*SusyM_Error)(kont-200).str();
    else if (kont &gt; 300 and kont &lt;= 315)
      message = (*InOut_Error)(kont-300).str();
    else if (kont &gt; 400 and kont &lt;= 422)
      message = (*Sugra_Error)(kont-400).str();
    else if (kont &gt; 500 and kont &lt;= 525)
      message = (*LoopMass_Error)(kont-500).str();
    else if (kont &gt; 600 and kont &lt;= 609)
      message = (*TwoLoopHiggs_Error)(kont-600).str();
    else if (kont &gt; 1000 and kont &lt;= 1010)
      message = (*MathQP_Error)(kont-1000).str();
    else
      message = &quot;GAMBIT caught an error in SPheno. Check the SPheno output for more info.&quot;;

    logger() &lt;&lt; message &lt;&lt; EOM;
    invalid_point().raise(message);

    return ;

  }
}
END_BE_NAMESPACE


// Initialisation function (definition)
BE_INI_FUNCTION
{

  // Scan-level initialisation
  static bool scan_level = true;
  if (scan_level)
  {
    // Dump all internal output to stdout
    *ErrCan = 6;

    // Set the function pointer in SPheno to our ErrorHandler callback function
    *ErrorHandler_cptr = &amp; CAT_4(BACKENDNAME,_,SAFE_VERSION,_ErrorHandler);

    try{ Set_All_Parameters_0(); }
    catch(std::runtime_error&amp; e) { invalid_point().raise(e.what()); }

    /****************/
    /* Block MODSEL */
    /****************/
    if((*ModelInUse)(&quot;CMSSM&quot;) or (*ModelInUse)(&quot;MSSM63atMGUT&quot;))
    {
      *HighScaleModel = &quot;mSUGRA&quot;;
      SetHighScaleModel(&quot;SUGRA&quot;);
    }
    else if((*ModelInUse)(&quot;MSSM63atQ&quot;))
    {
      *HighScaleModel = &quot;MSSM&quot;;
    }
    else
    {
      str message = &quot;Model not recognised&quot;;
      logger() &lt;&lt; message &lt;&lt; EOM;
      invalid_point().raise(message);
    }

  }
  scan_level = false;


}
END_BE_INI_FUNCTION
</code></pre><hr><p>Updated on 2022-08-02 at 18:18:41 +0000</p><div class=edit-page><a href=https://github.com/RC1242RC/gambit_gh_pages/blob/master/content/en/documentation/code/gambit_sphinx/Files/SPheno__4__0__3_8cpp.md><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828.0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>Edit this page on GitHub</a></div></main></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Powered by <a class=text-muted href=https://www.netlify.com/>Netlify</a>, <a class=text-muted href=https://gohugo.io/>Hugo</a>, and <a class=text-muted href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline><li class=list-inline-item><a href=/license/>License</a></li></ul></div></div></div></footer><script src=/js/bootstrap.min.54bf0932b8a36d0e152b1635b099a6ef1394d35327e2437550a075c9c8ed1bd8aed5847c21b36fc02ed24014c031d9ca24017b0c78b1639d7e2fa8329898b842.js integrity="sha512-VL8JMrijbQ4VKxY1sJmm7xOU01Mn4kN1UKB1ycjtG9iu1YR8IbNvwC7SQBTAMdnKJAF7DHixY51+L6gymJi4Qg==" crossorigin=anonymous defer></script>
<script src=/js/highlight.min.5b48bc253dc75aeea5fb366ecf700f4925e2b6eb1a1466f2124b722d68148d67bc0a9365d2b8ad9c585161b46372d23b08509a16f1fd518542b894756d4752d0.js integrity="sha512-W0i8JT3HWu6l+zZuz3APSSXitusaFGbyEktyLWgUjWe8CpNl0ritnFhRYbRjctI7CFCaFvH9UYVCuJR1bUdS0A==" crossorigin=anonymous defer></script>
<script src=/main.min.40265e9a032aeba5eaf67baac3cbbc22667a7533215d326eeb3e9f4d5e4be40f9ff4dcd22949db73ae527ca26a19d7998091a8973c82af760b2c0daa335190ed.js integrity="sha512-QCZemgMq66Xq9nuqw8u8ImZ6dTMhXTJu6z6fTV5L5A+f9NzSKUnbc65SfKJqGdeZgJGolzyCr3YLLA2qM1GQ7Q==" crossorigin=anonymous defer></script>
<script src=https://rc1242rc.github.io/index.min.bf15e814991a9d3ef02f52a26d135d3cd0a098afc407e971daad9f276d437236be129db79cd96bd09f86d0730d8272253cdaff9edd528739d4fc2013efa8d4ba.js integrity="sha512-vxXoFJkanT7wL1KibRNdPNCgmK/EB+lx2q2fJ21Dcja+Ep23nNlr0J+G0HMNgnIlPNr/nt1ShznU/CAT76jUug==" crossorigin=anonymous defer></script></body></html>