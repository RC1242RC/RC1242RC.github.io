<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=https://rc1242rc.github.io/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://rc1242rc.github.io/fonts/vendor/jost/jost-v4-latin-500.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://rc1242rc.github.io/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><script>(()=>{var e=localStorage.getItem("theme");e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><link rel=stylesheet href=https://rc1242rc.github.io/main.f12f7e04ea768acebec10c86baf049d74d6a79f24bc0dfb7ed77aa60462432916dd1ce8f41c78b69496adf650b3039a28a210183cce598f09b95d6fecb5ff999.css integrity="sha512-8S9+BOp2is6+wQyGuvBJ101qefJLwN+37XeqYEYkMpFt0c6PQceLaUlq32ULMDmiiiEBg8zlmPCbldb+y1/5mQ==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>file frontends/DarkSUSY_5_1_3.cpp - GAMBIT</title><meta name=description content="[No description available]"><link rel=canonical href=https://rc1242rc.github.io/documentation/code/darkbit_development/files/darksusy__5__1__3_8cpp/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="file frontends/DarkSUSY_5_1_3.cpp"><meta property="og:description" content="[No description available]"><meta property="og:url" content="https://rc1242rc.github.io/documentation/code/darkbit_development/files/darksusy__5__1__3_8cpp/"><meta property="og:site_name" content="GAMBIT"><meta property="og:image" content="https://rc1242rc.github.io/gambit_logo.png"><meta property="og:image:alt" content="GAMBIT"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content><meta name=twitter:creator content><meta name=twitter:title content="file frontends/DarkSUSY_5_1_3.cpp"><meta name=twitter:description content="[No description available]"><meta name=twitter:image content="https://rc1242rc.github.io/gambit_logo.png"><meta name=twitter:image:alt content="file frontends/DarkSUSY_5_1_3.cpp"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://rc1242rc.github.io/#/schema/organization/1","name":"Doks","url":"https://rc1242rc.github.io/","sameAs":["https://github.com/GambitBSM"],"logo":{"@type":"ImageObject","@id":"https://rc1242rc.github.io/#/schema/image/1","url":"https://rc1242rc.github.io/logo-doks.png","width":450,"height":416,"caption":"Doks"},"image":{"@id":"https://rc1242rc.github.io/#/schema/image/1"}},{"@type":"WebSite","@id":"https://rc1242rc.github.io/#/schema/website/1","url":"https://rc1242rc.github.io/","name":"GAMBIT","description":"Documentation for the Global And Modular BSM Inference Tool","publisher":{"@id":"https://rc1242rc.github.io/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://rc1242rc.github.io/documentation/code/darkbit_development/files/darksusy__5__1__3_8cpp/","url":"https://rc1242rc.github.io/documentation/code/darkbit_development/files/darksusy__5__1__3_8cpp/","name":"file frontends\/DarkSUSY_5_1_3.cpp","description":"[No description available]","isPartOf":{"@id":"https://rc1242rc.github.io/#/schema/website/1"},"about":{"@id":"https://rc1242rc.github.io/#/schema/organization/1"},"datePublished":"0001-01-01T00:00:00CET","dateModified":"0001-01-01T00:00:00CET","breadcrumb":{"@id":"https://rc1242rc.github.io/documentation/code/darkbit_development/files/darksusy__5__1__3_8cpp/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://rc1242rc.github.io/documentation/code/darkbit_development/files/darksusy__5__1__3_8cpp/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://rc1242rc.github.io/documentation/code/darkbit_development/files/darksusy__5__1__3_8cpp/"]}]},{"@type":"BreadcrumbList","@id":"https://rc1242rc.github.io/documentation/code/darkbit_development/files/darksusy__5__1__3_8cpp/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/","url":"https://rc1242rc.github.io/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/documentation/","url":"https://rc1242rc.github.io/documentation/","name":"Documentation"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/documentation/code/","url":"https://rc1242rc.github.io/documentation/code/","name":"Code"}},{"@type":"ListItem","position":4,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/documentation/code/darkbit_development/","url":"https://rc1242rc.github.io/documentation/code/darkbit_development/","name":"Darkbit Development"}},{"@type":"ListItem","position":5,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/documentation/code/darkbit_development/files/","url":"https://rc1242rc.github.io/documentation/code/darkbit_development/files/","name":"Files"}},{"@type":"ListItem","position":6,"item":{"@id":"https://rc1242rc.github.io/documentation/code/darkbit_development/files/darksusy__5__1__3_8cpp/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://rc1242rc.github.io/documentation/code/darkbit_development/files/darksusy__5__1__3_8cpp/#/schema/image/2","url":"https://rc1242rc.github.io/gambit_logo.png","contentUrl":"https://rc1242rc.github.io/gambit_logo.png","caption":"file frontends\/DarkSUSY_5_1_3.cpp"}]}]}</script><meta name=theme-color content="#fff"><link rel=icon href=https://rc1242rc.github.io/favicon.ico sizes=any><link rel=icon type=image/svg+xml href=https://rc1242rc.github.io/favicon.svg><link rel=apple-touch-icon sizes=180x180 href=https://rc1242rc.github.io/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://rc1242rc.github.io/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://rc1242rc.github.io/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://rc1242rc.github.io/site.webmanifest></head><body class="documentation single light"><div class=sticky-top><div class=header-bar></div><header class="navbar navbar-expand-md navbar-light doks-navbar"><nav class="container-xxl flex-wrap flex-md-nowrap" aria-label="Main navigation"><a class="navbar-brand p-0 me-auto" href=https://rc1242rc.github.io/ aria-label=GAMBIT><img class=logo-light src=https://rc1242rc.github.io//images/gambit_logo.png width=50px>
<img class="logo-dark d-none" src=https://rc1242rc.github.io//images/gambit_logo.png width=50px>
GAMBIT</a>
<button class="btn btn-menu order-2 d-block d-lg-none" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasDoks aria-controls=offcanvasDoks aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><div class="offcanvas offcanvas-end border-0 py-lg-1" tabindex=-1 id=offcanvasDoks data-bs-backdrop=true aria-labelledby=offcanvasDoksLabel><div class="header-bar d-lg-none"></div><div class="offcanvas-header d-lg-none"><h2 class="h5 offcanvas-title ps-2" id=offcanvasDoksLabel><a class=text-dark href=/>GAMBIT</a></h2><button type=button class="btn-close text-reset me-2" data-bs-dismiss=offcanvas aria-label="Close main menu"></button></div><div class="offcanvas-body p-4 p-lg-0"><ul class="nav flex-column flex-lg-row align-items-lg-center mt-2 mt-lg-0 ms-lg-2 me-lg-auto"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Documentation
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/documentation/installation/introduction/>Installation</a></li><li><a class=dropdown-item href=/documentation/examples/colliderbit>Examples</a></li><li><a class=dropdown-item href=/documentation/help/faqs/>Help</a></li><li><a class=dropdown-item href=/documentation/code/index_classes>Code Reference</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Community
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/community/publications/>Publications</a></li><li><a class=dropdown-item href=/community/talks/>Talks</a></li><li><a class=dropdown-item href=/community/members/>Members</a></li><li><a class=dropdown-item href=/community/code_of_conduct/>Code of Conduct</a></li><li><a class=dropdown-item href=/community/contact/>Contact</a></li></ul></li></ul><hr class="text-black-50 my-4 d-lg-none"><form class="doks-search position-relative flex-grow-1 ms-lg-auto me-lg-2"><input id=search class="form-control is-search" type=search placeholder="Search site..." aria-label="Search site..." autocomplete=off><div id=suggestions class="shadow bg-white rounded d-none"></div></form><hr class="text-black-50 my-4 d-lg-none"><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=https://github.com/GambitBSM><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><small class="ms-2 d-lg-none">GitHub</small></a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn btn-doks-light dropdown-toggle" id=doks-versions data-bs-toggle=dropdown aria-expanded=false data-bs-display=static aria-label="Toggle version menu">
<span class=d-none>Doks</span>
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=doks-versions></ul></div></div></div></nav></header></div><div class="wrap container-xxl" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class=docs-links aria-label="Main navigation"><ul class="list-unstyled collapsible-sidebar"><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-installation aria-expanded=false>
Installation</button><div class=collapse id=section-installation><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/installation/introduction/>Getting Started</a></li><li><a class="docs-link rounded" href=/documentation/installation/docker_usage/>Docker Usage</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_linux/>Installation for Linux</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_windows/>Installation for Windows</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_macos/>Installation for macOS</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-examples aria-expanded=false>
Examples</button><div class=collapse id=section-examples><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/examples/colliderbit/>ColliderBit</a></li><li><a class="docs-link rounded" href=/documentation/examples/anotherbit/>AnotherBit</a></li><li><a class="docs-link rounded" href=/documentation/examples/anotherbit2/>AnotherBit2</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-help aria-expanded=false>
Help</button><div class=collapse id=section-help><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/help/faqs/>FAQs</a></li><li><a class="docs-link rounded" href=/documentation/help/compiler_matrix/>Compiler Matrix</a></li><li><a class="docs-link rounded" href=/documentation/help/known_issues/>Known Issues</a></li><li><a class="docs-link rounded" href=/documentation/help/configuration_examples/>Configuration Examples</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-code aria-expanded=false>
Code Reference</button></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section- aria-expanded=false>
GAMBIT_VERSION_HERE</button><div class=collapse id=section-><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/code/colliderbit_development/index_classes/>Classes</a></li><li><a class="docs-link rounded" href=/documentation/code/colliderbit_development/index_files/>Files</a></li><li><a class="docs-link rounded" href=/documentation/code/colliderbit_development/index_pages/>Pages</a></li><li><a class="docs-link rounded" href=/documentation/code/colliderbit_development/index_namespaces/>Namespaces</a></li></ul></div></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=d-xl-none><button class="btn btn-outline-primary btn-sm doks-toc-toggle collapsed" type=button data-bs-toggle=collapse data-bs-target=#onThisPage aria-controls=doks-docs-nav aria-expanded=false aria-label="Toggle On this page navigation">
<span>On this page</span>
<span><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"/><polyline points="7 6 12 11 17 6"/></svg><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"/><polyline points="17 18 12 13 7 18"/></svg></span></button><div class=collapse id=onThisPage><div class="card card-body mt-3 py-1"><div class=page-links><nav id=TableOfContents><ul><li><ul><li><a href=#functions>Functions</a></li><li><a href=#attributes>Attributes</a></li><li><a href=#detailed-description>Detailed Description</a></li><li><a href=#functions-documentation>Functions Documentation</a><ul><li><a href=#function-if>function if</a></li><li><a href=#function-if-1>function if</a></li><li><a href=#function-if-2>function if</a></li><li><a href=#function-if-3>function if</a></li><li><a href=#function-if-4>function if</a></li></ul></li><li><a href=#attributes-documentation>Attributes Documentation</a><ul><li><a href=#variable-be_namespace>variable BE_NAMESPACE</a></li><li><a href=#variable-dsparticle_mass>variable DSparticle_mass</a></li><li><a href=#variable-gambitparticle_mass>variable GAMBITparticle_mass</a></li><li><a href=#variable-be_ini_function>variable BE_INI_FUNCTION</a></li><li><a href=#variable-mssm_result>variable mssm_result</a></li></ul></li><li><a href=#source-code>Source code</a></li></ul></li></ul></nav></div></div></div></div><div class="page-links d-none d-xl-block"><h3>On this page</h3><nav id=TableOfContents><ul><li><ul><li><a href=#functions>Functions</a></li><li><a href=#attributes>Attributes</a></li><li><a href=#detailed-description>Detailed Description</a></li><li><a href=#functions-documentation>Functions Documentation</a><ul><li><a href=#function-if>function if</a></li><li><a href=#function-if-1>function if</a></li><li><a href=#function-if-2>function if</a></li><li><a href=#function-if-3>function if</a></li><li><a href=#function-if-4>function if</a></li></ul></li><li><a href=#attributes-documentation>Attributes Documentation</a><ul><li><a href=#variable-be_namespace>variable BE_NAMESPACE</a></li><li><a href=#variable-dsparticle_mass>variable DSparticle_mass</a></li><li><a href=#variable-gambitparticle_mass>variable GAMBITparticle_mass</a></li><li><a href=#variable-be_ini_function>variable BE_INI_FUNCTION</a></li><li><a href=#variable-mssm_result>variable mssm_result</a></li></ul></li><li><a href=#source-code>Source code</a></li></ul></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9 mx-xl-auto"><h1>file frontends/DarkSUSY_5_1_3.cpp</h1><p class=lead></p><p>[No description available] <a href=#detailed-description>More&mldr;</a></p><h2 id=functions>Functions <a href=#functions class=anchor aria-hidden=true>#</a></h2><table><thead><tr><th></th><th>Name</th></tr></thead><tbody><tr><td></td><td><strong><a href=/documentation/code/darkbit_development/files/darksusy__5__1__3_8cpp/#function-if>if</a></strong>(scan_level )</td></tr><tr><td></td><td><strong><a href=/documentation/code/darkbit_development/files/darksusy__5__1__3_8cpp/#function-if>if</a></strong>(runOptions-> hasKey"debug_SLHA_filenames")</td></tr><tr><td>else</td><td><strong><a href=/documentation/code/darkbit_development/files/darksusy__5__1__3_8cpp/#function-if>if</a></strong>(ModelInUse(&ldquo;CMSSM&rdquo;) and runOptions->getValueOrDef&lt; bool >(false, &ldquo;use_DS_isasugra&rdquo;) )<br>Option use_DS_isasugra<bool>: Use DS internal isasugra for parameter running (false)</td></tr><tr><td>else</td><td><strong><a href=/documentation/code/darkbit_development/files/darksusy__5__1__3_8cpp/#function-if>if</a></strong>(ModelInUse(&ldquo;MSSM63atQ&rdquo;)</td></tr><tr><td></td><td><strong><a href=/documentation/code/darkbit_development/files/darksusy__5__1__3_8cpp/#function-if>if</a></strong>((ModelInUse(&ldquo;MSSM63atQ&rdquo;)</td></tr></tbody></table><h2 id=attributes>Attributes <a href=#attributes class=anchor aria-hidden=true>#</a></h2><table><thead><tr><th></th><th>Name</th></tr></thead><tbody><tr><td></td><td><strong><a href=/documentation/code/darkbit_development/files/darksusy__5__1__3_8cpp/#variable-be-namespace>BE_NAMESPACE</a></strong></td></tr><tr><td>std::vector&lt; double ></td><td><strong><a href=/documentation/code/darkbit_development/files/darksusy__5__1__3_8cpp/#variable-dsparticle-mass>DSparticle_mass</a></strong></td></tr><tr><td>std::vector&lt; double ></td><td><strong><a href=/documentation/code/darkbit_development/files/darksusy__5__1__3_8cpp/#variable-gambitparticle-mass>GAMBITparticle_mass</a></strong></td></tr><tr><td><a href=/documentation/code/darkbit_development/files/common__macros_8hpp/#define-end-be-namespace>END_BE_NAMESPACE</a></td><td><strong><a href=/documentation/code/darkbit_development/files/darksusy__5__1__3_8cpp/#variable-be-ini-function>BE_INI_FUNCTION</a></strong></td></tr><tr><td>bool</td><td><strong><a href=/documentation/code/darkbit_development/files/darksusy__5__1__3_8cpp/#variable-mssm-result>mssm_result</a></strong></td></tr></tbody></table><h2 id=detailed-description>Detailed Description <a href=#detailed-description class=anchor aria-hidden=true>#</a></h2><p><strong>Author</strong>:</p><ul><li>Anders Kvellestad (<a href=mailto:anders.kvellestad@fys.uio.no>anders.kvellestad@fys.uio.no</a>)</li><li>Pat Scott (<a href=mailto:p.scott@imperial.ac.uk>p.scott@imperial.ac.uk</a>)</li><li>Christoph Weniger (<a href=mailto:c.weniger@uva.nl>c.weniger@uva.nl</a>)</li><li>Torsten Bringmann (<a href=mailto:torsten.bringmann@fys.uio.no>torsten.bringmann@fys.uio.no</a>)</li><li>Lars A. Dal (<a href=mailto:l.a.dal@fys.uio.no>l.a.dal@fys.uio.no</a>)</li><li>Joakim Edsjo (<a href=mailto:edsjo@fysik.su.se>edsjo@fysik.su.se</a>)</li></ul><p><strong>Date</strong>:</p><ul><li>2013 Mar</li><li>2013 Apr 2015 Mar, Aug 2016 Feb</li><li>2013 Jul</li><li>2013 Jul, 2014 Mar, 2015 May, 2019 May</li><li>2014 Mar</li><li>2015 Aug, 2016 Mar</li></ul><p>Frontend for DarkSUSY 5.1.3 backend</p><hr><p>Authors (add name and date if you modify):</p><hr><h2 id=functions-documentation>Functions Documentation <a href=#functions-documentation class=anchor aria-hidden=true>#</a></h2><h3 id=function-if>function if <a href=#function-if class=anchor aria-hidden=true>#</a></h3><pre><code>if(
    scan_level 
)
</code></pre><h3 id=function-if-1>function if <a href=#function-if-1 class=anchor aria-hidden=true>#</a></h3><pre><code>if(
    runOptions-&gt; hasKey&quot;debug_SLHA_filenames&quot;
)
</code></pre><p>Option debug_SLHA_filenames&lt;std::vector<a href=std::string>std::string</a>>: Optional override list of SLHA filenames used for backend initialization default</p><h3 id=function-if-2>function if <a href=#function-if-2 class=anchor aria-hidden=true>#</a></h3><pre><code>else if(
    ModelInUse(&quot;CMSSM&quot;) and runOptions-&gt;getValueOrDef&lt; bool &gt;(false, &quot;use_DS_isasugra&quot;) 
)
</code></pre><p>Option use_DS_isasugra<bool>: Use DS internal isasugra for parameter running (false)</p><h3 id=function-if-3>function if <a href=#function-if-3 class=anchor aria-hidden=true>#</a></h3><pre><code>else if(
    ModelInUse(&quot;MSSM63atQ&quot;)||ModelInUse(&quot;CMSSM&quot;) 
)
</code></pre><p>Option use_dsSLHAread<bool>: Use DS internal SLHA reader to initialize backend (false)</p><h3 id=function-if-4>function if <a href=#function-if-4 class=anchor aria-hidden=true>#</a></h3><pre><code>if(
    (ModelInUse(&quot;MSSM63atQ&quot;)||ModelInUse(&quot;CMSSM&quot;)) &amp;&amp;! mssm_result
)
</code></pre><h2 id=attributes-documentation>Attributes Documentation <a href=#attributes-documentation class=anchor aria-hidden=true>#</a></h2><h3 id=variable-be_namespace>variable BE_NAMESPACE <a href=#variable-be_namespace class=anchor aria-hidden=true>#</a></h3><pre><code>BE_NAMESPACE {
  const double min_DS_rwidth = 5.e-3;
</code></pre><h3 id=variable-dsparticle_mass>variable DSparticle_mass <a href=#variable-dsparticle_mass class=anchor aria-hidden=true>#</a></h3><pre><code>std::vector&lt; double &gt; DSparticle_mass;
</code></pre><h3 id=variable-gambitparticle_mass>variable GAMBITparticle_mass <a href=#variable-gambitparticle_mass class=anchor aria-hidden=true>#</a></h3><pre><code>std::vector&lt; double &gt; GAMBITparticle_mass;
</code></pre><h3 id=variable-be_ini_function>variable BE_INI_FUNCTION <a href=#variable-be_ini_function class=anchor aria-hidden=true>#</a></h3><pre><code>END_BE_NAMESPACE BE_INI_FUNCTION {
  
  bool static scan_level = true;
</code></pre><h3 id=variable-mssm_result>variable mssm_result <a href=#variable-mssm_result class=anchor aria-hidden=true>#</a></h3><pre><code>bool mssm_result = false;
</code></pre><h2 id=source-code>Source code <a href=#source-code class=anchor aria-hidden=true>#</a></h2><pre><code>//   GAMBIT: Global and Modular BSM Inference Tool
//   *********************************************

#include &quot;gambit/Backends/frontend_macros.hpp&quot;
#include &quot;gambit/Backends/frontends/DarkSUSY_5_1_3.hpp&quot;
#include &quot;gambit/Utils/file_lock.hpp&quot;
#include &quot;gambit/Utils/mpiwrapper.hpp&quot;

//#define DARKSUSY_DEBUG

// Some ad-hoc DarkSUSY global state.
BE_NAMESPACE
{
  const double min_DS_rwidth = 5.e-3; // 0.5%  to avoid numerical problems
  std::vector&lt;double&gt; DSparticle_mass;
  std::vector&lt;double&gt; GAMBITparticle_mass;
}
END_BE_NAMESPACE

// Initialisation function (definition)
BE_INI_FUNCTION
{
  // Initialize DarkSUSY (only) if run for the first time
  bool static scan_level = true;

  if (scan_level)
  {

    // Do the call to dsinit one-by-one for each MPI process, as DarkSUSY loads up
    // HiggsBounds, which writes files at init then reads them back in later.
    Utils::ProcessLock mylock(&quot;DarkSUSY_&quot; STRINGIFY(SAFE_VERSION) &quot;_init&quot;);
    mylock.get_lock();
    dsinit();
    mylock.release_lock();

    dsrdinit();

    // Initialize yield tables for use in cascade decays (initialize more if needed)
    dshainit(151); // Initialize positron tables
    dshainit(152); // Initialize gamma ray tables
    dshainit(154); // Initialize antiproton tables
    // Note, for DarkSUSY 5, anti-deuteron does not need special initialization
    // as they are calculated from antiproton fluxes

    // Call dshayield for first call initialization of variables
    double tmp1 = 100.0;
    double tmp2 = 10.0;
    int tmp3 = 15;
    int tmp4 = 152;
    int tmp5 = 0;
    dshayield(tmp1,tmp2,tmp3,tmp4,tmp5);

    scan_level = false;

  }

  // Initialization function for a given MSSM point
  // (previous capability DarkSUSY_PointInit)
  bool mssm_result = false;

  // If the user provides a file list, just read in SLHA files for debugging
  // and ignore the MSSM_spectrum dependency.
  if (runOptions-&gt;hasKey(&quot;debug_SLHA_filenames&quot;))
  {
    static unsigned int counter = 0;
    logger() &lt;&lt; LogTags::debug &lt;&lt;
      &quot;Initializing DarkSUSY via debug_SLHA_filenames option.&quot; &lt;&lt; EOM;

    std::vector&lt;str&gt; filenames = runOptions-&gt;getValue&lt;std::vector&lt;str&gt; &gt;(&quot;debug_SLHA_filenames&quot;);
    const char * filename = filenames[counter].c_str();
    int len = filenames[counter].length();
    int flag = 15;
    dsSLHAread(byVal(filename),flag,byVal(len));
    dsprep();

    counter++;
    if (counter &gt;= filenames.size()) counter = 0;
    mssm_result = true;
  }

  // CMSSM with DS-internal ISASUGRA (should be avoided, only for debugging)
  else if (ModelInUse(&quot;CMSSM&quot;) and runOptions-&gt;getValueOrDef&lt;bool&gt;(false, &quot;use_DS_isasugra&quot;))
  {
    // Setup mSUGRA model from CMSSM parameters
    double am0    = *Param[&quot;M0&quot;];     // m0
    double amhf   = *Param[&quot;M12&quot;];    // m_1/2
    double aa0    = *Param[&quot;A0&quot;];     // A0
    double asgnmu = *Param[&quot;SignMu&quot;];  // sign(mu)
    double atanbe = *Param[&quot;TanBeta&quot;];   // tan(beta)
    logger() &lt;&lt; &quot;Initializing DarkSUSY via dsgive_model_isasugra:&quot; &lt;&lt; EOM;
    logger() &lt;&lt; &quot;  m0        =&quot; &lt;&lt; am0    &lt;&lt; std::endl;
    logger() &lt;&lt; &quot;  m_1/2     =&quot; &lt;&lt; amhf   &lt;&lt; std::endl;
    logger() &lt;&lt; &quot;  A0        =&quot; &lt;&lt; aa0    &lt;&lt; std::endl;
    logger() &lt;&lt; &quot;  sign(mu)  =&quot; &lt;&lt; asgnmu &lt;&lt; std::endl;
    logger() &lt;&lt; &quot;  tan(beta) =&quot; &lt;&lt; atanbe &lt;&lt; EOM;
    dsgive_model_isasugra(am0, amhf, aa0, asgnmu, atanbe);
    int unphys, hwarning;
    dssusy_isasugra(unphys, hwarning);

    if (unphys &lt; 0)
    {
      backend_warning().raise(LOCAL_INFO, &quot;Model point is theoretically inconsistent (DarkSUSY).&quot;);
      invalid_point().raise(&quot;Model point is theoretically inconsistent (DarkSUSY).&quot;);
      mssm_result = false;
    }
    else if (unphys &gt; 0)
    {
      backend_warning().raise(LOCAL_INFO, &quot;Neutralino is not the LSP (DarkSUSY).&quot;);
      invalid_point().raise(&quot;Neutralino is not the LSP (DarkSUSY).&quot;);
      mssm_result = false;
    }
    else if (hwarning != 0)
    {
      backend_warning().raise(LOCAL_INFO,
          &quot;Radiative corrections in Higgs sector &quot;
          &quot;outside range of validity (DarkSUSY).&quot;);
      mssm_result = true;
    }
    else
    {
      mssm_result = true;
    }
  }

  else if (ModelInUse(&quot;MSSM63atQ&quot;) || ModelInUse(&quot;CMSSM&quot;))
  {
    SLHAstruct mySLHA;
    bool use_dsSLHAread = runOptions-&gt;getValueOrDef&lt;bool&gt;(false, &quot;use_dsSLHAread&quot;);
    int slha_version = 2;
    const Spectrum&amp; mySpec = *Dep::MSSM_spectrum;
    try
    {
      mySLHA = mySpec.getSLHAea(2);
    }
    catch(Gambit::exception&amp; e)
    {
        slha_version = 1;
        mySLHA = mySpec.getSLHAea(1);
        use_dsSLHAread = true;
    }

    // Use an actual SLHA file.  DarkSUSY is on its own wrt (s)particle widths this way.
    if (use_dsSLHAread || slha_version == 1)
    {
      if (!use_dsSLHAread) {backend_error().raise(LOCAL_INFO,
              &quot;An SLHA1 spectrum requires use of the DarkSUSY SLHA reader rather than the diskless\n&quot;
              &quot;GAMBIT DarkSUSY initialization. To enable the DarkSUSY SLHA reader, set the option\n&quot;
              &quot;use_dsSLHAread for the function DarkSUSY_PointInit_MSSM to true.&quot;);}

      int rank = 0;
      #ifdef WITH_MPI
        if(GMPI::Is_initialized())
        {
          GMPI::Comm comm;
          rank = comm.Get_rank();
        }
      #endif

      // Add model select block to inform DS about 6x6 mixing
      if (slha_version == 2)
      {
          SLHAea::Block modsel_block(&quot;MODSEL&quot;);
          modsel_block.push_back(&quot;BLOCK MODSEL&quot;);
          modsel_block.push_back(&quot;6 3 # FV&quot;);
          mySLHA.push_back(modsel_block);
      }

      // Set filename
      std::string fstr = &quot;DarkBit_temp_&quot;;
      fstr += std::to_string(rank) + &quot;.slha&quot;;
      // Dump SLHA onto disk
      std::ofstream ofs(fstr);
      ofs &lt;&lt; mySLHA;
      ofs.close();
      // Initialize SUSY spectrum from SLHA
      int len = fstr.size();
      int flag = 15;
      const char * filename = fstr.c_str();
      logger() &lt;&lt; LogTags::debug &lt;&lt; &quot;Initializing DarkSUSY via SLHA.&quot; &lt;&lt; EOM;
      dsSLHAread(byVal(filename),flag,byVal(len));
      //The following used to be a separate capability dsprep up to DS5
      //(as also specified in the manual)
      dsprep();
      mssm_result = true;
    }

    // Do pure diskless SLHA initialisation, including (s)particle widths from GAMBIT.
    else
    {
      if (init_diskless(mySLHA, *Dep::decay_rates) == 0 )
      {
        logger() &lt;&lt; LogTags::debug &lt;&lt; &quot;Using diskless SLHA interface to DarkSUSY.&quot; &lt;&lt; EOM;
        dsprep();
        mssm_result = true;
      }
    }
  }

  if ( (ModelInUse(&quot;MSSM63atQ&quot;) || ModelInUse(&quot;CMSSM&quot;)) &amp;&amp; !mssm_result )
  {
    backend_warning().raise(LOCAL_INFO,
        &quot;DarkSUSY point initialization failed.&quot;);
    invalid_point().raise(&quot;DarkSUSY point initialization failed.&quot;);
  }

}
END_BE_INI_FUNCTION


// Convenience functions (definitions)
BE_NAMESPACE
{

  void required_block(const std::string&amp; name, const SLHAea::Coll&amp; slha)
  {
    if (slha.find(name) != slha.end()) return;
    else backend_error().raise(LOCAL_INFO, &quot;Sorry, DarkSUSY needs SLHA block: &quot; + name + &quot;.\n&quot;
    &quot;If you tried to read in a debug SLHA file with missing entries,                       \n&quot;
    &quot;then sort out your SLHA file so that it is readable by DarkSUSY!                      &quot;);
  }

  void dsgenericwimp_nusetup(const double (&amp;annihilation_bf)[29], const double (&amp;Higgs_decay_BFs_neutral)[29][3],
   const double (&amp;Higgs_decay_BFs_charged)[15], const double (&amp;Higgs_masses_neutral)[3], const double &amp;Higgs_mass_charged,
   const double &amp;mwimp)
  {
    // Transfer WIMP mass common block.
    wabranch-&gt;wamwimp = mwimp;

    // Transfer branching fractions to WIMP annihilation common blocks.
    // For channel indices, see dswayieldone.f
    for (int i=1; i&lt;=29; i++)
    {
      wabranch-&gt;wabr(i) = annihilation_bf[i-1];
    }

    // Transfer Higgs decay branching fractions (not widths) to Higgs decay common blocks.
    // The total width is not relevant, as all Higgs decay in flight eventually, so
    // only the BFs are needed to calculate the yields into neutrinos from decays in flight.
    for (int i=1; i&lt;=3; i++)    // Loop over the neutral Higgses
    {
      for (int j=1; j&lt;=29; j++) // Loop over the known decay channels
      {
        wabranch-&gt;was0br(j,i) = Higgs_decay_BFs_neutral[j-1][i-1];
      }
    }

    for (int i=1; i&lt;=15; i++)   // Loop over the known charged Higgs decay channels
    {
      wabranch-&gt;wascbr(i) = Higgs_decay_BFs_charged[i-1];
    }

    // Transfer Higgs masses to common blocks.
    for (int i=1; i&lt;=3; i++)    // Loop over the neutral Higgses
    {
      wabranch-&gt;was0m(i) = Higgs_masses_neutral[i-1];                   // Neutral Higgses
    }
    wabranch-&gt;wascm = Higgs_mass_charged;                               // Charged Higgses

    // Tell DarkSUSY we've taken care of business.
    wabranch-&gt;dswasetupcalled = true;

  }

  double neutrino_yield(const double&amp; log10E, const int&amp; ptype, void*&amp;)
  {
    int istat = 0;
    const char object[3] = &quot;su&quot;;
    double result = 1e-30 * dsntmuonyield(pow(10.0,log10E),10.0,object[0],3,1,ptype,istat);
    if ((istat bitand 1) == 1)
    {
      if (not piped_warnings.inquire()) // Don't bother re-raising a warning if it's already been done since the last .check().
        piped_warnings.request(LOCAL_INFO, &quot;Neutrino yield from Sun is lower bound; likelihood will be conservative.&quot;);
    }
    if ((istat bitand 4) == 4)
    {
      if (not piped_warnings.inquire()) // Don't bother re-raising a warning if it's already been done since the last .check().
        piped_warnings.request(LOCAL_INFO, &quot;DarkSUSY's dswayield_int didn't converge. This occasionally happens &quot;
                                           &quot;due to finite statistics in the nu yield tables from Pythia. &quot;
                                           &quot;This is benign (the missing integrals are always negligible).&quot;);
    }
    if (istat &gt; 4)
    {
      std::ostringstream err;
      err &lt;&lt; &quot;Error from DarkSUSY::dswayield functions in neutrino flux calculation.  istat = &quot; &lt;&lt; istat;
      piped_errors.request(LOCAL_INFO, err.str());
    }
    return result;
  }

  // FIXME: add channel codes!
  int DSparticle_code(const str&amp; particleID)
  {
    int kpart;
    if (particleID==&quot;nu_e&quot; or particleID==&quot;nubar_e&quot;){
     kpart=1;
    }else if (particleID==&quot;e-_1&quot; or particleID==&quot;e+_1&quot;){
     kpart=2;
    }else if (particleID==&quot;nu_mu&quot; or particleID==&quot;nubar_mu&quot;){
     kpart=3;
    }else if (particleID==&quot;e-_2&quot; or particleID==&quot;e+_2&quot;){
     kpart=4;
    }else if (particleID==&quot;nu_tau&quot; or particleID==&quot;nubar_tau&quot;){
     kpart=5;
    }else if (particleID==&quot;e-_3&quot; or particleID==&quot;e+_3&quot;){
     kpart=6;
    }else if (particleID==&quot;u_1&quot; or particleID==&quot;ubar_1&quot;){
     kpart=7;
    }else if (particleID==&quot;d_1&quot; or particleID==&quot;dbar_1&quot;){
     kpart=8;
    }else if (particleID==&quot;u_2&quot; or particleID==&quot;ubar_2&quot;){
     kpart=9;
    }else if (particleID==&quot;d_2&quot; or particleID==&quot;dbar_2&quot;){
     kpart=10;
    }else if (particleID==&quot;u_3&quot; or particleID==&quot;ubar_3&quot;){
     kpart=11;
    }else if (particleID==&quot;d_3&quot; or particleID==&quot;dbar_3&quot;){
     kpart=12;
    }else if (particleID==&quot;gamma&quot;){
     kpart=13;
    }else if (particleID==&quot;W+&quot; or particleID==&quot;W-&quot;){
     kpart=14;
    }else if (particleID==&quot;Z0&quot;){
     kpart=15;
    }else if (particleID==&quot;g&quot;){
     kpart=16;
    }else if (particleID==&quot;h0_1&quot;){
     kpart=18;
    }else if (particleID==&quot;h0_2&quot;){
     kpart=17;
    }else if (particleID==&quot;A0&quot;){
     kpart=19;
    }else if (particleID==&quot;H+&quot; or particleID==&quot;H-&quot;){
     kpart=20;
    }else if (particleID==&quot;~nu_1&quot; or particleID==&quot;~nubar_1&quot;){
     kpart=21;
    }else if (particleID==&quot;~e-_1&quot; or particleID==&quot;~e+_1&quot;){
     kpart=22;
    }else if (particleID==&quot;~e-_4&quot; or particleID==&quot;~e+_4&quot;){
     kpart=23;
    }else if (particleID==&quot;~nu_2&quot; or particleID==&quot;~nubar_2&quot;){
     kpart=24;
    }else if (particleID==&quot;~e-_2&quot; or particleID==&quot;~e+_2&quot;){
     kpart=25;
    }else if (particleID==&quot;~e-_5&quot; or particleID==&quot;~e+_5&quot;){
     kpart=26;
    }else if (particleID==&quot;~nu_3&quot; or particleID==&quot;~nubar_3&quot;){
     kpart=27;
    }else if (particleID==&quot;~e-_3&quot; or particleID==&quot;~e+_3&quot;){
     kpart=28;
    }else if (particleID==&quot;~e-_6&quot; or particleID==&quot;~e+_6&quot;){
     kpart=29;
    }else if (particleID==&quot;~u_1&quot; or particleID==&quot;~ubar_1&quot;){
     kpart=30;
    }else if (particleID==&quot;~u_4&quot; or particleID==&quot;~ubar_4&quot;){
     kpart=31;
    }else if (particleID==&quot;~d_1&quot; or particleID==&quot;~dbar_1&quot;){
     kpart=32;
    }else if (particleID==&quot;~d_4&quot; or particleID==&quot;~dbar_4&quot;){
     kpart=33;
    }else if (particleID==&quot;~u_2&quot; or particleID==&quot;~ubar_2&quot;){
     kpart=34;
    }else if (particleID==&quot;~u_5&quot; or particleID==&quot;~ubar_5&quot;){
     kpart=35;
    }else if (particleID==&quot;~d_2&quot; or particleID==&quot;~dbar_2&quot;){
     kpart=36;
    }else if (particleID==&quot;~d_5&quot; or particleID==&quot;~dbar_5&quot;){
     kpart=37;
    }else if (particleID==&quot;~u_3&quot; or particleID==&quot;~ubar_3&quot;){
     kpart=38;
    }else if (particleID==&quot;~u_6&quot; or particleID==&quot;~ubar_6&quot;){
     kpart=39;
    }else if (particleID==&quot;~d_3&quot; or particleID==&quot;~dbar_3&quot;){
     kpart=40;
    }else if (particleID==&quot;~d_6&quot; or particleID==&quot;~dbar_6&quot;){
     kpart=41;
    }else if (particleID==&quot;~chi0_1&quot;){
     kpart=42;
    }else if (particleID==&quot;~chi0_2&quot;){
     kpart=43;
    }else if (particleID==&quot;~chi0_3&quot;){
     kpart=44;
    }else if (particleID==&quot;~chi0_4&quot;){
     kpart=45;
    }else if (particleID==&quot;~chi+_1&quot; or particleID==&quot;~chi-_1&quot;){
     kpart=46;
    }else if (particleID==&quot;~chi+_2&quot; or particleID==&quot;~chi-_2&quot;){
     kpart=47;
    }else if (particleID==&quot;~g&quot;){
     kpart=48;
    } else{
     std::ostringstream err;
     err &lt;&lt; &quot;ERROR: translation into DS particle code not implemented &quot;
         &lt;&lt; &quot;for string identifier &quot; &lt;&lt; particleID;
     backend_error().raise(LOCAL_INFO, err.str());
     kpart=-100;
    }
    return kpart;
  }

  int init_diskless(const SLHAstruct &amp;mySLHA, const DecayTable &amp;myDecays)
  {
    using SLHAea::to;
    DS5_PACODES *DSpart = &amp;(*pacodes);

    // Define required blocks and raise an error if a block is missing
    required_block(&quot;SMINPUTS&quot;, mySLHA);
    required_block(&quot;VCKMIN&quot;,   mySLHA);
    required_block(&quot;MSOFT&quot;,    mySLHA);
    required_block(&quot;MASS&quot;,     mySLHA);
    required_block(&quot;NMIX&quot;,     mySLHA);
    required_block(&quot;VMIX&quot;,     mySLHA);
    required_block(&quot;UMIX&quot;,     mySLHA);
    required_block(&quot;ALPHA&quot;,    mySLHA);
    required_block(&quot;HMIX&quot;,     mySLHA);
    required_block(&quot;YU&quot;,       mySLHA);
    required_block(&quot;YD&quot;,       mySLHA);
    required_block(&quot;YE&quot;,       mySLHA);
    required_block(&quot;MSL2&quot;,     mySLHA);
    required_block(&quot;MSE2&quot;,     mySLHA);
    required_block(&quot;MSQ2&quot;,     mySLHA);
    required_block(&quot;MSD2&quot;,     mySLHA);
    required_block(&quot;MSU2&quot;,     mySLHA);
    required_block(&quot;TD&quot;,       mySLHA);
    required_block(&quot;TU&quot;,       mySLHA);
    required_block(&quot;TE&quot;,       mySLHA);
    required_block(&quot;USQMIX&quot;,   mySLHA);
    required_block(&quot;DSQMIX&quot;,   mySLHA);
    required_block(&quot;SELMIX&quot;,   mySLHA);
    required_block(&quot;SNUMIX&quot;,   mySLHA);

    // Make sure the b pole mass is present in the MASS block
    if (mySLHA.at(&quot;MASS&quot;).find(initVector&lt;str&gt;(&quot;5&quot;)) == mySLHA.at(&quot;MASS&quot;).end())
      backend_error().raise(LOCAL_INFO, &quot;DarkSUSY init_diskless needs b pole mass entry (5) in SLHA(ea) MASS block.&quot;);

    // Do some initial DarkSUSY housekeeping.
    dsmssmzero();            // zero all the MSSM parameters and variables
    mssmtype-&gt;modeltype = 0; // tell DarkSUSY that we are working in the general MSSM
    // To match the DarkSUSY SLHAreader, you would need to also set
    // mssmswitch-&gt;higwid = 1;  // tell DarkSUSY not to use FeynHiggs for Higgs widths.

    // Block SMINPUTS
    couplingconstants-&gt;alphem           = 1./to&lt;double&gt;(mySLHA.at(&quot;SMINPUTS&quot;).at(1).at(1)); // 1/alpha_{QED}
    smruseful-&gt;alph3mz                  = to&lt;double&gt;(mySLHA.at(&quot;SMINPUTS&quot;).at(3).at(1));    // alpha_s @ MZ
    smruseful-&gt;gfermi                   = to&lt;double&gt;(mySLHA.at(&quot;SMINPUTS&quot;).at(2).at(1));    // Fermi constant
    mspctm-&gt;mass(DSparticle_code(&quot;Z0&quot;)) = to&lt;double&gt;(mySLHA.at(&quot;SMINPUTS&quot;).at(4).at(1));    // Z boson mass

    // Here we set the masses to be used in DarkSUSY.  Note that all masses in the mspctm-&gt;mass block
    // must match those in the ProcessCatalog in DarkBit, as these are used to define the kinematic
    // edges used in relic density integrations and similar within DarkSUSY.  Mostly these should be
    // pole masses, except in cases where that is not possible (i.e. light quarks).

    // Lepton masses
    mspctm-&gt;mass(DSpart-&gt;kl(1))  = to&lt;double&gt;(mySLHA.at(&quot;SMINPUTS&quot;).at(11).at(1));  // electron pole mass
    mspctm-&gt;mass(DSpart-&gt;kl(2))  = to&lt;double&gt;(mySLHA.at(&quot;SMINPUTS&quot;).at(13).at(1));  // muon pole mass
    mspctm-&gt;mass(DSpart-&gt;kl(3))  = to&lt;double&gt;(mySLHA.at(&quot;SMINPUTS&quot;).at(7).at(1));   // tau pole mass
    mspctm-&gt;mass(DSpart-&gt;knu(1)) = to&lt;double&gt;(mySLHA.at(&quot;SMINPUTS&quot;).at(12).at(1));  // nu_1 pole mass
    mspctm-&gt;mass(DSpart-&gt;knu(2)) = to&lt;double&gt;(mySLHA.at(&quot;SMINPUTS&quot;).at(14).at(1));  // nu_2 pole mass
    mspctm-&gt;mass(DSpart-&gt;knu(3)) = to&lt;double&gt;(mySLHA.at(&quot;SMINPUTS&quot;).at(8).at(1));   // nu_3 pole mass

    // Quark masses as defined in SLHA2
    mspctm-&gt;mu2gev               = to&lt;double&gt;(mySLHA.at(&quot;SMINPUTS&quot;).at(22).at(1)); // up quark mass @ 2 GeV
    mspctm-&gt;md2gev               = to&lt;double&gt;(mySLHA.at(&quot;SMINPUTS&quot;).at(21).at(1)); // down quark mass @ 2 GeV
    mspctm-&gt;ms2gev               = to&lt;double&gt;(mySLHA.at(&quot;SMINPUTS&quot;).at(23).at(1)); // strange mass @ 2 GeV
    mspctm-&gt;mcmc                 = to&lt;double&gt;(mySLHA.at(&quot;SMINPUTS&quot;).at(24).at(1)); // charm mass at m_c
    mspctm-&gt;mbmb                 = to&lt;double&gt;(mySLHA.at(&quot;SMINPUTS&quot;).at(5).at(1));  // bottom mass at m_b
    mspctm-&gt;mass(DSpart-&gt;kqu(3)) = to&lt;double&gt;(mySLHA.at(&quot;SMINPUTS&quot;).at(6).at(1));  // top pole mass

    // Do the DarkSUSY-style sin^2 theta_W calculation (will be overwritten later).
    smruseful-&gt;s2thw=dsgf2s2thw(smruseful-&gt;gfermi, couplingconstants-&gt;alphem, mspctm-&gt;mass(DSparticle_code(&quot;Z0&quot;)), mspctm-&gt;mass(DSpart-&gt;kqu(3)),1);

    // Set other internal quark masses for DarkSUSY
    dsfindmtmt();                                                                  // top mass at mt
    mspctm-&gt;mass(DSpart-&gt;kqu(1)) = mspctm-&gt;mu2gev;                                 // use 2GeV u mass as proxy for pole
    mspctm-&gt;mass(DSpart-&gt;kqd(1)) = mspctm-&gt;md2gev;                                 // use 2GeV d mass as proxy for pole
    mspctm-&gt;mass(DSpart-&gt;kqd(2)) = mspctm-&gt;ms2gev;                                 // use 2GeV s mass as proxy for pole
    mspctm-&gt;mass(DSpart-&gt;kqu(2)) = dsmqpole4loop(DSpart-&gt;kqu(2),mspctm-&gt;mcmc);     // use DarkSUSY internal routine to get mc pole
    mspctm-&gt;mass(DSpart-&gt;kqd(3)) = to&lt;double&gt;(mySLHA.at(&quot;MASS&quot;).at(5).at(1));      // the GAMBIT way to get the bottom pole mass
    //mspctm-&gt;mass(DSpart-&gt;kqd(3)) = dsmqpole4loop(DSpart-&gt;kqd(3),mspctm-&gt;mbmb);   // the DarkSUSY SLHAreader way to get mb pole

    // Block MINPAR we skip, it is not needed

    // Block MSOFT
    mssmpar-&gt;m1 = to&lt;double&gt;(mySLHA.at(&quot;MSOFT&quot;).at(1).at(1));
    mssmpar-&gt;m2 = to&lt;double&gt;(mySLHA.at(&quot;MSOFT&quot;).at(2).at(1));
    mssmpar-&gt;m3 = to&lt;double&gt;(mySLHA.at(&quot;MSOFT&quot;).at(3).at(1));
    mssmpar-&gt;mass2l(1) = pow(to&lt;double&gt;(mySLHA.at(&quot;MSOFT&quot;).at(31).at(1)),2);
    mssmpar-&gt;mass2l(2) = pow(to&lt;double&gt;(mySLHA.at(&quot;MSOFT&quot;).at(32).at(1)),2);
    mssmpar-&gt;mass2l(3) = pow(to&lt;double&gt;(mySLHA.at(&quot;MSOFT&quot;).at(33).at(1)),2);
    mssmpar-&gt;mass2e(1) = pow(to&lt;double&gt;(mySLHA.at(&quot;MSOFT&quot;).at(34).at(1)),2);
    mssmpar-&gt;mass2e(2) = pow(to&lt;double&gt;(mySLHA.at(&quot;MSOFT&quot;).at(35).at(1)),2);
    mssmpar-&gt;mass2e(3) = pow(to&lt;double&gt;(mySLHA.at(&quot;MSOFT&quot;).at(36).at(1)),2);
    mssmpar-&gt;mass2q(1) = pow(to&lt;double&gt;(mySLHA.at(&quot;MSOFT&quot;).at(41).at(1)),2);
    mssmpar-&gt;mass2q(2) = pow(to&lt;double&gt;(mySLHA.at(&quot;MSOFT&quot;).at(42).at(1)),2);
    mssmpar-&gt;mass2q(3) = pow(to&lt;double&gt;(mySLHA.at(&quot;MSOFT&quot;).at(43).at(1)),2);
    mssmpar-&gt;mass2u(1) = pow(to&lt;double&gt;(mySLHA.at(&quot;MSOFT&quot;).at(44).at(1)),2);
    mssmpar-&gt;mass2u(2) = pow(to&lt;double&gt;(mySLHA.at(&quot;MSOFT&quot;).at(45).at(1)),2);
    mssmpar-&gt;mass2u(3) = pow(to&lt;double&gt;(mySLHA.at(&quot;MSOFT&quot;).at(46).at(1)),2);
    mssmpar-&gt;mass2d(1) = pow(to&lt;double&gt;(mySLHA.at(&quot;MSOFT&quot;).at(47).at(1)),2);
    mssmpar-&gt;mass2d(2) = pow(to&lt;double&gt;(mySLHA.at(&quot;MSOFT&quot;).at(48).at(1)),2);
    mssmpar-&gt;mass2d(3) = pow(to&lt;double&gt;(mySLHA.at(&quot;MSOFT&quot;).at(49).at(1)),2);

    // Block HMIX
    mssmpar-&gt;mu = to&lt;double&gt;(mySLHA.at(&quot;HMIX&quot;).at(1).at(1));
    mssmpar-&gt;tanbe = to&lt;double&gt;(mySLHA.at(&quot;HMIX&quot;).at(2).at(1));

    // A boson mass
    mspctm-&gt;mass(DSparticle_code(&quot;A0&quot;)) = to&lt;double&gt;(mySLHA.at(&quot;MASS&quot;).at(36).at(1));
    mssmpar-&gt;ma = mspctm-&gt;mass(DSparticle_code(&quot;A0&quot;));

    // Now set up some defaults (part of it will be overwritten later)
    dssuconst();
    mssmiuseful-&gt;lsp = DSpart-&gt;kn(1);
    mssmiuseful-&gt;kln = 1;
    // To match the DS SLHAreader, you would then need to call
    // int unphys, hwarning;
    // dsspectrum(unphys, hwarning);

    // CKM matrix read from VCKMIN - Wolfenstein parameters.
    double lambda = to&lt;double&gt;(mySLHA.at(&quot;VCKMIN&quot;).at(1).at(1));   // Wolfenstein lambda
    double A = to&lt;double&gt;(mySLHA.at(&quot;VCKMIN&quot;).at(2).at(1));        // Wolfenstein A
    double rhobar = to&lt;double&gt;(mySLHA.at(&quot;VCKMIN&quot;).at(3).at(1));   // Wolfenstein rhobar
    double etabar = to&lt;double&gt;(mySLHA.at(&quot;VCKMIN&quot;).at(4).at(1));   // Wolfenstein etabar
    // Use Wolfenstein converter to get the VCKM matrix.
    mixing-&gt;ckm(1,1) = Spectrum::Wolf2V_ud(lambda,A,rhobar,etabar);
    mixing-&gt;ckm(1,2) = Spectrum::Wolf2V_us(lambda,A,rhobar,etabar);
    mixing-&gt;ckm(1,3) = Spectrum::Wolf2V_ub(lambda,A,rhobar,etabar);
    mixing-&gt;ckm(2,1) = Spectrum::Wolf2V_cd(lambda,A,rhobar,etabar);
    mixing-&gt;ckm(2,2) = Spectrum::Wolf2V_cs(lambda,A,rhobar,etabar);
    mixing-&gt;ckm(2,3) = Spectrum::Wolf2V_cb(lambda,A,rhobar,etabar);
    mixing-&gt;ckm(3,1) = Spectrum::Wolf2V_td(lambda,A,rhobar,etabar);
    mixing-&gt;ckm(3,2) = Spectrum::Wolf2V_ts(lambda,A,rhobar,etabar);
    mixing-&gt;ckm(3,3) = Spectrum::Wolf2V_tb(lambda,A,rhobar,etabar);
    // The lower-order DarkSUSY SLHAreader way of doing it; not as good, but this is what you'd need to use to match DS exactly.
    //sckm-&gt;ckms12 = lambda;
    //sckm-&gt;ckms23 = A*pow(sckm-&gt;ckms12,2);
    //std::complex&lt;double&gt; aux(rhobar, etabar);
    //aux = aux * (sckm-&gt;ckms23/pow(sckm-&gt;ckms12,2)) * pow(sckm-&gt;ckms12,3);
    //sckm-&gt;ckms13 = std::norm(aux);
    //sckm-&gt;ckmdelta = std::arg(aux);
    //dssuconst_ckm();

    // In principle, we might want to change to VCKM instead of VCKMIN, if VCKM is present. Like this:
    // sckm-&gt;ckms12 = to&lt;double&gt;(mySLHA.at(&quot;VCKM&quot;).at(1).at(1));
    // sckm-&gt;ckms23 = to&lt;double&gt;(mySLHA.at(&quot;VCKM&quot;).at(2).at(1))*sckm.ckms12**2;
    // sckm-&gt;ckmdelta = 0;
    // for (int i=1; i&lt;=3; i++) for (int j=1; j&lt;=3; j++)
    // {
    //   mixing-&gt;ckm(i,j) = to&lt;double_complex&gt;(mySLHA.at(&quot;VCKM&quot;).at(i,j).at(2));
    // }

    // OK, we now have to enforce the tree-level condition for unitarity.
    // We then have a choice of calculating both sin^2 theta_W and MW
    // from alpha, MZ and GF as we normally do in DarkSUSY. This line would
    // enforce that:
    //  mspctm-&gt;mass(DSparticle_code(&quot;W+&quot;))=mspctm-&gt;mass(DSparticle_code(&quot;Z0&quot;))*sqrt(1.0-smruseful-&gt;s2thw);
    // However, it is more prudent to take the value of MW from the SLHA file
    // as given (read in earlier), and instead enforce the tree-level condition
    // by redefining sin^2 theta_W. That we do here:
    mspctm-&gt;mass(DSparticle_code(&quot;W+&quot;))  = to&lt;double&gt;(mySLHA.at(&quot;MASS&quot;).at(24).at(1));    // W boson mass
    smruseful-&gt;s2thw=1.0-pow(mspctm-&gt;mass(DSparticle_code(&quot;W+&quot;))/mspctm-&gt;mass(DSparticle_code(&quot;Z0&quot;)),2);

    // Higgs masses. Note h0_1 is the lightest CP-even neutral higgs, and h2_0 the heavier.
    mspctm-&gt;mass(DSparticle_code(&quot;h0_1&quot;)) = to&lt;double&gt;(mySLHA.at(&quot;MASS&quot;).at(25).at(1));
    mspctm-&gt;mass(DSparticle_code(&quot;h0_2&quot;)) = to&lt;double&gt;(mySLHA.at(&quot;MASS&quot;).at(35).at(1));
    mspctm-&gt;mass(DSparticle_code(&quot;H+&quot;))   = to&lt;double&gt;(mySLHA.at(&quot;MASS&quot;).at(37).at(1));
    mspctm-&gt;mass(DSparticle_code(&quot;A0&quot;))   = to&lt;double&gt;(mySLHA.at(&quot;MASS&quot;).at(36).at(1));

    // SUSY particles
    mspctm-&gt;mass(DSpart-&gt;ksnu(1)) =  to&lt;double&gt;(mySLHA.at(&quot;MASS&quot;).at(1000012).at(1));
    mspctm-&gt;mass(DSpart-&gt;ksnu(2)) =  to&lt;double&gt;(mySLHA.at(&quot;MASS&quot;).at(1000014).at(1));
    mspctm-&gt;mass(DSpart-&gt;ksnu(3)) =  to&lt;double&gt;(mySLHA.at(&quot;MASS&quot;).at(1000016).at(1));
    mspctm-&gt;mass(DSpart-&gt;ksl(1))  =  to&lt;double&gt;(mySLHA.at(&quot;MASS&quot;).at(1000011).at(1));
    mspctm-&gt;mass(DSpart-&gt;ksl(2))  =  to&lt;double&gt;(mySLHA.at(&quot;MASS&quot;).at(1000013).at(1));
    mspctm-&gt;mass(DSpart-&gt;ksl(3))  =  to&lt;double&gt;(mySLHA.at(&quot;MASS&quot;).at(1000015).at(1));
    mspctm-&gt;mass(DSpart-&gt;ksl(4))  =  to&lt;double&gt;(mySLHA.at(&quot;MASS&quot;).at(2000011).at(1));
    mspctm-&gt;mass(DSpart-&gt;ksl(5))  =  to&lt;double&gt;(mySLHA.at(&quot;MASS&quot;).at(2000013).at(1));
    mspctm-&gt;mass(DSpart-&gt;ksl(6))  =  to&lt;double&gt;(mySLHA.at(&quot;MASS&quot;).at(2000015).at(1));
    mspctm-&gt;mass(DSpart-&gt;ksqu(1)) =  to&lt;double&gt;(mySLHA.at(&quot;MASS&quot;).at(1000002).at(1));
    mspctm-&gt;mass(DSpart-&gt;ksqu(2)) =  to&lt;double&gt;(mySLHA.at(&quot;MASS&quot;).at(1000004).at(1));
    mspctm-&gt;mass(DSpart-&gt;ksqu(3)) =  to&lt;double&gt;(mySLHA.at(&quot;MASS&quot;).at(1000006).at(1));
    mspctm-&gt;mass(DSpart-&gt;ksqu(4)) =  to&lt;double&gt;(mySLHA.at(&quot;MASS&quot;).at(2000002).at(1));
    mspctm-&gt;mass(DSpart-&gt;ksqu(5)) =  to&lt;double&gt;(mySLHA.at(&quot;MASS&quot;).at(2000004).at(1));
    mspctm-&gt;mass(DSpart-&gt;ksqu(6)) =  to&lt;double&gt;(mySLHA.at(&quot;MASS&quot;).at(2000006).at(1));
    mspctm-&gt;mass(DSpart-&gt;ksqd(1)) =  to&lt;double&gt;(mySLHA.at(&quot;MASS&quot;).at(1000001).at(1));
    mspctm-&gt;mass(DSpart-&gt;ksqd(2)) =  to&lt;double&gt;(mySLHA.at(&quot;MASS&quot;).at(1000003).at(1));
    mspctm-&gt;mass(DSpart-&gt;ksqd(3)) =  to&lt;double&gt;(mySLHA.at(&quot;MASS&quot;).at(1000005).at(1));
    mspctm-&gt;mass(DSpart-&gt;ksqd(4)) =  to&lt;double&gt;(mySLHA.at(&quot;MASS&quot;).at(2000001).at(1));
    mspctm-&gt;mass(DSpart-&gt;ksqd(5)) =  to&lt;double&gt;(mySLHA.at(&quot;MASS&quot;).at(2000003).at(1));
    mspctm-&gt;mass(DSpart-&gt;ksqd(6)) =  to&lt;double&gt;(mySLHA.at(&quot;MASS&quot;).at(2000005).at(1));

    // Neutralinos carry the sign of the eigenvalue, as we need it for NMIX later
    mspctm-&gt;mass(DSpart-&gt;kn(1)) =  to&lt;double&gt;(mySLHA.at(&quot;MASS&quot;).at(1000022).at(1));
    mspctm-&gt;mass(DSpart-&gt;kn(2)) =  to&lt;double&gt;(mySLHA.at(&quot;MASS&quot;).at(1000023).at(1));
    mspctm-&gt;mass(DSpart-&gt;kn(3)) =  to&lt;double&gt;(mySLHA.at(&quot;MASS&quot;).at(1000025).at(1));
    mspctm-&gt;mass(DSpart-&gt;kn(4)) =  to&lt;double&gt;(mySLHA.at(&quot;MASS&quot;).at(1000035).at(1));

    // Charginos
    mspctm-&gt;mass(DSpart-&gt;kcha(1)) =  to&lt;double&gt;(mySLHA.at(&quot;MASS&quot;).at(1000024).at(1));
    mspctm-&gt;mass(DSpart-&gt;kcha(2)) =  to&lt;double&gt;(mySLHA.at(&quot;MASS&quot;).at(1000037).at(1));

    // Gluino
    mspctm-&gt;mass(DSparticle_code(&quot;~g&quot;)) =  to&lt;double&gt;(mySLHA.at(&quot;MASS&quot;).at(1000021).at(1));

    // Gravitino (not implemented in DarkSUSY)
    // mspctm-&gt;mass(DSpart-&gt;k...) =  to&lt;double&gt;(mySLHA.at(&quot;MASS&quot;).at(1000039).at(1));

    // Block NMIX
    for (int i=1; i&lt;=4; i++)
    {
      for (int j=1; j&lt;=4; j++)
      {
        mssmmixing-&gt;neunmx(i,j)=to&lt;double&gt;(mySLHA.at(&quot;NMIX&quot;).at(i,j).at(2));
      }
    }
    // Make NMIX imaginary if mass eigenvalue is negative
    for (int i=1; i&lt;=4; i++)
    {
      for (int j=1; j&lt;=4; j++)
      {
        if (mspctm-&gt;mass(DSpart-&gt;kn(i)) &lt; 0)
        {
          mssmmixing-&gt;neunmx(i,j).im = mssmmixing-&gt;neunmx(i,j).re;
          mssmmixing-&gt;neunmx(i,j).re = 0.0;
        }
      }
      mspctm-&gt;mass(DSpart-&gt;kn(i)) = std::abs(mspctm-&gt;mass(DSpart-&gt;kn(i)));
    }

    // Block UMIX
    for (int i=1; i&lt;=2; i++)
    {
      for (int j=1; j&lt;=2; j++)
      {
        mssmmixing-&gt;chaumx(i,j)=to&lt;double&gt;(mySLHA.at(&quot;UMIX&quot;).at(i,j).at(2));
      }
    }

    // Block VMIX
    for (int i=1; i&lt;=2; i++)
    {
      for (int j=1; j&lt;=2; j++)
      {
        mssmmixing-&gt;chavmx(i,j)=to&lt;double&gt;(mySLHA.at(&quot;VMIX&quot;).at(i,j).at(2));
      }
    }

    // Block ALPHA
    mssmmixing-&gt;alpha = to&lt;double&gt;(mySLHA.at(&quot;ALPHA&quot;).back().at(0));  // Higgs mixing angle

    //If you want to exactly match the DarkSUSY SLHAreader, you should also now run
    //dssuconst_yukawa_running();

    // Block YE, YU, YD - Yukawas
    for (int i=1; i&lt;=3; i++)
    {
      couplingconstants-&gt;yukawa(DSpart-&gt;kl(i))=to&lt;double&gt;(mySLHA.at(&quot;YE&quot;).at(i,i).at(2));
      couplingconstants-&gt;yukawa(DSpart-&gt;kqu(i))=to&lt;double&gt;(mySLHA.at(&quot;YU&quot;).at(i,i).at(2));
      couplingconstants-&gt;yukawa(DSpart-&gt;kqd(i))=to&lt;double&gt;(mySLHA.at(&quot;YD&quot;).at(i,i).at(2));
    }

    // Block MSL2, MSE2, MSQ2, MSU2, MSD2
    for (int i=1; i&lt;=3; i++)
    {
      mssmpar-&gt;mass2l(i) = to&lt;double&gt;(mySLHA.at(&quot;MSL2&quot;).at(i,i).at(2));
      mssmpar-&gt;mass2e(i) = to&lt;double&gt;(mySLHA.at(&quot;MSE2&quot;).at(i,i).at(2));
      mssmpar-&gt;mass2q(i) = to&lt;double&gt;(mySLHA.at(&quot;MSQ2&quot;).at(i,i).at(2));
      mssmpar-&gt;mass2u(i) = to&lt;double&gt;(mySLHA.at(&quot;MSU2&quot;).at(i,i).at(2));
      mssmpar-&gt;mass2d(i) = to&lt;double&gt;(mySLHA.at(&quot;MSD2&quot;).at(i,i).at(2));
    }

    // BLOCK TE, TU and TD. I read these instead of AE, AU, AD.
    for (int i=1; i&lt;=3; i++)
    {
      mssmpar-&gt;asofte(i)=to&lt;double&gt;(mySLHA.at(&quot;TE&quot;).at(i,i).at(2))/couplingconstants-&gt;yukawa(DSpart-&gt;kl(i));
      mssmpar-&gt;asoftu(i)=to&lt;double&gt;(mySLHA.at(&quot;TU&quot;).at(i,i).at(2))/couplingconstants-&gt;yukawa(DSpart-&gt;kqu(i));
      mssmpar-&gt;asoftd(i)=to&lt;double&gt;(mySLHA.at(&quot;TD&quot;).at(i,i).at(2))/couplingconstants-&gt;yukawa(DSpart-&gt;kqd(i));
    }

    // Block SNUMIX
    for (int i=1; i&lt;=3; i++)
    {
      for (int j=1; j&lt;=3; j++)
      {
        mssmmixing-&gt;slulmx(i,j) = to&lt;double&gt;(mySLHA.at(&quot;SNUMIX&quot;).at(i,j).at(2));
      }
    }

    // Block SELMIX
    for (int i=1; i&lt;=6; i++)
    {
      for (int j=1; j&lt;=3; j++)
      {
        mssmmixing-&gt;sldlmx(i,j) = to&lt;double&gt;(mySLHA.at(&quot;SELMIX&quot;).at(i,j).at(2));
        mssmmixing-&gt;sldrmx(i,j) = to&lt;double&gt;(mySLHA.at(&quot;SELMIX&quot;).at(i,j+3).at(2));
      }
    }

    // Block USQMIX
    for (int i=1; i&lt;=6; i++)
    {
      for (int j=1; j&lt;=3; j++)
      {
        mssmmixing-&gt;squlmx(i,j) = to&lt;double&gt;(mySLHA.at(&quot;USQMIX&quot;).at(i,j).at(2));
        mssmmixing-&gt;squrmx(i,j) = to&lt;double&gt;(mySLHA.at(&quot;USQMIX&quot;).at(i,j+3).at(2));
      }
    }

    // Block DSQMIX
    for (int i=1; i&lt;=6; i++)
    {
      for (int j=1; j&lt;=3; j++)
      {
        mssmmixing-&gt;sqdlmx(i,j) = to&lt;double&gt;(mySLHA.at(&quot;DSQMIX&quot;).at(i,j).at(2));
        mssmmixing-&gt;sqdrmx(i,j) = to&lt;double&gt;(mySLHA.at(&quot;DSQMIX&quot;).at(i,j+3).at(2));
      }
    }

    // Do flavour reordering for SLHA2 compatibility
    dsorder_flavour();
    // Set up SUSY vertices
    dsvertx();

    // At this point, if you wanted to match the DarkSUSY SLHAreader, you would also call
    // dshigwid();
    // dsspwid();
    // which just fudge a few widths...but we won't do that, because we can get real decay widths from DecayBit.

    // Set up Higgs widths.  h1_0 is the lightest CP even Higgs in GAMBIT (opposite to DS).
    widths-&gt;width(DSparticle_code(&quot;h0_1&quot;)) = myDecays.at(std::pair&lt;int,int&gt;(25,0)).width_in_GeV;
    widths-&gt;width(DSparticle_code(&quot;h0_2&quot;)) = myDecays.at(std::pair&lt;int,int&gt;(35,0)).width_in_GeV;
    widths-&gt;width(DSparticle_code(&quot;A0&quot;))   = myDecays.at(std::pair&lt;int,int&gt;(36,0)).width_in_GeV;
    widths-&gt;width(DSparticle_code(&quot;H+&quot;))   = myDecays.at(std::pair&lt;int,int&gt;(37,0)).width_in_GeV;

    // Set up Higgs partial widths.
    const static std::vector&lt; std::vector&lt;str&gt; &gt; charged_channels = DS_charged_h_decay_channels();
    const static std::vector&lt; std::vector&lt;str&gt; &gt; neutral_channels = DS_neutral_h_decay_channels();
    const static std::vector&lt;str&gt; sister_chan = initVector&lt;str&gt;(&quot;W+&quot;, &quot;H-&quot;);
    const static std::vector&lt;str&gt; missing_chan = initVector&lt;str&gt;(&quot;W-&quot;, &quot;H+&quot;);
    const DecayTable::Entry&amp; h01 = myDecays.at(std::pair&lt;int,int&gt;(25,0));
    const DecayTable::Entry&amp; h02 = myDecays.at(std::pair&lt;int,int&gt;(35,0));
    const DecayTable::Entry&amp; A0  = myDecays.at(std::pair&lt;int,int&gt;(36,0));
    const DecayTable::Entry&amp; Hpm = myDecays.at(std::pair&lt;int,int&gt;(37,0));
    for (unsigned int i = 0; i &lt; neutral_channels.size(); i++)
    {
      const std::vector&lt;str&gt;&amp; chan = neutral_channels[i];
      mssmwidths-&gt;hdwidth(i+1,2) = (h01.has_channel(chan) ? widths-&gt;width(DSparticle_code(&quot;h0_1&quot;)) * h01.BF(chan) : 0.0);
      mssmwidths-&gt;hdwidth(i+1,1) = (h02.has_channel(chan) ? widths-&gt;width(DSparticle_code(&quot;h0_2&quot;)) * h02.BF(chan) : 0.0);
      mssmwidths-&gt;hdwidth(i+1,3) = (A0.has_channel(chan)  ? widths-&gt;width(DSparticle_code(&quot;A0&quot;))   * A0.BF(chan)  : 0.0);
      if (neutral_channels[i] == sister_chan)
      {
        // Add the missing W-H+ contributions.
        mssmwidths-&gt;hdwidth(i+1,2) = (h01.has_channel(missing_chan) ? widths-&gt;width(DSparticle_code(&quot;h0_1&quot;)) * h01.BF(missing_chan) : 0.0);
        mssmwidths-&gt;hdwidth(i+1,1) = (h02.has_channel(missing_chan) ? widths-&gt;width(DSparticle_code(&quot;h0_2&quot;)) * h02.BF(missing_chan) : 0.0);
        mssmwidths-&gt;hdwidth(i+1,3) = (A0.has_channel(missing_chan)  ? widths-&gt;width(DSparticle_code(&quot;A0&quot;))   * A0.BF(missing_chan)  : 0.0);
      }
    }
    for (unsigned int i = 0; i &lt; charged_channels.size(); i++)
    {
      mssmwidths-&gt;hdwidth(i+1,4) = (Hpm.has_channel(charged_channels[i]) ? widths-&gt;width(DSparticle_code(&quot;H+&quot;)) * Hpm.BF(charged_channels[i]) : 0.0);
    }

    // Set up SM fermion widths
    widths-&gt;width(DSparticle_code(&quot;u_3&quot;))    = myDecays.at(std::pair&lt;int,int&gt;(6,1)).width_in_GeV;
    widths-&gt;width(DSparticle_code(&quot;e-_2&quot;))  = myDecays.at(std::pair&lt;int,int&gt;(13,1)).width_in_GeV;
    widths-&gt;width(DSparticle_code(&quot;e-_3&quot;)) = myDecays.at(std::pair&lt;int,int&gt;(15,1)).width_in_GeV;

    // Set up SM gauge boson widths
    widths-&gt;width(DSparticle_code(&quot;W+&quot;)) = myDecays.at(std::pair&lt;int,int&gt;(24,0)).width_in_GeV;
    widths-&gt;width(DSparticle_code(&quot;Z0&quot;)) = myDecays.at(std::pair&lt;int,int&gt;(23,0)).width_in_GeV;

    // Set up sfermion widths
    widths-&gt;width(DSpart-&gt;ksnu(1)) = myDecays.at(std::pair&lt;int,int&gt;(1000012,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;ksnu(2)) = myDecays.at(std::pair&lt;int,int&gt;(1000014,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;ksnu(3)) = myDecays.at(std::pair&lt;int,int&gt;(1000016,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;ksl(1))  = myDecays.at(std::pair&lt;int,int&gt;(1000011,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;ksl(2))  = myDecays.at(std::pair&lt;int,int&gt;(1000013,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;ksl(3))  = myDecays.at(std::pair&lt;int,int&gt;(1000015,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;ksl(4))  = myDecays.at(std::pair&lt;int,int&gt;(2000011,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;ksl(5))  = myDecays.at(std::pair&lt;int,int&gt;(2000013,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;ksl(6))  = myDecays.at(std::pair&lt;int,int&gt;(2000015,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;ksqu(1)) = myDecays.at(std::pair&lt;int,int&gt;(1000002,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;ksqu(2)) = myDecays.at(std::pair&lt;int,int&gt;(1000004,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;ksqu(3)) = myDecays.at(std::pair&lt;int,int&gt;(1000006,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;ksqu(4)) = myDecays.at(std::pair&lt;int,int&gt;(2000002,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;ksqu(5)) = myDecays.at(std::pair&lt;int,int&gt;(2000004,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;ksqu(6)) = myDecays.at(std::pair&lt;int,int&gt;(2000006,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;ksqd(1)) = myDecays.at(std::pair&lt;int,int&gt;(1000001,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;ksqd(2)) = myDecays.at(std::pair&lt;int,int&gt;(1000003,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;ksqd(3)) = myDecays.at(std::pair&lt;int,int&gt;(1000005,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;ksqd(4)) = myDecays.at(std::pair&lt;int,int&gt;(2000001,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;ksqd(5)) = myDecays.at(std::pair&lt;int,int&gt;(2000003,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;ksqd(6)) = myDecays.at(std::pair&lt;int,int&gt;(2000005,0)).width_in_GeV;

    // Set up neutralino widths.  Note that the zero neutralino width is taken care of below.
    widths-&gt;width(DSpart-&gt;kn(1)) = myDecays.at(std::pair&lt;int,int&gt;(1000022,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;kn(2)) = myDecays.at(std::pair&lt;int,int&gt;(1000023,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;kn(3)) = myDecays.at(std::pair&lt;int,int&gt;(1000025,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;kn(4)) = myDecays.at(std::pair&lt;int,int&gt;(1000035,0)).width_in_GeV;

    // Set up chargino widths.
    widths-&gt;width(DSpart-&gt;kcha(1)) = myDecays.at(std::pair&lt;int,int&gt;(1000024,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;kcha(2)) = myDecays.at(std::pair&lt;int,int&gt;(1000037,0)).width_in_GeV;

    // Gluino width.
    widths-&gt;width(DSparticle_code(&quot;~g&quot;)) = myDecays.at(std::pair&lt;int,int&gt;(1000021,0)).width_in_GeV;

    // Gravitino width (not implemented in DS).
    //widths-&gt;width(DSparticle_code(&quot;~G&quot;)) = ;

    // Integration routines in DS cannot handle very small sparticle widths.
    // Make sure not to fall below minimal value in order to avoid numerical issues.
    for (std::size_t i=21; i&lt;49; i++)
    {
      if (widths-&gt;width(i)&lt;min_DS_rwidth *mspctm-&gt;mass(i))
      {
        widths-&gt;width(i)=min_DS_rwidth *mspctm-&gt;mass(i);
      }
    }

    #ifdef DARKSUSY_DEBUG
      // Spit out spectrum and width files for debug purposes.
      int u1 = 50;
      int u2 = 100050;
      #ifdef WITH_MPI
        int rank = GMPI::Comm().Get_rank();
        u1 += rank;
        u2 += rank;
      #endif
      dswspectrum(u1);
      dswwidth(u2);
    #endif

    return 0;  // everything OK (hah. maybe.)
  }

  std::vector&lt;double&gt; DD_couplings()
  {
    double gps,gns,gpa,gna;
    dsddgpgn(gps,gns,gpa,gna);
    std::vector&lt;double&gt; couplings;
    couplings.clear();
    couplings.push_back(gps);
    couplings.push_back(gns);
    couplings.push_back(gpa);
    couplings.push_back(gna);
    return couplings;
  }

  std::vector&lt; std::vector&lt;str&gt; &gt; DS_neutral_h_decay_channels()
  {
    return initVector&lt; std::vector&lt;str&gt; &gt;
     (initVector&lt;str&gt;(&quot;h0_2&quot;, &quot;h0_2&quot;),
      initVector&lt;str&gt;(&quot;h0_1&quot;, &quot;h0_2&quot;),
      initVector&lt;str&gt;(&quot;h0_1&quot;, &quot;h0_1&quot;),
      initVector&lt;str&gt;(&quot;A0&quot;, &quot;A0&quot;),
      initVector&lt;str&gt;(&quot;h0_2&quot;, &quot;A0&quot;),
      initVector&lt;str&gt;(&quot;h0_1&quot;, &quot;A0&quot;),
      initVector&lt;str&gt;(&quot;H+&quot;, &quot;H-&quot;),
      initVector&lt;str&gt;(&quot;Z0&quot;, &quot;h0_2&quot;),
      initVector&lt;str&gt;(&quot;Z0&quot;, &quot;h0_1&quot;),
      initVector&lt;str&gt;(&quot;Z0&quot;, &quot;A0&quot;),
      // actually supposed to be W+H- and W-H+
      initVector&lt;str&gt;(&quot;W+&quot;, &quot;H-&quot;),
      initVector&lt;str&gt;(&quot;Z0&quot;, &quot;Z0&quot;),
      initVector&lt;str&gt;(&quot;W+&quot;, &quot;W-&quot;),
      initVector&lt;str&gt;(&quot;nu_e&quot;, &quot;nubar_e&quot;),
      initVector&lt;str&gt;(&quot;e+_1&quot;, &quot;e-_1&quot;),
      initVector&lt;str&gt;(&quot;nu_mu&quot;, &quot;nubar_mu&quot;),
      initVector&lt;str&gt;(&quot;e+_2&quot;, &quot;e-_2&quot;),
      initVector&lt;str&gt;(&quot;nu_tau&quot;, &quot;nubar_tau&quot;),
      initVector&lt;str&gt;(&quot;e+_3&quot;, &quot;e-_3&quot;),
      initVector&lt;str&gt;(&quot;u_1&quot;, &quot;ubar_1&quot;),
      initVector&lt;str&gt;(&quot;d_1&quot;, &quot;dbar_1&quot;),
      initVector&lt;str&gt;(&quot;u_2&quot;, &quot;ubar_2&quot;),
      initVector&lt;str&gt;(&quot;d_2&quot;, &quot;dbar_2&quot;),
      initVector&lt;str&gt;(&quot;u_3&quot;, &quot;ubar_3&quot;),
      initVector&lt;str&gt;(&quot;d_3&quot;, &quot;dbar_3&quot;),
      initVector&lt;str&gt;(&quot;g&quot;, &quot;g&quot;),
      // actually qqg (not implemented in DS though)
      initVector&lt;str&gt;(&quot;d_3&quot;, &quot;dbar_3&quot;, &quot;g&quot;),
      initVector&lt;str&gt;(&quot;gamma&quot;, &quot;gamma&quot;),
      initVector&lt;str&gt;(&quot;Z0&quot;, &quot;gamma&quot;)
     );
  }

  std::vector&lt; std::vector&lt;str&gt; &gt; DS_charged_h_decay_channels()
  {
    return initVector&lt; std::vector&lt;str&gt; &gt;
     (initVector&lt;str&gt;(&quot;u_1&quot;, &quot;dbar_1&quot;),
      initVector&lt;str&gt;(&quot;u_1&quot;, &quot;dbar_2&quot;),
      initVector&lt;str&gt;(&quot;u_1&quot;, &quot;dbar_3&quot;),
      initVector&lt;str&gt;(&quot;u_2&quot;, &quot;dbar_1&quot;),
      initVector&lt;str&gt;(&quot;u_2&quot;, &quot;dbar_2&quot;),
      initVector&lt;str&gt;(&quot;u_2&quot;, &quot;dbar_3&quot;),
      initVector&lt;str&gt;(&quot;u_3&quot;, &quot;dbar_1&quot;),
      initVector&lt;str&gt;(&quot;u_3&quot;, &quot;dbar_2&quot;),
      initVector&lt;str&gt;(&quot;u_3&quot;, &quot;dbar_3&quot;),
      initVector&lt;str&gt;(&quot;e+_1&quot;, &quot;nu_e&quot;),
      initVector&lt;str&gt;(&quot;e+_2&quot;, &quot;nu_mu&quot;),
      initVector&lt;str&gt;(&quot;e+_3&quot;, &quot;nu_tau&quot;),
      initVector&lt;str&gt;(&quot;W+&quot;, &quot;h0_2&quot;),
      initVector&lt;str&gt;(&quot;W+&quot;, &quot;h0_1&quot;),
      initVector&lt;str&gt;(&quot;W+&quot;, &quot;A0&quot;)
     );
  }
}
END_BE_NAMESPACE
</code></pre><hr><p>Updated on 2022-08-02 at 18:18:48 +0000</p><div class=edit-page><a href=https://github.com/RC1242RC/gambit_gh_pages/blob/master/content/en/documentation/code/DarkBit_development/Files/DarkSUSY__5__1__3_8cpp.md><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828.0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>Edit this page on GitHub</a></div></main></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Powered by <a class=text-muted href=https://www.netlify.com/>Netlify</a>, <a class=text-muted href=https://gohugo.io/>Hugo</a>, and <a class=text-muted href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline><li class=list-inline-item><a href=/license/>License</a></li></ul></div></div></div></footer><script src=/js/bootstrap.min.54bf0932b8a36d0e152b1635b099a6ef1394d35327e2437550a075c9c8ed1bd8aed5847c21b36fc02ed24014c031d9ca24017b0c78b1639d7e2fa8329898b842.js integrity="sha512-VL8JMrijbQ4VKxY1sJmm7xOU01Mn4kN1UKB1ycjtG9iu1YR8IbNvwC7SQBTAMdnKJAF7DHixY51+L6gymJi4Qg==" crossorigin=anonymous defer></script>
<script src=/js/highlight.min.5b48bc253dc75aeea5fb366ecf700f4925e2b6eb1a1466f2124b722d68148d67bc0a9365d2b8ad9c585161b46372d23b08509a16f1fd518542b894756d4752d0.js integrity="sha512-W0i8JT3HWu6l+zZuz3APSSXitusaFGbyEktyLWgUjWe8CpNl0ritnFhRYbRjctI7CFCaFvH9UYVCuJR1bUdS0A==" crossorigin=anonymous defer></script>
<script src=/main.min.40265e9a032aeba5eaf67baac3cbbc22667a7533215d326eeb3e9f4d5e4be40f9ff4dcd22949db73ae527ca26a19d7998091a8973c82af760b2c0daa335190ed.js integrity="sha512-QCZemgMq66Xq9nuqw8u8ImZ6dTMhXTJu6z6fTV5L5A+f9NzSKUnbc65SfKJqGdeZgJGolzyCr3YLLA2qM1GQ7Q==" crossorigin=anonymous defer></script>
<script src=https://rc1242rc.github.io/index.min.bf15e814991a9d3ef02f52a26d135d3cd0a098afc407e971daad9f276d437236be129db79cd96bd09f86d0730d8272253cdaff9edd528739d4fc2013efa8d4ba.js integrity="sha512-vxXoFJkanT7wL1KibRNdPNCgmK/EB+lx2q2fJ21Dcja+Ep23nNlr0J+G0HMNgnIlPNr/nt1ShznU/CAT76jUug==" crossorigin=anonymous defer></script></body></html>