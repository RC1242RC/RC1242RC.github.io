<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=https://rc1242rc.github.io/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://rc1242rc.github.io/fonts/vendor/jost/jost-v4-latin-500.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://rc1242rc.github.io/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><script>(()=>{var e=localStorage.getItem("theme");e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><link rel=stylesheet href=https://rc1242rc.github.io/main.f12f7e04ea768acebec10c86baf049d74d6a79f24bc0dfb7ed77aa60462432916dd1ce8f41c78b69496adf650b3039a28a210183cce598f09b95d6fecb5ff999.css integrity="sha512-8S9+BOp2is6+wQyGuvBJ101qefJLwN+37XeqYEYkMpFt0c6PQceLaUlq32ULMDmiiiEBg8zlmPCbldb+y1/5mQ==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>file modules/CBGB/modules/utils.py - GAMBIT</title><meta name=description content="[No description available]"><link rel=canonical href=https://rc1242rc.github.io/documentation/code/darkbit_development/files/cbgb_2modules_2utils_8py/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="file modules/CBGB/modules/utils.py"><meta property="og:description" content="[No description available]"><meta property="og:url" content="https://rc1242rc.github.io/documentation/code/darkbit_development/files/cbgb_2modules_2utils_8py/"><meta property="og:site_name" content="GAMBIT"><meta property="og:image" content="https://rc1242rc.github.io/gambit_logo.png"><meta property="og:image:alt" content="GAMBIT"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content><meta name=twitter:creator content><meta name=twitter:title content="file modules/CBGB/modules/utils.py"><meta name=twitter:description content="[No description available]"><meta name=twitter:image content="https://rc1242rc.github.io/gambit_logo.png"><meta name=twitter:image:alt content="file modules/CBGB/modules/utils.py"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://rc1242rc.github.io/#/schema/organization/1","name":"Doks","url":"https://rc1242rc.github.io/","sameAs":["https://github.com/GambitBSM"],"logo":{"@type":"ImageObject","@id":"https://rc1242rc.github.io/#/schema/image/1","url":"https://rc1242rc.github.io/logo-doks.png","width":450,"height":416,"caption":"Doks"},"image":{"@id":"https://rc1242rc.github.io/#/schema/image/1"}},{"@type":"WebSite","@id":"https://rc1242rc.github.io/#/schema/website/1","url":"https://rc1242rc.github.io/","name":"GAMBIT","description":"Documentation for the Global And Modular BSM Inference Tool","publisher":{"@id":"https://rc1242rc.github.io/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://rc1242rc.github.io/documentation/code/darkbit_development/files/cbgb_2modules_2utils_8py/","url":"https://rc1242rc.github.io/documentation/code/darkbit_development/files/cbgb_2modules_2utils_8py/","name":"file modules\/CBGB\/modules\/utils.py","description":"[No description available]","isPartOf":{"@id":"https://rc1242rc.github.io/#/schema/website/1"},"about":{"@id":"https://rc1242rc.github.io/#/schema/organization/1"},"datePublished":"0001-01-01T00:00:00CET","dateModified":"0001-01-01T00:00:00CET","breadcrumb":{"@id":"https://rc1242rc.github.io/documentation/code/darkbit_development/files/cbgb_2modules_2utils_8py/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://rc1242rc.github.io/documentation/code/darkbit_development/files/cbgb_2modules_2utils_8py/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://rc1242rc.github.io/documentation/code/darkbit_development/files/cbgb_2modules_2utils_8py/"]}]},{"@type":"BreadcrumbList","@id":"https://rc1242rc.github.io/documentation/code/darkbit_development/files/cbgb_2modules_2utils_8py/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/","url":"https://rc1242rc.github.io/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/documentation/","url":"https://rc1242rc.github.io/documentation/","name":"Documentation"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/documentation/code/","url":"https://rc1242rc.github.io/documentation/code/","name":"Code"}},{"@type":"ListItem","position":4,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/documentation/code/darkbit_development/","url":"https://rc1242rc.github.io/documentation/code/darkbit_development/","name":"Darkbit Development"}},{"@type":"ListItem","position":5,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/documentation/code/darkbit_development/files/","url":"https://rc1242rc.github.io/documentation/code/darkbit_development/files/","name":"Files"}},{"@type":"ListItem","position":6,"item":{"@id":"https://rc1242rc.github.io/documentation/code/darkbit_development/files/cbgb_2modules_2utils_8py/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://rc1242rc.github.io/documentation/code/darkbit_development/files/cbgb_2modules_2utils_8py/#/schema/image/2","url":"https://rc1242rc.github.io/gambit_logo.png","contentUrl":"https://rc1242rc.github.io/gambit_logo.png","caption":"file modules\/CBGB\/modules\/utils.py"}]}]}</script><meta name=theme-color content="#fff"><link rel=icon href=https://rc1242rc.github.io/favicon.ico sizes=any><link rel=icon type=image/svg+xml href=https://rc1242rc.github.io/favicon.svg><link rel=apple-touch-icon sizes=180x180 href=https://rc1242rc.github.io/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://rc1242rc.github.io/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://rc1242rc.github.io/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://rc1242rc.github.io/site.webmanifest></head><body class="documentation single light"><div class=sticky-top><div class=header-bar></div><header class="navbar navbar-expand-md navbar-light doks-navbar"><nav class="container-xxl flex-wrap flex-md-nowrap" aria-label="Main navigation"><a class="navbar-brand p-0 me-auto" href=https://rc1242rc.github.io/ aria-label=GAMBIT><img class=logo-light src=https://rc1242rc.github.io//images/gambit_logo.png width=50px>
<img class="logo-dark d-none" src=https://rc1242rc.github.io//images/gambit_logo.png width=50px>
GAMBIT</a>
<button class="btn btn-menu order-2 d-block d-lg-none" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasDoks aria-controls=offcanvasDoks aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><div class="offcanvas offcanvas-end border-0 py-lg-1" tabindex=-1 id=offcanvasDoks data-bs-backdrop=true aria-labelledby=offcanvasDoksLabel><div class="header-bar d-lg-none"></div><div class="offcanvas-header d-lg-none"><h2 class="h5 offcanvas-title ps-2" id=offcanvasDoksLabel><a class=text-dark href=/>GAMBIT</a></h2><button type=button class="btn-close text-reset me-2" data-bs-dismiss=offcanvas aria-label="Close main menu"></button></div><div class="offcanvas-body p-4 p-lg-0"><ul class="nav flex-column flex-lg-row align-items-lg-center mt-2 mt-lg-0 ms-lg-2 me-lg-auto"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Documentation
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/documentation/installation/introduction/>Installation</a></li><li><a class=dropdown-item href=/documentation/examples/colliderbit>Examples</a></li><li><a class=dropdown-item href=/documentation/help/faqs/>Help</a></li><li><a class=dropdown-item href=/documentation/code/index_classes>Code Reference</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Community
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/community/publications/>Publications</a></li><li><a class=dropdown-item href=/community/talks/>Talks</a></li><li><a class=dropdown-item href=/community/members/>Members</a></li><li><a class=dropdown-item href=/community/code_of_conduct/>Code of Conduct</a></li><li><a class=dropdown-item href=/community/contact/>Contact</a></li></ul></li></ul><hr class="text-black-50 my-4 d-lg-none"><form class="doks-search position-relative flex-grow-1 ms-lg-auto me-lg-2"><input id=search class="form-control is-search" type=search placeholder="Search site..." aria-label="Search site..." autocomplete=off><div id=suggestions class="shadow bg-white rounded d-none"></div></form><hr class="text-black-50 my-4 d-lg-none"><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=https://github.com/GambitBSM><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><small class="ms-2 d-lg-none">GitHub</small></a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn btn-doks-light dropdown-toggle" id=doks-versions data-bs-toggle=dropdown aria-expanded=false data-bs-display=static aria-label="Toggle version menu">
<span class=d-none>Doks</span>
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=doks-versions></ul></div></div></div></nav></header></div><div class="wrap container-xxl" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class=docs-links aria-label="Main navigation"><ul class="list-unstyled collapsible-sidebar"><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-installation aria-expanded=false>
Installation</button><div class=collapse id=section-installation><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/installation/introduction/>Getting Started</a></li><li><a class="docs-link rounded" href=/documentation/installation/docker_usage/>Docker Usage</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_linux/>Installation for Linux</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_windows/>Installation for Windows</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_macos/>Installation for macOS</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-examples aria-expanded=false>
Examples</button><div class=collapse id=section-examples><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/examples/colliderbit/>ColliderBit</a></li><li><a class="docs-link rounded" href=/documentation/examples/anotherbit/>AnotherBit</a></li><li><a class="docs-link rounded" href=/documentation/examples/anotherbit2/>AnotherBit2</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-help aria-expanded=false>
Help</button><div class=collapse id=section-help><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/help/faqs/>FAQs</a></li><li><a class="docs-link rounded" href=/documentation/help/compiler_matrix/>Compiler Matrix</a></li><li><a class="docs-link rounded" href=/documentation/help/known_issues/>Known Issues</a></li><li><a class="docs-link rounded" href=/documentation/help/configuration_examples/>Configuration Examples</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-code aria-expanded=false>
Code Reference</button></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section- aria-expanded=false>
GAMBIT_VERSION_HERE</button><div class=collapse id=section-><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/code/colliderbit_development/index_classes/>Classes</a></li><li><a class="docs-link rounded" href=/documentation/code/colliderbit_development/index_files/>Files</a></li><li><a class="docs-link rounded" href=/documentation/code/colliderbit_development/index_pages/>Pages</a></li><li><a class="docs-link rounded" href=/documentation/code/colliderbit_development/index_namespaces/>Namespaces</a></li></ul></div></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=d-xl-none><button class="btn btn-outline-primary btn-sm doks-toc-toggle collapsed" type=button data-bs-toggle=collapse data-bs-target=#onThisPage aria-controls=doks-docs-nav aria-expanded=false aria-label="Toggle On this page navigation">
<span>On this page</span>
<span><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"/><polyline points="7 6 12 11 17 6"/></svg><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"/><polyline points="17 18 12 13 7 18"/></svg></span></button><div class=collapse id=onThisPage><div class="card card-body mt-3 py-1"><div class=page-links><nav id=TableOfContents><ul><li><ul><li><a href=#namespaces>Namespaces</a></li><li><a href=#source-code>Source code</a></li></ul></li></ul></nav></div></div></div></div><div class="page-links d-none d-xl-block"><h3>On this page</h3><nav id=TableOfContents><ul><li><ul><li><a href=#namespaces>Namespaces</a></li><li><a href=#source-code>Source code</a></li></ul></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9 mx-xl-auto"><h1>file modules/CBGB/modules/utils.py</h1><p class=lead></p><p>[No description available]</p><h2 id=namespaces>Namespaces <a href=#namespaces class=anchor aria-hidden=true>#</a></h2><table><thead><tr><th>Name</th></tr></thead><tbody><tr><td><strong><a href=/documentation/code/darkbit_development/namespaces/namespacemodules/>modules</a></strong></td></tr><tr><td><strong><a href=/documentation/code/darkbit_development/namespaces/namespacemodules_1_1utils/>modules::utils</a></strong></td></tr></tbody></table><h2 id=source-code>Source code <a href=#source-code class=anchor aria-hidden=true>#</a></h2><pre><code>#
#   ==================================
#   |                                |
#   |   Utility functions for CBGB   |
#   |                                |
#   ==================================
#

from collections import OrderedDict
from modules import gb
import importlib
import modules.active_cfg
cfg = importlib.import_module(&quot;configs.&quot; + modules.active_cfg.module_name)


# ====== removeComments ========

# Takes a list of code lines and removes comments.
# For fixed format files, any character at position 0 is a comment.
# For lines containing '!' everything after '!' is removed.

def removeComments(code_lines):

    code_lines_nocomment = []

    for line in code_lines:

        if len(line) == 0:
            code_lines_nocomment.append('')
            continue

        if (cfg.format == 'fixed') and (line[0] != ' '):
            new_line = ''

        elif '!' in line:
            pos = line.find('!')
            new_line = line[:pos]

        else:
            new_line = line

        code_lines_nocomment.append(new_line)

    return code_lines_nocomment

# ====== END: removeComments ========



# ====== removeBlankLines ========

# Removes any empty (all whitespace) strings from a list of strings.

def removeBlankLines(code_lines):

    # Walk through the list of code lines backwards and discard 
    # any lines that contain nothing but whitespace.
    for i in range(len(code_lines))[::-1]:
        if code_lines[i].strip() == '':
            code_lines.pop(i)

    return code_lines

# ====== END: removeBlankLines ========



# ====== removeLeadingTrailingBlanks ========

# Removes leading and trailing blanks from the strings
# in a list of strings.

def removeLeadingTrailingBlanks(code_lines):

    for i in range(len(code_lines)):
        code_lines[i] = code_lines[i].lstrip().rstrip()

    return code_lines

# ====== END: removeLeadingTrailingBlanks ========



# ====== removeStatementLabels ========

# Replaces statement labels with empty spaces.
# (A statement label is a number given as the first 
# non-blank part of a statement.)

def removeStatementLabels(code_lines):

    for i in range(len(code_lines)):

        line = code_lines[i]

        if cfg.format == 'fixed':
            label = line[0:5].strip()
            if label.isdigit():
                code_lines[i] = line.replace(label, ' '*len(label), 1)

        elif cfg.format == 'free':

            line_list = line.split()
            if (len(line_list) &gt; 0):
                label = line_list[0]
                if label.isdigit():
                    code_lines[i] = line.replace(label, ' '*len(label), 1)                    

        else:
            raise RuntimeError(&quot;cfg.format must be set to either 'fixed' or 'free'.&quot;)

    return code_lines

# ====== END: removeStatementLabels ========



# ====== removeKeywords ========

# Replaces Fortran keywords that CBGB doesn't 
# care about with empty spaces.

def removeKeywords(code_lines):

    for i in range(len(code_lines)):

        line = code_lines[i]

        line = line.replace(&quot;::&quot;, &quot; &quot;)

        line = line.replace(&quot;intent(in)&quot;, &quot; &quot;)
        line = line.replace(&quot;intent(out)&quot;, &quot; &quot;)
        line = line.replace(&quot;intent (in)&quot;, &quot; &quot;)
        line = line.replace(&quot;intent (out)&quot;, &quot; &quot;)

        # Add more keywords here...

        code_lines[i] = line

    return code_lines

# ====== END: removeKeywords ========



# ====== allSingleSpace ========

# Replaces multiple spaces with a single space.

def allSingleSpace(code_lines):

    for i in range(len(code_lines)):

        line = code_lines[i]

        line = ' '.join(line.split())

        code_lines[i] = line

    return code_lines

# ====== END: allSingleSpace ========



# ====== joinContinuedLines ========

def joinContinuedLines(code_lines):

    joined_code_lines = ['']

    if cfg.format == 'fixed':

        for line in code_lines:
            
            # Check for line continuation (any character at column 6).
            # (This assumes that len(line) &gt;= 6 for all lines in code_lines,
            # which should be OK due to prior code formatting.)

            try:
                # - If found, append to previous line.
                if line[5] not in [' ','\t']:
                    joined_code_lines[-1] += line[6:]

                # - If not found, store current_line and start constructing a new.
                else:
                    joined_code_lines.append(line)

            except:
                print [line]
                raise
            


    elif cfg.format == 'free':

        continue_line = False
        for line in code_lines:

            if continue_line:
                if line.lstrip()[0] == '&amp;':
                    joined_code_lines[-1] += line.lstrip()[1:].rstrip().rstrip('&amp;')
                else:
                    joined_code_lines[-1] += line.rstrip().rstrip('&amp;')
            else:
                joined_code_lines.append(line.rstrip().rstrip('&amp;'))


            # Check for line continuation. (Line ends with '&amp;'.)
            if line.rstrip()[-1] == '&amp;':
                continue_line = True
            else:
                continue_line = False

    else:
        raise RuntimeError(&quot;cfg.format must be set to either 'fixed' or 'free'.&quot;)

    if joined_code_lines[0] == '':
        joined_code_lines.pop(0)

    return joined_code_lines


# ====== END: joinContinuedLines ========




# ====== getCodeParts ========

def getCodeParts(code_lines, prepend_module_name=False):

    code_parts_dict = OrderedDict()

    unnamed_part_counter = 1
    start_line  = 0
    end_line    = 0

    current_part = 'general'
    current_module = ''

    for i, line in enumerate(code_lines):

        #
        # Detect beginning/end of a module
        #
        if current_part == 'general':

            # Detect beginning of a module
            if 'module ' in line[0:7].lower():
                current_module = line.split()[1]

            # Detect end of a module
            if current_module != '':
                if (line.replace(' ','').strip().lower() in ['end','endmodule', 'endmodule'+current_module.lower()]):
                    current_module = ''

        #
        # Detect start of program/function/subroutine, end current 'general' part
        #

        if current_part == 'general':

            new_part = ''
            if 'subroutine ' in line[0:11].lower():
                new_part = 'subroutine'
            elif ('function ' in line[0:9].lower()) or (' function ' in line.lower()):
                new_part = 'function'
            elif 'program ' in line[0:8].lower():
                new_part = 'program'

            # If the beginning of a new code part is found:
            # - store the line numbers for the current 'general' code part
            # - set start_line for the new code part
            # - identify a name for the new code part
            if new_part in ['subroutine', 'function', 'program']:
    
    
                # Store lines (if any) from current 'general' part
                if (start_line &lt; i):

                    if current_part == 'general':
                        name_long = 'unnamed_' + current_part + '_' + str(unnamed_part_counter)
                        unnamed_part_counter += 1

                    code_parts_dict[name_long] = { 
                                              'category'   : current_part,
                                              'code_lines' : code_lines[start_line:i],
                                              'module'     : current_module
                                            }


                # Restart line count for new code part
                start_line = i
    
                # Identify name for new code part
                name = getCodePartName(line, new_part)
                if (name == 'unnamed_' + new_part):
                    name = name + '_' + str(unnamed_part_counter)
                    unnamed_part_counter += 1

                # line_list = line.split()
                # line_list_lowercase = line.lower().split()
                # keyword_index = line_list_lowercase.index(new_part)

                # if len(line_list) == keyword_index+1:
                #     name_long = 'unnamed_' + new_part + '_' + str(unnamed_part_counter)
                #     unnamed_part_counter += 1

                # else:
                #     # name_item = line_list[line_list.index(new_part)+1]
                #     name_item = line_list[keyword_index+1]
                #     if '(' in name_item:
                #         name = name_item[:name_item.find('(')]
                #     else:
                #         name = name_item

                if (current_module != '') and (prepend_module_name):
                    name_long = current_module + '::' + name
                else:
                    name_long =  name

                # Update current_part
                current_part = new_part


      
        #
        # Detect end of program/function/subroutine, start new 'general' part
        #

        elif (current_part in ['subroutine', 'function', 'program']) and (line.replace(' ','').strip().lower() in ['end','end'+current_part, 'end'+current_part+name.lower()]):


            # Store in dict
            if (start_line &lt; i):

                if current_part == 'general':
                    name_long = 'unnamed_' + current_part + '_' + str(unnamed_part_counter)
                    unnamed_part_counter += 1

                code_parts_dict[name_long] = { 
                                          'category'   : current_part,
                                          'code_lines' : code_lines[start_line:i+1],
                                          'module'     : current_module
                                        }

                # Set variables for the next code part
                start_line = i+1
                current_part = 'general'

    #
    # end loop over code lines
    #

    # Store final bit:
    if (start_line &lt; i):

        if current_part == 'general':
            name_long = 'unnamed_' + current_part + '_' + str(unnamed_part_counter)
            unnamed_part_counter += 1

        code_parts_dict[name_long] = { 
                                  'category'   : current_part,
                                  'code_lines' : code_lines[start_line:i+1],
                                  'module'     : current_module
                                }

    return code_parts_dict

# ====== END: getCodeParts ========




# ====== getCodePartName ========

def getCodePartName(code_line, keyword):

    line_list = code_line.split()
    line_list_lowercase = code_line.lower().split()
    keyword_index = line_list_lowercase.index(keyword)

    if len(line_list) == keyword_index+1:
        name = 'unnamed_' + keyword

    else:
        name_item = line_list[keyword_index+1]
        if '(' in name_item:
            name = name_item[:name_item.find('(')]
        else:
            name = name_item

    return name

# ====== END: getCodePartName ========






# ====== getImplicitDefs ========

# Return a dict with the following structure: 
#   { 
#     'a': ('double precision',1), 
#     'b': ('real',8),
#     'c': (None,None),
#     ...
#   }
#

def getImplicitDefs(code_lines):

    implicit_defs = gb.default_implicit_types

    for i,line in enumerate(code_lines):

        # Split line into words
        line_list = line.split()

        # Look for 'implicit' statement
        if line_list[0].lower() == 'implicit':

            # If 'implicit none', then no other 'implicit' statements are allowed
            if line_list[1].lower() == 'none':
                return dict.fromkeys(gb.alphabet,(None,None))

            # Remove the 'implicit' keyword
            typedef_line   = ' '.join(line_list[1:])

            # If there are multiple implicit statements on a single line,
            # split them up and treat them separately.
            for temp_line in typedef_line.split(')'):

                # Do a bunch of string manipulations to identify
                # the type name (e.g. 'double precision') and 
                # character specifications (e.g. 'a-z').
                if temp_line == '':
                    continue

                temp_line = temp_line.replace('(','')
                temp_line = temp_line.replace(',',' ')
                temp_line = temp_line.strip()
                while ' -' in temp_line:
                    temp_line = temp_line.replace(' -','-')
                while '- ' in temp_line:
                    temp_line = temp_line.replace('- ','-')
                temp_line = ' '.join(temp_line.split())
                temp_line_list = temp_line.split()

                char_list = []
                type_name_list = []
                for entry in temp_line_list:
                    if ((len(entry)==1) and (entry in gb.alphabet)) or (len(entry)==3 and (entry[1]=='-')):
                        char_list.append(entry)
                    else:
                        type_name_list.append(entry)

                full_type_name = ''.join(type_name_list)
                if '*' in full_type_name:
                    type_name, type_size_str = full_type_name.split('*')
                    type_size = int(type_size_str)
                else:
                    type_name = full_type_name
                    type_size = 1


                # Loop through the character specifiers in char_list
                # and set the correct types in the implicit_defs dict

                for char in char_list:

                    if (len(char)==1) and (char in gb.alphabet):
                        implicit_defs[char.lower()] = (type_name,type_size)

                    elif (len(char)==3 ) and (char[1]=='-'):
                        start_char = char[0]
                        end_char = char[2]

                        for key_char in implicit_defs.keys():
                            if (key_char &gt;= start_char) and (key_char &lt;= end_char):
                                implicit_defs[key_char.lower()] = (type_name,type_size)

    return implicit_defs

# ====== END: getImplicitDefs ========




# ====== getParameterDefs ========

# Return a dict with the following structure: 
#   { 
#     'some_variable'   : '1234' 
#     'another_variable': '10'
#     ...
#   }
#
# Note: Currently, only integer parameters are useful (array dimensions and indices).
#

def getParameterDefs(code_lines):

    parameter_defs = {}

    for i,line in enumerate(code_lines):

        # Look for 'parameter' statement
        if line[0:9].lower() == 'parameter':

            # Remove 'parameter'
            line = line[9:]

            # Remove blanks
            line = line.replace(' ','')

            # Remove parenthesis
            line = line.lstrip('(').rstrip(')')

            # Split at comma
            parameter_entries = line.split(',')

            for entry in parameter_entries:

                # Split at '=' symbol
                var_name, value_str = entry.split('=')

                try:
                    value = eval(value_str)
                except:
                    print '    WARNING: Could not interpret the parameter &quot;%s&quot; with value &quot;%s&quot;. Ignoring it.' % (var_name, value_str)
                    continue


                # At the moment, CBGB can only make use of integer parameters. (Their only use is for array dimensions and indices.)
                if not isinstance( value, ( int, long ) ):
                    print '    INFO: Ignoring parameter &quot;%s&quot; with value &quot;%s&quot; as it was not recognized as an integer.' % (var_name, value_str)
                    continue

                value = int(value)

                # Adding variable to parameter_defs dictionary
                parameter_defs[var_name] = value

    return parameter_defs

# ====== END: getParameterDefs ========




# ====== getCommonBlockDicts ========

def getCommonBlockDicts(code_lines):

    cb_dicts = []

    for line in code_lines:

        # Remove whitespaces
        line = line.replace(' ','')

        # Ignore lines that don't start with 'common/'
        if (len(line) &lt; 7) or (line[:7].lower() != 'common/'):
            continue

        # Identify common block name and names of member variables
        line_list   = line.split('/')
        cb_name     = line_list[1]
        var_seq_str = line_list[2] 

        var_dicts = parseVariableSequence(var_seq_str)
        var_names = var_dicts.keys()

        cb_dicts.append( {'name':cb_name, 'member_names':var_names} )

    return cb_dicts

# ====== END: getCommonBlockDicts ========




# ====== isVariableDecl ========

def isVariableDecl(line_in, return_type=False):

    is_variable_decl = False
    type_name = ''
    type_size = 1

    line = line_in
    line = line.replace(',',' ').replace('*',' * ').replace('::',' ')
    line = line.replace('(', ' (').replace(')',') ')
    line = ' '.join(line.split())

    line_list = line.split()
    for i in [3,2,1]:
        check_type = ''.join(line_list[:i]).lower()

        print 'DEBUG: Is this a type? : ', [line_in], [check_type]

        # Check that we can deal with this Fortran type.
        if check_type in gb.type_translation_dict.keys():

            # If type is 'character*', identify the integer that specifies the 
            # string length.
            if check_type=='character':
                if (line_list[1] == '*') and (line_list[2].isdigit()):
                    check_type += '*' + line_list[2]

            if '*' in check_type:
                type_name, type_size_str = check_type.split('*')
                type_size = int(type_size_str)
            else:
                type_name = check_type

            is_variable_decl = True
            print 'DEBUG: --- YES!'
            break

    if return_type:
        return is_variable_decl, type_name, type_size
    else:
        return is_variable_decl

# ====== END: isVariableDecl ========




# ====== isDimensionStatement ========

def isDimensionStatement(line_in):

    is_dim_stmnt = False

    line = line_in
    line_list = line.split()

    if (len(line_list) &gt; 1) and (line_list[0].lower() == 'dimension'):
        is_dim_stmnt = True

    return is_dim_stmnt

# ====== END: isDimensionStatement ========



# ====== getArrayIndicesTuples ========

# Example:
# Input:  '-2:10,7,1:2'
# Output: [(-2,7), (1,7), (1,2)]

def getArrayIndicesTuples(dimensions_str, parameter_defs):

    indicies_tuples = []

    # Check for empty dimensions string
    if dimensions_str == '':
        return indicies_tuples

    # Check for assumed-shape arrays. We can't deal with that yet...        
    if dimensions_str == ':':
        raise RuntimeError

    # Loop over comma-separated entries in dimensions_str
    for dim_str in dimensions_str.split(','):

        if ':' in dim_str:
            # start_index, end_index = [int(s) for s in dim_str.split(':')]
            start_index_str, end_index_str = [s for s in dim_str.split(':')]

            if start_index_str in parameter_defs.keys():
                start_index = int( parameter_defs[start_index_str] )
            else:
                start_index = int(start_index_str)

            if end_index_str in parameter_defs.keys():
                end_index = int( parameter_defs[end_index_str] )
            else:
                end_index = int(end_index_str)

        else:
            start_index = 1
            end_index_str = dim_str
            if end_index_str in parameter_defs.keys():
                end_index = int( parameter_defs[end_index_str] )
            else:
                end_index = int(end_index_str)


        indicies_tuples.append( (start_index,end_index) )

    return indicies_tuples

# ====== END: getArrayIndicesTuples ========



# ====== getVariablesDict ========

def getVariablesDict(code_lines, get_variables):

    if len(get_variables) == 0:
        return OrderedDict()

    return_var_dicts = OrderedDict.fromkeys(get_variables, value=None)

    implicit_defs = getImplicitDefs(code_lines)

    for line in code_lines:

        #
        # First, make use of all variable type declaration lines
        #
        
        is_var_decl, type_name, type_size = isVariableDecl(line, return_type=True)

        if is_var_decl:

            # Remove type name from beginning of line so that
            # only the list of variable names remain.
            full_type_name = type_name + '*' + str(type_size)

            line_list = line.split()
            i = 1
            while i &lt;= len(line_list):
                if ''.join(line_list[:i]).lower() in full_type_name:
                    i += 1
                    continue
                else:
                    break
            var_seq = ''.join(line_list[i-1:])

            # Parse line to extract info on the different variables
            var_dicts = parseVariableSequence(var_seq)

            # Append type_name and type_size to var_dicts
            for var_name in var_dicts.keys():

                # - Add type name
                var_dicts[var_name]['type'] = type_name
                # - Use the maximum of the sizes specified in the type name and in the variable sequence
                #   (Normally one of these should be 1 by default.)
                var_dicts[var_name]['size'] = max(type_size,var_dicts[var_name]['size'])


                # Check for character array type:
                if (var_dicts[var_name]['type'] == 'character'): 
                    dim_str = var_dicts[var_name]['dimension']
                    size    = var_dicts[var_name]['size']
                    if (dim_str == '') and (size &gt; 1):
                        var_dicts[var_name]['dimension'] = '1:%i' % size

            # For requested variables, append the variable dicts to return_var_dicts
            for var_name in var_dicts.keys():
                if var_name in get_variables:
                    return_var_dicts[var_name] = var_dicts[var_name]



        #
        # Then, check all the 'dimension' statements
        #

        is_dim_stmnt = isDimensionStatement(line)

        if is_dim_stmnt:

            # Remove whitespace and 'dimension' keyword
            line = line.replace(' ','')
            line = line.replace('dimension','',1)

            # Parse line to extract info on the different variables
            dim_var_dicts = parseVariableSequence(line)

            # For variables that already exist in return_var_dicts, simply
            # update the 'dimension'. For variables that don't exist in 
            # return_var_dicts, create a new entry based on implicit types.
            for var_name in dim_var_dicts.keys():

                if var_name in get_variables:

                    # If info on this variable has not yet been added to return_var_dicts,
                    # insert a complete dict
                    if return_var_dicts[var_name] == None:
                        # Get type from implicit types
                        first_char = var_name[0]
                        type_name, type_size = implicit_defs[first_char.lower()]

                        if type_name == None or type_size == None:
                            raise RuntimeError(&quot;No type declaration (neither explicit nor implicit) was found for variable '%s'.&quot; % var_name)

                        return_var_dicts[var_name] = { 
                                                       'type'     : type_name,
                                                       'dimension': dim_var_dicts[var_name]['dimension'],
                                                       'size'     : type_size
                                                     }

                    # If info on this variable already exists, simply update the 'dimension' entry in the
                    # correct dict
                    else:
                        return_var_dicts[var_name]['dimension'] = dim_var_dicts[var_name]['dimension']


    #
    # END: Loop over code lines
    #

    #
    # Finally, add any missing variables that have not appeared in explicit type
    # declarations or 'dimension' statements
    #

    for get_var_name in get_variables:

        if return_var_dicts[get_var_name] == None:

            # Get type from implicit types
            first_char = get_var_name[0]
            type_name, type_size = implicit_defs[first_char.lower()]

            if type_name == None or type_size == None:
                raise RuntimeError(&quot;No type declaration (neither explicit nor implicit) was found for variable '%s'.&quot; % get_var_name)

            return_var_dicts[get_var_name] = { 
                                              'type'     : type_name,
                                              'dimension': '',
                                              'size'     : type_size
                                             }

    return return_var_dicts

# ====== END: getVariablesDict ========




# ====== parseVariableSequence ========

# Input : &quot;var1*100, var2(1:20)*20, var3&quot;
#
# Output: { 
#           'var1': { 'size': 100, 'dimension': ''       }, 
#           'var2': { 'size': 20,  'dimension': '(1:20)' },
#           'var3': { 'size': 1,   'dimension': ''       }
#         }

def parseVariableSequence(var_seq_str):

    result_dict = OrderedDict()

    line = var_seq_str

    # Remove all whitespace
    line = line.replace(' ','')

    # Split into separate variables by detecting commas 
    # (excluding commas inside brackets).
    i = 0
    bracket_balance = 0
    while i &lt; len(line):
        
        char = line[i]

        # Keep track of the brackets
        if char == '(':
            bracket_balance += 1
        elif char == ')':
            bracket_balance -= 1

        # If a comma is found, replace it with a whitespace
        if (char == ',') and (bracket_balance == 0):
            line = line[:i] + ' ' + line[i+1:]

        # Increment index
        i += 1

    # Split line at whitespaces
    var_str_list = line.split()

    for var_str in var_str_list:

        # Check for dimension bracket and size integer
        has_dim_bracket = bool('(' in var_str and ')' in var_str)
        has_size_int    = bool('*' in var_str)

        # Insert whitespace to separate variable name, dimension bracket and size integer
        var_str = var_str.replace('(',' ').replace(')',' ').replace('*',' ')

        # Split at whitespace
        var_str_list = var_str.split()

        # Identify name, dimension, size
        if has_dim_bracket and has_size_int:
            var_name     = var_str_list[0]
            var_dim_str  = var_str_list[1]
            var_size     = int(var_str_list[2])
        elif has_dim_bracket and not has_size_int:
            var_name     = var_str_list[0]
            var_dim_str  = var_str_list[1]
            var_size     = 1
        elif has_size_int and not has_dim_bracket:
            var_name     = var_str_list[0]
            var_dim_str  = ''
            var_size     = int(var_str_list[1])
        else:
            var_name     = var_str_list[0]
            var_dim_str  = '' 
            var_size     = 1

        # Append to result_dict
        result_dict[var_name] = {'dimension': var_dim_str, 'size': var_size}

    return result_dict

# ====== END: parseVariableSequence ========



# ====== getFunctionArgumentNames ========

def getFunctionArgumentNames(code_line):

# Input : &quot;subroutine some_subroutine(arg1,arg2,arg3)&quot;
#
# Output: [&quot;arg1&quot;,&quot;arg2&quot;,&quot;arg3&quot;] 

    arg_names = []
    if ('(' not in code_line) or (')' not in code_line):
        return arg_names

    # Pick out argument sequence
    arg_seq_str = code_line.split('(')[-1].split(')')[0]

    # Strip away any whitespace
    arg_seq_str = ''.join(arg_seq_str.split())

    # Construct list
    if arg_seq_str != '':
        arg_names = arg_seq_str.split(',')

    # Return resulting list
    return arg_names

# ====== END: getFunctionArgumentNames ========



# ====== getFunctionReturnType ========

def getFunctionReturnType(code_lines):

    f_decl_line = code_lines[0]

    f_decl_line_list = f_decl_line.split()
    f_index = f_decl_line.lower().split().index('function')
    
    # Get function name
    f_name = getCodePartName(f_decl_line, 'function')

    # Grab content in declaration line preceding the 'function' keyword
    # and append the function name to form a regular variable declaration: 
    f_return_type_line = ' '.join(f_decl_line_list[:f_index] + [f_name])

    # If f_return_type_line forms a valid type declaration, use it.
    # Otherwise, search the function body for a declaration.
    is_decl = isVariableDecl(f_return_type_line)
    if is_decl:
        result_dict = getVariablesDict([f_return_type_line], [f_name])
        return_type_dict = result_dict[f_name]
    else:
        result_dict = getVariablesDict(code_lines[1:], [f_name])
        return_type_dict = result_dict[f_name]

    return return_type_dict

# ====== END: getFunctionReturnType ========



# # ====== getFunctionDict ========

# def getFunctionDict(code_lines):

#     f_dict = OrderedDict()

#     # Get function/subroutine name
#     f_dict['name'] = getF


#     return f_dict

# # ====== END: getFunctionDict ========



# ====== generateTypeDeclCommonBlock ========

def generateTypeDeclCommonBlock(cb_dict, var_info_dict, parameter_defs):

    indent = ' '*4

    code = ''

    cb_name = cb_dict['name']
    cb_type_name = cb_name + '_type'

    code += 'struct %s\n' % cb_type_name
    code += '{\n'

    for var_name, var_dict in var_info_dict.items():

        try:
            c_type_name = getCTypeName(var_dict, parameter_defs)
        except RuntimeError:
            print &quot;    ERROR: Failed to translate variable '%s' in common block '%s' to C type.&quot; % (var_name, cb_name)
            raise

        code += indent + c_type_name + ' ' + var_name + ';\n'

    code += '};\n'

    return code

# ====== END: generateTypeDeclCommonBlock ========



# ====== generateFrontendCommonBlock ========

def generateFrontendCommonBlock(cb_dict):

    code = ''

    cb_name            = cb_dict['name']
    cb_type_name       = cb_name + '_type'
    cb_capability_name = cfg.cb_capability_prefix + cb_name + cfg.cb_capability_suffix

    cb_mangled_symbol = getMangledSymbolName(cb_name)

    code += 'BE_VARIABLE(%s, %s, &quot;%s&quot;, &quot;%s&quot;)\n' % (cb_name, cb_type_name, cb_mangled_symbol, cb_capability_name)

    return code

# ====== END: generateFrontendCommonBlock ========



# ====== generateFrontendFunction ========

def generateFrontendFunction(f_dict, parameter_defs):

    code = ''

    module_name  = f_dict['module']
    f_name_short = f_dict['name']
    if module_name != '':
        f_name = module_name + '_' + f_name_short
    else:
        f_name = f_name_short

    arg_info_dict = f_dict['arg_info']

    # Get correct C type for the return type.
    # - if function:
    if 'return_type_info' in f_dict.keys():
        ret_type_info_dict = f_dict['return_type_info']
        try:
            f_return_type_c = getCTypeName(ret_type_info_dict, parameter_defs)
        except RuntimeError:
            print &quot;    ERROR: Failed to translate the return type of function '%s' to C type.&quot; % (f_name)
            raise
    # - if subroutine:
    else:
        f_return_type_c = 'void'


    # Generate mangled symbol name
    f_mangled_symbol = getMangledSymbolName(f_name_short, module=module_name)

    # Construct capability name
    if (cfg.module_name_in_capability) and (module_name != ''):
        f_capability_name = cfg.f_capability_prefix + f_name + cfg.f_capability_suffix
    else:
        f_capability_name = cfg.f_capability_prefix + f_name_short + cfg.f_capability_suffix


    # Construct argument list
    arg_bracket = '('
    for arg_name, d in arg_info_dict.items():
        try:
            c_type_name = getCTypeName(d, parameter_defs)
        except RuntimeError:
            print &quot;    ERROR: Failed to translate the argument '%s' in %s '%s' to C type.&quot; % (arg_name, f_dict['category'], f_name_short)
            raise
        arg_bracket += c_type_name + '&amp;, '
    arg_bracket = arg_bracket.rstrip(', ')
    arg_bracket += ')'

    # Generate BE_FUNCTION macro call
    code += 'BE_FUNCTION(%s, %s, %s &quot;%s&quot;, &quot;%s&quot;)\n' % (f_name, f_return_type_c, arg_bracket, f_mangled_symbol, f_capability_name)
    
    return code

# ====== END: generateFrontendFunction ========




# ====== getMangledSymbolName ========

def getMangledSymbolName(identifier, module=''):

    if cfg.name_mangling == 'gfortran':
        if module != '':
            mangled_symbol = '__' + module.lower() + '_MOD_' + identifier.lower()
        else:
            mangled_symbol = identifier.lower() + '_'
    elif cfg.name_mangling == 'ifort':
        if module != '':
            mangled_symbol = module.lower() + '_MP_' + identifier.lower() + '_'
        else:
            mangled_symbol = identifier.lower() + '_'
    elif cfg.name_mangling == 'g77':
        if '_' in identifier:
            mangled_symbol = identifier.lower() + '__'
        else:
            mangled_symbol = identifier.lower() + '_'
    else:
        raise RuntimeError(&quot;cfg.name_mangling must be set to either 'gfortran', 'ifort' or 'g77'.&quot;)

    return mangled_symbol

# ====== END: getMangledSymbolName ========



# ====== getCTypeName ========

def getCTypeName(var_dict, parameter_defs):

    fortran_type_name = var_dict['type']
    
    if (fortran_type_name != 'character') and (var_dict['size'] &gt; 1):
        fortran_type_name += '*' + str(var_dict['size'])

    c_type_base_name = gb.type_translation_dict[fortran_type_name]

    try:
        array_indices_tuples = getArrayIndicesTuples(var_dict['dimension'], parameter_defs)
    except RuntimeError:
        print '    ERROR: Cannot determine the correct size for variable of type %s(%s).' % (fortran_type_name, var_dict['dimension'])
        raise

    # Is this variable an array?
    if (fortran_type_name != 'character') and (len(array_indices_tuples) &gt; 0):
        is_array = True
    elif (fortran_type_name == 'character') and (len(array_indices_tuples) &gt; 1):
        is_array = True
    else:
        is_array = False

    # For arrays, construct a string of comma-separated array indices
    if is_array:
        all_indices_list = [i for tpl in array_indices_tuples for i in tpl]
        all_indices_str = ','.join( map(str,all_indices_list) )

    #
    # Determine the correct C++ type name
    #

    # Special treatment for the character type
    if (fortran_type_name == 'character') and (var_dict['size'] &gt; 1):
        if is_array:
            template_bracket = '&lt; %i,%s &gt;' % (var_dict['size'], all_indices_str)
            c_type_name = 'FstringArray' + template_bracket
        else:
            c_type_name = 'Fstring&lt;%i&gt;' % var_dict['size'] 

    # All other types
    else:
        if is_array:
            template_bracket = '&lt; %s,%s &gt;' % (c_type_base_name, all_indices_str)
            c_type_name = 'Farray' + template_bracket
        else:
            c_type_name = c_type_base_name


    # Return result
    return c_type_name

# ====== END: getCTypeName ========



# ====== addNamespace ========

# Encapsulate code string in a namespace

def addNamespace(code, namespace_name, indent=4):

    # Add indentation
    code_lines = [' '*indent + line for line in code.splitlines()]
    code = '\n'.join(code_lines)

    # Add namespace
    code = 'namespace ' + namespace_name + '\n' + '{\n' + code + '\n}\n'

    return code

# ====== END: addNamespace ========
</code></pre><hr><p>Updated on 2022-08-02 at 18:18:48 +0000</p><div class=edit-page><a href=https://github.com/RC1242RC/gambit_gh_pages/blob/master/content/en/documentation/code/DarkBit_development/Files/CBGB_2modules_2utils_8py.md><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828.0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>Edit this page on GitHub</a></div></main></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Powered by <a class=text-muted href=https://www.netlify.com/>Netlify</a>, <a class=text-muted href=https://gohugo.io/>Hugo</a>, and <a class=text-muted href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline><li class=list-inline-item><a href=/license/>License</a></li></ul></div></div></div></footer><script src=/js/bootstrap.min.54bf0932b8a36d0e152b1635b099a6ef1394d35327e2437550a075c9c8ed1bd8aed5847c21b36fc02ed24014c031d9ca24017b0c78b1639d7e2fa8329898b842.js integrity="sha512-VL8JMrijbQ4VKxY1sJmm7xOU01Mn4kN1UKB1ycjtG9iu1YR8IbNvwC7SQBTAMdnKJAF7DHixY51+L6gymJi4Qg==" crossorigin=anonymous defer></script>
<script src=/js/highlight.min.5b48bc253dc75aeea5fb366ecf700f4925e2b6eb1a1466f2124b722d68148d67bc0a9365d2b8ad9c585161b46372d23b08509a16f1fd518542b894756d4752d0.js integrity="sha512-W0i8JT3HWu6l+zZuz3APSSXitusaFGbyEktyLWgUjWe8CpNl0ritnFhRYbRjctI7CFCaFvH9UYVCuJR1bUdS0A==" crossorigin=anonymous defer></script>
<script src=/main.min.40265e9a032aeba5eaf67baac3cbbc22667a7533215d326eeb3e9f4d5e4be40f9ff4dcd22949db73ae527ca26a19d7998091a8973c82af760b2c0daa335190ed.js integrity="sha512-QCZemgMq66Xq9nuqw8u8ImZ6dTMhXTJu6z6fTV5L5A+f9NzSKUnbc65SfKJqGdeZgJGolzyCr3YLLA2qM1GQ7Q==" crossorigin=anonymous defer></script>
<script src=https://rc1242rc.github.io/index.min.97d6402d7a34cdd5bd42756d4cab0cf30d540a9cfd60b87b21ea49bb4e8ab243c43c3171889d41e133bd95a5c6d18e02d0f4cd3d09c2e02e58f2cc367481d403.js integrity="sha512-l9ZALXo0zdW9QnVtTKsM8w1UCpz9YLh7IepJu06KskPEPDFxiJ1B4TO9laXG0Y4C0PTNPQnC4C5Y8sw2dIHUAw==" crossorigin=anonymous defer></script></body></html>