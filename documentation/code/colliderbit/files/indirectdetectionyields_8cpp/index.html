<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=https://rc1242rc.github.io/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://rc1242rc.github.io/fonts/vendor/jost/jost-v4-latin-500.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://rc1242rc.github.io/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><script>(()=>{var e=localStorage.getItem("theme");e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><link rel=stylesheet href=https://rc1242rc.github.io/main.f12f7e04ea768acebec10c86baf049d74d6a79f24bc0dfb7ed77aa60462432916dd1ce8f41c78b69496adf650b3039a28a210183cce598f09b95d6fecb5ff999.css integrity="sha512-8S9+BOp2is6+wQyGuvBJ101qefJLwN+37XeqYEYkMpFt0c6PQceLaUlq32ULMDmiiiEBg8zlmPCbldb+y1/5mQ==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>file src/IndirectDetectionYields.cpp - GAMBIT</title><meta name=description content="[No description available]"><link rel=canonical href=https://rc1242rc.github.io/documentation/code/colliderbit/files/indirectdetectionyields_8cpp/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="file src/IndirectDetectionYields.cpp"><meta property="og:description" content="[No description available]"><meta property="og:url" content="https://rc1242rc.github.io/documentation/code/colliderbit/files/indirectdetectionyields_8cpp/"><meta property="og:site_name" content="GAMBIT"><meta property="og:image" content="https://rc1242rc.github.io/gambit_logo.png"><meta property="og:image:alt" content="GAMBIT"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content><meta name=twitter:creator content><meta name=twitter:title content="file src/IndirectDetectionYields.cpp"><meta name=twitter:description content="[No description available]"><meta name=twitter:image content="https://rc1242rc.github.io/gambit_logo.png"><meta name=twitter:image:alt content="file src/IndirectDetectionYields.cpp"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://rc1242rc.github.io/#/schema/organization/1","name":"Doks","url":"https://rc1242rc.github.io/","sameAs":["https://github.com/GambitBSM"],"logo":{"@type":"ImageObject","@id":"https://rc1242rc.github.io/#/schema/image/1","url":"https://rc1242rc.github.io/logo-doks.png","width":450,"height":416,"caption":"Doks"},"image":{"@id":"https://rc1242rc.github.io/#/schema/image/1"}},{"@type":"WebSite","@id":"https://rc1242rc.github.io/#/schema/website/1","url":"https://rc1242rc.github.io/","name":"GAMBIT","description":"Documentation for the Global And Modular BSM Inference Tool","publisher":{"@id":"https://rc1242rc.github.io/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://rc1242rc.github.io/documentation/code/colliderbit/files/indirectdetectionyields_8cpp/","url":"https://rc1242rc.github.io/documentation/code/colliderbit/files/indirectdetectionyields_8cpp/","name":"file src\/IndirectDetectionYields.cpp","description":"[No description available]","isPartOf":{"@id":"https://rc1242rc.github.io/#/schema/website/1"},"about":{"@id":"https://rc1242rc.github.io/#/schema/organization/1"},"datePublished":"0001-01-01T00:00:00CET","dateModified":"0001-01-01T00:00:00CET","breadcrumb":{"@id":"https://rc1242rc.github.io/documentation/code/colliderbit/files/indirectdetectionyields_8cpp/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://rc1242rc.github.io/documentation/code/colliderbit/files/indirectdetectionyields_8cpp/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://rc1242rc.github.io/documentation/code/colliderbit/files/indirectdetectionyields_8cpp/"]}]},{"@type":"BreadcrumbList","@id":"https://rc1242rc.github.io/documentation/code/colliderbit/files/indirectdetectionyields_8cpp/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/","url":"https://rc1242rc.github.io/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/documentation/","url":"https://rc1242rc.github.io/documentation/","name":"Documentation"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/documentation/code/","url":"https://rc1242rc.github.io/documentation/code/","name":"Code"}},{"@type":"ListItem","position":4,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/documentation/code/colliderbit/","url":"https://rc1242rc.github.io/documentation/code/colliderbit/","name":"Colliderbit"}},{"@type":"ListItem","position":5,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/documentation/code/colliderbit/files/","url":"https://rc1242rc.github.io/documentation/code/colliderbit/files/","name":"Files"}},{"@type":"ListItem","position":6,"item":{"@id":"https://rc1242rc.github.io/documentation/code/colliderbit/files/indirectdetectionyields_8cpp/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://rc1242rc.github.io/documentation/code/colliderbit/files/indirectdetectionyields_8cpp/#/schema/image/2","url":"https://rc1242rc.github.io/gambit_logo.png","contentUrl":"https://rc1242rc.github.io/gambit_logo.png","caption":"file src\/IndirectDetectionYields.cpp"}]}]}</script><meta name=theme-color content="#fff"><link rel=icon href=https://rc1242rc.github.io/favicon.ico sizes=any><link rel=icon type=image/svg+xml href=https://rc1242rc.github.io/favicon.svg><link rel=apple-touch-icon sizes=180x180 href=https://rc1242rc.github.io/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://rc1242rc.github.io/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://rc1242rc.github.io/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://rc1242rc.github.io/site.webmanifest></head><body class="documentation single light"><div class=sticky-top><div class=header-bar></div><header class="navbar navbar-expand-md navbar-light doks-navbar"><nav class="container-xxl flex-wrap flex-md-nowrap" aria-label="Main navigation"><a class="navbar-brand p-0 me-auto" href=https://rc1242rc.github.io/ aria-label=GAMBIT><img class=logo-light src=https://rc1242rc.github.io//images/gambit_logo.png width=50px>
<img class="logo-dark d-none" src=https://rc1242rc.github.io//images/gambit_logo.png width=50px>
GAMBIT</a>
<button class="btn btn-menu order-2 d-block d-lg-none" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasDoks aria-controls=offcanvasDoks aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><div class="offcanvas offcanvas-end border-0 py-lg-1" tabindex=-1 id=offcanvasDoks data-bs-backdrop=true aria-labelledby=offcanvasDoksLabel><div class="header-bar d-lg-none"></div><div class="offcanvas-header d-lg-none"><h2 class="h5 offcanvas-title ps-2" id=offcanvasDoksLabel><a class=text-dark href=/>GAMBIT</a></h2><button type=button class="btn-close text-reset me-2" data-bs-dismiss=offcanvas aria-label="Close main menu"></button></div><div class="offcanvas-body p-4 p-lg-0"><ul class="nav flex-column flex-lg-row align-items-lg-center mt-2 mt-lg-0 ms-lg-2 me-lg-auto"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Documentation
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/documentation/installation/introduction/>Installation</a></li><li><a class=dropdown-item href=/documentation/examples/colliderbit_example>Examples</a></li><li><a class=dropdown-item href=/documentation/help/faqs/>Help</a></li><li><a class=dropdown-item href=/documentation/code/gambit_sphinx/index_classes>Code Reference</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Community
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/community/publications/>Publications</a></li><li><a class=dropdown-item href=/community/talks/>Talks</a></li><li><a class=dropdown-item href=/community/members/>Members</a></li><li><a class=dropdown-item href=/community/code_of_conduct/>Code of Conduct</a></li><li><a class=dropdown-item href=/community/contact/>Contact</a></li></ul></li></ul><hr class="text-black-50 my-4 d-lg-none"><form class="doks-search position-relative flex-grow-1 ms-lg-auto me-lg-2"><input id=search class="form-control is-search" type=search placeholder="Search site..." aria-label="Search site..." autocomplete=off><div id=suggestions class="shadow bg-white rounded d-none"></div></form><hr class="text-black-50 my-4 d-lg-none"><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=https://github.com/GambitBSM><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><small class="ms-2 d-lg-none">GitHub</small></a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn btn-doks-light dropdown-toggle" id=doks-versions data-bs-toggle=dropdown aria-expanded=false data-bs-display=static aria-label="Toggle version menu">
<span class=d-none>Doks</span>
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=doks-versions></ul></div></div></div></nav></header></div><div class="wrap container-xxl" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class=docs-links aria-label="Main navigation"><ul class="list-unstyled collapsible-sidebar"><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-installation aria-expanded=false>
Installation</button><div class=collapse id=section-installation><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/installation/introduction/>Getting Started</a></li><li><a class="docs-link rounded" href=/documentation/installation/docker_usage/>Docker Usage</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_linux/>Installation for Linux</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_windows/>Installation for Windows</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_macos/>Installation for macOS</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-examples aria-expanded=false>
Examples</button><div class=collapse id=section-examples><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/examples/colliderbit_example/>ColliderBit Example</a></li><li><a class="docs-link rounded" href=/documentation/examples/anotherbit/>AnotherBit</a></li><li><a class="docs-link rounded" href=/documentation/examples/anotherbit2/>AnotherBit2</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-help aria-expanded=false>
Help</button><div class=collapse id=section-help><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/help/faqs/>FAQs</a></li><li><a class="docs-link rounded" href=/documentation/help/compiler_matrix/>Compiler Matrix</a></li><li><a class="docs-link rounded" href=/documentation/help/known_issues/>Known Issues</a></li><li><a class="docs-link rounded" href=/documentation/help/configuration_examples/>Configuration Examples</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-code aria-expanded=true>
Code Reference</button><div class="collapse show" id=section-code><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li class="my-1 ms-3"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-gambit_sphinx aria-expanded=true>
<font style="color: #5d2f86;" size=-6>release</font> &nbsp; gambit sphinx</button><div class="collapse show" id=section-gambit_sphinx><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/code/gambit_sphinx/index_classes/>Classes</a></li><li><a class="docs-link rounded" href=/documentation/code/gambit_sphinx/index_files/>Files</a></li><li><a class="docs-link rounded" href=/documentation/code/gambit_sphinx/index_pages/>Pages</a></li><li><a class="docs-link rounded" href=/documentation/code/gambit_sphinx/index_namespaces/>Namespaces</a></li></ul></div></li><li class="my-1 ms-3"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-ColliderBit aria-expanded=true>
<font style="color: #5d2f86;" size=-6>development</font> &nbsp; ColliderBit</button><div class="collapse show" id=section-ColliderBit><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/code/colliderbit/index_classes/>Classes</a></li><li><a class="docs-link rounded" href=/documentation/code/colliderbit/index_files/>Files</a></li><li><a class="docs-link rounded" href=/documentation/code/colliderbit/index_pages/>Pages</a></li><li><a class="docs-link rounded" href=/documentation/code/colliderbit/index_namespaces/>Namespaces</a></li></ul></div></li><li class="my-1 ms-3"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-DarkBit aria-expanded=true>
<font style="color: #5d2f86;" size=-6>development</font> &nbsp; DarkBit</button><div class="collapse show" id=section-DarkBit><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/code/darkbit/index_classes/>Classes</a></li><li><a class="docs-link rounded" href=/documentation/code/darkbit/index_files/>Files</a></li><li><a class="docs-link rounded" href=/documentation/code/darkbit/index_pages/>Pages</a></li><li><a class="docs-link rounded" href=/documentation/code/darkbit/index_namespaces/>Namespaces</a></li></ul></div></li><li class="my-1 ms-3"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-main aria-expanded=true>
<font style="color: #5d2f86;" size=-6>development</font> &nbsp; main</button><div class="collapse show" id=section-main><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/code/main/index_classes/>Classes</a></li><li><a class="docs-link rounded" href=/documentation/code/main/index_files/>Files</a></li><li><a class="docs-link rounded" href=/documentation/code/main/index_pages/>Pages</a></li><li><a class="docs-link rounded" href=/documentation/code/main/index_namespaces/>Namespaces</a></li></ul></div></li></ul></div></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=d-xl-none><button class="btn btn-outline-primary btn-sm doks-toc-toggle collapsed" type=button data-bs-toggle=collapse data-bs-target=#onThisPage aria-controls=doks-docs-nav aria-expanded=false aria-label="Toggle On this page navigation">
<span>On this page</span>
<span><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"/><polyline points="7 6 12 11 17 6"/></svg><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"/><polyline points="17 18 12 13 7 18"/></svg></span></button><div class=collapse id=onThisPage><div class="card card-body mt-3 py-1"><div class=page-links><nav id=TableOfContents><ul><li><ul><li><a href=#namespaces>Namespaces</a></li><li><a href=#detailed-description>Detailed Description</a></li><li><a href=#source-code>Source code</a></li></ul></li></ul></nav></div></div></div></div><div class="page-links d-none d-xl-block"><h3>On this page</h3><nav id=TableOfContents><ul><li><ul><li><a href=#namespaces>Namespaces</a></li><li><a href=#detailed-description>Detailed Description</a></li><li><a href=#source-code>Source code</a></li></ul></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9 mx-xl-auto"><nav aria-label=breadcrumb><ol class=breadcrumb><li class=breadcrumb-item><a href=/>Home</a></li><li class=breadcrumb-item><a href=/documentation/>Documentation</a></li><li class=breadcrumb-item><a href=/documentation/code/>Code Reference</a></li><li class=breadcrumb-item><a href=/documentation/code/colliderbit/>ColliderBit</a></li><li class="breadcrumb-item active" aria-current=page>file src/IndirectDetectionYields.cpp</li></ol></nav><h1>file src/IndirectDetectionYields.cpp</h1><p class=lead></p><p>[No description available] <a href=#detailed-description>More&mldr;</a></p><h2 id=namespaces>Namespaces <a href=#namespaces class=anchor aria-hidden=true>#</a></h2><table><thead><tr><th>Name</th></tr></thead><tbody><tr><td><strong><a href=/documentation/code/colliderbit/namespaces/namespacegambit/>Gambit</a></strong><br>Simulation of &ldquo;Search for photonic signatures of gauge-mediated supersymmetry in 13 TeV pp collisions with the ATLAS detector&rdquo;.</td></tr><tr><td><strong><a href=/documentation/code/colliderbit/namespaces/namespacegambit_1_1darkbit/>Gambit::DarkBit</a></strong></td></tr></tbody></table><h2 id=detailed-description>Detailed Description <a href=#detailed-description class=anchor aria-hidden=true>#</a></h2><p><strong>Author</strong>:</p><ul><li>Christoph Weniger (<a href=mailto:c.weniger@uva.nl>c.weniger@uva.nl</a>)</li><li>Sebastian Wild (<a href=mailto:sebastian.wild@ph.tum.de>sebastian.wild@ph.tum.de</a>)</li><li>Sanjay Bloor (<a href=mailto:sanjay.bloor12@imperial.ac.uk>sanjay.bloor12@imperial.ac.uk</a>)</li><li>Pat Scott (<a href=mailto:pat.scott@uq.edu.au>pat.scott@uq.edu.au</a>)</li><li>Patrick Stoecker (<a href=mailto:stoecker@physik.rwth-aachen.de>stoecker@physik.rwth-aachen.de</a>)</li></ul><p><strong>Date</strong>:</p><ul><li>2013 Jul - 2015 May</li><li>2016 Aug</li><li>2018 Aug</li><li>2020 Nov, Dec</li><li>2021 Mar</li></ul><p>Routines for the calculation of particle yields from dark matter annihilation / decay.</p><hr><p>Authors (add name and date if you modify):</p><hr><h2 id=source-code>Source code <a href=#source-code class=anchor aria-hidden=true>#</a></h2><pre><code>//   GAMBIT: Global and Modular BSM Inference Tool
//   *********************************************
///  \file
///
///  Routines for the calculation of particle yields
///  from dark matter annihilation / decay.
///
///  *********************************************
///
///  Authors (add name and date if you modify):
///
///  \author Christoph Weniger
///          (c.weniger@uva.nl)
///  \date 2013 Jul - 2015 May
///
///  \author Sebastian Wild
///          (sebastian.wild@ph.tum.de)
///  \date 2016 Aug
///
///  \author Sanjay Bloor
///          (sanjay.bloor12@imperial.ac.uk)
///  \date 2018 Aug
///
///  \author Pat Scott
///          (pat.scott@uq.edu.au)
///  \date 2020 Nov, Dec
///
///  \author Patrick Stoecker
///          (stoecker@physik.rwth-aachen.de)
///  \date 2021 Mar
///
///  *********************************************

#include &quot;gambit/Elements/gambit_module_headers.hpp&quot;
#include &quot;gambit/DarkBit/DarkBit_rollcall.hpp&quot;
#include &quot;gambit/Utils/ascii_table_reader.hpp&quot;
#include &quot;gambit/DarkBit/DarkBit_utils.hpp&quot;

//#define DARKBIT_DEBUG

namespace Gambit
{
  namespace DarkBit
  {

    /*! \brief Boosts an energy spectrum of isotropic particles into another
     *         frame (and isotropizes again).
     *  Parameters:
     *    gamma: Lorentz boost factor
     *    dNdE: Spectrum
     *    mass: mass of particle
     */
    daFunk::Funk boost_dNdE(daFunk::Funk dNdE, double gamma, double mass)
    {
      if ( gamma &lt; 1.0 + .02 )  // Ignore less than 2% boosts
      {
        if (gamma &lt; 1.0)
          DarkBit_error().raise(LOCAL_INFO,
            &quot;boost_dNdE: Requested Lorentz boost with gamma &lt; 1&quot;);
        return dNdE;
      }
      double betaGamma = sqrt(gamma*gamma-1);
      daFunk::Funk E = daFunk::var(&quot;E&quot;);
      daFunk::Funk lnE = daFunk::var(&quot;lnE&quot;);
      daFunk::Funk Ep = daFunk::var(&quot;Ep&quot;);
      daFunk::Funk halfBox_int = betaGamma*sqrt(E*E-mass*mass);
      daFunk::Funk halfBox_bound = betaGamma*sqrt(Ep*Ep-mass*mass);
      daFunk::Funk integrand = dNdE/(2*halfBox_int);
      return integrand-&gt;gsl_integration(&quot;E&quot;, Ep*gamma-halfBox_bound, Ep*gamma+halfBox_bound)
        -&gt;set_epsabs(0)-&gt;set_limit(100)-&gt;set_epsrel(1e-3)-&gt;set_use_log_fallback(true)-&gt;set(&quot;Ep&quot;, daFunk::var(&quot;E&quot;));
      //
      // Note: integration over lnE causes problems in the WIMP example (3) as the singularity is dropped.
      // return (integrand*E)-&gt;set(&quot;E&quot;, exp(lnE))-&gt;gsl_integration(&quot;lnE&quot;, log(Ep*gamma-halfBox_bound), log(Ep*gamma+halfBox_bound))
      //  -&gt;set_epsabs(0)-&gt;set_epsrel(1e-3)-&gt;set(&quot;Ep&quot;, daFunk::var(&quot;E&quot;));
    }


    /*! \brief Helper function returning yield from
     *         a given DM process.
     */
    daFunk::Funk getYield(const str&amp; yield, const bool is_annihilation, const str&amp; DMid, const str&amp; DMbarid,
      TH_ProcessCatalog catalog, SimYieldTable table, double line_width, stringFunkMap cascadeMC_spectra)
    {
      using DarkBit_utils::gamma3bdy_limits;

      // Make sure that the ProcessCatalog process matches the is_annihilation flag.
      const TH_Process* p = (is_annihilation ? catalog.find(DMid, DMbarid) : catalog.find(DMid));
      if (p == NULL) DarkBit_error().raise(LOCAL_INFO, &quot;Process does not match type indicated by is_annihilation flag.&quot;);

      // Get particle mass from process catalog
      const double mass = catalog.getParticleProperty(DMid).mass;
      const double Ecm(is_annihilation ? 2*mass : mass);

      // Get annihilation or decay process from process catalog and set up yield vector
      TH_Process process(is_annihilation ? catalog.getProcess(DMid, DMbarid) : catalog.getProcess(DMid));
      daFunk::Funk Yield(is_annihilation ? daFunk::zero(&quot;E&quot;, &quot;v&quot;) : daFunk::zero(&quot;E&quot;));

      // Adding two-body channels
      for (std::vector&lt;TH_Channel&gt;::iterator it = process.channelList.begin();
          it != process.channelList.end(); ++it)
      {
        bool added = false;  // If spectrum is not available from any source

        // Here only take care of two-body final states
        if (it-&gt;nFinalStates != 2) continue;

        // Get final state masses
        double m0 = catalog.getParticleProperty(it-&gt;finalStateIDs[0]).mass;
        double m1 = catalog.getParticleProperty(it-&gt;finalStateIDs[1]).mass;

        // Ignore channels that are kinematically closed for v=0
        if ( m0 + m1 &gt; Ecm ) continue;

        // Ignore channels with 0 BR in v=0 limit (if &quot;v&quot; is a variable of genRate, i.e. not a decay).
        if (it-&gt;genRate-&gt;hasArg(&quot;v&quot;) &amp;&amp; it-&gt;genRate-&gt;bind(&quot;v&quot;)-&gt;eval(0.) &lt;= 0.0) continue;
        else if ( !(it-&gt;genRate-&gt;hasArgs()) &amp;&amp; it-&gt;genRate-&gt;bind()-&gt;eval() &lt;=0.0) continue;

        double E0 = 0.5*(Ecm*Ecm+m0*m0-m1*m1)/Ecm;
        double E1 = Ecm-E0;

        // Check whether two-body hard process final state is in SimYield table
        if ( table.hasChannel(it-&gt;finalStateIDs[0], it-&gt;finalStateIDs[1], yield) )
        {
          Yield = Yield +
            it-&gt;genRate*(table)(
                it-&gt;finalStateIDs[0], it-&gt;finalStateIDs[1], yield, Ecm);
          added = true;
        }
        // Deal with composite final states
        else
        {
          daFunk::Funk spec0 = daFunk::zero(&quot;E&quot;);
          daFunk::Funk spec1 = daFunk::zero(&quot;E&quot;);
          added = true;

          // Final state particle one
          // Tabulated spectrum available?
          if ( table.hasChannel(it-&gt;finalStateIDs[0], yield) )
          {
            spec0 = (table)(it-&gt;finalStateIDs[0], yield)-&gt;set(&quot;Ecm&quot;,E0);
          }
          // Monochromatic line?
          else if ( it-&gt;finalStateIDs[0] == yield )
          {
            daFunk::Funk E = daFunk::var(&quot;E&quot;);
            spec0 = daFunk::delta(&quot;E&quot;,E0,E0*line_width);
          }
          // MC spectra available?
          else if ( cascadeMC_spectra.count(it-&gt;finalStateIDs[0]) )
          {
            double gamma0 = E0/m0;
            //std::cout &lt;&lt; it-&gt;finalStateIDs[0] &lt;&lt; &quot; &quot; &lt;&lt; gamma0 &lt;&lt; std::endl;
            spec0 = boost_dNdE(cascadeMC_spectra.at(it-&gt;finalStateIDs[0]), gamma0, 0.0);
          }
          else added = false;

          // Final state particle two
          if ( table.hasChannel(it-&gt;finalStateIDs[1], yield) )
          {
            spec1 = (table)(it-&gt;finalStateIDs[1], yield)-&gt;set(&quot;Ecm&quot;, E1);
          }
          else if ( it-&gt;finalStateIDs[1] == yield )
          {
            daFunk::Funk E = daFunk::var(&quot;E&quot;);
            spec1 = daFunk::delta(&quot;E&quot;,E1,E1*line_width);
          }
          else if ( cascadeMC_spectra.count(it-&gt;finalStateIDs[1]) )
          {
            double gamma1 = E1/m1;
            //std::cout &lt;&lt; it-&gt;finalStateIDs[1] &lt;&lt; &quot; &quot; &lt;&lt; gamma1 &lt;&lt; std::endl;
            spec1 = boost_dNdE(cascadeMC_spectra.at(it-&gt;finalStateIDs[1]), gamma1, 0.0);
          }
          else added = false;

          #ifdef DARKBIT_DEBUG
            std::cout &lt;&lt; it-&gt;finalStateIDs[0] &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;finalStateIDs[1] &lt;&lt; std::endl;
            //std::cout &lt;&lt; &quot;gammas: &quot; &lt;&lt; gamma0 &lt;&lt; &quot;, &quot; &lt;&lt; gamma1 &lt;&lt; std::endl;
            daFunk::Funk chnSpec = (daFunk::zero(&quot;v&quot;, &quot;E&quot;)
              +  spec0
              +  spec1)-&gt; set(&quot;v&quot;, 0.);
            auto x = daFunk::logspace(0, 3, 10);
            std::vector&lt;double&gt; y = chnSpec-&gt;bind(&quot;E&quot;)-&gt;vect(x);
            std::cout &lt;&lt; it-&gt;finalStateIDs[0] &lt;&lt; it-&gt;finalStateIDs[1] &lt;&lt; &quot;:\n&quot;;
            std::cout &lt;&lt; &quot;  E: [&quot;;
            for (std::vector&lt;double&gt;::iterator it2 = x.begin(); it2 != x.end(); it2++)
              std::cout &lt;&lt; *it2 &lt;&lt; &quot;, &quot;;
            std::cout &lt;&lt; &quot;]\n&quot;;
            std::cout &lt;&lt; &quot;  dNdE: [&quot;;
            for (std::vector&lt;double&gt;::iterator it2 = y.begin(); it2 != y.end(); it2++)
              std::cout &lt;&lt; *it2 &lt;&lt; &quot;, &quot;;
            std::cout &lt;&lt; &quot;]\n&quot;;
          #endif

          if (!added)
          {
            DarkBit_warning().raise(LOCAL_INFO, &quot;DarkBit::getYield (with yield = &quot; + yield + &quot;) cannot &quot;
              &quot;find spectra for &quot; + it-&gt;finalStateIDs[0] + &quot; &quot; + it-&gt;finalStateIDs[1]);
          }

          Yield = Yield + (spec0 + spec1) * it-&gt;genRate;
        }
      } // End adding two-body final states

      // Adding three-body final states
      //
      // NOTE:  Three body processes are added even if they are closed at v=0
      for (std::vector&lt;TH_Channel&gt;::iterator it = process.channelList.begin();
          it != process.channelList.end(); ++it)
      {
        bool added = true;

        // Here only take care of three-body final states
        if (it-&gt;nFinalStates != 3) continue;

        /*
        // Implement tabulated three-body final states
        // Keep this for future use
        if ( it-&gt;nFinalStates == 3
         and table-&gt;hasChannel(it-&gt;finalStateIDs[0], yield)
         and table-&gt;hasChannel(it-&gt;finalStateIDs[1], yield)
         and table-&gt;hasChannel(it-&gt;finalStateIDs[2], yield) )
        {
         daFunk::Funk dNdE1dE2 = it-&gt;genRate-&gt;set(&quot;v&quot;,0.);
         daFunk::Funk spec0 = (table)(it-&gt;finalStateIDs[0], yield);
         daFunk::Funk spec1 = (table)(it-&gt;finalStateIDs[1], yield);
         daFunk::Funk spec2 = (table)(it-&gt;finalStateIDs[2], yield);
         Yield = Yield + convspec(spec0, spec1, spec2, dNdE1dE2);
        }
        */

        if ( it-&gt;finalStateIDs[0] == yield )
        {
          if ( it-&gt;finalStateIDs[1] == yield or it-&gt;finalStateIDs[2] == yield)
          {
            DarkBit_warning().raise(LOCAL_INFO, &quot;Second and/or third primary &quot;+yield+&quot; in three-body final states ignored.&quot;);
          }
          double m1 = catalog.getParticleProperty(it-&gt;finalStateIDs[1]).mass;
          double m2 = catalog.getParticleProperty(it-&gt;finalStateIDs[2]).mass;
          daFunk::Funk E1_low =  daFunk::func(gamma3bdy_limits&lt;0&gt;, daFunk::var(&quot;E&quot;),
              mass, m1, m2);
          daFunk::Funk E1_high =  daFunk::func(gamma3bdy_limits&lt;1&gt;, daFunk::var(&quot;E&quot;),
              mass, m1, m2);
          daFunk::Funk dsigmavde = it-&gt;genRate-&gt;gsl_integration(
              &quot;E1&quot;, E1_low, E1_high);

          Yield = Yield + dsigmavde;
        }
        else added = false;

        if (!added)
        {
          DarkBit_warning().raise(LOCAL_INFO,
              &quot;DarkBit::getYield ignoring final state &quot;
              + it-&gt;finalStateIDs[0] + &quot; &quot; + it-&gt;finalStateIDs[1] + &quot; &quot; + it-&gt;finalStateIDs[2]);
        }
      }

      // Rescale the yield by the correct kinematic factor
      if (is_annihilation)
      {
        // If process involves non-self-conjugate DM then we need to add a factor of 1/2
        // to the final spectrum. This must be explicitly set in the process catalog.
        double k = (process.isSelfConj) ? 1. : 0.5;
        Yield = k*daFunk::ifelse(1e-6 - daFunk::var(&quot;v&quot;), Yield/(mass*mass),
          daFunk::throwError(&quot;Spectrum currently only defined for v=0.&quot;));
      }
      else
      {
        Yield = Yield/mass;
      }

      return Yield;

    }

    /// \brief General routine to derive gamma-ray annihilation yield.
    /// This function returns
    ///   k*dN/dE*(sv)/mDM**2 (E, v)  [cm^3/s/GeV^3]
    /// the energy spectrum of photons times sigma*v/m^2, as function of energy (in GeV)
    /// and velocity (as a fraction of c), multiplied by k=1 for self-conjugate DM or k=1/2
    /// for non-self conjugate.  By default, only the v=0 component is calculated.
    void GA_AnnYield_General(daFunk::Funk &amp;result)
    {
      using namespace Pipes::GA_AnnYield_General;
      std::string DMid= *Dep::DarkMatter_ID;
      std::string DMbarid = *Dep::DarkMatterConj_ID;
      /// Option line_width&lt;double&gt;: Set relative line width used in gamma-ray spectra (default 0.03)
      const double line_width = runOptions-&gt;getValueOrDef&lt;double&gt;(0.03,  &quot;line_width&quot;);
      result = getYield(&quot;gamma&quot;, true, DMid, DMbarid, *Dep::TH_ProcessCatalog, *Dep::GA_SimYieldTable,
                        line_width, *Dep::cascadeMC_gammaSpectra);
    }

    /// \brief General routine to derive gamma-ray decay yield.
    /// This function returns
    ///   dN/dE*(Gamma)/mDM (E)  [1/s/GeV^2]
    /// the energy spectrum of photons times Gamma/m, as function of energy (in GeV).
    void GA_DecayYield_General(daFunk::Funk &amp;result)
    {
      using namespace Pipes::GA_DecayYield_General;
      std::string DMid = *Dep::DarkMatter_ID;
      /// Option line_width&lt;double&gt;: Set relative line width used in gamma-ray spectra (default 0.03)
      const double line_width = runOptions-&gt;getValueOrDef&lt;double&gt;(0.03,  &quot;line_width&quot;);
      result = getYield(&quot;gamma&quot;, false, DMid, &quot;null&quot;, *Dep::TH_ProcessCatalog, *Dep::GA_SimYieldTable,
                        line_width, *Dep::cascadeMC_gammaSpectra);
    }

    /// \brief General routine to derive electron annihilation yield.
    /// This function returns
    /// k*dN/dE*(sv)/mDM**2 (E, v)  [cm^3/s/GeV^3]
    /// the energy spectrum of electrons times sigma*v/m^2, as function of energy (in GeV)
    /// and velocity (as a fraction of c), multiplied by k=1 for self-conjugate DM or k=1/2
    /// for non-self conjugate.  By default, only the v=0 component is calculated.
    void electron_AnnYield_General(daFunk::Funk &amp;result)
    {
      using namespace Pipes::electron_AnnYield_General;
      std::string DMid= *Dep::DarkMatter_ID;
      std::string DMbarid = *Dep::DarkMatterConj_ID;
      /// Option line_width&lt;double&gt;: Set relative line width used in gamma-ray spectra (default 0.03)
      const double line_width = runOptions-&gt;getValueOrDef&lt;double&gt;(0.03,  &quot;line_width&quot;);
      result = getYield(&quot;e-_1&quot;, true, DMid, DMbarid, *Dep::TH_ProcessCatalog, *Dep::electron_SimYieldTable,
                        line_width, *Dep::cascadeMC_electronSpectra);
    }

    /// \brief General routine to derive electron decay yield.
    /// This function returns
    ///   dN/dE*(Gamma)/mDM (E)  [1/s/GeV^2]
    /// the energy spectrum of electrons times Gamma/m, as function of energy (in GeV).
    void electron_DecayYield_General(daFunk::Funk &amp;result)
    {
      using namespace Pipes::electron_DecayYield_General;
      std::string DMid = *Dep::DarkMatter_ID;
      /// Option line_width&lt;double&gt;: Set relative line width used in gamma-ray spectra (default 0.03)
      const double line_width = runOptions-&gt;getValueOrDef&lt;double&gt;(0.03,  &quot;line_width&quot;);
      result = getYield(&quot;e-_1&quot;, false, DMid, &quot;null&quot;, *Dep::TH_ProcessCatalog, *Dep::electron_SimYieldTable,
                        line_width, *Dep::cascadeMC_electronSpectra);
    }

    /// \brief General routine to derive positron annihilation yield.
    /// This function returns
    /// k*dN/dE*(sv)/mDM**2 (E, v)  [cm^3/s/GeV^3]
    /// the energy spectrum of positrons times sigma*v/m^2, as function of energy (in GeV)
    /// and velocity (as a fraction of c), multiplied by k=1 for self-conjugate DM or k=1/2
    /// for non-self conjugate.  By default, only the v=0 component is calculated.
    void positron_AnnYield_General(daFunk::Funk &amp;result)
    {
      using namespace Pipes::positron_AnnYield_General;
      std::string DMid= *Dep::DarkMatter_ID;
      std::string DMbarid = *Dep::DarkMatterConj_ID;
      /// Option line_width&lt;double&gt;: Set relative line width used in gamma-ray spectra (default 0.03)
      const double line_width = runOptions-&gt;getValueOrDef&lt;double&gt;(0.03,  &quot;line_width&quot;);
      result = getYield(&quot;e+_1&quot;, true, DMid, DMbarid, *Dep::TH_ProcessCatalog, *Dep::positron_SimYieldTable,
                        line_width, *Dep::cascadeMC_positronSpectra);
    }

    /// \brief General routine to derive positron decay yield.
    /// This function returns
    ///   dN/dE*(Gamma)/mDM (E)  [1/s/GeV^2]
    /// the energy spectrum of positrons times Gamma/m, as function of energy (in GeV).
    void positron_DecayYield_General(daFunk::Funk &amp;result)
    {
      using namespace Pipes::positron_DecayYield_General;
      std::string DMid = *Dep::DarkMatter_ID;
      /// Option line_width&lt;double&gt;: Set relative line width used in gamma-ray spectra (default 0.03)
      const double line_width = runOptions-&gt;getValueOrDef&lt;double&gt;(0.03,  &quot;line_width&quot;);
      result = getYield(&quot;e+_1&quot;, false, DMid, &quot;null&quot;, *Dep::TH_ProcessCatalog, *Dep::positron_SimYieldTable,
                        line_width, *Dep::cascadeMC_positronSpectra);
    }

    /// \brief General routine to derive antiproton annihilation yield.
    /// This function returns
    /// k*dN/dE*(sv)/mDM**2 (E, v)  [cm^3/s/GeV^3]
    /// the energy spectrum of antiprotons times sigma*v/m^2, as function of energy (in GeV)
    /// and velocity (as a fraction of c), multiplied by k=1 for self-conjugate DM or k=1/2
    /// for non-self conjugate.  By default, only the v=0 component is calculated.
    void antiproton_AnnYield_General(daFunk::Funk &amp;result)
    {
      using namespace Pipes::antiproton_AnnYield_General;
      std::string DMid= *Dep::DarkMatter_ID;
      std::string DMbarid = *Dep::DarkMatterConj_ID;
      /// Option line_width&lt;double&gt;: Set relative line width used in gamma-ray spectra (default 0.03)
      const double line_width = runOptions-&gt;getValueOrDef&lt;double&gt;(0.03,  &quot;line_width&quot;);
      result = getYield(&quot;pbar&quot;, true, DMid, DMbarid, *Dep::TH_ProcessCatalog, *Dep::antiproton_SimYieldTable,
                        line_width, *Dep::cascadeMC_antiprotonSpectra);
    }

    /// \brief General routine to derive antiproton decay yield.
    /// This function returns
    ///   dN/dE*(Gamma)/mDM (E)  [1/s/GeV^2]
    /// the energy spectrum of antiprotons times Gamma/m, as function of energy (in GeV).
    void antiproton_DecayYield_General(daFunk::Funk &amp;result)
    {
      using namespace Pipes::antiproton_DecayYield_General;
      std::string DMid = *Dep::DarkMatter_ID;
      /// Option line_width&lt;double&gt;: Set relative line width used in gamma-ray spectra (default 0.03)
      const double line_width = runOptions-&gt;getValueOrDef&lt;double&gt;(0.03,  &quot;line_width&quot;);
      result = getYield(&quot;pbar&quot;, false, DMid, &quot;null&quot;, *Dep::TH_ProcessCatalog, *Dep::antiproton_SimYieldTable,
                        line_width, *Dep::cascadeMC_antiprotonSpectra);
    }

    /// \brief General routine to derive antideuteron annihilation yield.
    /// This function returns
    /// k*dN/dE*(sv)/mDM**2 (E, v)  [cm^3/s/GeV^3]
    /// the energy spectrum of antideuterons times sigma*v/m^2, as function of energy (in GeV)
    /// and velocity (as a fraction of c), multiplied by k=1 for self-conjugate DM or k=1/2
    /// for non-self conjugate.  By default, only the v=0 component is calculated.
    void antideuteron_AnnYield_General(daFunk::Funk &amp;result)
    {
      using namespace Pipes::antideuteron_AnnYield_General;
      std::string DMid= *Dep::DarkMatter_ID;
      std::string DMbarid = *Dep::DarkMatterConj_ID;
      /// Option line_width&lt;double&gt;: Set relative line width used in gamma-ray spectra (default 0.03)
      const double line_width = runOptions-&gt;getValueOrDef&lt;double&gt;(0.03,  &quot;line_width&quot;);
      result = getYield(&quot;Dbar&quot;, true, DMid, DMbarid, *Dep::TH_ProcessCatalog, *Dep::antideuteron_SimYieldTable,
                        line_width, *Dep::cascadeMC_antideuteronSpectra);
    }

    /// \brief General routine to derive antideuteron decay yield.
    /// This function returns
    ///   dN/dE*(Gamma)/mDM (E)  [1/s/GeV^2]
    /// the energy spectrum of antideuterons times Gamma/m, as function of energy (in GeV).
    void antideuteron_DecayYield_General(daFunk::Funk &amp;result)
    {
      using namespace Pipes::antideuteron_DecayYield_General;
      std::string DMid = *Dep::DarkMatter_ID;
      /// Option line_width&lt;double&gt;: Set relative line width used in gamma-ray spectra (default 0.03)
      const double line_width = runOptions-&gt;getValueOrDef&lt;double&gt;(0.03,  &quot;line_width&quot;);
      result = getYield(&quot;Dbar&quot;, false, DMid, &quot;null&quot;, *Dep::TH_ProcessCatalog, *Dep::antideuteron_SimYieldTable,
                        line_width, *Dep::cascadeMC_antideuteronSpectra);
    }


    // SimYields =======================================================


    /// Combined SimYieldTable containing final yields of all stable particles
    void Combine_SimYields(SimYieldTable&amp; result)
    {
      using namespace Pipes::Combine_SimYields;
      static bool initialized = false;
      if ( not initialized )
      {
        if (Downstream::neededFor(&quot;cascadeMC_gammaSpectra&quot;)) Dep::GA_SimYieldTable-&gt;donateChannels(result);
        if (Downstream::neededFor(&quot;cascadeMC_electronSpectra&quot;)) Dep::positron_SimYieldTable-&gt;donateChannels(result);
        if (Downstream::neededFor(&quot;cascadeMC_positronSpectra&quot;)) Dep::electron_SimYieldTable-&gt;donateChannels(result);
        if (Downstream::neededFor(&quot;cascadeMC_antiprotonSpectra&quot;)) Dep::antiproton_SimYieldTable-&gt;donateChannels(result);
        if (Downstream::neededFor(&quot;cascadeMC_antideuteronSpectra&quot;)) Dep::antideuteron_SimYieldTable-&gt;donateChannels(result);
        initialized = true;
      }
    }

    /// Gamma-ray SimYieldTable based on DarkSUSY5 tabulated results. (DS6 below)
    void GA_SimYieldTable_DS5(SimYieldTable&amp; result)
    {
      using namespace Pipes::GA_SimYieldTable_DS5;

      static bool initialized = false;
      if ( not initialized )
      {
        int flag = 0;      // some flag
        int yieldk = 152;  // gamma ray yield

        using DarkBit_utils::str_flav_to_mass;

        double mDM_min, mDM_max;
        /// Option allow_yield_extrapolation&lt;bool&gt;: Spectra extrapolated for masses beyond Pythia results (default false)
        bool allow_yield_extrapolation = runOptions-&gt;getValueOrDef(false, &quot;allow_yield_extrapolation&quot;);
        if ( allow_yield_extrapolation )
        {
          mDM_min = 0.0; // in this case, the minimally allowed dark matter mass will later be set to be the mass of the final state particle,
                         // with an additional factor 0.99 for the case of Z, W or t final states (following DarkSUSY)
          mDM_max = 1.0e6;
        }
        else
        {
          mDM_min = 10.0; // minimal dark matter mass simulated in DarkSUSY.
          mDM_max = 5000.; // maximal dark matter mass simulated in DarkSUSY.
        }

        auto add_channel = [&amp;](int ch, str P1, str P2, str FINAL, double EcmMin, double EcmMax)
        {
          daFunk::Funk dNdE = daFunk::func_fromThreadsafe(BEreq::dshayield.pointer(), daFunk::var(&quot;mwimp&quot;),
           daFunk::var(&quot;Ekin&quot;), ch, yieldk, flag)-&gt;set(&quot;mwimp&quot;, daFunk::var(&quot;Ecm&quot;)/2);
          result.addChannel(dNdE, str_flav_to_mass(P1), str_flav_to_mass(P2), FINAL, EcmMin, EcmMax, runOptions);
        };

        // The following routine adds an annihilation channel, for which the yields are extrapolated below Ecm_ToScale
        // using the approximation that x*dN/dx is a constant function of the dark matter mass.
        auto add_channel_with_scaling = [&amp;](int ch, str P1, str P2, str FINAL, double EcmMin, double EcmMax, double Ecm_ToScale)
        {
          daFunk::Funk Ecm_ToUse = fmax(Ecm_ToScale, daFunk::var(&quot;Ecm&quot;));
          daFunk::Funk ScalingFactor = Ecm_ToUse/daFunk::var(&quot;Ecm&quot;);
          daFunk::Funk dNdE = ScalingFactor * daFunk::func_fromThreadsafe(BEreq::dshayield.pointer(), daFunk::var(&quot;mwimp&quot;),
           ScalingFactor * daFunk::var(&quot;Ekin&quot;), ch, yieldk, flag)-&gt;set(&quot;mwimp&quot;, Ecm_ToUse/2);
          result.addChannel(dNdE, str_flav_to_mass(P1), str_flav_to_mass(P2), FINAL, EcmMin, EcmMax, runOptions);
        };

        // Specifies also center of mass energy range
        add_channel(12, &quot;Z0&quot;, &quot;Z0&quot;, &quot;gamma&quot;, 2*90.288, 2*mDM_max);
        add_channel(13, &quot;W+&quot;, &quot;W-&quot;, &quot;gamma&quot;, 2*79.4475, 2*mDM_max);
        add_channel(14, &quot;nu_e&quot;, &quot;nubar_e&quot;, &quot;gamma&quot;, 2*std::max(mDM_min, 0.0), 2*mDM_max);  // Zero
        add_channel(15, &quot;e+&quot;, &quot;e-&quot;, &quot;gamma&quot;, 2*std::max(mDM_min, 0.0), 2*mDM_max);  // Zero
        add_channel(16, &quot;nu_mu&quot;, &quot;nubar_mu&quot;, &quot;gamma&quot;, 2*std::max(mDM_min, 0.0), 2*mDM_max);  // Zero
        add_channel(17, &quot;mu+&quot;, &quot;mu-&quot;, &quot;gamma&quot;, 2*std::max(mDM_min, 0.0), 2*mDM_max);
        add_channel(18, &quot;nu_tau&quot;, &quot;nubar_tau&quot;, &quot;gamma&quot;, 2*std::max(mDM_min, 0.0), 2*mDM_max);  // Zero
        add_channel(19, &quot;tau+&quot;, &quot;tau-&quot;, &quot;gamma&quot;, 2*std::max(mDM_min, 1.7841), 2*mDM_max);
        //add_channel(20, &quot;u&quot;, &quot;ubar&quot;, &quot;gamma&quot;, 0., 2*mDM_max);  // Zero
        add_channel(22, &quot;u&quot;, &quot;ubar&quot;, &quot;gamma&quot;, 2*std::max(mDM_min, 1.35), 2*mDM_max);  // approx by cc
        //add_channel(21, &quot;d&quot;, &quot;dbar&quot;, &quot;gamma&quot;, 0., 2*mDM_max);  // Zero
        add_channel(22, &quot;d&quot;, &quot;dbar&quot;, &quot;gamma&quot;, 2*std::max(mDM_min, 1.35), 2*mDM_max);  // approx by cc
        add_channel(22, &quot;c&quot;, &quot;cbar&quot;, &quot;gamma&quot;, 2*std::max(mDM_min, 1.35), 2*mDM_max);
        //add_channel(23, &quot;s&quot;, &quot;sbar&quot;, &quot;gamma&quot;, 0., 2*mDM_max);  // Zero
        add_channel(22, &quot;s&quot;, &quot;sbar&quot;, &quot;gamma&quot;, 2*std::max(mDM_min, 1.35), 2*mDM_max);  // approx by cc
        add_channel_with_scaling(24, &quot;t&quot;, &quot;tbar&quot;, &quot;gamma&quot;, 2*160.0, 2*mDM_max, 2*173.3);
        add_channel(25, &quot;b&quot;, &quot;bbar&quot;, &quot;gamma&quot;, 2*std::max(mDM_min, 5.0), 2*mDM_max);
        add_channel(26, &quot;g&quot;, &quot;g&quot;, &quot;gamma&quot;, 2*std::max(mDM_min, 0.0), 2*mDM_max);

        // Add approximations for single-particle cases.
        // TODO: Replace by boosted rest frame spectrum Z0
        daFunk::Funk dNdE;
        dNdE = daFunk::func_fromThreadsafe(BEreq::dshayield.pointer(), daFunk::var(&quot;Ecm&quot;), daFunk::var(&quot;Ekin&quot;), 12, yieldk, flag);
        result.addChannel(dNdE/2, &quot;Z0&quot;, &quot;gamma&quot;, 90.288, mDM_max, runOptions);
        dNdE = daFunk::func_fromThreadsafe(BEreq::dshayield.pointer(), daFunk::var(&quot;Ecm&quot;), daFunk::var(&quot;Ekin&quot;), 13, yieldk, flag);
        result.addChannel(dNdE/2, &quot;W+&quot;, &quot;gamma&quot;, 79.4475, mDM_max, runOptions);
        result.addChannel(dNdE/2, &quot;W-&quot;, &quot;gamma&quot;, 79.4475, mDM_max, runOptions);
        dNdE = daFunk::func_fromThreadsafe(BEreq::dshayield.pointer(), daFunk::var(&quot;Ecm&quot;), daFunk::var(&quot;Ekin&quot;), 15, yieldk, flag);
        result.addChannel(dNdE/2, str_flav_to_mass(&quot;e+&quot;), &quot;gamma&quot;, std::max(mDM_min, 0.0), mDM_max, runOptions);
        result.addChannel(dNdE/2, str_flav_to_mass(&quot;e-&quot;), &quot;gamma&quot;, std::max(mDM_min, 0.0), mDM_max, runOptions);
        dNdE = daFunk::func_fromThreadsafe(BEreq::dshayield.pointer(), daFunk::var(&quot;Ecm&quot;), daFunk::var(&quot;Ekin&quot;), 17, yieldk, flag);
        result.addChannel(dNdE/2, str_flav_to_mass(&quot;mu+&quot;), &quot;gamma&quot;, std::max(mDM_min, 0.0), mDM_max, runOptions);
        result.addChannel(dNdE/2, str_flav_to_mass(&quot;mu-&quot;), &quot;gamma&quot;, std::max(mDM_min, 0.0), mDM_max, runOptions);
        dNdE = daFunk::func_fromThreadsafe(BEreq::dshayield.pointer(), daFunk::var(&quot;Ecm&quot;), daFunk::var(&quot;Ekin&quot;), 19, yieldk, flag);
        result.addChannel(dNdE/2, str_flav_to_mass(&quot;tau+&quot;), &quot;gamma&quot;, std::max(mDM_min, 1.7841), mDM_max, runOptions);
        result.addChannel(dNdE/2, str_flav_to_mass(&quot;tau-&quot;), &quot;gamma&quot;, std::max(mDM_min, 1.7841), mDM_max, runOptions);

        double Ecm_ToScale_top = 173.3;
        daFunk::Funk Ecm_ToUse_top = fmax(Ecm_ToScale_top, daFunk::var(&quot;Ecm&quot;));
        daFunk::Funk ScalingFactor_top = Ecm_ToUse_top/daFunk::var(&quot;Ecm&quot;);
        dNdE = ScalingFactor_top * daFunk::func_fromThreadsafe(BEreq::dshayield.pointer(), Ecm_ToUse_top,
         ScalingFactor_top * daFunk::var(&quot;Ekin&quot;), 24, yieldk, flag);
        result.addChannel(dNdE/2, str_flav_to_mass(&quot;t&quot;), &quot;gamma&quot;, 160.0, mDM_max, runOptions);
        result.addChannel(dNdE/2, str_flav_to_mass(&quot;tbar&quot;), &quot;gamma&quot;, 160.0, mDM_max, runOptions);

        // add channels with &quot;mixed final states&quot;, i.e. final state particles with (potentially) different masses
        daFunk::Funk Ecm = daFunk::var(&quot;Ecm&quot;);
        auto add_channel_mixedmasses = [&amp;](int ch1, int ch2, str P1, str P2, str FINAL, double m1, double m2, double EcmMin, double EcmMax)
        {
          daFunk::Funk dNdE_1 = daFunk::func_fromThreadsafe(BEreq::dshayield.pointer(), daFunk::var(&quot;E1&quot;),
           daFunk::var(&quot;Ekin&quot;), ch1, yieldk, flag)-&gt;set(&quot;E1&quot;, Ecm/2 + (m1*m1 - m2*m2)/(2*Ecm));
          daFunk::Funk dNdE_2 = daFunk::func_fromThreadsafe(BEreq::dshayield.pointer(), daFunk::var(&quot;E2&quot;),
           daFunk::var(&quot;Ekin&quot;), ch2, yieldk, flag)-&gt;set(&quot;E2&quot;, Ecm/2 + (m2*m2 - m1*m1)/(2*Ecm));
          result.addChannel(0.5*(dNdE_1 + dNdE_2), str_flav_to_mass(P1), str_flav_to_mass(P2), FINAL, EcmMin, EcmMax, runOptions);
        };

        // - In the following: approximate spectra from u,d,s (20,21,23) by spectrum from c (22).
        // - The numerical values for EcmMin and EcmMax are obtained from applying the corresponding two-body kinematics
        //   to the minimally/maximally allowed center-of-mass energies. Hence, EcmMin depends on the flag allow_yield_extrapolation.
        //   If it is false, the assigmnents of Ecm_min assume the value mDM_min = 10.0.

        add_channel_mixedmasses(22, 22, &quot;u&quot;, &quot;dbar&quot;, &quot;gamma&quot;, 0.0, 0.0, (allow_yield_extrapolation ? 2*1.35 : 20.0), 2*mDM_max);
        add_channel_mixedmasses(22, 22, &quot;d&quot;, &quot;ubar&quot;, &quot;gamma&quot;, 0.0, 0.0, (allow_yield_extrapolation ? 2*1.35 : 20.0), 2*mDM_max);
        add_channel_mixedmasses(22, 22, &quot;u&quot;, &quot;sbar&quot;, &quot;gamma&quot;, 0.0, 0.0, (allow_yield_extrapolation ? 2*1.35 : 20.0), 2*mDM_max);
        add_channel_mixedmasses(22, 22, &quot;s&quot;, &quot;ubar&quot;, &quot;gamma&quot;, 0.0, 0.0, (allow_yield_extrapolation ? 2*1.35 : 20.0), 2*mDM_max);
        add_channel_mixedmasses(22, 25, &quot;u&quot;, &quot;bbar&quot;, &quot;gamma&quot;, 0.0, 5.0, (allow_yield_extrapolation ? 6.530 : 21.181), 2*mDM_max);
        add_channel_mixedmasses(25, 22, &quot;b&quot;, &quot;ubar&quot;, &quot;gamma&quot;, 5.0, 0.0, (allow_yield_extrapolation ? 6.530 : 21.181), 2*mDM_max);

        add_channel_mixedmasses(22, 22, &quot;c&quot;, &quot;dbar&quot;, &quot;gamma&quot;, 1.35, 0.0, (allow_yield_extrapolation ? 3.260 : 20.091), 2*mDM_max);
        add_channel_mixedmasses(22, 22, &quot;d&quot;, &quot;cbar&quot;, &quot;gamma&quot;, 0.0, 1.35, (allow_yield_extrapolation ? 3.260 : 20.091), 2*mDM_max);
        add_channel_mixedmasses(22, 22, &quot;c&quot;, &quot;sbar&quot;, &quot;gamma&quot;, 1.35, 0.0, (allow_yield_extrapolation ? 3.260 : 20.091), 2*mDM_max);
        add_channel_mixedmasses(22, 22, &quot;s&quot;, &quot;cbar&quot;, &quot;gamma&quot;, 0.0, 1.35, (allow_yield_extrapolation ? 3.260 : 20.091), 2*mDM_max);
        add_channel_mixedmasses(22, 25, &quot;c&quot;, &quot;bbar&quot;, &quot;gamma&quot;, 1.35, 5.0, (allow_yield_extrapolation ? 6.35 : 21.099), 2*mDM_max);
        add_channel_mixedmasses(25, 22, &quot;b&quot;, &quot;cbar&quot;, &quot;gamma&quot;, 5.0, 1.35, (allow_yield_extrapolation ? 6.35 : 21.099), 2*mDM_max);

        add_channel_mixedmasses(24, 22, &quot;t&quot;, &quot;dbar&quot;, &quot;gamma&quot;, 175.0, 0.0, (allow_yield_extrapolation ? 176.355 : 185.285), 2*mDM_max);
        add_channel_mixedmasses(22, 24, &quot;d&quot;, &quot;tbar&quot;, &quot;gamma&quot;, 0.0, 175.0, (allow_yield_extrapolation ? 176.355 : 185.285), 2*mDM_max);
        add_channel_mixedmasses(24, 22, &quot;t&quot;, &quot;sbar&quot;, &quot;gamma&quot;, 175.0, 0.0, (allow_yield_extrapolation ? 176.355 : 185.285), 2*mDM_max);
        add_channel_mixedmasses(22, 24, &quot;s&quot;, &quot;tbar&quot;, &quot;gamma&quot;, 0.0, 175.0, (allow_yield_extrapolation ? 176.355 : 185.285), 2*mDM_max);
        add_channel_mixedmasses(24, 25, &quot;t&quot;, &quot;bbar&quot;, &quot;gamma&quot;, 175.0, 5.0, (allow_yield_extrapolation ? 180.0 : 185.214), 2*mDM_max);
        add_channel_mixedmasses(25, 24, &quot;b&quot;, &quot;tbar&quot;, &quot;gamma&quot;, 5.0, 175.0, (allow_yield_extrapolation ? 180.0 : 185.214), 2*mDM_max);

        initialized = true;
      }
    }

    /// Construct a SimYieldTable based on DarkSUSY6 tabulated results.
    SimYieldTable SimYieldTable_DarkSUSY(const str&amp; yield, const bool allow_yield_extrapolation, double(*dsanyield)(double&amp;,double&amp;,int&amp;,char*,int&amp;,int&amp;,int&amp;), safe_ptr&lt;Options&gt; runOptions)
    {
      using DarkBit_utils::str_flav_to_mass;

      const int flag = 0;            // some flag
      const int diff=1;              // differential yields (=1)
      char*hel =  (char *)&quot;0&quot;;       // helicity

      int yieldpdg;                  // PDG code of final state
      double mDM_min, mDM_max;       // Boundaries of tabulation
      SimYieldTable result;          // The table itself

      // Determine PDG code of the particle for which the yield has been requested
      if (yield == &quot;gamma&quot;)
        yieldpdg =  22;
      else if (yield == &quot;e+_1&quot;)
        yieldpdg = -11;
      else if (yield == &quot;pbar&quot;)
        yieldpdg = -2212;
      else if (yield == &quot;Dbar&quot;)
        yieldpdg = -1000010020;
      else if (yield == &quot;pi0&quot;)
        yieldpdg = 111;
      else if (yield == &quot;nu_e + nu_ebar&quot;)
        yieldpdg = 12;
      else if (yield == &quot;nu_mu + nu_mubar&quot;)
        yieldpdg = 14;
      else if (yield == &quot;nu_tau + nu_taubar&quot;)
        yieldpdg = 16;
      else
        DarkBit_error().raise(LOCAL_INFO, &quot;SimYieldTable_DarkSUSY called with unrecognised final state &quot; + yield);

      if ( allow_yield_extrapolation )
      {
        mDM_min = 0.0; // in this case, the minimally allowed dark matter mass will later be set to be the mass of the final state particle,
                       // with an additional factor 0.99 for the case of Z, W or t final states (following DarkSUSY)
        mDM_max = 1.0e6;
      }
      else
      {
        mDM_min = 3.0; // minimal dark matter mass simulated in DarkSUSY6.
        mDM_max = 20000.; // maximal dark matter mass simulated in DarkSUSY6.
      }

      auto add_channel = [&amp;](int pdg, str p1, str p2, double EcmMin, double EcmMax)
      {
        daFunk::Funk dNdE = daFunk::func_fromThreadsafe(dsanyield, daFunk::var(&quot;mwimp&quot;),
         daFunk::var(&quot;Ekin&quot;), pdg, hel, yieldpdg, diff, flag)-&gt;set(&quot;mwimp&quot;, daFunk::var(&quot;Ecm&quot;)/2);
        result.addChannel(dNdE, str_flav_to_mass(p1), str_flav_to_mass(p2), yield, EcmMin, EcmMax, runOptions);
      };

      // The following routine adds an annihilation/decay channel, for which the yields are extrapolated below Ecm_ToScale
      // using the approximation that x*dN/dx is a constant function of the dark matter mass.
      auto add_channel_with_scaling = [&amp;](int pdg, str P1, str P2, double EcmMin, double EcmMax, double Ecm_ToScale)
      {
        daFunk::Funk Ecm_ToUse = fmax(Ecm_ToScale, daFunk::var(&quot;Ecm&quot;));
        daFunk::Funk ScalingFactor = Ecm_ToUse/daFunk::var(&quot;Ecm&quot;);
        daFunk::Funk dNdE = ScalingFactor * daFunk::func_fromThreadsafe(dsanyield, daFunk::var(&quot;mwimp&quot;),
         ScalingFactor * daFunk::var(&quot;Ekin&quot;), pdg, hel, yieldpdg, diff, flag)-&gt;set(&quot;mwimp&quot;, Ecm_ToUse/2);
        result.addChannel(dNdE, str_flav_to_mass(P1), str_flav_to_mass(P2), yield, EcmMin, EcmMax, runOptions);
      };

      // specifies also center of mass energy range
      add_channel(23, &quot;Z0&quot;, &quot;Z0&quot;, 2*90.288, 2*mDM_max);
      add_channel(24, &quot;W+&quot;, &quot;W-&quot;, 2*79.4475, 2*mDM_max);
      add_channel(12, &quot;nu_e&quot;, &quot;nubar_e&quot;, 2*std::max(mDM_min, 0.0), 2*mDM_max);  // Zero
      add_channel(11, &quot;e+&quot;, &quot;e-&quot;, 2*std::max(mDM_min, 0.0), 2*mDM_max);  // Zero
      add_channel(14, &quot;nu_mu&quot;, &quot;nubar_mu&quot;, 2*std::max(mDM_min, 0.0), 2*mDM_max);  // Zero
      add_channel(13, &quot;mu+&quot;, &quot;mu-&quot;, 2*std::max(mDM_min, 0.0), 2*mDM_max);
      add_channel(16, &quot;nu_tau&quot;, &quot;nubar_tau&quot;, 2*std::max(mDM_min, 0.0), 2*mDM_max);  // Zero
      add_channel(15, &quot;tau+&quot;, &quot;tau-&quot;, 2*std::max(mDM_min, 1.7841), 2*mDM_max);
      //add_channel(2, &quot;u&quot;, &quot;ubar&quot;, 0., 2*mDM_max);  // Zero
      add_channel(2, &quot;u&quot;, &quot;ubar&quot;, 2*std::max(mDM_min, 1.35), 2*mDM_max);  // approx by cc
      //add_channel(1, &quot;d&quot;, &quot;dbar&quot;, 0., 2*mDM_max);  // Zero
      add_channel(1, &quot;d&quot;, &quot;dbar&quot;, 2*std::max(mDM_min, 1.35), 2*mDM_max);  // approx by cc
      add_channel(4, &quot;c&quot;, &quot;cbar&quot;, 2*std::max(mDM_min, 1.35), 2*mDM_max);
      //add_channel(3, &quot;s&quot;, &quot;sbar&quot;, 0., 2*mDM_max);  // Zero
      add_channel(3, &quot;s&quot;, &quot;sbar&quot;, 2*std::max(mDM_min, 1.35), 2*mDM_max);  // approx by cc
      add_channel_with_scaling(6, &quot;t&quot;, &quot;tbar&quot;, 2*160.0, 2*mDM_max, 2*173.3);
      add_channel(5, &quot;b&quot;, &quot;bbar&quot;, 2*std::max(mDM_min, 5.0), 2*mDM_max);
      add_channel(21, &quot;g&quot;, &quot;g&quot;, 2*std::max(mDM_min, 0.0), 2*mDM_max);

      // Add approximations for single-particle cases.
      // TODO: Replace by boosted rest frame spectrum Z0
      daFunk::Funk dNdE;
      dNdE = daFunk::func_fromThreadsafe(dsanyield, daFunk::var(&quot;Ecm&quot;), daFunk::var(&quot;Ekin&quot;), 23, hel,yieldpdg, diff,flag);
      result.addChannel(dNdE/2, &quot;Z0&quot;, yield, 90.288, mDM_max, runOptions);
      dNdE = daFunk::func_fromThreadsafe(dsanyield, daFunk::var(&quot;Ecm&quot;), daFunk::var(&quot;Ekin&quot;), 24, hel,yieldpdg, diff, flag);
      result.addChannel(dNdE/2, &quot;W+&quot;, yield, 79.4475, mDM_max, runOptions);
      result.addChannel(dNdE/2, &quot;W-&quot;, yield, 79.4475, mDM_max, runOptions);
      dNdE = daFunk::func_fromThreadsafe(dsanyield, daFunk::var(&quot;Ecm&quot;), daFunk::var(&quot;Ekin&quot;), 11, hel, yieldpdg, diff, flag);
      result.addChannel(dNdE/2, str_flav_to_mass(&quot;e+&quot;), yield, std::max(mDM_min, 0.0), mDM_max, runOptions);
      result.addChannel(dNdE/2, str_flav_to_mass(&quot;e-&quot;), yield, std::max(mDM_min, 0.0), mDM_max, runOptions);
      dNdE = daFunk::func_fromThreadsafe(dsanyield, daFunk::var(&quot;Ecm&quot;), daFunk::var(&quot;Ekin&quot;), 13, hel, yieldpdg, diff, flag);
      result.addChannel(dNdE/2, str_flav_to_mass(&quot;mu+&quot;), yield, std::max(mDM_min, 0.0), mDM_max, runOptions);
      result.addChannel(dNdE/2, str_flav_to_mass(&quot;mu-&quot;), yield, std::max(mDM_min, 0.0), mDM_max, runOptions);
      dNdE = daFunk::func_fromThreadsafe(dsanyield, daFunk::var(&quot;Ecm&quot;), daFunk::var(&quot;Ekin&quot;), 15, hel, yieldpdg, diff, flag);
      result.addChannel(dNdE/2, str_flav_to_mass(&quot;tau+&quot;), yield, std::max(mDM_min, 1.7841), mDM_max, runOptions);
      result.addChannel(dNdE/2, str_flav_to_mass(&quot;tau-&quot;), yield, std::max(mDM_min, 1.7841), mDM_max, runOptions);

      double Ecm_ToScale_top = 173.3;
      daFunk::Funk Ecm_ToUse_top = fmax(Ecm_ToScale_top, daFunk::var(&quot;Ecm&quot;));
      daFunk::Funk ScalingFactor_top = Ecm_ToUse_top/daFunk::var(&quot;Ecm&quot;);
      dNdE = ScalingFactor_top * daFunk::func_fromThreadsafe(dsanyield, Ecm_ToUse_top,
       ScalingFactor_top * daFunk::var(&quot;Ekin&quot;), 6, hel, yieldpdg, diff, flag);
      result.addChannel(dNdE/2, str_flav_to_mass(&quot;t&quot;), yield, 160.0, mDM_max, runOptions);
      result.addChannel(dNdE/2, str_flav_to_mass(&quot;tbar&quot;), yield, 160.0, mDM_max, runOptions);

      // Add channels with &quot;mixed final states&quot;, i.e. final state particles with (potentially) different masses
      daFunk::Funk Ecm = daFunk::var(&quot;Ecm&quot;);
      auto add_channel_mixedmasses = [&amp;](int pdg1, int pdg2, str P1, str P2, double m1, double m2, double EcmMin, double EcmMax)
      {
        daFunk::Funk dNdE_1 = daFunk::func_fromThreadsafe(dsanyield, daFunk::var(&quot;E1&quot;),
         daFunk::var(&quot;Ekin&quot;), pdg1, hel, yieldpdg, diff, flag)-&gt;set(&quot;E1&quot;, Ecm/2 + (m1*m1 - m2*m2)/(2*Ecm));
        daFunk::Funk dNdE_2 = daFunk::func_fromThreadsafe(dsanyield, daFunk::var(&quot;E2&quot;),
         daFunk::var(&quot;Ekin&quot;), pdg2, hel, yieldpdg, diff, flag)-&gt;set(&quot;E2&quot;, Ecm/2 + (m2*m2 - m1*m1)/(2*Ecm));
        result.addChannel(0.5*(dNdE_1 + dNdE_2), str_flav_to_mass(P1), str_flav_to_mass(P2), yield, EcmMin, EcmMax, runOptions);
      };

      // - The numerical values for EcmMin and EcmMax are obtained from applying the corresponding two-body kinematics
      //   to the minimally/maximally allowed center-of-mass energies. Hence, EcmMin depends on the flag allow_yield_extrapolation.

      add_channel_mixedmasses(2, -1, &quot;u&quot;, &quot;dbar&quot;, 0.0, 0.0, (allow_yield_extrapolation ? 2*1.35 : 20.0), 2*mDM_max);
      add_channel_mixedmasses(1, -2, &quot;d&quot;, &quot;ubar&quot;, 0.0, 0.0, (allow_yield_extrapolation ? 2*1.35 : 20.0), 2*mDM_max);
      add_channel_mixedmasses(2, -3, &quot;u&quot;, &quot;sbar&quot;, 0.0, 0.0, (allow_yield_extrapolation ? 2*1.35 : 20.0), 2*mDM_max);
      add_channel_mixedmasses(3, -2, &quot;s&quot;, &quot;ubar&quot;, 0.0, 0.0, (allow_yield_extrapolation ? 2*1.35 : 20.0), 2*mDM_max);
      add_channel_mixedmasses(2, -5, &quot;u&quot;, &quot;bbar&quot;, 0.0, 5.0, (allow_yield_extrapolation ? 6.530 : 21.181), 2*mDM_max);
      add_channel_mixedmasses(5, -2, &quot;b&quot;, &quot;ubar&quot;, 5.0, 0.0, (allow_yield_extrapolation ? 6.530 : 21.181), 2*mDM_max);

      add_channel_mixedmasses(4, -1, &quot;c&quot;, &quot;dbar&quot;, 1.35, 0.0, (allow_yield_extrapolation ? 3.260 : 20.091), 2*mDM_max);
      add_channel_mixedmasses(1, -4, &quot;d&quot;, &quot;cbar&quot;, 0.0, 1.35, (allow_yield_extrapolation ? 3.260 : 20.091), 2*mDM_max);
      add_channel_mixedmasses(4, -3, &quot;c&quot;, &quot;sbar&quot;, 1.35, 0.0, (allow_yield_extrapolation ? 3.260 : 20.091), 2*mDM_max);
      add_channel_mixedmasses(3, -4, &quot;s&quot;, &quot;cbar&quot;, 0.0, 1.35, (allow_yield_extrapolation ? 3.260 : 20.091), 2*mDM_max);
      add_channel_mixedmasses(4, -5, &quot;c&quot;, &quot;bbar&quot;, 1.35, 5.0, (allow_yield_extrapolation ? 6.35 : 21.099), 2*mDM_max);
      add_channel_mixedmasses(5, -4, &quot;b&quot;, &quot;cbar&quot;, 5.0, 1.35, (allow_yield_extrapolation ? 6.35 : 21.099), 2*mDM_max);

      add_channel_mixedmasses(6, -1, &quot;t&quot;, &quot;dbar&quot;, 175.0, 0.0, (allow_yield_extrapolation ? 176.355 : 185.285), 2*mDM_max);
      add_channel_mixedmasses(1, -6, &quot;d&quot;, &quot;tbar&quot;, 0.0, 175.0, (allow_yield_extrapolation ? 176.355 : 185.285), 2*mDM_max);
      add_channel_mixedmasses(6, -3, &quot;t&quot;, &quot;sbar&quot;, 175.0, 0.0, (allow_yield_extrapolation ? 176.355 : 185.285), 2*mDM_max);
      add_channel_mixedmasses(3, -6, &quot;s&quot;, &quot;tbar&quot;, 0.0, 175.0, (allow_yield_extrapolation ? 176.355 : 185.285), 2*mDM_max);
      add_channel_mixedmasses(6, -5, &quot;t&quot;, &quot;bbar&quot;, 175.0, 5.0, (allow_yield_extrapolation ? 180.0 : 185.214), 2*mDM_max);
      add_channel_mixedmasses(5, -6, &quot;b&quot;, &quot;tbar&quot;, 5.0, 175.0, (allow_yield_extrapolation ? 180.0 : 185.214), 2*mDM_max);

      return result;
    }

    /// Gamma-ray SimYieldTable based on DarkSUSY6 tabulated results.
    void GA_SimYieldTable_DarkSUSY(SimYieldTable&amp; result)
    {
      using namespace Pipes::GA_SimYieldTable_DarkSUSY;

      static bool initialized = false;
      if ( not initialized )
      {
        /// Option allow_yield_extrapolation&lt;bool&gt;: Spectra extrapolated for masses beyond Pythia results (default false)
        bool allow_yield_extrapolation = runOptions-&gt;getValueOrDef(false, &quot;allow_yield_extrapolation&quot;);
        result = SimYieldTable_DarkSUSY(&quot;gamma&quot;, allow_yield_extrapolation, BEreq::dsanyield_sim.pointer(), runOptions);
        initialized = true;
      }
    }

    /// Positron SimYieldTable based on DarkSUSY6 tabulated results.
    void positron_SimYieldTable_DarkSUSY(SimYieldTable&amp; result)
    {
      using namespace Pipes::positron_SimYieldTable_DarkSUSY;

      static bool initialized = false;
      if ( not initialized )
      {
        /// Option allow_yield_extrapolation&lt;bool&gt;: Spectra extrapolated for masses beyond Pythia results (default false)
        bool allow_yield_extrapolation = runOptions-&gt;getValueOrDef(false, &quot;allow_yield_extrapolation&quot;);
        result = SimYieldTable_DarkSUSY(&quot;e+_1&quot;, allow_yield_extrapolation, BEreq::dsanyield_sim.pointer(), runOptions);
        initialized = true;
      }
    }

    /// Anti-proton SimYieldTable based on DarkSUSY6 tabulated results.
    void antiproton_SimYieldTable_DarkSUSY(SimYieldTable&amp; result)
    {
      using namespace Pipes::antiproton_SimYieldTable_DarkSUSY;

      static bool initialized = false;
      if ( not initialized )
      {
        /// Option allow_yield_extrapolation&lt;bool&gt;: Spectra extrapolated for masses beyond Pythia results (default false)
        bool allow_yield_extrapolation = runOptions-&gt;getValueOrDef(false, &quot;allow_yield_extrapolation&quot;);
        result = SimYieldTable_DarkSUSY(&quot;pbar&quot;, allow_yield_extrapolation, BEreq::dsanyield_sim.pointer(), runOptions);
        initialized = true;
      }
    }

    /// Anti-deuteron SimYieldTable based on DarkSUSY6 tabulated results.
    void antideuteron_SimYieldTable_DarkSUSY(SimYieldTable&amp; result)
    {
      using namespace Pipes::antideuteron_SimYieldTable_DarkSUSY;

      static bool initialized = false;
      if ( not initialized )
      {
        /// Option allow_yield_extrapolation&lt;bool&gt;: Spectra extrapolated for masses beyond Pythia results (default false)
        bool allow_yield_extrapolation = runOptions-&gt;getValueOrDef(false, &quot;allow_yield_extrapolation&quot;);
        result = SimYieldTable_DarkSUSY(&quot;Dbar&quot;, allow_yield_extrapolation, BEreq::dsanyield_sim.pointer(), runOptions);
        initialized = true;
      }
    }

    /// Gamma-ray SimYieldTable based on MicrOmegas tabulated results.
    void GA_SimYieldTable_MicrOmegas(SimYieldTable&amp; result)
    {
      using namespace Pipes::GA_SimYieldTable_MicrOmegas;
      using DarkBit_utils::str_flav_to_mass;

      static bool initialized = false;
      const int outN = 0;  // gamma

      if ( not initialized )
      {
        double mDM_max;
        if ( runOptions-&gt;getValueOrDef(false, &quot;allow_yield_extrapolation&quot;) )
        {
          mDM_max = 1.0e6;
        }
        else
        {
          mDM_max = 5000.; // maximal dark matter mass simulated in micromegas.
        }

        auto add_channel = [&amp;](int inP, str P1, str P2, str FINAL, double EcmMin, double EcmMax)
        {
          daFunk::Funk dNdE = daFunk::func_fromThreadsafe(BEreq::dNdE.pointer(), daFunk::var(&quot;Ecm&quot;), daFunk::var(&quot;E&quot;), inP, outN)/daFunk::var(&quot;E&quot;);
          result.addChannel(dNdE, str_flav_to_mass(P1), str_flav_to_mass(P2), FINAL, EcmMin, EcmMax, runOptions);  // specifies also center of mass energy range
        };

        // The following routine adds an annihilation channel, for which the yields are extrapolated below Ecm_ToScale
        // using the approximation that x*dN/dx is a constant function of the dark matter mass.
        auto add_channel_with_scaling = [&amp;](int inP, str P1, str P2, str FINAL, double EcmMin, double EcmMax, double Ecm_ToScale)
        {
          daFunk::Funk Ecm_ToUse = fmax(Ecm_ToScale, daFunk::var(&quot;Ecm&quot;));
          daFunk::Funk ScalingFactor = Ecm_ToUse/daFunk::var(&quot;Ecm&quot;);
          daFunk::Funk dNdE = ScalingFactor * daFunk::func_fromThreadsafe(BEreq::dNdE.pointer(), Ecm_ToUse,
           ScalingFactor * daFunk::var(&quot;E&quot;), inP, outN)/(ScalingFactor * daFunk::var(&quot;E&quot;));
          result.addChannel(dNdE, str_flav_to_mass(P1), str_flav_to_mass(P2), FINAL, EcmMin, EcmMax, runOptions);
        };

        add_channel(0, &quot;g&quot;, &quot;g&quot;, &quot;gamma&quot;, 2*2., 2*mDM_max);
        add_channel(1, &quot;d&quot;, &quot;dbar&quot;, &quot;gamma&quot;, 2*2., 2*mDM_max);
        add_channel(2, &quot;u&quot;, &quot;ubar&quot;, &quot;gamma&quot;, 2*2., 2*mDM_max);
        add_channel(3, &quot;s&quot;, &quot;sbar&quot;, &quot;gamma&quot;, 2*2., 2*mDM_max);
        add_channel(4, &quot;c&quot;, &quot;cbar&quot;, &quot;gamma&quot;, 2*2., 2*mDM_max);
        add_channel(5, &quot;b&quot;, &quot;bbar&quot;, &quot;gamma&quot;, 2*5., 2*mDM_max);
        add_channel_with_scaling(6, &quot;t&quot;, &quot;tbar&quot;, &quot;gamma&quot;, 2*160.0, 2*mDM_max, 2.0*176.0);
        add_channel(7, &quot;e+&quot;, &quot;e-&quot;, &quot;gamma&quot;, 2*2., 2*mDM_max);
        add_channel(8, &quot;mu+&quot;, &quot;mu-&quot;, &quot;gamma&quot;, 2*2., 2*mDM_max);
        add_channel(9, &quot;tau+&quot;, &quot;tau-&quot;, &quot;gamma&quot;, 2*2., 2*mDM_max);
        add_channel(10, &quot;Z0&quot;, &quot;Z0&quot;, &quot;gamma&quot;, 2*90.288, 2*mDM_max);
        add_channel(13, &quot;W+&quot;, &quot;W-&quot;, &quot;gamma&quot;, 2*79.497, 2*mDM_max);

        result.addChannel(daFunk::zero(&quot;Ecm&quot;, &quot;E&quot;), &quot;nu_e&quot;, &quot;nubar_e&quot;, &quot;gamma&quot;, 2*2., 2*mDM_max, runOptions);
        result.addChannel(daFunk::zero(&quot;Ecm&quot;, &quot;E&quot;), &quot;nu_mu&quot;, &quot;nubar_mu&quot;, &quot;gamma&quot;, 2*2., 2*mDM_max, runOptions);
        result.addChannel(daFunk::zero(&quot;Ecm&quot;, &quot;E&quot;), &quot;nu_tau&quot;, &quot;nubar_tau&quot;, &quot;gamma&quot;, 2*2., 2*mDM_max, runOptions);

        // Add approximations for single-particle cases.
        daFunk::Funk dNdE;
        dNdE = (daFunk::func_fromThreadsafe(BEreq::dNdE.pointer(), daFunk::var(&quot;_Ecm&quot;), daFunk::var(&quot;E&quot;), 8, outN)
               /daFunk::var(&quot;E&quot;))-&gt;set(&quot;_Ecm&quot;, daFunk::var(&quot;Ecm&quot;)*2);
        result.addChannel(dNdE/2, str_flav_to_mass(&quot;mu+&quot;), &quot;gamma&quot;, 2., mDM_max, runOptions);
        result.addChannel(dNdE/2, str_flav_to_mass(&quot;mu-&quot;), &quot;gamma&quot;, 2., mDM_max, runOptions);
        dNdE = (daFunk::func_fromThreadsafe(BEreq::dNdE.pointer(), daFunk::var(&quot;_Ecm&quot;), daFunk::var(&quot;E&quot;), 9, outN)
               /daFunk::var(&quot;E&quot;))-&gt;set(&quot;_Ecm&quot;, daFunk::var(&quot;Ecm&quot;)*2);
        result.addChannel(dNdE/2, str_flav_to_mass(&quot;tau+&quot;), &quot;gamma&quot;, 2., mDM_max, runOptions);
        result.addChannel(dNdE/2, str_flav_to_mass(&quot;tau-&quot;), &quot;gamma&quot;, 2., mDM_max, runOptions);
        dNdE = (daFunk::func_fromThreadsafe(BEreq::dNdE.pointer(), daFunk::var(&quot;_Ecm&quot;), daFunk::var(&quot;E&quot;), 10, outN)
               /daFunk::var(&quot;E&quot;))-&gt;set(&quot;_Ecm&quot;, daFunk::var(&quot;Ecm&quot;)*2);
        result.addChannel(dNdE/2, &quot;Z0&quot;, &quot;gamma&quot;, 90.288, mDM_max, runOptions);
        dNdE = (daFunk::func_fromThreadsafe(BEreq::dNdE.pointer(), daFunk::var(&quot;_Ecm&quot;), daFunk::var(&quot;E&quot;), 13, outN)
               /daFunk::var(&quot;E&quot;))-&gt;set(&quot;_Ecm&quot;, daFunk::var(&quot;Ecm&quot;)*2);
        result.addChannel(dNdE/2, &quot;W+&quot;, &quot;gamma&quot;, 79.497, mDM_max, runOptions);
        result.addChannel(dNdE/2, &quot;W-&quot;, &quot;gamma&quot;, 79.497, mDM_max, runOptions);

        // Add single particle lookup for t tbar to prevent them from being tagged as missing final states for cascades.
        double Ecm_ToScale_top = 176.0;
        daFunk::Funk Ecm_ToUse_top = fmax(Ecm_ToScale_top, daFunk::var(&quot;Ecm&quot;));
        daFunk::Funk ScalingFactor_top = Ecm_ToUse_top/daFunk::var(&quot;Ecm&quot;);
        dNdE =  ScalingFactor_top * (daFunk::func_fromThreadsafe(BEreq::dNdE.pointer(), daFunk::var(&quot;_Ecm&quot;), ScalingFactor_top * daFunk::var(&quot;E&quot;), 6, outN)
               /(ScalingFactor_top * daFunk::var(&quot;E&quot;)))-&gt;set(&quot;_Ecm&quot;, Ecm_ToUse_top*2.0);
        result.addChannel(dNdE/2, str_flav_to_mass(&quot;t&quot;),    &quot;gamma&quot;, 160.0, mDM_max, runOptions);
        result.addChannel(dNdE/2, str_flav_to_mass(&quot;tbar&quot;), &quot;gamma&quot;, 160.0, mDM_max, runOptions);

        // Add channels with &quot;mixed final states&quot;, i.e. final state particles with (potentially) different masses
        daFunk::Funk Ecm = daFunk::var(&quot;Ecm&quot;);
        auto add_channel_mixedmasses = [&amp;](int inP1, int inP2, str P1, str P2, str FINAL, double m1, double m2, double EcmMin, double EcmMax)
        {
          daFunk::Funk dNdE_1 = (daFunk::func_fromThreadsafe(BEreq::dNdE.pointer(), daFunk::var(&quot;Ecm1&quot;),
           daFunk::var(&quot;E&quot;), inP1, outN)-&gt;set(&quot;Ecm1&quot;, Ecm + (m1*m1 - m2*m2)/Ecm))/daFunk::var(&quot;E&quot;);
          daFunk::Funk dNdE_2 = (daFunk::func_fromThreadsafe(BEreq::dNdE.pointer(), daFunk::var(&quot;Ecm2&quot;),
           daFunk::var(&quot;E&quot;), inP2, outN)-&gt;set(&quot;Ecm2&quot;, Ecm + (m2*m2 - m1*m1)/Ecm))/daFunk::var(&quot;E&quot;);
          result.addChannel(0.5*(dNdE_1 + dNdE_2), str_flav_to_mass(P1), str_flav_to_mass(P2), FINAL, EcmMin, EcmMax, runOptions);
        };

        // - The numerical values for EcmMin and EcmMax are obtained from applying the corresponding two-body kinematics
        //   to the minimal/maximal center-of-mass energies allowed by the micromegas tables
        add_channel_mixedmasses(2, 1, &quot;u&quot;, &quot;dbar&quot;, &quot;gamma&quot;, 0.0, 0.0, 2*2., 2*mDM_max);
        add_channel_mixedmasses(1, 2, &quot;d&quot;, &quot;ubar&quot;, &quot;gamma&quot;, 0.0, 0.0, 2*2., 2*mDM_max);
        add_channel_mixedmasses(2, 3, &quot;u&quot;, &quot;sbar&quot;, &quot;gamma&quot;, 0.0, 0.0, 2*2., 2*mDM_max);
        add_channel_mixedmasses(3, 2, &quot;s&quot;, &quot;ubar&quot;, &quot;gamma&quot;, 0.0, 0.0, 2*2., 2*mDM_max);
        add_channel_mixedmasses(2, 5, &quot;u&quot;, &quot;bbar&quot;, &quot;gamma&quot;, 0.0, 5.0, 7.386, 2*mDM_max);
        add_channel_mixedmasses(5, 2, &quot;b&quot;, &quot;ubar&quot;, &quot;gamma&quot;, 5.0, 0.0, 7.386, 2*mDM_max);

        add_channel_mixedmasses(4, 1, &quot;c&quot;, &quot;dbar&quot;, &quot;gamma&quot;, 1.35, 0.0, 4.413, 2*mDM_max);
        add_channel_mixedmasses(1, 4, &quot;d&quot;, &quot;cbar&quot;, &quot;gamma&quot;, 0.0, 1.35, 4.413, 2*mDM_max);
        add_channel_mixedmasses(4, 3, &quot;c&quot;, &quot;sbar&quot;, &quot;gamma&quot;, 1.35, 0.0, 4.413, 2*mDM_max);
        add_channel_mixedmasses(3, 4, &quot;s&quot;, &quot;cbar&quot;, &quot;gamma&quot;, 0.0, 1.35, 4.413, 2*mDM_max);
        add_channel_mixedmasses(4, 5, &quot;c&quot;, &quot;bbar&quot;, &quot;gamma&quot;, 1.35, 5.0, 7.214, 2*mDM_max);
        add_channel_mixedmasses(5, 4, &quot;b&quot;, &quot;cbar&quot;, &quot;gamma&quot;, 5.0, 1.35, 7.214, 2*mDM_max);

        add_channel_mixedmasses(6, 1, &quot;t&quot;, &quot;dbar&quot;, &quot;gamma&quot;, 176.0, 0.0, 178.011, 2*mDM_max);
        add_channel_mixedmasses(1, 6, &quot;d&quot;, &quot;tbar&quot;, &quot;gamma&quot;, 0.0, 176.0, 178.011, 2*mDM_max);
        add_channel_mixedmasses(6, 3, &quot;t&quot;, &quot;sbar&quot;, &quot;gamma&quot;, 176.0, 0.0, 178.011, 2*mDM_max);
        add_channel_mixedmasses(3, 6, &quot;s&quot;, &quot;tbar&quot;, &quot;gamma&quot;, 0.0, 176.0, 178.011, 2*mDM_max);
        add_channel_mixedmasses(6, 5, &quot;t&quot;, &quot;bbar&quot;, &quot;gamma&quot;, 176.0, 5.0, 181.0, 2*mDM_max);
        add_channel_mixedmasses(5, 6, &quot;b&quot;, &quot;tbar&quot;, &quot;gamma&quot;, 5.0, 176.0, 181.0, 2*mDM_max);

        initialized = true;
      }
    }

    /// Positron SimYieldTable based on MicrOmegas tabulated results.
    void positron_SimYieldTable_MicrOmegas(SimYieldTable&amp; /*result*/)
    {
      using namespace Pipes::positron_SimYieldTable_MicrOmegas;
      static bool initialized = false;

      if ( not initialized )
      {
        DarkBit_error().raise(LOCAL_INFO,
            &quot;positron_SimYieldTable_MicrOmegas is not implemented yet.  Use e.g. positron_SimYieldTable_DarkSUSY instead.&quot;);
      }
    }

    SimYieldTable SimYieldTable_PPPC(const str&amp; yield, bool allow_yield_extrapolation, double(*PPPC_yield)(double,double,std::string), safe_ptr&lt;Options&gt; runOptions)
    {
      using DarkBit_utils::str_flav_to_mass;

      SimYieldTable result;

      const double mDM_min = 5.0;
      const double mDM_max = 100000.0;

      auto add_channel = [&amp;](const str&amp; p1, const str&amp; p2, const str&amp; channel, double EcmMin, double EcmMax)
      {
        daFunk::Funk m = daFunk::var(&quot;m&quot;);
        daFunk::Funk x = daFunk::var(&quot;x&quot;);
        daFunk::Funk E = daFunk::var(&quot;Ekin&quot;);
        daFunk::Funk Ecm = daFunk::var(&quot;Ecm&quot;);

        daFunk::Funk dNdE = daFunk::func( PPPC_yield, daFunk::var(&quot;m&quot;), daFunk::var(&quot;x&quot;), channel);
        dNdE = dNdE-&gt;set(&quot;x&quot;, E/m);

        if (p2.size() &gt; 0)
        {
          dNdE = dNdE-&gt;set(&quot;m&quot;,Ecm/2);
          result.addChannel(dNdE, str_flav_to_mass(p1), str_flav_to_mass(p2), yield, EcmMin, EcmMax, runOptions);
        }
        else
        {
          dNdE = dNdE-&gt;set(&quot;m&quot;,Ecm);
          result.addChannel(dNdE/2, str_flav_to_mass(p1), yield, EcmMin, EcmMax, runOptions);
        }
      };

      // The following routine adds an annihilation/decay channel, for which the yields are extrapolated below Ecm_ToScale
      // using the approximation that x*dN/dx is a constant function of the dark matter mass.
      auto add_channel_with_scaling = [&amp;](const str&amp; p1, const str&amp; p2, const str&amp; channel, double EcmMin, double EcmMax, double Ecm_ToScale)
      {
        daFunk::Funk m = daFunk::var(&quot;m&quot;);
        daFunk::Funk x = daFunk::var(&quot;x&quot;);
        daFunk::Funk E = daFunk::var(&quot;Ekin&quot;);

        daFunk::Funk Ecm_ToUse = fmax(Ecm_ToScale, daFunk::var(&quot;Ecm&quot;));
        daFunk::Funk ScalingFactor = Ecm_ToUse/daFunk::var(&quot;Ecm&quot;);

        daFunk::Funk dNdE = daFunk::func( PPPC_yield, daFunk::var(&quot;m&quot;), daFunk::var(&quot;x&quot;), channel);
        dNdE = (ScalingFactor*dNdE)-&gt;set(&quot;x&quot;, E/m);

        if (p2.size() &gt; 0)
        {
          dNdE = dNdE-&gt;set(&quot;m&quot;,Ecm_ToUse/2);
          result.addChannel(dNdE, str_flav_to_mass(p1), str_flav_to_mass(p2), yield, EcmMin, EcmMax, runOptions);
        }
        else
        {
          dNdE = dNdE-&gt;set(&quot;m&quot;,Ecm_ToUse);
          result.addChannel(dNdE/2, str_flav_to_mass(p1), yield, EcmMin, EcmMax, runOptions);
        }
      };

      add_channel(&quot;e+&quot;,   &quot;e-&quot;,   &quot;e&quot;,   2*std::max(mDM_min, 0.0), 2*mDM_max);
      add_channel(&quot;mu+&quot;,  &quot;mu-&quot;,  &quot;mu&quot;,  2*std::max(mDM_min, 0.0), 2*mDM_max);
      add_channel(&quot;tau+&quot;, &quot;tau-&quot;, &quot;tau&quot;, 2*std::max(mDM_min, 0.0), 2*mDM_max);

      add_channel(&quot;u&quot;, &quot;ubar&quot;, &quot;q&quot;, 2*std::max(mDM_min, 1.35), 2*mDM_max);  // u,d,s are treated as one species
      add_channel(&quot;d&quot;, &quot;dbar&quot;, &quot;q&quot;, 2*std::max(mDM_min, 1.35), 2*mDM_max);
      add_channel(&quot;s&quot;, &quot;sbar&quot;, &quot;q&quot;, 2*std::max(mDM_min, 1.35), 2*mDM_max);

      add_channel(&quot;c&quot;, &quot;cbar&quot;, &quot;c&quot;, 2*std::max(mDM_min, 1.35), 2*mDM_max);
      add_channel(&quot;b&quot;, &quot;bbar&quot;, &quot;b&quot;, 2*std::max(mDM_min, 5.0),  2*mDM_max);
      add_channel_with_scaling(&quot;t&quot;, &quot;tbar&quot;, &quot;t&quot;, 2*std::max(mDM_min, 160.0), 2*mDM_max, 2*173.3);

      add_channel(&quot;W+&quot;, &quot;W-&quot;, &quot;W&quot;, 2*std::max(mDM_min, 79.4475), 2*mDM_max);
      add_channel(&quot;Z0&quot;, &quot;Z0&quot;, &quot;Z&quot;, 2*std::max(mDM_min, 90.288),  2*mDM_max);
      add_channel(&quot;g&quot;,  &quot;g&quot;,  &quot;g&quot;, 2*std::max(mDM_min, 0.0),     2*mDM_max);
      //add_channel(&quot;gamma&quot;,  &quot;gamma&quot;,  &quot;gamma&quot;, 2*std::max(mDM_min, 0.0), 2*mDM_max);
      //add_channel(&quot;h&quot;,  &quot;h&quot;,  &quot;h&quot;, 2*std::max(mDM_min, 125.1), 2*mDM_max);

      add_channel(&quot;nu_e&quot;,   &quot;nubar_e&quot;,   &quot;nu_e&quot;,   2*std::max(mDM_min, 0.0), 2*mDM_max);
      add_channel(&quot;nu_mu&quot;,  &quot;nubar_mu&quot;,  &quot;nu_mu&quot;,  2*std::max(mDM_min, 0.0), 2*mDM_max);
      add_channel(&quot;nu_tau&quot;, &quot;nubar_tau&quot;, &quot;nu_tau&quot;, 2*std::max(mDM_min, 0.0), 2*mDM_max);

      // Add approximations for single-particle cases.
      add_channel(&quot;Z0&quot;, &quot;&quot;, &quot;Z&quot;, std::max(mDM_min, 90.288),  mDM_max);
      add_channel(&quot;W+&quot;, &quot;&quot;, &quot;W&quot;, std::max(mDM_min, 79.4475), mDM_max);
      add_channel(&quot;W-&quot;, &quot;&quot;, &quot;W&quot;, std::max(mDM_min, 79.4475), mDM_max);

      add_channel(&quot;e+&quot;,   &quot;&quot;, &quot;e&quot;,   std::max(mDM_min, 0.0), mDM_max);
      add_channel(&quot;e-&quot;,   &quot;&quot;, &quot;e&quot;,   std::max(mDM_min, 0.0), mDM_max);
      add_channel(&quot;mu+&quot;,  &quot;&quot;, &quot;mu&quot;,  std::max(mDM_min, 0.0), mDM_max);
      add_channel(&quot;mu-&quot;,  &quot;&quot;, &quot;mu&quot;,  std::max(mDM_min, 0.0), mDM_max);
      add_channel(&quot;tau+&quot;, &quot;&quot;, &quot;tau&quot;, std::max(mDM_min, 0.0), mDM_max);
      add_channel(&quot;tau-&quot;, &quot;&quot;, &quot;tau&quot;, std::max(mDM_min, 0.0), mDM_max);

      add_channel_with_scaling(&quot;t&quot;,    &quot;&quot;, &quot;t&quot;, std::max(mDM_min, 160.0), mDM_max, 173.3);
      add_channel_with_scaling(&quot;tbar&quot;, &quot;&quot;, &quot;t&quot;, std::max(mDM_min, 160.0), mDM_max, 173.3);

      // Add channels with &quot;mixed final states&quot;, i.e. final state particles with (potentially) different masses
      auto add_channel_mixedmasses = [&amp;](const str&amp; p1, const str&amp; p2, const str&amp; ch1, const str&amp; ch2, double m1, double m2, double EcmMin, double EcmMax)
      {
        daFunk::Funk m = daFunk::var(&quot;m&quot;);
        daFunk::Funk x = daFunk::var(&quot;x&quot;);
        daFunk::Funk E = daFunk::var(&quot;Ekin&quot;);
        daFunk::Funk Ecm = daFunk::var(&quot;Ecm&quot;);

        daFunk::Funk dNdE1 = daFunk::func( PPPC_yield, daFunk::var(&quot;m&quot;), daFunk::var(&quot;x&quot;), ch1);
        dNdE1 = dNdE1-&gt;set(&quot;x&quot;, E/m)-&gt;set(&quot;m&quot;, Ecm/2 + (m1*m1 - m2*m2)/(2*Ecm));
        daFunk::Funk dNdE2 = daFunk::func( PPPC_yield, daFunk::var(&quot;m&quot;), daFunk::var(&quot;x&quot;), ch2);
        dNdE2 = dNdE2-&gt;set(&quot;x&quot;, E/m)-&gt;set(&quot;m&quot;, Ecm/2 + (m2*m2 - m1*m1)/(2*Ecm));

        result.addChannel((dNdE1+dNdE2)/2, str_flav_to_mass(p1), str_flav_to_mass(p2), yield, EcmMin, EcmMax, runOptions);
      };
      // - The numerical values for EcmMin and EcmMax are obtained from applying the corresponding two-body kinematics
      //   to the minimally/maximally allowed center-of-mass energies. Hence, EcmMin depends on the flag allow_yield_extrapolation
      add_channel_mixedmasses(&quot;u&quot;, &quot;dbar&quot;, &quot;q&quot;,&quot;q&quot;, 0.0, 0.0, (allow_yield_extrapolation ? 2*1.35 : 10.0), 2*mDM_max);
      add_channel_mixedmasses(&quot;d&quot;, &quot;ubar&quot;, &quot;q&quot;,&quot;q&quot;, 0.0, 0.0, (allow_yield_extrapolation ? 2*1.35 : 10.0), 2*mDM_max);
      add_channel_mixedmasses(&quot;u&quot;, &quot;sbar&quot;, &quot;q&quot;,&quot;q&quot;, 0.0, 0.0, (allow_yield_extrapolation ? 2*1.35 : 10.0), 2*mDM_max);
      add_channel_mixedmasses(&quot;s&quot;, &quot;ubar&quot;, &quot;q&quot;,&quot;q&quot;, 0.0, 0.0, (allow_yield_extrapolation ? 2*1.35 : 10.0), 2*mDM_max);
      add_channel_mixedmasses(&quot;u&quot;, &quot;bbar&quot;, &quot;q&quot;,&quot;b&quot;, 0.0, 5.0, (allow_yield_extrapolation ? 6.530 : 21.181), 2*mDM_max);
      add_channel_mixedmasses(&quot;b&quot;, &quot;ubar&quot;, &quot;b&quot;,&quot;q&quot;, 5.0, 0.0, (allow_yield_extrapolation ? 6.530 : 21.181), 2*mDM_max);

      add_channel_mixedmasses(&quot;c&quot;, &quot;dbar&quot;, &quot;c&quot;,&quot;q&quot;, 1.35, 0.0, (allow_yield_extrapolation ? 3.260 : 20.091), 2*mDM_max);
      add_channel_mixedmasses(&quot;d&quot;, &quot;cbar&quot;, &quot;q&quot;,&quot;c&quot;, 0.0, 1.35, (allow_yield_extrapolation ? 3.260 : 20.091), 2*mDM_max);
      add_channel_mixedmasses(&quot;c&quot;, &quot;sbar&quot;, &quot;c&quot;,&quot;q&quot;, 1.35, 0.0, (allow_yield_extrapolation ? 3.260 : 20.091), 2*mDM_max);
      add_channel_mixedmasses(&quot;s&quot;, &quot;cbar&quot;, &quot;q&quot;,&quot;c&quot;, 0.0, 1.35, (allow_yield_extrapolation ? 3.260 : 20.091), 2*mDM_max);
      add_channel_mixedmasses(&quot;c&quot;, &quot;bbar&quot;, &quot;c&quot;,&quot;b&quot;, 1.35, 5.0, (allow_yield_extrapolation ? 6.35 : 21.099), 2*mDM_max);
      add_channel_mixedmasses(&quot;b&quot;, &quot;cbar&quot;, &quot;b&quot;,&quot;c&quot;, 5.0, 1.35, (allow_yield_extrapolation ? 6.35 : 21.099), 2*mDM_max);

      add_channel_mixedmasses(&quot;t&quot;, &quot;dbar&quot;, &quot;t&quot;,&quot;q&quot;, 175.0, 0.0, (allow_yield_extrapolation ? 176.355 : 185.285), 2*mDM_max);
      add_channel_mixedmasses(&quot;d&quot;, &quot;tbar&quot;, &quot;q&quot;,&quot;t&quot;, 0.0, 175.0, (allow_yield_extrapolation ? 176.355 : 185.285), 2*mDM_max);
      add_channel_mixedmasses(&quot;t&quot;, &quot;sbar&quot;, &quot;t&quot;,&quot;q&quot;, 175.0, 0.0, (allow_yield_extrapolation ? 176.355 : 185.285), 2*mDM_max);
      add_channel_mixedmasses(&quot;s&quot;, &quot;tbar&quot;, &quot;q&quot;,&quot;t&quot;, 0.0, 175.0, (allow_yield_extrapolation ? 176.355 : 185.285), 2*mDM_max);
      add_channel_mixedmasses(&quot;t&quot;, &quot;bbar&quot;, &quot;t&quot;,&quot;b&quot;, 175.0, 5.0, (allow_yield_extrapolation ? 180.0 : 185.214), 2*mDM_max);
      add_channel_mixedmasses(&quot;b&quot;, &quot;tbar&quot;, &quot;b&quot;,&quot;t&quot;, 5.0, 175.0, (allow_yield_extrapolation ? 180.0 : 185.214), 2*mDM_max);

      return result;
    }

    // Functions for the PPPC yields are defined elsewhere
    // (in PPPC.cpp if someone asks)
    double PPPC_dNdE_gamma(double m, double x, std::string channel);
    double PPPC_dNdE_positron(double m, double x, std::string channel);

    /// Gamma-ray SimYieldTable based on PPPC4DMID Cirelli et al. 2010
    void GA_SimYieldTable_PPPC(SimYieldTable&amp; result)
    {
      using namespace Pipes::GA_SimYieldTable_PPPC;
      static bool initialized = false;

      if ( not initialized )
      {
        /// Option allow_yield_extrapolation&lt;bool&gt;: Spectra extrapolated for masses beyond Pythia results (default false)
        //bool allow_yield_extrapolation = runOptions-&gt;getValueOrDef(false, &quot;allow_yield_extrapolation&quot;);
        bool allow_yield_extrapolation = false;
        result = SimYieldTable_PPPC(&quot;gamma&quot;, allow_yield_extrapolation, &amp;PPPC_dNdE_gamma, runOptions);
        initialized = true;
      }
    }

    /// Positron SimYieldTable based on PPPC4DMID Cirelli et al. 2010
    void positron_SimYieldTable_PPPC(SimYieldTable&amp; result)
    {
      using namespace Pipes::positron_SimYieldTable_PPPC;
      static bool initialized = false;

      if ( not initialized )
      {
        /// Option allow_yield_extrapolation&lt;bool&gt;: Spectra extrapolated for masses beyond Pythia results (default false)
        //bool allow_yield_extrapolation = runOptions-&gt;getValueOrDef(false, &quot;allow_yield_extrapolation&quot;);
        bool allow_yield_extrapolation = false;
        result = SimYieldTable_PPPC(&quot;e+_1&quot;, allow_yield_extrapolation, &amp;PPPC_dNdE_positron, runOptions);
        initialized = true;
      }
    }

    /// Bypasses to skip specific yields in FullSimYieldTable
    void GA_SimYieldTable_empty(SimYieldTable&amp; result)
    {
      static const SimYieldTable empty_table;
      result = empty_table;
    }

    void positron_SimYieldTable_empty(SimYieldTable&amp; result)
    {
      static const SimYieldTable empty_table;
      result = empty_table;
    }

    void antiproton_SimYieldTable_empty(SimYieldTable&amp; result)
    {
      static const SimYieldTable empty_table;
      result = empty_table;
    }

    void antideuteron_SimYieldTable_empty(SimYieldTable&amp; result)
    {
      static const SimYieldTable empty_table;
      result = empty_table;
    }

    /// Electron SimYieldTable based on positron table
    void electron_SimYieldTable_from_positron_SimYieldTable(SimYieldTable&amp; result)
    {
      static bool initialized = false;
      if ( not initialized )
      {
        // Just duplicate the positron yield.  DarkSUSY at least does not offer separate electron yields.
        result = *Pipes::electron_SimYieldTable_from_positron_SimYieldTable::Dep::positron_SimYieldTable;
        result.replaceFinalState(&quot;e+_1&quot;,&quot;e-_1&quot;);
        initialized = true;
      }
    }

    // Dumper functions ================================================

    /// \brief Helper function to dump any spectra
    int dump(const str&amp; filename, const daFunk::Funk&amp; spectrum)
    {
      std::ofstream myfile (filename);
      if (myfile.is_open())
      {
        for (int i = 0; i&lt;=1200; i++)
        {
          double energy = pow(10., i/200. - 4.);
          myfile &lt;&lt; energy &lt;&lt; &quot; &quot; &lt;&lt; spectrum-&gt;bind(&quot;E&quot;)-&gt;eval(energy) &lt;&lt; &quot;\n&quot;;
        }
        myfile.close();
        return 0;
      }
      else
      {
        DarkBit_error().raise(LOCAL_INFO, &quot;Failed to open file &quot; + filename + &quot;.&quot;);
      }
      return 1;
    }

    /// \brief Helper function to dump gamma-ray spectra.
    void dump_gammaSpectrum(int &amp;result)
    {
      using namespace Pipes::dump_gammaSpectrum;
      daFunk::Funk spectrum = (*Dep::GA_Yield)-&gt;set(&quot;v&quot;, 0.);
      // Option filename&lt;string&gt;: Filename for gamma-ray spectrum dump
      // (default: dNdE_gamma.dat)
      std::string filename = runOptions-&gt;getValueOrDef&lt;std::string&gt;(&quot;dNdE_gamma.dat&quot;, &quot;filename&quot;);
      logger() &lt;&lt; &quot;FILENAME for gamma dump: &quot; &lt;&lt; filename &lt;&lt; EOM;
      result = dump(filename, spectrum);
    }

    /// \brief Helper function to dump electron spectra.
    void dump_electronSpectrum(int &amp;result)
    {
      using namespace Pipes::dump_electronSpectrum;
      daFunk::Funk spectrum = (*Dep::electron_Yield)-&gt;set(&quot;v&quot;, 0.);
      // Option filename&lt;string&gt;: Filename for electron spectrum dump
      // (default: dNdE_electron.dat)
      std::string filename = runOptions-&gt;getValueOrDef&lt;std::string&gt;(&quot;dNdE_electron.dat&quot;, &quot;filename&quot;);
      logger() &lt;&lt; &quot;FILENAME for electron dump: &quot; &lt;&lt; filename &lt;&lt; EOM;
      result = dump(filename, spectrum);
    }

    /// \brief Helper function to dump positron spectra.
    void dump_positronSpectrum(int &amp;result)
    {
      using namespace Pipes::dump_positronSpectrum;
      daFunk::Funk spectrum = (*Dep::positron_Yield)-&gt;set(&quot;v&quot;, 0.);
      // Option filename&lt;string&gt;: Filename for positron spectrum dump
      // (default: dNdE_positron.dat)
      std::string filename = runOptions-&gt;getValueOrDef&lt;std::string&gt;(&quot;dNdE_positron.dat&quot;, &quot;filename&quot;);
      logger() &lt;&lt; &quot;FILENAME for positron dump: &quot; &lt;&lt; filename &lt;&lt; EOM;
      result = dump(filename, spectrum);
    }

    /// \brief Helper function to dump anti-proton spectra.
    void dump_antiprotonSpectrum(int &amp;result)
    {
      using namespace Pipes::dump_antiprotonSpectrum;
      daFunk::Funk spectrum = (*Dep::antiproton_Yield)-&gt;set(&quot;v&quot;, 0.);
      // Option filename&lt;string&gt;: Filename for antiproton spectrum dump
      // (default: dNdE_antiproton.dat)
      std::string filename = runOptions-&gt;getValueOrDef&lt;std::string&gt;(&quot;dNdE_antiproton.dat&quot;, &quot;filename&quot;);
      logger() &lt;&lt; &quot;FILENAME for antiproton dump: &quot; &lt;&lt; filename &lt;&lt; EOM;
      result = dump(filename, spectrum);
    }

    /// \brief Helper function to dump anti-deuteron spectra.
    void dump_antideuteronSpectrum(int &amp;result)
    {
      using namespace Pipes::dump_antideuteronSpectrum;
      daFunk::Funk spectrum = (*Dep::antideuteron_Yield)-&gt;set(&quot;v&quot;, 0.);
      // Option filename&lt;string&gt;: Filename for antideuteron spectrum dump
      // (default: dNdE_antideuteron.dat)
      std::string filename = runOptions-&gt;getValueOrDef&lt;std::string&gt;(&quot;dNdE_antideuteron.dat&quot;, &quot;filename&quot;);
      logger() &lt;&lt; &quot;FILENAME for antideuteron dump: &quot; &lt;&lt; filename &lt;&lt; EOM;
      result = dump(filename, spectrum);
    }

  }
}
</code></pre><hr><p>Updated on 2022-08-03 at 12:58:19 +0000</p><div class=edit-page><a href=https://github.com/RC1242RC/gambit_gh_pages/blob/master/content/en/documentation/code/ColliderBit/Files/IndirectDetectionYields_8cpp.md><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828.0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>Edit this page on GitHub</a></div></main></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Powered by <a class=text-muted href=https://www.netlify.com/>Netlify</a>, <a class=text-muted href=https://gohugo.io/>Hugo</a>, and <a class=text-muted href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline><li class=list-inline-item><a href=/license/>License</a></li></ul></div></div></div></footer><script src=/js/bootstrap.min.54bf0932b8a36d0e152b1635b099a6ef1394d35327e2437550a075c9c8ed1bd8aed5847c21b36fc02ed24014c031d9ca24017b0c78b1639d7e2fa8329898b842.js integrity="sha512-VL8JMrijbQ4VKxY1sJmm7xOU01Mn4kN1UKB1ycjtG9iu1YR8IbNvwC7SQBTAMdnKJAF7DHixY51+L6gymJi4Qg==" crossorigin=anonymous defer></script>
<script src=/js/highlight.min.5b48bc253dc75aeea5fb366ecf700f4925e2b6eb1a1466f2124b722d68148d67bc0a9365d2b8ad9c585161b46372d23b08509a16f1fd518542b894756d4752d0.js integrity="sha512-W0i8JT3HWu6l+zZuz3APSSXitusaFGbyEktyLWgUjWe8CpNl0ritnFhRYbRjctI7CFCaFvH9UYVCuJR1bUdS0A==" crossorigin=anonymous defer></script>
<script src=/main.min.40265e9a032aeba5eaf67baac3cbbc22667a7533215d326eeb3e9f4d5e4be40f9ff4dcd22949db73ae527ca26a19d7998091a8973c82af760b2c0daa335190ed.js integrity="sha512-QCZemgMq66Xq9nuqw8u8ImZ6dTMhXTJu6z6fTV5L5A+f9NzSKUnbc65SfKJqGdeZgJGolzyCr3YLLA2qM1GQ7Q==" crossorigin=anonymous defer></script>
<script src=https://rc1242rc.github.io/index.min.cb3cfc52c7c54bd8c25d1fbd0a5de239406787c3dcdce4c8c0c6a90e32667d32f427e033d04af1c0f2c4a86667aa8d3df23f54c6a7873d639d2ca7c2edf7146d.js integrity="sha512-yzz8UsfFS9jCXR+9Cl3iOUBnh8Pc3OTIwMapDjJmfTL0J+Az0ErxwPLEqGZnqo098j9UxqeHPWOdLKfC7fcUbQ==" crossorigin=anonymous defer></script></body></html>