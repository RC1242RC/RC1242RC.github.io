<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=https://rc1242rc.github.io/main_development/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://rc1242rc.github.io/main_development/fonts/vendor/jost/jost-v4-latin-500.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://rc1242rc.github.io/main_development/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><script>(()=>{var e=localStorage.getItem("theme");e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><link rel=stylesheet href=https://rc1242rc.github.io/main_development/main.1fa2debdf0a1b20e7268d11906902449af896197928a5bdae9dca95b629cdd73746db3d8c6afacb7320d9deb149a318c764669d08a1ddfd34a657ab2aeab866a.css integrity="sha512-H6LevfChsg5yaNEZBpAkSa+JYZeSilva6dypW2Kc3XN0bbPYxq+stzINnesUmjGMdkZp0Iod39NKZXqyrquGag==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>file FlavBit/flav_loop_functions.hpp - GAMBIT</title><meta name=description content="[No description available]"><link rel=canonical href=https://rc1242rc.github.io/main_development/documentation/code/files/flav__loop__functions_8hpp/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="file FlavBit/flav_loop_functions.hpp"><meta property="og:description" content="[No description available]"><meta property="og:url" content="https://rc1242rc.github.io/main_development/documentation/code/files/flav__loop__functions_8hpp/"><meta property="og:site_name" content="GAMBIT"><meta property="og:image" content="https://rc1242rc.github.io/main_development/gambit_logo.png"><meta property="og:image:alt" content="GAMBIT"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content><meta name=twitter:creator content><meta name=twitter:title content="file FlavBit/flav_loop_functions.hpp"><meta name=twitter:description content="[No description available]"><meta name=twitter:image content="https://rc1242rc.github.io/main_development/gambit_logo.png"><meta name=twitter:image:alt content="file FlavBit/flav_loop_functions.hpp"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://rc1242rc.github.io/#/schema/organization/1","name":"Doks","url":"https://rc1242rc.github.io/","sameAs":["https://github.com/GambitBSM"],"logo":{"@type":"ImageObject","@id":"https://rc1242rc.github.io/#/schema/image/1","url":"https://rc1242rc.github.io/logo-doks.png","width":450,"height":416,"caption":"Doks"},"image":{"@id":"https://rc1242rc.github.io/#/schema/image/1"}},{"@type":"WebSite","@id":"https://rc1242rc.github.io/#/schema/website/1","url":"https://rc1242rc.github.io/","name":"GAMBIT","description":"Documentation for the Global And Modular BSM Inference Tool","publisher":{"@id":"https://rc1242rc.github.io/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://rc1242rc.github.io/main_development/documentation/code/files/flav__loop__functions_8hpp/","url":"https://rc1242rc.github.io/main_development/documentation/code/files/flav__loop__functions_8hpp/","name":"file FlavBit\/flav_loop_functions.hpp","description":"[No description available]","isPartOf":{"@id":"https://rc1242rc.github.io/#/schema/website/1"},"about":{"@id":"https://rc1242rc.github.io/#/schema/organization/1"},"datePublished":"0001-01-01T00:00:00CET","dateModified":"0001-01-01T00:00:00CET","breadcrumb":{"@id":"https://rc1242rc.github.io/main_development/documentation/code/files/flav__loop__functions_8hpp/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://rc1242rc.github.io/main_development/documentation/code/files/flav__loop__functions_8hpp/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://rc1242rc.github.io/main_development/documentation/code/files/flav__loop__functions_8hpp/"]}]},{"@type":"BreadcrumbList","@id":"https://rc1242rc.github.io/main_development/documentation/code/files/flav__loop__functions_8hpp/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/main_development","url":"https://rc1242rc.github.io/main_development","name":"Home"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/main_development/documentation/","url":"https://rc1242rc.github.io/main_development/documentation/","name":"Documentation"}},{"@type":"ListItem","position":4,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/main_development/documentation/code/","url":"https://rc1242rc.github.io/main_development/documentation/code/","name":"Code"}},{"@type":"ListItem","position":5,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/main_development/documentation/code/files/","url":"https://rc1242rc.github.io/main_development/documentation/code/files/","name":"Files"}},{"@type":"ListItem","position":6,"item":{"@id":"https://rc1242rc.github.io/main_development/documentation/code/files/flav__loop__functions_8hpp/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://rc1242rc.github.io/main_development/documentation/code/files/flav__loop__functions_8hpp/#/schema/image/2","url":"https://rc1242rc.github.io/main_development/gambit_logo.png","contentUrl":"https://rc1242rc.github.io/main_development/gambit_logo.png","caption":"file FlavBit\/flav_loop_functions.hpp"}]}]}</script><meta name=theme-color content="#fff"><link rel=icon href=https://rc1242rc.github.io/main_development/favicon.ico sizes=any><link rel=icon type=image/svg+xml href=https://rc1242rc.github.io/main_development/favicon.svg><link rel=apple-touch-icon sizes=180x180 href=https://rc1242rc.github.io/main_development/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://rc1242rc.github.io/main_development/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://rc1242rc.github.io/main_development/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://rc1242rc.github.io/main_development/site.webmanifest></head><body class="documentation single light"><div class=sticky-top><div class=header-bar></div><header class="navbar navbar-expand-md navbar-light doks-navbar"><nav class="container-xxl flex-wrap flex-md-nowrap" aria-label="Main navigation"><a class="navbar-brand p-0 me-auto" href=/ aria-label=GAMBIT><img class=logo-light src=gambit_logo.png width=50px>
<img class="logo-dark d-none" src=gambit_logo.png width=50px>
GAMBIT</a>
<button class="btn btn-menu order-2 d-block d-lg-none" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasDoks aria-controls=offcanvasDoks aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><div class="offcanvas offcanvas-end border-0 py-lg-1" tabindex=-1 id=offcanvasDoks data-bs-backdrop=true aria-labelledby=offcanvasDoksLabel><div class="header-bar d-lg-none"></div><div class="offcanvas-header d-lg-none"><h2 class="h5 offcanvas-title ps-2" id=offcanvasDoksLabel><a class=text-dark href=/>GAMBIT</a></h2><button type=button class="btn-close text-reset me-2" data-bs-dismiss=offcanvas aria-label="Close main menu"></button></div><div class="offcanvas-body p-4 p-lg-0"><ul class="nav flex-column flex-lg-row align-items-lg-center mt-2 mt-lg-0 ms-lg-2 me-lg-auto"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Documentation
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/main_development/documentation/installation/introduction/>Installation</a></li><li><a class=dropdown-item href=/main_development/documentation/examples/colliderbit>Examples</a></li><li><a class=dropdown-item href=/main_development/documentation/help/faqs/>Help</a></li><li><a class=dropdown-item href=/main_development/documentation/code/index_classes>Code Reference</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Community
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/main_development/community/publications/>Publications</a></li><li><a class=dropdown-item href=/main_development/community/talks/>Talks</a></li><li><a class=dropdown-item href=/main_development/community/members/>Members</a></li><li><a class=dropdown-item href=/main_development/community/code_of_conduct/>Code of Conduct</a></li><li><a class=dropdown-item href=/main_development/community/contact/>Contact</a></li></ul></li></ul><hr class="text-black-50 my-4 d-lg-none"><form class="doks-search position-relative flex-grow-1 ms-lg-auto me-lg-2"><input id=search class="form-control is-search" type=search placeholder="Search site..." aria-label="Search site..." autocomplete=off><div id=suggestions class="shadow bg-white rounded d-none"></div></form><hr class="text-black-50 my-4 d-lg-none"><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=https://github.com/GambitBSM><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><small class="ms-2 d-lg-none">GitHub</small></a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn btn-doks-light dropdown-toggle" id=doks-versions data-bs-toggle=dropdown aria-expanded=false data-bs-display=static aria-label="Toggle version menu">
<span class=d-none>Doks</span> Main Development
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=doks-versions><li><a class=dropdown-item href=/%7b%7b%20replace%20$version%20%27%20%27%20%27_%27%20%7d%7d/documentation/code/index_classes/>Main Development</a></li><li><a class=dropdown-item href=/%7b%7b%20replace%20$version%20%27%20%27%20%27_%27%20%7d%7d/documentation/code/index_classes/>TestBit</a></li></ul></div></div></div></nav></header></div><div class="wrap container-xxl" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class=docs-links aria-label="Main navigation"><ul class="list-unstyled collapsible-sidebar"><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-installation aria-expanded=false>
Installation</button><div class=collapse id=section-installation><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/main_development/documentation/installation/introduction/>Getting Started</a></li><li><a class="docs-link rounded" href=/main_development/documentation/installation/docker_usage/>Docker Usage</a></li><li><a class="docs-link rounded" href=/main_development/documentation/installation/installation_for_linux/>Installation for Linux</a></li><li><a class="docs-link rounded" href=/main_development/documentation/installation/installation_for_windows/>Installation for Windows</a></li><li><a class="docs-link rounded" href=/main_development/documentation/installation/installation_for_macos/>Installation for macOS</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-examples aria-expanded=false>
Examples</button><div class=collapse id=section-examples><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/main_development/documentation/examples/colliderbit/>ColliderBit</a></li><li><a class="docs-link rounded" href=/main_development/documentation/examples/anotherbit/>AnotherBit</a></li><li><a class="docs-link rounded" href=/main_development/documentation/examples/anotherbit2/>AnotherBit2</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-help aria-expanded=false>
Help</button><div class=collapse id=section-help><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/main_development/documentation/help/faqs/>FAQs</a></li><li><a class="docs-link rounded" href=/main_development/documentation/help/compiler_matrix/>Compiler Matrix</a></li><li><a class="docs-link rounded" href=/main_development/documentation/help/known_issues/>Known Issues</a></li><li><a class="docs-link rounded" href=/main_development/documentation/help/configuration_examples/>Configuration Examples</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-code aria-expanded=false>
Code Reference</button><div class=collapse id=section-code><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/main_development/documentation/code/index_classes/>Classes</a></li><li><a class="docs-link rounded" href=/main_development/documentation/code/index_files/>Files</a></li><li><a class="docs-link rounded" href=/main_development/documentation/code/index_pages/>Pages</a></li><li><a class="docs-link rounded" href=/main_development/documentation/code/index_namespaces/>Namespaces</a></li></ul></div></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=d-xl-none><button class="btn btn-outline-primary btn-sm doks-toc-toggle collapsed" type=button data-bs-toggle=collapse data-bs-target=#onThisPage aria-controls=doks-docs-nav aria-expanded=false aria-label="Toggle On this page navigation">
<span>On this page</span>
<span><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"/><polyline points="7 6 12 11 17 6"/></svg><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"/><polyline points="17 18 12 13 7 18"/></svg></span></button><div class=collapse id=onThisPage><div class="card card-body mt-3 py-1"><div class=page-links><nav id=TableOfContents><ul><li><ul><li><a href=#namespaces>Namespaces</a></li><li><a href=#detailed-description>Detailed Description</a></li><li><a href=#source-code>Source code</a></li></ul></li></ul></nav></div></div></div></div><div class="page-links d-none d-xl-block"><h3>On this page</h3><nav id=TableOfContents><ul><li><ul><li><a href=#namespaces>Namespaces</a></li><li><a href=#detailed-description>Detailed Description</a></li><li><a href=#source-code>Source code</a></li></ul></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9 mx-xl-auto"><h1>file FlavBit/flav_loop_functions.hpp</h1><p class=lead></p><p>[No description available] <a href=#detailed-description>More&mldr;</a></p><h2 id=namespaces>Namespaces <a href=#namespaces class=anchor aria-hidden=true>#</a></h2><table><thead><tr><th>Name</th></tr></thead><tbody><tr><td><strong><a href=/documentation/code/namespaces/namespacegambit/>Gambit</a></strong><br>TODO: see if we can use this one:</td></tr><tr><td><strong><a href=/documentation/code/namespaces/namespacegambit_1_1flavbit/>Gambit::FlavBit</a></strong></td></tr><tr><td><strong><a href=/documentation/code/namespaces/namespacegambit_1_1flavbit_1_1loopfunctions/>Gambit::FlavBit::LoopFunctions</a></strong></td></tr><tr><td><strong><a href=/documentation/code/namespaces/namespacegambit_1_1flavbit_1_1vertices/>Gambit::FlavBit::Vertices</a></strong></td></tr><tr><td><strong><a href=/documentation/code/namespaces/namespacegambit_1_1flavbit_1_1penguins/>Gambit::FlavBit::Penguins</a></strong></td></tr><tr><td><strong><a href=/documentation/code/namespaces/namespacegambit_1_1flavbit_1_1boxes/>Gambit::FlavBit::Boxes</a></strong></td></tr><tr><td><strong><a href=/documentation/code/namespaces/namespacegambit_1_1flavbit_1_1formfactors/>Gambit::FlavBit::FormFactors</a></strong></td></tr></tbody></table><h2 id=detailed-description>Detailed Description <a href=#detailed-description class=anchor aria-hidden=true>#</a></h2><p><strong>Author</strong>: Tomas Gonzalo (<a href=mailto:t.e.gonzalo@fys.uio.no>t.e.gonzalo@fys.uio.no</a>)</p><p><strong>Date</strong>: 2017 Aug, 2018 Feb</p><p>Loop functions for flavour violating decays of charged leptons (from hep-ph/9403398) And for RK from 1706.07570</p><hr><p>Authors (add name and date if you modify):</p><hr><h2 id=source-code>Source code <a href=#source-code class=anchor aria-hidden=true>#</a></h2><pre><code>//   GAMBIT: Global and Modular BSM Inference Tool
//   *********************************************

#ifndef __flav_loop_functions_hpp
#define __flav_loop_functions_hpp

namespace Gambit
{

  namespace FlavBit
  {
    using namespace std;

    // Loop functions for LFV diagrams
    namespace LoopFunctions
    {
      double G1(const double x)
      {
        if(x == 0)
          return -7./12.;
        if(x == 1)
          return -5./12.;
        else
          return (-7. + 33.*x - 57.*x*x + 31.*x*x*x + 6.*x*x*(1. - 3*x)*log(x))/(12.*pow(1.-x,4));
      }

      double G1(const double a, const double b, const double c)
      {
        if(b == c and b != 0)
          return G1(a/b)/b;
        else
          return 0; // TODO: 2C12 + 2C22 - C1 or 2C12 + C11 - C2
      }

      double MFVV(const double a, const double b)
      {
        if(a == b)
          return 1. / (3. * b);
        else if(a == 0)
          return 5. / (9. * b);
        else
          return (6.*a*a*(a-3.*b)*log(a/b) - (a-b)*(5.*a*a - 22.*a*b + 5.*b*b))/(9.*pow(a-b,4));
      }

      double B1(const double a, const double b, const double Q)
      {
        if(a == b)
          return 0.5 * log(b / pow(Q,2));
        else if(a == 0)
          return -0.25 + 0.5*log(b / pow(Q,2));
        else
          return -0.5 + 0.5*log(b / pow(Q,2)) - (a*a - b*b + 2.*a*a*log(b/a)) / (4.*pow(a-b,2));
      }

      double B0(const double a, const double b, const double Q)
      {
        // TODO: behaviour when a = 0 and b = 0 undefined
        if(a == 0 and b == 0)
          return 0;
        else if(a == b)
          return -log(b / pow(Q,2));
        else if(a == 0)
          return 1. - log(b / pow(Q,2));
        else if(b == 0)
          return 1. - log(a) - log(1./pow(Q,2));
        else
          return 1. - log(b / pow(Q,2)) + 1./(b-a) * a * log(a/b);
      }

      double C0(const double a, const double b, const double c)
      {
        // TODO: behaviour when two paramers are 0 undefined, set it to zero
        if(a == 0 and b == 0 and c == 0)
          return 0;
        if(a == 0 and b == 0) 
          return 0;
        else if(a == 0 and c == 0) 
          return 0;
        else if(b == 0 and c == 0)
          return 0;
        else if(c == 0)
          return C0(a,c,b);
        else if(a == b and b == c) 
          return - 1./(2*c);
        else if(a == b)
          return (-b + c- c*log(c/b)) / pow(b-c,2);
        else if(a == c and b != 0)
          return C0(a,c,b);
        else if(a == c and b == 0)
          return -1./c;
        else if(b == c and a != 0)
          return (a - c + a*log(c/a)) / pow(a-c,2);
        else if(b == c and a == 0)
          return -1./c;
        else if(a == 0)
          return (-log(b) + log(c)) / (b-c);
        else if(b == 0)
          return log(c/a)/(a-c);
        else
          return -1. / (a-b)*(a-c)*(b-c)*( b*(c-a)*log(b/a) + c*(a-b)*log(c/a));
      }

      double C00(const double a, const double b, const double c, const double Q)
      {
        // TODO: behaviour when all three parameters are zero is undefined, set it to zero
        if(a == 0 and b == 0 and c == 0)
          return 0;
        else if(b == 0 and c == 0)
          return 0.125*(3. - 2.*log(a/pow(Q,2)));
        else if(a == 0 and b == 0)
          return 0.125*(3. - 2.*log(c) - 2.*log(1./pow(Q,2)));
        else if(c == 0)
          return C00(a,c,b,Q);
        else if(a == b and b == c)
          return -0.25*log(c/pow(Q,2));
        else if(a == b)
          return - (2.*c*c*log(c/b) + (b-c)*(-b + 3.*c + 2.*(b-c)*log(b/pow(Q,2))))/(8.*pow(b-c,2));
        else if(a == c and b != 0)
          return C00(a,c,b,Q);
        else if(a == c and b == 0)
          return 0.125*(1. - 2.*log(c/pow(Q,2)));
        else if(b == c and a != 0)
          return (2.*(2.*a-c)*c*log(c/a)-(a-c)*(-3.*a+c+2.*(a-c)*log(a/pow(Q,2))))/(8.*pow(a-c,2));
        else if(b == c and a == 0)
          return 0.125*(1. - 2.*log(c) - 2.*log(1./pow(Q,2)));
        else if(a == 0)
          return -(2.*b*log(b) - 2.*c*log(c) + (b-c)*(-3.+2.*log(1./pow(Q,2))))/(8.*(b-c));
        else if(b == 0)
          return (2.*c*log(c/a) - (a-c)*(-3. + 2.*log(a/pow(Q,2))))/(8.*(a-c));
        else
          return 1. / (8.*(a-b)*(a-c)*(b-c)) * ( (c-a)*((a-b)*(2.*log(a/pow(Q,2))-3.)*(b-c) - 2.*b*b*log(b/a)) + 2.*c*c*(b-a)*log(c/a));
      }

      // Finite combination of loop functions that appears in VZw10
      double B02C00C0(const double a, const double b, const double c, const double Q)
      {
        if(a == 0 and b == 0)
          return 0.25*(1.0 - 2.0*log(c) - 2.0*log(1 / pow(Q,2)));
        else
          return B0(a,b,Q) - 2*C00(a,b,c,Q) + C0(a,b,c)*c;
      }

      double D0(const double a, const double b, const double c, const double d)
      {
        //TODO: behaviour when two or more parameters are zero is undefined, set it to zero
        if((!a and !b) or (!b and !c) or (!b and !d) or (!c and !d))
          return 0;
        else if(c == 0)
          return D0(a,c,b,d);
        else if(d == 0)
          return D0(a,d,c,b);
        else if(a == b and b == c and c == d)
          return 1. / (6.*d*d);
        else if(a == b and b == c)
          return D0(a,d,c,d);
        else if(a == b and b == d)
          return D0(a,c,b,d);
        else if(a == c and c == d and b == 0)
          return 1. / (2.*c*c);
        else if(a == c and c == d and b != 0)
          return (-b*b + c*c + 2.*b*c*log(b/c)) / (2.*c*pow(c-b,3));
        else if(b == c and c == d and a == 0)
          return 1. / (2.*d*d);
        else if(b == c and c == d and a != 0)
          return (a*a - d*d + 2.*a*d*log(d/a)) / (2.*d*pow(a-d,3));
        else if(a == d and b == c)
          return (-2*c + 2*d + (c+d)*log(c/d)) / pow(c-d,3);
        else if(a == d and b == 0)
          return (c - d -d*log(c/d)) / (pow(c-d,2)*d);
        else if(a == d)
          return 1./ ((b-d)*(d-c))-(b*log(b/d))/((b-c)*pow(b-d,2))+(c*log(c/d))/((b-c)*pow(c-d,2));
        else if(a == c)
          return D0(a,b,d,c);
        else if(a == b)
          return D0(a,d,c,b);
        else if(b == c)
          return D0(a,d,c,b);
        else if(b == d)
          return D0(a,c,b,d);
        else if(c == d and b == 0)
          return (a - d + d*log(d/a)) / (d*pow(a-d,2));
        else if(c == d and a == 0)
          return (b - d + d*log(d/b)) / (d*pow(b-d,2));
        else if(c == d)
          return (b*pow(a-d,2)*log(b/a) - (a-b)*( (a-d)*(b-d) + (a*b-d*d)*log(d/a) )) / ((a-b)*pow(a-d,2)*pow(b-d,2));
        else if(b == 0)
          return log(c/a)/((a-c)*(c-d)) + log(d/a)/((a-d)*(d-c));
        else if(a == 0)
          return ((d-c)*log(b) + (b-d)*log(c) + (c-b)*log(d))/((b-c)*(b-d)*(c-d));
        else
          return -(b*log(b/a)/((b-a)*(b-c)*(b-d)) + c*log(c/a)/((c-a)*(c-b)*(c-d)) + d*log(d/a)/((d-a)*(d-b)*(d-c)));
      }

      double D27(const double a, const double b, const double c, const double d)
      {
        //TODO: behaviour when three or more parameters are zero is undefined, set it to zero
        if((!a and !b and !c) or (!a and !b and !d) or (!a and !c and !d) or (!b and !c and !d))
          return 0; 
        if(a == b and b == c and c == d)
           return -1./(12.*d);
        if(a == d and c == d and b == 0)
           return -1. / (8.*d);
        if(a == d and c == d)
           return (3.*b*b - 4.*b*d + d*d - 2.*b*b*log(b/d))/(8.*pow(b-d,3));
        if(b == c and c == d)
           return D27(b,a,c,d);
        if(a == b and b == c)
           return D27(a,d,c,b);
        if(a == b and b == d)
           return D27(a,c,b,d);
        if(a == b and c == d and b == 0)
          return -1./(4.*d);
        if(a == b and c == d and d == 0)
          return -1./(4.*b);
        if(a == b and c == d) 
          return (-b*b + d*d -2.*b*d*log(d/b)) / (4.*pow(b-d,3));
        if(a == c and b == d)
          return D27(a,c,b,d);
        if(a == d and b == c)
          return D27(a,b,d,c);
        if(a == b and b == 0)
          return log(d/c)/(4.*(c-d));
        if(a == b and c == 0)
          return - (b -d +d*log(d/b))/(4.*pow(b-d,2));
        if(a == b and d == 0)
          return D27(a,b,d,c);
        if(a == b)
          return 0.25*(-c*c*log(c/b)/(pow(b-c,2)*(c-d)) + (b*(d-b)/(b-c) + d*d*log(d/b)/(c-d))/pow(b-d,2));
        if(a == c)
          return D27(a,c,b,d);
        if(a == d)
          return D27(a,d,c,b);
        if(b == c and a == 0)
          return (-c+d+d*log(c/d))/(4.*pow(c-d,2));
        if(b == c and c == 0)
          return log(d/a)/(4.*(a-d));
        if(b == c and d == 0)
          return (a-c+a*log(c/a))/(4.*pow(a-c,2));
        if(b == c)
          return (c*(a-d)*(a*(c-2.*d)+c*d)*log(c/a)+(a-c)*(c*(a-d)*(c-d)+(a-c)*d*d*log(d/a)))/(4.*pow(a-c,2)*(a-d)*pow(c-d,2));
        if(b == d)
          return D27(a,b,d,c);
        if(c == d)
          return D27(a,c,d,b);
        if(a == 0)
          return (b*(-c+d)*log(b)+c*(b-d)*log(c)+(-b+c)*d*log(d))/(4.*(b-c)*(b-d)*(c-d));
        if(b == 0)
          return ((c*log(c/a))/((a - c)*(c - d)) + (d*log(d/a))/((a - d)*(-c + d)))/4.;
        if(c == 0)
          return D27(a,c,b,d);
        if(d == 0)
          return D27(a,d,c,b);
        else
          return -0.25*(b*b*log(b/a)/((b-a)*(b-c)*(b-d)) + c*c*log(c/a)/((c-a)*(c-b)*(c-d)) + d*d*log(d/a)/((d-a)*(d-b)*(d-c)));
      }

      double IC0D0(const double a, const double b, const double c, const double d)
      {
        return C0(a,b,c) + d*D0(a,b,c,d);
      }
    }

    // Loop function for RK
    namespace LoopFunctions
    {
      double E(const double x, const double y)
      {
        if(x == 0 or y == 0)
          return 0.0;
        if(x == y)
          return (x*(-4.0 + 15.0*x - 12.0*pow(x,2) + pow(x,3) + 6.0*pow(x,2)*log(x)))/ (4.*pow(-1.0 + x,3));
        return x*y*(-3.0/(4.0*(1.0-x)*(1.0 - y)) + ((0.25 - 3.0/(4.0*pow(-1.0 + x,2)) - 3.0/(2.0*(-1.0 + x)))*log(x))/(x - y) + ((0.25 - 3.0/(4.0*pow(-1.0 + y,2)) - 3.0/(2.0*(-1 + y)))*log(y))/(-x + y));
      }

    }

    // Vertices for LFV diagrams
    namespace Vertices
    {
      // Fermion-vector vertices
      complex&lt;double&gt; VpL(int i, int j, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U)
      {
        double g2 = sminputs.mW * sqrt( 8. * sminputs.GF / sqrt(2));
        return  -1. / sqrt(2) * g2 * U(i,j);
      
      }

      double EL(int i,int j, SMInputs sminputs)
      {
        if(i != j)  return 0; 

        double e = sqrt(4. * pi / sminputs.alphainv);
        double g1 = e * sminputs.mZ / sminputs.mW;
        double g2 = sminputs.mW * sqrt( 8. * sminputs.GF / sqrt(2));
        double cw = sminputs.mW / sminputs.mZ;
        double sw = sqrt(1. - cw*cw);
        return 0.5 * (-g1*sw + g2*cw);
        
      }
 
      double ER(int i, int j, SMInputs sminputs)
      {
        if(i != j) return 0;
 
        double e = sqrt(4. * pi / sminputs.alphainv);
        double g1 = e * sminputs.mZ / sminputs.mW;
        double cw = sminputs.mW / sminputs.mZ;
        double sw = sqrt(1. - cw*cw);
        return - g1*sw; 
      }

      complex&lt;double&gt; VL(int i, int j, SMInputs sminputs)
      {
        double e = sqrt(4. * pi / sminputs.alphainv);
        double g1 = e * sminputs.mZ / sminputs.mW;
        double g2 = sminputs.mW * sqrt( 8. * sminputs.GF / sqrt(2));
        double cw = sminputs.mW / sminputs.mZ;
        double sw = sqrt(1. - cw*cw);

        if(i == j)
          return -0.5*(g1*sw + g2*cw);
        else
          return 0.;
      }

      complex&lt;double&gt; VR(int i, int j, SMInputs sminputs)
      {
        double e = sqrt(4. * pi / sminputs.alphainv);
        double g1 = e * sminputs.mZ / sminputs.mW;
        double g2 = sminputs.mW * sqrt( 8. * sminputs.GF / sqrt(2));
        double cw = sminputs.mW / sminputs.mZ;
        double sw = sqrt(1. - cw*cw);

        if(i == j)
          return 0.5*(g1*sw + g2*cw);
        else
          return 0.;
      }

      complex&lt;double&gt; DL(int i, int j, SMInputs sminputs)
      {
        double e = sqrt(4. * pi / sminputs.alphainv);
        double g1 = e * sminputs.mZ / sminputs.mW;
        double g2 = sminputs.mW * sqrt( 8. * sminputs.GF / sqrt(2));
        double cw = sminputs.mW / sminputs.mZ;
        double sw = sqrt(1. - cw*cw);

        if(i == j)
          return 1./6. * (3.*g2*cw + g1*sw);
        else
          return 0;
      }

      complex&lt;double&gt; DR(int i, int j, SMInputs sminputs)
      {
        double e = sqrt(4. * pi / sminputs.alphainv);
        double g1 = e * sminputs.mZ / sminputs.mW;
        double cw = sminputs.mW / sminputs.mZ;
        double sw = sqrt(1. - cw*cw);

        if(i == j)
          return -1./3.*g1*sw;
        else
          return 0.;
      }

      complex&lt;double&gt; UL(int i, int j, SMInputs sminputs)
      {
        double e = sqrt(4. * pi / sminputs.alphainv);
        double g1 = e * sminputs.mZ / sminputs.mW;
        double g2 = sminputs.mW * sqrt( 8. * sminputs.GF / sqrt(2));
        double cw = sminputs.mW / sminputs.mZ;
        double sw = sqrt(1. - cw*cw);

        if(i == j)
          return -1./6. * (3.*g2*cw - g1*sw);
        else
          return 0;
      }

      complex&lt;double&gt; UR(int i, int j, SMInputs sminputs)
      {
        double e = sqrt(4. * pi / sminputs.alphainv);
        double g1 = e * sminputs.mZ / sminputs.mW;
        double cw = sminputs.mW / sminputs.mZ;
        double sw = sqrt(1. - cw*cw);

        if(i == j)
          return 2./3.*g1*sw;
        else
          return 0.;
      }

      complex&lt;double&gt; VuL(int i, int j, SMInputs sminputs)
      {
         double g2 = sminputs.mW * sqrt( 8. * sminputs.GF / sqrt(2));
         Eigen::Matrix3cd VCKM;
         double lambda = sminputs.CKM.lambda, A = sminputs.CKM.A;
         double rhobar = sminputs.CKM.rhobar, etabar = sminputs.CKM.etabar;
         complex&lt;double&gt; I = {0,1};

         complex&lt;double&gt; Vub = real(rhobar + I*etabar)*sqrt(1.-A*A*pow(lambda,4))/(sqrt(1.-pow(lambda,2))*(1.- A*A*pow(lambda,4)*(rhobar+I*etabar)));
         double rho = real(Vub);
         double eta = imag(Vub);

         VCKM &lt;&lt; 1. - 0.5*pow(lambda,2), lambda, A*pow(lambda,3)*(rho - I*eta),
                 -lambda, 1. - 0.5*pow(lambda,2), A*pow(lambda,2),
                 A*pow(lambda,3)*(1. - eta - I*eta), -A*pow(lambda,2), 1;

         return -1./sqrt(2) * g2 * VCKM(i,j);
      }

      // Vector vertices
      double Fw(SMInputs sminputs)
      {
        return sqrt(4.* pi/ sminputs.alphainv);
      }

      double Zww(SMInputs sminputs)
      {
        double g2 = sminputs.mW * sqrt( 8. * sminputs.GF / sqrt(2));
        return -g2 * sminputs.mW / sminputs.mZ;
      }

      // Scalar vertices
      double HL(int i, int j, SMInputs sminputs)
      {
        double vev = 1. / sqrt(sqrt(2.)*sminputs.GF);
        
        if(i == 0 and j == 0)
          return -1. / vev * sminputs.mE;
        if(i == 1 and j == 1)
          return -1. / vev * sminputs.mMu;
        if(i == 2 and j == 2)
          return -1. / vev * sminputs.mTau;
        else 
          return 0;
      }

      double HR(int i, int j, SMInputs sminputs)
      {
        return HL(i, j , sminputs);
      } 

      double HdL(int i, int j, SMInputs sminputs)
      {
        double vev = 1. / sqrt(sqrt(2.)*sminputs.GF);

        if(i == 0 and j == 0)
          return -1. / vev * sminputs.mD;
        else if(i == 1 and j == 1)
          return -1. / vev * sminputs.mS;
        else if(i == 2 and j == 2)
          return -1. / vev * sminputs.mBmB;
        else
          return 0;
      }

      double HdR(int i, int j, SMInputs sminputs)
      {
        return HdL(i, j, sminputs);
      }

      double HuL(int i, int j, SMInputs sminputs)
      {
        double vev = 1. / sqrt(sqrt(2.)*sminputs.GF);

        if(i == 0 and j == 0)
          return -1. / vev * sminputs.mU;
        else if(i == 1 and j == 1)
          return -1. / vev * sminputs.mCmC;
        else if(i == 2 and j == 2)
          return -1. / vev * sminputs.mT;
        else
          return 0;
      }

      double HuR(int i, int j, SMInputs sminputs)
      {
        return HuL(i, j, sminputs);
      }


    }

    // Penguin contributions
    namespace Penguins
    {
      // Fotonic penguins

      complex&lt;double&gt; A1R(int alpha, int beta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; mnu)
      {
        complex&lt;double&gt; a1r = {0,0};

        for(int a=0; a&lt;6; a++)
        {
          a1r += Vertices::Fw(sminputs) * Vertices::VpL(alpha,a,sminputs,U) * conj(Vertices::VpL(beta,a,sminputs,U)) * LoopFunctions::MFVV(pow(mnu[a],2), pow(sminputs.mW,2));
        }

        return a1r;
      }

      complex&lt;double&gt; A2L(int alpha, int beta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu)
      {
         complex&lt;double&gt; a2l = {0,0};
         double mW = sminputs.mW;

         for(int a=0; a&lt;6; a++)
           a2l += -2. * Vertices::Fw(sminputs) * Vertices::VpL(alpha,a,sminputs,U) * conj(Vertices::VpL(beta,a,sminputs,U)) * LoopFunctions::G1(pow(mnu[a],2), mW*mW, mW*mW) * ml[beta];

         return a2l;
      }

      complex&lt;double&gt; A2R(int alpha, int beta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu)
      {
         complex&lt;double&gt; a2r = {0,0};
         double mW = sminputs.mW;
         for(int a=0; a&lt;6; a++)
          a2r += -2. * Vertices::Fw(sminputs) * Vertices::VpL(alpha,a,sminputs,U) * conj(Vertices::VpL(beta,a,sminputs,U)) * LoopFunctions::G1(pow(mnu[a],2), mW*mW, mW*mW) * ml[alpha];

         return a2r;
      }

      // Z penguins
      complex&lt;double&gt; VZw2w4LL(int alpha, int beta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu)
      {
        complex&lt;double&gt; vzll = {0,0};
 
        for(int a=0; a&lt;6; a++)
          for(int c=0; c&lt;3; c++)
          {
            // Use MZ for the renormalization scale Q
            if(beta == c)
              vzll += Vertices::EL(beta,c, sminputs) * Vertices::VpL(alpha,a,sminputs,U) * conj(Vertices::VpL(c,a,sminputs,U)) * (1. + 2.* LoopFunctions::B1(pow(mnu[a],2),pow(sminputs.mW,2),sminputs.mZ))* pow(ml[alpha],2) / (pow(ml[alpha],2) - pow(ml[c],2));
            if(alpha == c) 
              vzll += Vertices::EL(alpha,c, sminputs) * Vertices::VpL(beta,a,sminputs,U) * conj(Vertices::VpL(c,a,sminputs,U)) * (1. + 2.* LoopFunctions::B1(pow(mnu[a],2),pow(sminputs.mW,2),sminputs.mZ))* pow(ml[beta],2) / (pow(ml[beta],2) - pow(ml[c],2));
         }

         return vzll;
      }

      complex&lt;double&gt; VZw2w4LR(int alpha, int beta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu)
      {
        return VZw2w4LL(alpha,beta,sminputs,U,ml,mnu);
      }
    
      complex&lt;double&gt; VZw2w4RR(int alpha, int beta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu)
      {
        complex&lt;double&gt; vzrr = {0,0};
 
        for(int a=0; a&lt;6; a++)
          for(int c=0; c&lt;3; c++)
          {
            if(beta == c)
              vzrr += Vertices::ER(beta,c,sminputs) * Vertices::VpL(alpha,a,sminputs,U) * conj(Vertices::VpL(c,a,sminputs,U)) * (1. + 2.* LoopFunctions::B1(pow(mnu[a],2),pow(sminputs.mW,2),sminputs.mZ))* ml[c]*ml[alpha] / (pow(ml[alpha],2) - pow(ml[c],2));
            if(alpha == c)
              vzrr += Vertices::ER(alpha,c, sminputs) * Vertices::VpL(beta,a,sminputs,U) * conj(Vertices::VpL(c,a,sminputs,U)) * (1. + 2.* LoopFunctions::B1(pow(mnu[a],2),pow(sminputs.mW,2),sminputs.mZ))* ml[c]*ml[beta] / (pow(ml[beta],2) - pow(ml[c],2));
         }

         return vzrr;
      }

      complex&lt;double&gt; VZw2w4RL(int alpha, int beta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu)
      {
        return VZw2w4RR(alpha, beta, sminputs, U, ml, mnu); 
      }

      complex&lt;double&gt; VZw8LL(int alpha, int beta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; mnu)
      {
        complex&lt;double&gt; vzll = {0,0};
        double mW = sminputs.mW;

        // Use MZ as the renormalization scale Q
    for(int a=0; a&lt;6; a++)
          vzll += Vertices::Zww(sminputs) * Vertices::VpL(alpha,a,sminputs,U) * conj(Vertices::VpL(beta,a,sminputs,U)) * (1. - 2.*(LoopFunctions::B0(mW*mW,mW*mW,sminputs.mZ) + 2.*LoopFunctions::C00(pow(mnu[a],2),mW*mW,mW*mW,sminputs.mZ) + LoopFunctions::C0(pow(mnu[a],2),mW*mW,mW*mW)*pow(mnu[a],2)));

        return vzll;
      }
    
      complex&lt;double&gt; VZw8LR(int alpha, int beta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; mnu)
      {
        return VZw8LL(alpha, beta, sminputs, U, mnu);
      }

      complex&lt;double&gt; VZw10LL(int alpha, int beta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; mnu)
      {
        complex&lt;double&gt; vzll = {0,0};
        double mW = sminputs.mW;
 
        // Use MZ as the renormalization scale Q
        for(int b=0; b&lt;6; b++)
        {
          // Use different loop function in case that mnu[b] 0
          if(mnu[b])
            vzll += - Vertices::VpL(alpha,b,sminputs,U) * conj(Vertices::VpL(beta,b,sminputs,U)) * (2.* Vertices::VR(b,b,sminputs) * LoopFunctions::C0(pow(mnu[b],2),pow(mnu[b],2),mW*mW) * mnu[b] * mnu[b] + Vertices::VL(b,b,sminputs) * (1. - 2.*(LoopFunctions::B0(pow(mnu[b],2),pow(mnu[b],2),sminputs.mZ) - 2.*LoopFunctions::C00(pow(mnu[b],2),pow(mnu[b],2),mW*mW,sminputs.mZ) + LoopFunctions::C0(pow(mnu[b],2),pow(mnu[b],2),mW*mW)*mW*mW)));
          else
            vzll += - Vertices::VpL(alpha,b,sminputs,U) * conj(Vertices::VpL(beta,b,sminputs,U)) * Vertices::VL(b,b,sminputs) * (1. - 2.*(LoopFunctions::B02C00C0(pow(mnu[b],2),pow(mnu[b],2),mW*mW,sminputs.mZ)));
        }

        return vzll;
      }

      complex&lt;double&gt; VZw10LR(int alpha, int beta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; mnu)
      {
        return VZw10LL(alpha, beta, sminputs, U, mnu);
      }

      // Sum over Z penguins
      complex&lt;double&gt; VZsumLL(int alpha, int beta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu)
      {
       return 1. / (16.*pow(pi,2)) * (VZw2w4LL(alpha, beta, sminputs, U, ml, mnu) + VZw8LL(alpha, beta, sminputs, U, mnu) + VZw10LL(alpha, beta, sminputs, U, mnu));
      }

      complex&lt;double&gt; VZsumLR(int alpha, int beta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu)
      {
        return 1. / (16.*pow(pi,2)) * (VZw2w4LR(alpha, beta, sminputs, U, ml, mnu) + VZw8LR(alpha, beta, sminputs, U, mnu) + VZw10LR(alpha, beta, sminputs, U, mnu));
      }

      complex&lt;double&gt; VZsumRL(int alpha, int beta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu)
      {
        return 1. / (16.*pow(pi,2)) * (VZw2w4RL(alpha, beta, sminputs, U, ml, mnu));
      }

      complex&lt;double&gt; VZsumRR(int alpha, int beta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu)
      {
        return 1. / (16.*pow(pi,2)) * (VZw2w4RR(alpha, beta, sminputs, U, ml, mnu));
      }

      // Scalar penguins
      complex&lt;double&gt; Shw2w4LL(int alpha, int beta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu)
      {
        complex&lt;double&gt; shll = {0,0};
        double mW = sminputs.mW;

        // Use mZ for the renormalisation scale Q
        for(int a=0; a&lt;6; a++)
          for(int c=0; c&lt;3; c++)
          {
            if(beta == c)
              shll += - (Vertices::HL(beta,c,sminputs) * Vertices::VpL(alpha,a,sminputs,U) * conj(Vertices::VpL(c,a,sminputs,U)) * (1. + 2.* LoopFunctions::B1(pow(mnu[a],2),mW*mW, sminputs.mZ)) * pow(ml[alpha],2))/(pow(ml[alpha],2) - pow(ml[c],2));
            if(alpha == c)
              shll += - (Vertices::HL(alpha,c,sminputs) * Vertices::VpL(beta,a,sminputs,U) * conj(Vertices::VpL(c,a,sminputs,U)) * (1. + 2.* LoopFunctions::B1(pow(mnu[a],2),mW*mW, sminputs.mZ)) * pow(ml[beta],2))/(pow(ml[beta],2) - pow(ml[c],2));
          }

        return shll;
      }

      complex&lt;double&gt; Shw2w4LR(int alpha, int beta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu)
      {
        return Shw2w4LL(alpha, beta, sminputs, U, ml, mnu);
      }

      complex&lt;double&gt; Shw2w4RR(int alpha, int beta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu)
      {
        complex&lt;double&gt; shrr = {0,0};
        double mW = sminputs.mW;

        // Use mZ for the renormalisation scale Q
        for(int a=0; a&lt;6; a++)
          for(int c=0; c&lt;3; c++)
          {
            if(beta == c)
              shrr += - (Vertices::HR(beta,c,sminputs) * Vertices::VpL(alpha,a,sminputs,U) * conj(Vertices::VpL(c,a,sminputs,U)) * (1. + 2.* LoopFunctions::B1(pow(mnu[a],2),mW*mW, sminputs.mZ)) * ml[c]*ml[alpha])/(pow(ml[alpha],2) - pow(ml[c],2));
            if(alpha == c)
              shrr += - (Vertices::HR(alpha,c,sminputs) * Vertices::VpL(beta,a,sminputs,U) * conj(Vertices::VpL(c,a,sminputs,U)) * (1. + 2.* LoopFunctions::B1(pow(mnu[a],2),mW*mW, sminputs.mZ)) * ml[c]*ml[beta])/(pow(ml[beta],2) - pow(ml[c],2));
          }

        return shrr;
      }

      complex&lt;double&gt; Shw2w4RL(int alpha, int beta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu)
      {
        return Shw2w4RR(alpha, beta, sminputs, U, ml, mnu);
      }

      // Sum over scalar penguins
      complex&lt;double&gt; ShsumLL(int alpha, int beta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu)
      {
        return 1. / (16.*pow(pi,2)) * Shw2w4LL(alpha, beta, sminputs, U, ml, mnu);
      }    

      complex&lt;double&gt; ShsumLR(int alpha, int beta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu)
      {
        return 1. / (16.*pow(pi,2)) * Shw2w4LR(alpha, beta, sminputs, U, ml, mnu);
      }    

      complex&lt;double&gt; ShsumRL(int alpha, int beta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu)
      {
        return 1. / (16.*pow(pi,2)) * Shw2w4RL(alpha, beta, sminputs, U, ml, mnu);
      }    

      complex&lt;double&gt; ShsumRR(int alpha, int beta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu)
      {
        return 1. / (16.*pow(pi,2)) * Shw2w4RR(alpha, beta, sminputs, U, ml, mnu);
      }    

    }

    // Box contributions
    namespace Boxes
    {
      complex&lt;double&gt; Vw4lLL(int alpha, int beta, int gamma, int delta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; mnu)
      {
        complex&lt;double&gt; vll = {0,0};
        double mW = sminputs.mW;

        for(int a=0; a&lt;6; a++)
          for(int c=0; c&lt;6; c++)
            vll += -4. * Vertices::VpL(alpha,a,sminputs,U) * conj(Vertices::VpL(beta,a,sminputs,U)) * Vertices::VpL(gamma,c,sminputs,U) * conj(Vertices::VpL(delta,c,sminputs,U)) * (LoopFunctions::IC0D0(pow(mnu[c],2),mW*mW, mW*mW, pow(mnu[a],2)) - 3. * LoopFunctions::D27(pow(mnu[a],2),pow(mnu[c],2),mW*mW,mW*mW));

        return vll;
      }

      complex&lt;double&gt; Vw8lLL(int alpha, int beta, int gamma, int delta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; mnu)
      {
        complex&lt;double&gt; vll = {0,0};
        double mW = sminputs.mW;

        for(int a=0; a&lt;6; a++)
          for(int c=0; c&lt;6; c++)
            vll += -2. * Vertices::VpL(alpha,a,sminputs,U) * conj(Vertices::VpL(delta,c,sminputs,U)) * Vertices::VpL(gamma,a,sminputs,U) * conj(Vertices::VpL(beta,c,sminputs,U)) * mnu[a] * mnu[c] * LoopFunctions::D0(pow(mnu[a],2),pow(mnu[c],2),mW*mW,mW*mW);

        return vll;
      }

      complex&lt;double&gt; Vw4lpLL(int alpha, int beta, int gamma, int delta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; mnu)
      {
        return Vw4lLL(alpha, delta, gamma, beta, sminputs, U, mnu);
      }

      complex&lt;double&gt; Vw8lpLL(int alpha, int beta, int gamma, int delta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; mnu)
      {
        return Vw8lLL(alpha, delta, gamma, beta, sminputs, U, mnu);
      }

      complex&lt;double&gt; Vw4dLL(int alpha, int beta, int gamma, int delta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; mnu)
      {
        complex&lt;double&gt; vll = {0,0};
        double mW = sminputs.mW;
        vector&lt;double&gt; mu = {sminputs.mU, sminputs.mCmC, sminputs.mT};

        for(int a=0; a&lt;6; a++)
          for(int c=0; c&lt;3; c++)
            vll += -4.*Vertices::VpL(alpha,a,sminputs,U)*conj(Vertices::VpL(beta,a,sminputs,U))*Vertices::VuL(gamma,c,sminputs)*conj(Vertices::VuL(delta,c,sminputs))*(LoopFunctions::IC0D0(pow(mu[c],2),mW*mW, mW*mW, pow(mnu[a],2)) - 3.*LoopFunctions::D27(pow(mnu[a],2),pow(mu[c],2),mW*mW,mW*mW));

        return vll;
      }

      complex&lt;double&gt; Vw4uLL(int alpha, int beta, int gamma, int delta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; mnu)
      {
        complex&lt;double&gt; vll = {0,0};
        double mW = sminputs.mW;
        vector&lt;double&gt; md = {sminputs.mD, sminputs.mS, sminputs.mBmB};

        for(int a=0; a&lt;6; a++)
          for(int c=0; c&lt;3; c++)
            vll += 16.*Vertices::VpL(alpha,a,sminputs,U)*conj(Vertices::VpL(beta,a,sminputs,U))*Vertices::VuL(delta,c,sminputs)*conj(Vertices::VuL(gamma,c,sminputs))*LoopFunctions::D27(pow(mnu[a],2),pow(md[c],2),mW*mW,mW*mW);

        return vll;
      }

      // Sum over boxes
      complex&lt;double&gt; VsumlLL(int alpha, int beta, int gamma, int delta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; mnu)
      {
        return 1. / (16.*pow(pi,2)) *( Vw4lLL(alpha, beta, gamma, delta, sminputs, U, mnu) + Vw8lLL(alpha, beta, gamma, delta, sminputs, U, mnu) + Vw4lpLL(alpha, beta, gamma, delta, sminputs, U, mnu) + Vw8lpLL(alpha, beta, gamma, delta, sminputs, U, mnu));
      }

      complex&lt;double&gt; VsumdLL(int alpha, int beta, int gamma, int delta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; mnu)
      {
        return 1./(16.*pow(pi,2)) *Vw4dLL(alpha, beta, gamma, delta, sminputs, U, mnu);
      }

      complex&lt;double&gt; VsumuLL(int alpha, int beta, int gamma, int delta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; mnu)
      {
        return 1./(16.*pow(pi,2)) *Vw4uLL(alpha, beta, gamma, delta, sminputs, U, mnu);
      }

    } // Diagrams


    // Form factors for LFV diagrams
    namespace FormFactors
    {

      complex&lt;double&gt; K1R(int alpha, int beta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; mnu)
      {
        double e = sqrt(4. * pi / sminputs.alphainv);
 
        return 1. / (16*pow(pi,2)*e) * Penguins::A1R(alpha, beta, sminputs, U, mnu);
      }

      complex&lt;double&gt; K2L(int alpha, int beta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu)
      {
        double e = sqrt(4. * pi / sminputs.alphainv);

        return 1. / (2. * 16.*pow(pi,2) * e * ml[alpha] ) * Penguins::A2L(alpha, beta, sminputs, U, ml, mnu);
      }

      complex&lt;double&gt; K2R(int alpha, int beta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu)
      {
        double e = sqrt(4. * pi / sminputs.alphainv);

        return 1. / (2. * 16.*pow(pi,2)*  e * ml[alpha] ) * Penguins::A2R(alpha, beta, sminputs, U, ml, mnu);
      }

      complex&lt;double&gt; AVLL(int alpha, int beta, int gamma, int delta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu)
      {
        return Penguins::VZsumLL(alpha,beta,sminputs,U,ml,mnu)*Vertices::EL(gamma,delta,sminputs) / pow(sminputs.mZ,2) + Boxes::VsumlLL(alpha,beta,gamma,delta,sminputs,U,mnu);
      }

      complex&lt;double&gt; AVLR(int alpha, int beta, int gamma, int delta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu)
      {
        return Penguins::VZsumLR(alpha,beta,sminputs,U,ml,mnu)*Vertices::ER(gamma,delta,sminputs) / pow(sminputs.mZ,2);
      }

      complex&lt;double&gt; AVRL(int alpha, int beta, int gamma, int delta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu)
      {
        return Penguins::VZsumRL(alpha,beta,sminputs,U,ml,mnu)*Vertices::EL(gamma,delta,sminputs) / pow(sminputs.mZ,2);
      }

     complex&lt;double&gt; AVRR(int alpha, int beta, int gamma, int delta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu)
      {
        return Penguins::VZsumRR(alpha,beta,sminputs,U,ml,mnu)*Vertices::ER(gamma,delta,sminputs) / pow(sminputs.mZ,2);
      }

      complex&lt;double&gt; ASLL(int alpha, int beta, int gamma, int delta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu, double mh)
      {
        return Penguins::ShsumLL(alpha,beta,sminputs,U,ml,mnu)*Vertices::HL(gamma,delta,sminputs) / pow(mh,2);
      }

      complex&lt;double&gt; ASLR(int alpha, int beta, int gamma, int delta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu, double mh)
      {
        return Penguins::ShsumLR(alpha,beta,sminputs,U,ml,mnu)*Vertices::HR(gamma,delta,sminputs) / pow(mh,2);
      }

      complex&lt;double&gt; ASRL(int alpha, int beta, int gamma, int delta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu, double mh)
      {
        return Penguins::ShsumRL(alpha,beta,sminputs,U,ml,mnu)*Vertices::HL(gamma,delta,sminputs) / pow(mh,2);
      }

      complex&lt;double&gt; ASRR(int alpha, int beta, int gamma, int delta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu, double mh)
      {
        return Penguins::ShsumRR(alpha,beta,sminputs,U,ml,mnu)*Vertices::HR(gamma,delta,sminputs) / pow(mh,2);
      }

      complex&lt;double&gt; BVLL(int alpha, int beta, int gamma, int delta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu)
      {
        return Penguins::VZsumLL(alpha,beta,sminputs,U,ml,mnu)*Vertices::DL(gamma,delta,sminputs) / pow(sminputs.mZ,2) + Boxes::VsumdLL(alpha,beta,gamma,delta,sminputs,U,mnu);
      }

      complex&lt;double&gt; BVLR(int alpha, int beta, int gamma, int delta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu)
      {
        return Penguins::VZsumLR(alpha,beta,sminputs,U,ml,mnu)*Vertices::DR(gamma,delta,sminputs) / pow(sminputs.mZ,2);
      }

      complex&lt;double&gt; BVRL(int alpha, int beta, int gamma, int delta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu)
      {
        return Penguins::VZsumRL(alpha,beta,sminputs,U,ml,mnu)*Vertices::DL(gamma,delta,sminputs) / pow(sminputs.mZ,2);
      }

     complex&lt;double&gt; BVRR(int alpha, int beta, int gamma, int delta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu)
      {
        return Penguins::VZsumRR(alpha,beta,sminputs,U,ml,mnu)*Vertices::DR(gamma,delta,sminputs) / pow(sminputs.mZ,2);
      }

      complex&lt;double&gt; BSLL(int alpha, int beta, int gamma, int delta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu, double mh)
      {
        return Penguins::ShsumLL(alpha,beta,sminputs,U,ml,mnu)*Vertices::HdL(gamma,delta,sminputs) / pow(mh,2);
      }

      complex&lt;double&gt; BSLR(int alpha, int beta, int gamma, int delta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu, double mh)
      {
        return Penguins::ShsumLR(alpha,beta,sminputs,U,ml,mnu)*Vertices::HdR(gamma,delta,sminputs) / pow(mh,2);
      }

      complex&lt;double&gt; BSRL(int alpha, int beta, int gamma, int delta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu, double mh)
      {
        return Penguins::ShsumRL(alpha,beta,sminputs,U,ml,mnu)*Vertices::HdL(gamma,delta,sminputs) / pow(mh,2);
      }

      complex&lt;double&gt; BSRR(int alpha, int beta, int gamma, int delta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu, double mh)
      {
        return Penguins::ShsumRR(alpha,beta,sminputs,U,ml,mnu)*Vertices::HdR(gamma,delta,sminputs) / pow(mh,2);
      }

      complex&lt;double&gt; CVLL(int alpha, int beta, int gamma, int delta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu)
      {
        return Penguins::VZsumLL(alpha,beta,sminputs,U,ml,mnu)*Vertices::UL(gamma,delta,sminputs) / pow(sminputs.mZ,2) + Boxes::VsumuLL(alpha,beta,gamma,delta,sminputs,U,mnu);
      }

      complex&lt;double&gt; CVLR(int alpha, int beta, int gamma, int delta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu)
      {
        return Penguins::VZsumLR(alpha,beta,sminputs,U,ml,mnu)*Vertices::UR(gamma,delta,sminputs) / pow(sminputs.mZ,2);
      }

      complex&lt;double&gt; CVRL(int alpha, int beta, int gamma, int delta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu)
      {
        return Penguins::VZsumRL(alpha,beta,sminputs,U,ml,mnu)*Vertices::UL(gamma,delta,sminputs) / pow(sminputs.mZ,2);
      }

      complex&lt;double&gt; CVRR(int alpha, int beta, int gamma, int delta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu)
      {
        return Penguins::VZsumRR(alpha,beta,sminputs,U,ml,mnu)*Vertices::UR(gamma,delta,sminputs) / pow(sminputs.mZ,2);
      }

      complex&lt;double&gt; CSLL(int alpha, int beta, int gamma, int delta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu, double mh)
      {
        return Penguins::ShsumLL(alpha,beta,sminputs,U,ml,mnu)*Vertices::HuL(gamma,delta,sminputs) / pow(mh,2);
      }

      complex&lt;double&gt; CSLR(int alpha, int beta, int gamma, int delta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu, double mh)
      {
        return Penguins::ShsumLR(alpha,beta,sminputs,U,ml,mnu)*Vertices::HuR(gamma,delta,sminputs) / pow(mh,2);
      }

      complex&lt;double&gt; CSRL(int alpha, int beta, int gamma, int delta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu, double mh)
      {
        return Penguins::ShsumRL(alpha,beta,sminputs,U,ml,mnu)*Vertices::HuL(gamma,delta,sminputs) / pow(mh,2);
      }

      complex&lt;double&gt; CSRR(int alpha, int beta, int gamma, int delta, SMInputs sminputs, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U, vector&lt;double&gt; ml, vector&lt;double&gt; mnu, double mh)
      {
        return Penguins::ShsumRR(alpha,beta,sminputs,U,ml,mnu)*Vertices::HuR(gamma,delta,sminputs) / pow(mh,2);
      }

    } // Form Factors
  }
}

#endif //#defined __flav_loop_functions_hpp__
</code></pre><hr><p>Updated on 2022-07-20 at 17:18:45 +0000</p><div class=edit-page><a href=https://github.com/RC1242RC/gambit_gh_pages/blob/master/content/en/documentation/code/Files/flav__loop__functions_8hpp.md><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828.0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>Edit this page on GitHub</a></div></main></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Powered by <a class=text-muted href=https://www.netlify.com/>Netlify</a>, <a class=text-muted href=https://gohugo.io/>Hugo</a>, and <a class=text-muted href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline><li class=list-inline-item><a href=/main_development/license/>License</a></li></ul></div></div></div></footer><script src=/main_development/js/bootstrap.min.54bf0932b8a36d0e152b1635b099a6ef1394d35327e2437550a075c9c8ed1bd8aed5847c21b36fc02ed24014c031d9ca24017b0c78b1639d7e2fa8329898b842.js integrity="sha512-VL8JMrijbQ4VKxY1sJmm7xOU01Mn4kN1UKB1ycjtG9iu1YR8IbNvwC7SQBTAMdnKJAF7DHixY51+L6gymJi4Qg==" crossorigin=anonymous defer></script>
<script src=/main_development/js/highlight.min.5b48bc253dc75aeea5fb366ecf700f4925e2b6eb1a1466f2124b722d68148d67bc0a9365d2b8ad9c585161b46372d23b08509a16f1fd518542b894756d4752d0.js integrity="sha512-W0i8JT3HWu6l+zZuz3APSSXitusaFGbyEktyLWgUjWe8CpNl0ritnFhRYbRjctI7CFCaFvH9UYVCuJR1bUdS0A==" crossorigin=anonymous defer></script>
<script src=/main_development/main.min.40265e9a032aeba5eaf67baac3cbbc22667a7533215d326eeb3e9f4d5e4be40f9ff4dcd22949db73ae527ca26a19d7998091a8973c82af760b2c0daa335190ed.js integrity="sha512-QCZemgMq66Xq9nuqw8u8ImZ6dTMhXTJu6z6fTV5L5A+f9NzSKUnbc65SfKJqGdeZgJGolzyCr3YLLA2qM1GQ7Q==" crossorigin=anonymous defer></script>
<script src=https://rc1242rc.github.io/main_development/index.min.2e958d3be0c5b27cae804290be7a3d5ff0b6d3ca87ab76eeeeb88dbe22b3f251bcc80b638457f7977802ccdc9ff51bd15b8e424e00a8ab3a22c4c1ab6824d4ad.js integrity="sha512-LpWNO+DFsnyugEKQvno9X/C208qHq3bu7riNviKz8lG8yAtjhFf3l3gCzNyf9RvRW45CTgCoqzoixMGraCTUrQ==" crossorigin=anonymous defer></script></body></html>