<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=https://rc1242rc.github.io/main_development/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://rc1242rc.github.io/main_development/fonts/vendor/jost/jost-v4-latin-500.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://rc1242rc.github.io/main_development/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><script>(()=>{var e=localStorage.getItem("theme");e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><link rel=stylesheet href=https://rc1242rc.github.io/main_development/main.1fa2debdf0a1b20e7268d11906902449af896197928a5bdae9dca95b629cdd73746db3d8c6afacb7320d9deb149a318c764669d08a1ddfd34a657ab2aeab866a.css integrity="sha512-H6LevfChsg5yaNEZBpAkSa+JYZeSilva6dypW2Kc3XN0bbPYxq+stzINnesUmjGMdkZp0Iod39NKZXqyrquGag==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>file modules/classutils.py - GAMBIT</title><meta name=description content="[No description available]"><link rel=canonical href=https://rc1242rc.github.io/main_development/documentation/code/files/classutils_8py/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="file modules/classutils.py"><meta property="og:description" content="[No description available]"><meta property="og:url" content="https://rc1242rc.github.io/main_development/documentation/code/files/classutils_8py/"><meta property="og:site_name" content="GAMBIT"><meta property="og:image" content="https://rc1242rc.github.io/main_development/gambit_logo.png"><meta property="og:image:alt" content="GAMBIT"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content><meta name=twitter:creator content><meta name=twitter:title content="file modules/classutils.py"><meta name=twitter:description content="[No description available]"><meta name=twitter:image content="https://rc1242rc.github.io/main_development/gambit_logo.png"><meta name=twitter:image:alt content="file modules/classutils.py"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://rc1242rc.github.io/#/schema/organization/1","name":"Doks","url":"https://rc1242rc.github.io/","sameAs":["https://github.com/GambitBSM"],"logo":{"@type":"ImageObject","@id":"https://rc1242rc.github.io/#/schema/image/1","url":"https://rc1242rc.github.io/logo-doks.png","width":450,"height":416,"caption":"Doks"},"image":{"@id":"https://rc1242rc.github.io/#/schema/image/1"}},{"@type":"WebSite","@id":"https://rc1242rc.github.io/#/schema/website/1","url":"https://rc1242rc.github.io/","name":"GAMBIT","description":"Documentation for the Global And Modular BSM Inference Tool","publisher":{"@id":"https://rc1242rc.github.io/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://rc1242rc.github.io/main_development/documentation/code/files/classutils_8py/","url":"https://rc1242rc.github.io/main_development/documentation/code/files/classutils_8py/","name":"file modules\/classutils.py","description":"[No description available]","isPartOf":{"@id":"https://rc1242rc.github.io/#/schema/website/1"},"about":{"@id":"https://rc1242rc.github.io/#/schema/organization/1"},"datePublished":"0001-01-01T00:00:00CET","dateModified":"0001-01-01T00:00:00CET","breadcrumb":{"@id":"https://rc1242rc.github.io/main_development/documentation/code/files/classutils_8py/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://rc1242rc.github.io/main_development/documentation/code/files/classutils_8py/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://rc1242rc.github.io/main_development/documentation/code/files/classutils_8py/"]}]},{"@type":"BreadcrumbList","@id":"https://rc1242rc.github.io/main_development/documentation/code/files/classutils_8py/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/main_development","url":"https://rc1242rc.github.io/main_development","name":"Home"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/main_development/documentation/","url":"https://rc1242rc.github.io/main_development/documentation/","name":"Documentation"}},{"@type":"ListItem","position":4,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/main_development/documentation/code/","url":"https://rc1242rc.github.io/main_development/documentation/code/","name":"Code"}},{"@type":"ListItem","position":5,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/main_development/documentation/code/files/","url":"https://rc1242rc.github.io/main_development/documentation/code/files/","name":"Files"}},{"@type":"ListItem","position":6,"item":{"@id":"https://rc1242rc.github.io/main_development/documentation/code/files/classutils_8py/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://rc1242rc.github.io/main_development/documentation/code/files/classutils_8py/#/schema/image/2","url":"https://rc1242rc.github.io/main_development/gambit_logo.png","contentUrl":"https://rc1242rc.github.io/main_development/gambit_logo.png","caption":"file modules\/classutils.py"}]}]}</script><meta name=theme-color content="#fff"><link rel=icon href=https://rc1242rc.github.io/main_development/favicon.ico sizes=any><link rel=icon type=image/svg+xml href=https://rc1242rc.github.io/main_development/favicon.svg><link rel=apple-touch-icon sizes=180x180 href=https://rc1242rc.github.io/main_development/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://rc1242rc.github.io/main_development/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://rc1242rc.github.io/main_development/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://rc1242rc.github.io/main_development/site.webmanifest></head><body class="documentation single light"><div class=sticky-top><div class=header-bar></div><header class="navbar navbar-expand-md navbar-light doks-navbar"><nav class="container-xxl flex-wrap flex-md-nowrap" aria-label="Main navigation"><a class="navbar-brand p-0 me-auto" href=/ aria-label=GAMBIT><img class=logo-light src=gambit_logo.png width=50px>
<img class="logo-dark d-none" src=gambit_logo.png width=50px>
GAMBIT</a>
<button class="btn btn-menu order-2 d-block d-lg-none" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasDoks aria-controls=offcanvasDoks aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><div class="offcanvas offcanvas-end border-0 py-lg-1" tabindex=-1 id=offcanvasDoks data-bs-backdrop=true aria-labelledby=offcanvasDoksLabel><div class="header-bar d-lg-none"></div><div class="offcanvas-header d-lg-none"><h2 class="h5 offcanvas-title ps-2" id=offcanvasDoksLabel><a class=text-dark href=/>GAMBIT</a></h2><button type=button class="btn-close text-reset me-2" data-bs-dismiss=offcanvas aria-label="Close main menu"></button></div><div class="offcanvas-body p-4 p-lg-0"><ul class="nav flex-column flex-lg-row align-items-lg-center mt-2 mt-lg-0 ms-lg-2 me-lg-auto"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Documentation
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/main_development/documentation/installation/introduction/>Installation</a></li><li><a class=dropdown-item href=/main_development/documentation/examples/colliderbit>Examples</a></li><li><a class=dropdown-item href=/main_development/documentation/help/faqs/>Help</a></li><li><a class=dropdown-item href=/main_development/documentation/code/index_classes>Code Reference</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Community
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/main_development/community/publications/>Publications</a></li><li><a class=dropdown-item href=/main_development/community/talks/>Talks</a></li><li><a class=dropdown-item href=/main_development/community/members/>Members</a></li><li><a class=dropdown-item href=/main_development/community/code_of_conduct/>Code of Conduct</a></li><li><a class=dropdown-item href=/main_development/community/contact/>Contact</a></li></ul></li></ul><hr class="text-black-50 my-4 d-lg-none"><form class="doks-search position-relative flex-grow-1 ms-lg-auto me-lg-2"><input id=search class="form-control is-search" type=search placeholder="Search site..." aria-label="Search site..." autocomplete=off><div id=suggestions class="shadow bg-white rounded d-none"></div></form><hr class="text-black-50 my-4 d-lg-none"><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=https://github.com/GambitBSM><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><small class="ms-2 d-lg-none">GitHub</small></a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn btn-doks-light dropdown-toggle" id=doks-versions data-bs-toggle=dropdown aria-expanded=false data-bs-display=static aria-label="Toggle version menu">
<span class=d-none>Doks</span> Main Development
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=doks-versions><li><a class=dropdown-item href=/main%20development/documentation/code/index_classes/>Main Development</a></li><li><a class=dropdown-item href=/testbit/documentation/code/index_classes/>TestBit</a></li></ul></div></div></div></nav></header></div><div class="wrap container-xxl" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class=docs-links aria-label="Main navigation"><ul class="list-unstyled collapsible-sidebar"><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-installation aria-expanded=false>
Installation</button><div class=collapse id=section-installation><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/main_development/documentation/installation/introduction/>Getting Started</a></li><li><a class="docs-link rounded" href=/main_development/documentation/installation/docker_usage/>Docker Usage</a></li><li><a class="docs-link rounded" href=/main_development/documentation/installation/installation_for_linux/>Installation for Linux</a></li><li><a class="docs-link rounded" href=/main_development/documentation/installation/installation_for_windows/>Installation for Windows</a></li><li><a class="docs-link rounded" href=/main_development/documentation/installation/installation_for_macos/>Installation for macOS</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-examples aria-expanded=false>
Examples</button><div class=collapse id=section-examples><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/main_development/documentation/examples/colliderbit/>ColliderBit</a></li><li><a class="docs-link rounded" href=/main_development/documentation/examples/anotherbit/>AnotherBit</a></li><li><a class="docs-link rounded" href=/main_development/documentation/examples/anotherbit2/>AnotherBit2</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-help aria-expanded=false>
Help</button><div class=collapse id=section-help><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/main_development/documentation/help/faqs/>FAQs</a></li><li><a class="docs-link rounded" href=/main_development/documentation/help/compiler_matrix/>Compiler Matrix</a></li><li><a class="docs-link rounded" href=/main_development/documentation/help/known_issues/>Known Issues</a></li><li><a class="docs-link rounded" href=/main_development/documentation/help/configuration_examples/>Configuration Examples</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-code aria-expanded=false>
Code Reference</button><div class=collapse id=section-code><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/main_development/documentation/code/index_classes/>Classes</a></li><li><a class="docs-link rounded" href=/main_development/documentation/code/index_files/>Files</a></li><li><a class="docs-link rounded" href=/main_development/documentation/code/index_pages/>Pages</a></li><li><a class="docs-link rounded" href=/main_development/documentation/code/index_namespaces/>Namespaces</a></li></ul></div></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=d-xl-none><button class="btn btn-outline-primary btn-sm doks-toc-toggle collapsed" type=button data-bs-toggle=collapse data-bs-target=#onThisPage aria-controls=doks-docs-nav aria-expanded=false aria-label="Toggle On this page navigation">
<span>On this page</span>
<span><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"/><polyline points="7 6 12 11 17 6"/></svg><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"/><polyline points="17 18 12 13 7 18"/></svg></span></button><div class=collapse id=onThisPage><div class="card card-body mt-3 py-1"><div class=page-links><nav id=TableOfContents><ul><li><ul><li><a href=#namespaces>Namespaces</a></li><li><a href=#source-code>Source code</a></li></ul></li></ul></nav></div></div></div></div><div class="page-links d-none d-xl-block"><h3>On this page</h3><nav id=TableOfContents><ul><li><ul><li><a href=#namespaces>Namespaces</a></li><li><a href=#source-code>Source code</a></li></ul></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9 mx-xl-auto"><h1>file modules/classutils.py</h1><p class=lead></p><p>[No description available]</p><h2 id=namespaces>Namespaces <a href=#namespaces class=anchor aria-hidden=true>#</a></h2><table><thead><tr><th>Name</th></tr></thead><tbody><tr><td><strong><a href=/documentation/code/namespaces/namespacemodules_1_1classutils/>modules::classutils</a></strong></td></tr></tbody></table><h2 id=source-code>Source code <a href=#source-code class=anchor aria-hidden=true>#</a></h2><pre><code>

from __future__ import print_function
from collections import OrderedDict
import os

# import modules.cfg as cfg
import modules.active_cfg as active_cfg
exec(&quot;import configs.&quot; + active_cfg.module_name + &quot; as cfg&quot;)
import modules.gb as gb
import modules.funcutils as funcutils
import modules.utils as utils
import modules.exceptions as exceptions
import modules.infomsg as infomsg


# ====== getAbstractClassName ========

def getAbstractClassName(input_name, prefix=gb.abstr_class_prefix, short=False):

    if '::' in input_name:
        namespaces, short_class_name = input_name.rsplit('::',1)
        abstract_class_name = namespaces + '::' + gb.abstr_class_prefix + short_class_name
    else:
        abstract_class_name = gb.abstr_class_prefix + input_name

    if short == True:
        return abstract_class_name.rsplit('::',1)[-1]
    else:
        return abstract_class_name

# ====== END: getAbstractClassName ========


# ====== constrEmptyTemplClassDecl ========

def constrEmptyTemplClassDecl(abstr_class_name_short, namespaces, template_bracket, indent=4):

    n_indents  = len(namespaces)
    class_decl = ''

    class_decl += utils.constrNamespace(namespaces, 'open')

    class_decl += ' '*n_indents*indent + 'template ' + template_bracket + '\n'
    class_decl += ' '*n_indents*indent + 'class ' + abstr_class_name_short + ' {};\n'

    class_decl += utils.constrNamespace(namespaces, 'close')
    
    class_decl += '\n'

    return class_decl

# ====== END: constrEmptyTemplClassDecl ========



# ====== constrTemplForwDecl ========

def constrTemplForwDecl(class_name_short, namespaces, template_bracket, indent=4):

    n_indents = len(namespaces)
    forw_decl = ''

    forw_decl += utils.constrNamespace(namespaces, 'open')

    forw_decl += ' '*n_indents*indent + 'template ' + template_bracket + '\n'
    forw_decl += ' '*n_indents*indent + 'class ' + class_name_short + ';\n'

    forw_decl += utils.constrNamespace(namespaces, 'close')
    
    forw_decl += '\n'

    return forw_decl

# ====== END: constrTemplForwDecl ========



# ====== constrAbstractClassDecl ========

def constrAbstractClassDecl(class_el, class_name, abstr_class_name, namespaces, indent=4, file_for_gambit=False, template_types=[], has_copy_constructor=True, construct_assignment_operator=True):

    n_indents = len(namespaces)

    # Check template_types argument:
    if len(template_types) &gt; 0:
        is_template = True

    else:
        is_template = False


    # Create list of all 'non-artificial' members of the class
    member_elements = utils.getMemberElements(class_el, include_artificial=False)


    # Get list of dicts with info on parent classes
    parent_classes = utils.getParentClasses(class_el)


    #
    # Construct the abstract class declaration
    #
    
    class_decl = ''

    # - Construct the beginning of the namespaces
    class_decl += utils.constrNamespace(namespaces, 'open')

    # - If this class is a template specialization, add 'template &lt;&gt;' at the top
    if is_template == True:
        class_decl += ' '*n_indents*indent + 'template &lt;&gt;\n'

    # - Construct the declaration line, with inheritance of abstract classes
    inheritance_line = ''
    for parent_dict in parent_classes:

        if parent_dict['loaded']:
            inheritance_line += 'virtual ' + parent_dict['access'] + ' ' + parent_dict['abstr_class_name']['long_templ'] + ', '

        elif parent_dict['fundamental'] or parent_dict['std']:
            # inheritance_line += 'virtual ' + parent_dict['access'] + ' ' + parent_dict['class_name']['long_templ'] + ', '
            reason = 'Avoid inheritance ambiguity.'
            infomsg.ParentClassIgnored(abstr_class_name['short'], parent_dict['class_name']['long_templ'], reason).printMessage()

        else:
            reason = 'Not loaded or accepted type.'
            infomsg.ParentClassIgnored(abstr_class_name['short'], parent_dict['class_name']['long_templ'], reason).printMessage()
            continue
    inheritance_line = inheritance_line.rstrip(', ')

    # If no other parent classes, add AbstractBase
    if inheritance_line == '':
        inheritance_line = ' : public virtual AbstractBase'
    else:
        inheritance_line = ' : ' + inheritance_line



    class_decl += ' '*n_indents*indent
    if is_template:
        class_decl += 'class ' + abstr_class_name['short'] + '&lt;' + ','.join(template_types) + '&gt;' + inheritance_line + '\n'
    else:
        class_decl += 'class ' + abstr_class_name['short'] + inheritance_line + '\n'

    # - Construct body of class declaration
    current_access = ''
    class_decl += ' '*n_indents*indent
    class_decl += '{' + '\n'
    done_members = []
    ptr_members_for_init = []

    for el in member_elements:

        # Check access
        element_access = el.get('access')

        if element_access != 'public':
            continue

        if current_access != element_access:
            class_decl += ' '*(n_indents+1)*indent
            class_decl += element_access + ':' +'\n'
            current_access = element_access

        #
        # Add code based on what element type this is
        #
        if el.tag in ['Constructor', 'Destructor']:
            pass   # (An empty virtual destructor will be added later)

        elif el.tag in ['Method', 'OperatorMethod']:

            # Check if this is an operator function
            is_operator = False
            if el.tag == 'OperatorMethod':
                is_operator = True

            # Check if this member function should be ignored.
            if funcutils.ignoreFunction(el):
                # infomsg.IgnoredMemberFunction( is_operator*'operator' + el.get('name') ).printMessage()
                continue

            # Check if this member function makes use of loaded types
            uses_loaded_type = funcutils.usesLoadedType(el)

            return_type_dict = utils.findType( gb.id_dict[el.get('returns')] )
            return_el     = return_type_dict['el']
            pointerness   = return_type_dict['pointerness']
            is_ref        = return_type_dict['is_reference']
            return_kw     = return_type_dict['cv_qualifiers']

            return_kw_str = ' '.join(return_kw) + ' '*bool(len(return_kw))
            return_type   = return_type_dict['name'] + '*'*pointerness + '&amp;'*is_ref

            return_is_loaded = utils.isLoadedClass(return_el)
            args = funcutils.getArgs(el)
            w_args = funcutils.constrWrapperArgs(args, add_ref=True)

            # If return type is a known class, add '::' for absolute namespace.
            if (not return_is_loaded) and utils.isKnownClass(return_el):
                return_type = '::' + return_type 


            # Check constness
            if ('const' in el.keys()) and (el.get('const')=='1'):
                is_const = True
            else:
                is_const = False


            # If default arguments are used, we need to generate overloaded versions
            n_overloads = funcutils.numberOfDefaultArgs(el)

            # One overloaded version for each set of default arguments
            for remove_n_args in range(n_overloads+1):

                if remove_n_args == 0:
                    use_args   = args
                    use_w_args = w_args
                else:
                    use_args   = args[:-remove_n_args]
                    use_w_args = w_args[:-remove_n_args]


                w_args_bracket = funcutils.constrArgsBracket(use_w_args, include_arg_name=True, include_arg_type=True, include_namespace=True)
                w_args_bracket_notypes = funcutils.constrArgsBracket(use_w_args, include_arg_name=True, include_arg_type=False)
                w_args_bracket_nonames = funcutils.constrArgsBracket(use_w_args, include_arg_name=False, include_arg_type=True, include_namespace=True)

                if is_operator:
                    if uses_loaded_type:
                        w_func_name = 'operator_' + gb.operator_names[el.get('name')] + gb.code_suffix
                    else:
                        w_func_name = 'operator' + el.get('name')    
                else:
                    if uses_loaded_type or (remove_n_args&gt;0):
                        w_func_name = el.get('name') + gb.code_suffix 
                    else:
                        w_func_name = el.get('name')

                #
                # If the method makes use of a loaded class, construct a pair of wrapper methods.
                #
                if uses_loaded_type:

                    # Construct the virtual member function that is overridden, e.g.:  
                    #
                    #   virtual X* getX_GAMBIT(arguments) {}
                    #

                    if return_is_loaded:
                        if is_ref:
                            # w_return_type = toWrapperType(return_type, include_namespace=True, include_global_namespace=True)
                            w_return_type = toAbstractType(return_type, include_namespace=True)
                        elif (not is_ref) and (pointerness &gt; 0):
                            w_return_type = toAbstractType(return_type, include_namespace=True)
                        else:
                            w_return_type = toAbstractType(return_type, include_namespace=True, add_pointer=True, remove_reference=True)
                    else:
                        w_return_type = return_type

                    class_decl += '\n'
                    class_decl += ' '*(n_indents+2)*indent
                    class_decl += 'virtual ' + return_kw_str + w_return_type + ' ' + w_func_name + w_args_bracket_nonames + is_const*' const' + ' =0;' + '\n'


                #
                # If the method does not make use of any loaded class, construct a single virtual method
                #
                else:
                    class_decl += '\n'
                    class_decl += ' '*(n_indents+2)*indent
                    class_decl += 'virtual ' + return_kw_str + return_type + ' ' + w_func_name + w_args_bracket_nonames + is_const*' const' + ' =0;' + '\n'


        #
        # If element is a public member variable of accepted type, construct virtual method that returns a reference to this variable
        #
        elif (el.tag in ('Field', 'Variable')) and (el.get('access') == 'public') and isAcceptedMemberVariable(el):

            class_decl += '\n' 
            class_decl += constrVariableRefFunction(el, virtual=True, indent=indent, n_indents=n_indents+2)

            # For member variables that are of type pointer-to-loaded-class, create a pointer-to-wrapper-class member variable
            if utils.isLoadedClass(el):
                
                el_type_dict = utils.findType(el)
                
                pointerness = el_type_dict['pointerness']
                is_ref      = el_type_dict['is_reference']
                
                if (pointerness &gt; 0) and (not is_ref):
                    el_type       = el_type_dict['name'] + '*'*pointerness
                    variable_name = el.get('name') + gb.code_suffix
                    
                    class_decl += ' '*(n_indents+2)*indent + el_type + ' ' + variable_name + ';\n'

                    # Register variable name so that it can be initialized in the constructor
                    ptr_members_for_init.append(variable_name)

        #
        # Ignore element
        #
        else:
            pass
    
    # - Member functions of the abstract class living in GAMBIT should never be called. If that happens, something is very wrong. 
    general_boss_warning = 'BOSS WARNING: Problem detected with the BOSSed class %s from backend %s. The function %s::%s in GAMBIT should never have been called...'

    # - Construct 'pointer_assign' and 'pointer_copy' functions
    if class_name['long_templ'] in gb.contains_pure_virtual_members:
        reason = &quot;Contains pure virtual member functions.&quot;
        infomsg.NoPointerCopyAndAssignmentFunctions(class_name['long_templ'], reason).printMessage()
    else:
        class_decl += '\n'
        if has_copy_constructor or construct_assignment_operator:
            class_decl += ' '*(n_indents+1)*indent + 'public:\n'
        if construct_assignment_operator:
            for parent_dict in parent_classes:
                if (parent_dict['loaded']) and (parent_dict['class_name']['long_templ'] not in gb.contains_pure_virtual_members):
                    class_decl += ' '*(n_indents+2)*indent + 'using ' + parent_dict['abstr_class_name']['long_templ'] + '::pointer_assign' + gb.code_suffix + ';\n'
            class_decl += constrPtrAssignFunc(class_el, abstr_class_name['short'], class_name['short'], virtual=True, indent=indent, n_indents=n_indents+2)
        if has_copy_constructor:
            class_decl += constrPtrCopyFunc(class_el, abstr_class_name['short'], class_name['short'], virtual=True, indent=indent, n_indents=n_indents+2)

    # - Construct code needed for 'destructor pattern' (abstract class and wrapper class must can delete each other)
    class_decl += '\n'
    class_decl += ' '*(n_indents+1)*indent + 'private:\n'
    class_decl += ' '*(n_indents+2)*indent +  class_name['short'] + '* wptr;\n'
    class_decl += ' '*(n_indents+2)*indent + 'bool delete_wrapper;\n'
    class_decl += ' '*(n_indents+1)*indent + 'public:\n'
    class_decl += ' '*(n_indents+2)*indent + class_name['short'] + '* get_wptr() { return wptr; }\n'
    class_decl += ' '*(n_indents+2)*indent + 'void set_wptr(' + class_name['short'] + '* wptr_in) { wptr = wptr_in; }\n'
    class_decl += ' '*(n_indents+2)*indent + 'bool get_delete_wrapper() { return delete_wrapper; }\n'
    class_decl += ' '*(n_indents+2)*indent + 'void set_delete_wrapper(bool del_wrp_in) { delete_wrapper = del_wrp_in; }\n'


    # - Constructor
    class_decl += '\n'
    class_decl += ' '*(n_indents+1)*indent + 'public:\n'
    class_decl += ' '*(n_indents+2)*indent +  abstr_class_name['short'] + '()\n'
    class_decl += ' '*(n_indents+2)*indent + '{\n'
    if gb.debug_mode:
        class_decl += ' '*(n_indents+3)*indent + 'std::cerr &lt;&lt; &quot;DEBUG: &quot; &lt;&lt; this &lt;&lt; &quot; ' + abstr_class_name['short'] + ' ctor&quot; &lt;&lt; std::endl;\n' 
    class_decl += ' '*(n_indents+3)*indent + 'wptr = 0;\n'
    class_decl += ' '*(n_indents+3)*indent + 'delete_wrapper = false;\n'
    class_decl += ' '*(n_indents+2)*indent + '}\n'


    # - Copy constructor
    # -- Construct code for calling copy constructors of *all* parent classes.
    #    (Required because this is the copy ctor of an abstract base class.)
    all_parent_classes = utils.getAllParentClasses(class_el, only_loaded_classes=True, return_dicts=True, reverse_order=True)
    parent_cctors_line = ''
    for parent_dict in all_parent_classes:
        if parent_dict['loaded']:
            parent_cctors_line += parent_dict['abstr_class_name']['long_templ'] + '(in), '
        elif parent_dict['fundamental'] or parent_dict['std']:
            reason = 'Avoid inheritance ambiguity.'
            infomsg.ParentClassIgnored(abstr_class_name['short'], parent_dict['class_name']['long_templ'], reason).printMessage()
        else:
            reason = 'Not loaded or accepted type.'
            infomsg.ParentClassIgnored(abstr_class_name['short'], parent_dict['class_name']['long_templ'], reason).printMessage()
            continue
    parent_cctors_line = parent_cctors_line.rstrip(', ')

    class_decl += '\n'
    if parent_cctors_line == '':
        class_decl += ' '*(n_indents+2)*indent + abstr_class_name['short'] + '(const ' + abstr_class_name['short'] + '&amp;)\n'
    else:
        parent_cctors_line = parent_cctors_line.rstrip(',\n') + '\n'
        class_decl += ' '*(n_indents+2)*indent + abstr_class_name['short'] + '(const ' + abstr_class_name['short'] + '&amp; in) : \n'
        class_decl += ' '*(n_indents+3)*indent + parent_cctors_line
    class_decl += ' '*(n_indents+2)*indent + '{\n'
    if gb.debug_mode:
        class_decl += ' '*(n_indents+3)*indent + 'std::cerr &lt;&lt; &quot;DEBUG: &quot; &lt;&lt; this &lt;&lt; &quot; ' + abstr_class_name['short'] + ' copy ctor&quot; &lt;&lt; std::endl;\n' 
    class_decl += ' '*(n_indents+3)*indent + 'wptr = 0;\n'
    class_decl += ' '*(n_indents+3)*indent + 'delete_wrapper = false;\n'
    class_decl += ' '*(n_indents+2)*indent + '}\n'

    
    # - Assignment operator. (Actually, no copying should be done. It only returns *this.)
    class_decl += '\n'
    class_decl += ' '*(n_indents+2)*indent + abstr_class_name['short'] + '&amp; operator=(const ' + abstr_class_name['short'] + '&amp;) { return *this; }\n'

    # - Function init_wrapper() 
    if file_for_gambit:
        class_decl += '\n'
        class_decl += ' '*(n_indents+2)*indent + 'virtual void init_wrapper() =0;\n'
    else:
        class_decl += '\n'
        class_decl += ' '*(n_indents+2)*indent + 'virtual void init_wrapper()\n'
        class_decl += ' '*(n_indents+2)*indent + '{\n'
        class_decl += ' '*(n_indents+3)*indent + 'if (wptr == 0)\n'
        class_decl += ' '*(n_indents+3)*indent + '{\n'
        class_decl += ' '*(n_indents+4)*indent + 'wptr = wrapper_creator(this);\n'
        # class_decl += ' '*(n_indents+4)*indent + 'wrapper_creator(this);\n'
        class_decl += ' '*(n_indents+4)*indent + 'delete_wrapper = true;\n'
        class_decl += ' '*(n_indents+3)*indent + '}\n'
        class_decl += ' '*(n_indents+2)*indent + '}\n'


    # - Function get_init_wptr()
    class_decl += '\n'
    class_decl += ' '*(n_indents+2)*indent + class_name['short'] + '* get_init_wptr()\n'
    class_decl += ' '*(n_indents+2)*indent + '{\n'
    class_decl += ' '*(n_indents+3)*indent + 'init_wrapper();\n'
    class_decl += ' '*(n_indents+3)*indent + 'return wptr;\n'
    class_decl += ' '*(n_indents+2)*indent + '}\n'

    # - Function get_init_wref()
    class_decl += '\n'
    class_decl += ' '*(n_indents+2)*indent + class_name['short'] + '&amp; get_init_wref()\n'
    class_decl += ' '*(n_indents+2)*indent + '{\n'
    class_decl += ' '*(n_indents+3)*indent + 'init_wrapper();\n'
    class_decl += ' '*(n_indents+3)*indent + 'return *wptr;\n'
    class_decl += ' '*(n_indents+2)*indent + '}\n'

    # - Destructor
    if file_for_gambit:
        class_decl += '\n'
        class_decl += ' '*(n_indents+2)*indent + 'virtual ~' + abstr_class_name['short'] + '() =0;\n'
    else:
        class_decl += '\n'
        class_decl += ' '*(n_indents+2)*indent + 'virtual ~' + abstr_class_name['short'] + '()\n'
        class_decl += ' '*(n_indents+2)*indent + '{\n'
        if gb.debug_mode:
            class_decl += ' '*(n_indents+3)*indent + 'std::cerr &lt;&lt; &quot;DEBUG: &quot; &lt;&lt; this &lt;&lt; &quot; ' + abstr_class_name['short'] + ' dtor (BEGIN)&quot; &lt;&lt; std::endl;\n' 
        class_decl += ' '*(n_indents+3)*indent + 'if (wptr != 0)\n'
        class_decl += ' '*(n_indents+3)*indent + '{\n'
        class_decl += ' '*(n_indents+4)*indent + 'set_delete_BEptr(wptr, false);\n'
        class_decl += ' '*(n_indents+4)*indent + 'if (delete_wrapper == true)\n'
        class_decl += ' '*(n_indents+4)*indent + '{\n'
        class_decl += ' '*(n_indents+5)*indent + 'wrapper_deleter(wptr);\n'
        class_decl += ' '*(n_indents+5)*indent + 'wptr = 0;\n'
        # Set wptr = 0 in all parent classes as well
        for parent_dict in all_parent_classes:
            if parent_dict['loaded']:
                class_decl += ' '*(n_indents+5)*indent + parent_dict['abstr_class_name']['long_templ'] + '::set_wptr(0);\n'
        class_decl += ' '*(n_indents+5)*indent + 'delete_wrapper = false;\n'
        class_decl += ' '*(n_indents+4)*indent + '}\n'
        class_decl += ' '*(n_indents+3)*indent + '}\n'
        if gb.debug_mode:
            class_decl += ' '*(n_indents+3)*indent + 'std::cerr &lt;&lt; &quot;DEBUG: &quot; &lt;&lt; this &lt;&lt; &quot; ' + abstr_class_name['short'] + ' dtor (END)&quot; &lt;&lt; std::endl;\n' 
        class_decl += ' '*(n_indents+2)*indent + '}\n'


    # - Close the class body
    class_decl += ' '*n_indents*indent + '};' + '\n'

    # - Construct the closing of the namespaces
    class_decl += utils.constrNamespace(namespaces, 'close')


    # Insert tags for the GAMBIT namespace
    class_decl = '\n__START_GAMBIT_NAMESPACE__\n\n' + class_decl + '\n__END_GAMBIT_NAMESPACE__\n'


    # - Add forward declaration of wrapper_creator function (needed by the 'destructor pattern')
    if not file_for_gambit:
        frwd_decl_creator  = '\n'
        frwd_decl_creator += '// Forward declaration for wrapper_creator.\n'
        frwd_decl_creator += gb.gambit_backend_namespace + '::' + class_name['long'] + '* wrapper_creator(' + gb.gambit_backend_namespace + '::' + abstr_class_name['long'] + '*);\n'
        # frwd_decl_creator += 'void wrapper_creator(' + gb.gambit_backend_namespace + '::' + abstr_class_name['long'] + '*);\n'
        frwd_decl_creator += '\n'

        class_decl = frwd_decl_creator + class_decl


    # - Add forward declaration of wrapper_deleter function (needed by the 'destructor pattern')
    if not file_for_gambit:
        frwd_decl_deleter  = '\n'
        frwd_decl_deleter += '// Forward declaration needed by the destructor pattern.\n'
        frwd_decl_deleter += 'void wrapper_deleter(' + gb.gambit_backend_namespace + '::' + class_name['long'] + '*);\n'
        frwd_decl_deleter += '\n'

        class_decl = frwd_decl_deleter + class_decl

    # - Add forward declaration of set_delete_BEptr function (needed by the 'destructor pattern')
    if not file_for_gambit:
        frwd_decl_setdel  = '\n'
        frwd_decl_setdel += '// Forward declaration needed by the destructor pattern.\n'
        frwd_decl_setdel += 'void set_delete_BEptr(' + gb.gambit_backend_namespace + '::' + class_name['long'] + '*, bool);\n'
        frwd_decl_setdel += '\n'

        class_decl = frwd_decl_setdel + class_decl


    # Insert include statements needed by GAMBIT
    backend_undef_incl_statement  = '#include &quot;' + os.path.join(gb.gambit_backend_incl_dir, 'backend_undefs.hpp') + '&quot;\n'
    identification_incl_statement = '#include &quot;' + 'identification.hpp' + '&quot;\n'

    class_decl = identification_incl_statement + class_decl + '\n' + backend_undef_incl_statement


    return class_decl

# ====== END: constrAbstractClassDecl ========



# ====== getAcceptableConstructors ========

def getAcceptableConstructors(class_el, skip_copy_constructors=False):

    # Check for copy constructor?
    if skip_copy_constructors:
        has_copy_constructor, copy_constr_id = checkCopyConstructor(class_el, return_id=True)

    # Create list of all acceptable constructors of the class
    constructor_elements = []
    if 'members' in class_el.keys():
        for mem_id in class_el.get('members').split():
            el = gb.id_dict[mem_id]
            if (el.tag == 'Constructor'): #and ('artificial' not in el.keys()):  #(el.get('explicit') == &quot;1&quot;):
                if skip_copy_constructors and (el.get('id') == copy_constr_id):
                    pass
                else:
                    constructor_elements.append(el)

    return constructor_elements

# ====== END: getAcceptableConstructors ========



# ====== constrFactoryFunctionCode ========

def constrFactoryFunctionCode(class_el, class_name, indent=4, template_types=[], skip_copy_constructors=False, use_wrapper_return=False, use_wrapper_args=False, add_include_statements=True, add_signatures_comment=True):

    # Replace '*' and '&amp;' in list of template types
    template_types = [e.replace('*','P').replace('&amp;','R') for e in template_types]

    constructor_elements = getAcceptableConstructors(class_el, skip_copy_constructors=skip_copy_constructors)

    # If no public constructors are found, return nothing
    if len(constructor_elements) == 0:
        reason = &quot;No public constructors.&quot;
        infomsg.NoFactoryFunctions(class_name['long_templ'], reason).printMessage()
        return ''

    # List to hold include statements that are generated based on the types used
    # in the constructors
    if add_include_statements:
        include_statements = []

    # Construct factory function definition(s)
    func_def = ''

    counter = 0
    for el in constructor_elements:
        if (el.tag == 'Constructor') and ((el.get('access') == 'protected') or (el.get('access') == 'private')):
            continue

        if add_include_statements:
            # - Generate include statements based on the types used in the constructor
            include_statements += utils.getIncludeStatements(el, convert_loaded_to='none', input_element='function', forward_declared='exclude')
            include_statements += utils.getIncludeStatements(el, convert_loaded_to='wrapper', input_element='function', forward_declared='exclude', use_full_path=True)

        # We need to generate as many overloaded versions as there are arguments with default values
        n_overloads = funcutils.numberOfDefaultArgs(el)

        # Identify arguments
        args = funcutils.getArgs(el)

        # Translate argument type of loaded classes
        if use_wrapper_args:
            w_args = funcutils.constrWrapperArgs(args, add_ref=True, convert_loaded_to_abstract=False)
        else:
            w_args = funcutils.constrWrapperArgs(args, add_ref=True, convert_loaded_to_abstract=True)

        # Invent argument names if missing
        argc = 1
        for i in range(len(args)):
            if args[i]['name'] == '':
                args[i]['name'] = 'arg_' + str(argc)
                argc += 1

        # Generate one factory function for each set of default arguments
        for remove_n_args in range(n_overloads+1):

            # Check that the constructor is acceptable
            if funcutils.ignoreFunction(el, limit_pointerness=True, remove_n_args=remove_n_args):
                continue

            # - Factory function name
            factory_name = 'Factory_' + class_name['short'] + '_' + str(counter)
            if len(template_types) &gt; 0:
                factory_name += '_' + '_'.join(template_types)
            factory_name += gb.code_suffix + '_' + str(gb.symbol_name_counter)
            gb.symbol_name_counter += 1

            if remove_n_args == 0:
                use_args   = args
                use_w_args = w_args
            else:
                use_args   = args[:-remove_n_args]
                use_w_args = w_args[:-remove_n_args]

            # Construct bracket with input arguments
            if use_wrapper_args:
                args_bracket         = funcutils.constrArgsBracket(use_w_args, include_namespace=True, use_wrapper_class=True)
                args_bracket_notypes = funcutils.constrArgsBracket(use_args, include_arg_type=False, cast_to_original=True, wrapper_to_pointer=True)
            else:
                args_bracket         = funcutils.constrArgsBracket(use_w_args, include_namespace=True)
                args_bracket_notypes = funcutils.constrArgsBracket(use_args, include_arg_type=False, cast_to_original=True)
            args_bracket_nonames = funcutils.constrArgsBracket(use_args, include_namespace=True, include_arg_type=True, include_arg_name=False, add_namespace_to_loaded='my_ns') 
            
            # Generate declaration line:
            if use_wrapper_return:
                return_type = toWrapperType(class_name['short'], include_namespace=True)
            else:
                return_type = toAbstractType(class_name['short'], add_pointer=True, include_namespace=True)
            func_def += return_type + ' ' + factory_name + args_bracket + '\n'

            # Generate body
            func_def += '{' + '\n'
            if use_wrapper_return:
                func_def += indent*' ' + 'return ' + return_type + '( new ' + class_name['long'] + args_bracket_notypes + ' );' + '\n'
            else:
                func_def += indent*' ' + 'return new ' + class_name['short'] + args_bracket_notypes + ';' + '\n'
            func_def += '}' + 2*'\n'

            # Add info to global dict with factory function info
            info_dict = OrderedDict()
            info_dict['name']         = factory_name
            info_dict['args_bracket'] = args_bracket_nonames

            if class_name['long'] not in gb.factory_info.keys():
                gb.factory_info[class_name['long']] = []
            gb.factory_info[class_name['long']].append( info_dict )

            # Increment counter
            counter += 1


    # If no functions were generated, return nothing
    if func_def == '':
        reason = &quot;No accepted constructors.&quot;
        infomsg.NoFactoryFunctions(class_name['long_templ'], reason).printMessage()
        return ''


    # Encapsulate code in the correct namespace
    namespaces = utils.getNamespaces(class_el)
    n_indents = len(namespaces)

    func_def_in_ns  = ''
    func_def_in_ns += utils.constrNamespace(namespaces, 'open')
    func_def_in_ns += utils.addIndentation(func_def, n_indents*cfg.indent)
    func_def_in_ns += utils.constrNamespace(namespaces, 'close')

    # Encapsulate code in 'extern &quot;C&quot; {...}'
    func_def_in_ns = 'extern &quot;C&quot;\n{\n' + func_def_in_ns + '}\n' 

    return_code = func_def_in_ns

    if add_include_statements:
        try:
            original_header_fname = utils.getOriginalHeaderPath(class_el, full_path=True)
            use_path = utils.shortenHeaderPath(original_header_fname)
            include_statements.append( '#include &quot;' + use_path + '&quot;')

        except exceptions.ReturnError as e:
            reason =  &quot;No original header file found.&quot;
            infomsg.NoIncludeStatementGenerated(class_name['long_templ'], reason).printMessage()
            pass

        include_statements.append( '#include &quot;' + gb.new_header_files[class_name['long']]['wrapper_fullpath'] + '&quot;' )
        include_statements.append( '#include &quot;' + os.path.join(gb.gambit_backend_incl_dir, gb.abstract_typedefs_fname + cfg.header_extension) + '&quot;' )
        include_statements.append( '#include &quot;' + os.path.join(gb.gambit_backend_incl_dir, gb.wrapper_typedefs_fname + cfg.header_extension) + '&quot;' )
        

        include_statements = list( OrderedDict.fromkeys(include_statements) )
        include_statements = utils.orderIncludeStatements(include_statements)
        include_statements_code = '\n'.join(include_statements) + 2*'\n'
        return_code = include_statements_code + return_code

    return return_code

# ====== END: constrFactoryFunctionCode ========



# ====== constrWrapperFunction ========

def constrWrapperFunction(method_el, indent=cfg.indent, n_indents=0, remove_n_args=0, only_declaration=False, include_full_namespace=False):

    # Check if this is an operator function
    is_operator = False
    if method_el.tag == 'OperatorMethod':
        is_operator = True

    # If operator, check that we have a name for it
    if (is_operator) and (method_el.get('name') not in gb.operator_names.keys()):
        raise Exception('No known name for the operator: %s  -- Add an entry to the following dictionary: gb.operator_names' % method_el.get('name'))

    # Function name
    if is_operator:
        func_name = 'operator' + method_el.get('name')
    else:
        func_name = method_el.get('name')


    # Function return type

    return_type_dict = utils.findType( gb.id_dict[method_el.get('returns')] )
    return_el     = return_type_dict['el']
    pointerness   = return_type_dict['pointerness']
    is_ref        = return_type_dict['is_reference']
    return_kw     = return_type_dict['cv_qualifiers']
    
    return_kw_str = ' '.join(return_kw) + ' '*bool(len(return_kw))
    return_type   = return_type_dict['name'] + '*'*pointerness + '&amp;'*is_ref


    return_is_loaded_class = utils.isLoadedClass(return_el)

    # Function arguments (get list of dicts with argument info)
    args = funcutils.getArgs(method_el)

    # Remove arguments when creating overloaded versions (for dealing with default argument values)
    if remove_n_args &gt; 0:
        args = args[:-remove_n_args]

    # Check constness (in the following sense: &quot;double someFunction() const&quot;, i.e. a function that does not modify member variables.)
    if ('const' in method_el.keys()) and (method_el.get('const')=='1'):
        is_const = True
    else:
        is_const = False

    # Construct wrapper function name
    w_func_name = funcutils.constrWrapperName(method_el, include_full_namespace=include_full_namespace)
    # if remove_n_args &gt; 0:
    #     w_func_name += '_overload_' + str(remove_n_args)


    # Choose wrapper return type
    if return_is_loaded_class:
        if (pointerness == 0) and (is_ref):
            w_return_type = toAbstractType(return_type, include_namespace=True)
        elif (pointerness == 0) and (not is_ref):
            w_return_type = toAbstractType(return_type, include_namespace=True, add_pointer=True, remove_reference=True)
        else:
            w_return_type = toAbstractType(return_type, include_namespace=True)

    else:
        w_return_type = return_type


    # Construct list of arguments for wrapper function
    w_args = funcutils.constrWrapperArgs(args, add_ref=True)

    # Construct bracket with input arguments for wrapper function
    if only_declaration:
        w_args_bracket = funcutils.constrArgsBracket(w_args, include_arg_name=False, include_namespace=True)
    else:
        w_args_bracket = funcutils.constrArgsBracket(w_args, include_namespace=True)

    # Construct declaration line for wrapper function
    w_func_line = funcutils.constrDeclLine(w_return_type, w_func_name, w_args_bracket, keywords=return_kw, is_const=is_const)

    # Construct function body for wrapper function
    if only_declaration:
        pass
    else:
        w_func_body = funcutils.constrWrapperBody(return_type, func_name, args, return_is_loaded_class, keywords=return_kw)

    # Combine code and add indentation
    wrapper_code  = ''
    if only_declaration:
        wrapper_code += utils.addIndentation(w_func_line, n_indents*indent) + ';\n'
    else:
        wrapper_code += utils.addIndentation(w_func_line, n_indents*indent) + '\n'
        wrapper_code += utils.addIndentation(w_func_body, n_indents*indent) + '\n'

    # Return result
    return wrapper_code

# ====== END: constrWrapperFunction ========



# ====== constrVariableRefFunction ========

def constrVariableRefFunction(var_el, virtual=False, indent=cfg.indent, n_indents=0, only_declaration=False,
                              include_full_namespace=False, add_return_type_suffix=False):

    func_code = ''

    var_name = var_el.get('name')

    var_type_dict    = utils.findType( var_el )
    var_type_name    = var_type_dict['name']
    pointerness      = var_type_dict['pointerness']
    is_ref           = var_type_dict['is_reference']
    var_kw           = var_type_dict['cv_qualifiers']
    var_array_limits = var_type_dict['array_limits']
    is_array         = var_type_dict['is_array']
    
    var_array_limits_str = ''.join([ '[%i]' % i for i in var_array_limits ])

    var_kw_str = ' '.join(var_kw) + ' '*bool(len(var_kw))
    var_type   = var_type_dict['name'] + '*'*pointerness + '&amp;'*is_ref

    # pointerness, is_ref = utils.pointerAndRefCheck(var_el)

    ref_method_name = var_name + '_ref' + gb.code_suffix

    if include_full_namespace:
        namespaces = utils.getNamespaces(var_el)
        if len(namespaces) &gt; 0:
            ref_method_name = '::'.join(namespaces) + '::' + ref_method_name


    var_is_loaded_class = utils.isLoadedClass(var_el)
    
    if (var_is_loaded_class) and (pointerness == 0):
        return_type = toAbstractType(var_type)
    elif (var_is_loaded_class) and (pointerness == 1) and (add_return_type_suffix):
        return_type   = toWrapperType(var_type, include_namespace=include_full_namespace)
        var_type_name = toWrapperType(var_type_name, include_namespace=include_full_namespace)
    else:
        return_type = var_type


    # If variable type is a known class, add '::' for absolute namespace.
    if (not var_is_loaded_class) and utils.isKnownClass(var_el):
        return_type = '::' + return_type 


    if (not is_ref) and (not is_array):
        return_type = return_type + '&amp;'
    else:
        pass


    func_code += ' '*n_indents*indent
    
    if virtual:
        if is_array:
            func_code += 'virtual ' + var_kw_str + return_type + ' (&amp;' + ref_method_name + '())' + var_array_limits_str + ' =0;\n'        
        else:
            func_code += 'virtual ' + var_kw_str + return_type + ' ' + ref_method_name + '() =0;\n'
    
    else:
        if is_array:
            func_code += var_kw_str + return_type + ' (&amp;' + ref_method_name + '())' + var_array_limits_str
        else:
            func_code += var_kw_str + return_type + ' ' + ref_method_name + '()' 

        if only_declaration:
            func_code += ';\n'
        else:
            if (var_is_loaded_class) and (pointerness &gt; 0):

                wrapper_var_name = var_name + gb.code_suffix

                func_code += '\n'
                func_code += ' '*n_indents*indent + '{\n'
                func_code += ' '*(n_indents+1)*indent + 'if (not ' + wrapper_var_name + ') { ' + wrapper_var_name + ' = new ' + var_type_name + '(' + var_name + ', true); }\n'
                func_code += ' '*(n_indents+1)*indent + 'return ' + wrapper_var_name + ';\n'
                func_code += ' '*n_indents*indent + '}\n'

            else:
                func_code += ' { return ' + var_name  +'; }\n'

    return func_code

# ====== END: constrVariableRefFunction ========



# ====== constrPtrCopyFunc ========

def constrPtrCopyFunc(class_el, abstr_class_name_short, class_name_short, virtual=False, indent=cfg.indent, n_indents=0, only_declaration=False, include_full_namespace=False):

    func_name = 'pointer_copy' + gb.code_suffix
    class_name = class_name_short
    abstr_class_name = abstr_class_name_short

    if include_full_namespace:
        namespaces_with_self = utils.getNamespaces(class_el, include_self=True)
        namespaces           = utils.getNamespaces(class_el)
        if len(namespaces_with_self) &gt; 0:
            func_name = '::'.join(namespaces_with_self) + '::' + func_name
        if len(namespaces) &gt; 0:
            abstr_class_name = '::'.join(namespaces) + '::' + abstr_class_name
            class_name = '::'.join(namespaces) + '::' + class_name

    ptr_code = ''
    if virtual:
        ptr_code += ' '*cfg.indent*n_indents + 'virtual '+ abstr_class_name + '*' + ' ' + func_name + '() =0;\n'   
    else:
        ptr_code += ' '*cfg.indent*n_indents + abstr_class_name + '*' + ' ' + func_name + '()'
        if only_declaration:
            ptr_code += ';\n'
        else:
            ptr_code += '\n'
            ptr_code += ' '*cfg.indent*n_indents + '{\n'
            ptr_code += ' '*cfg.indent*(n_indents+1) + abstr_class_name + '* new_ptr = new ' + class_name_short + '(*this);\n'
            ptr_code += ' '*cfg.indent*(n_indents+1) + 'return new_ptr;\n'
            ptr_code += ' '*cfg.indent*n_indents + '}\n'

    return ptr_code

# ====== END: constrPtrCopyFunc ========



# ====== constrPtrAssignFunc ========

def constrPtrAssignFunc(class_el, abstr_class_name_short, class_name_short, virtual=False, indent=cfg.indent, n_indents=0, only_declaration=False, include_full_namespace=False):

    func_name  = 'pointer_assign' + gb.code_suffix
    class_name = class_name_short
    abstr_class_name = abstr_class_name_short

    if include_full_namespace:
        namespaces_with_self = utils.getNamespaces(class_el, include_self=True)
        namespaces           = utils.getNamespaces(class_el)
        if len(namespaces_with_self) &gt; 0:
            func_name = '::'.join(namespaces_with_self) + '::' + func_name
        if len(namespaces) &gt; 0:
            abstr_class_name = '::'.join(namespaces) + '::' + abstr_class_name
            class_name = '::'.join(namespaces) + '::' + class_name

    ptr_code = ''
    
    if virtual:
        ptr_code += ' '*cfg.indent*n_indents + 'virtual void ' + func_name + '(' + abstr_class_name + '*) =0;\n'
    else:
        ptr_code += ' '*cfg.indent*n_indents + 'void ' + func_name + '(' + abstr_class_name + '* in)'
        if only_declaration:
            ptr_code += ';\n'
        else:
            ptr_code += '\n'
            ptr_code += ' '*cfg.indent*n_indents + '{\n'
            ptr_code += ' '*cfg.indent*(n_indents+1) + gb.gambit_backend_namespace + '::' + class_name + '* wptr_temp = ' + abstr_class_name + '::get_wptr();\n'
            ptr_code += ' '*cfg.indent*(n_indents+1) + '*this = *dynamic_cast&lt;' + class_name_short + '*&gt;(in);\n'
            ptr_code += ' '*cfg.indent*(n_indents+1) + abstr_class_name_short + '::set_wptr(wptr_temp);\n'
            ptr_code += ' '*cfg.indent*n_indents + '}\n'

    return ptr_code

# ====== END: constrPtrAssignFunc ========



# ====== checkAssignmentOperator ========

def checkAssignmentOperator(class_el):

    found_assignment_operator = False
    is_artificial = False

    # Get list of all class members
    class_members = utils.getMemberElements(class_el, include_artificial=True)

    # Look for assignment operator
    for mem_el in class_members:
        if (mem_el.tag == 'OperatorMethod') and (mem_el.get('name') == '='):

            # Check that return type is either void or the class type itself (possibly as a reference)
            return_type_dict = utils.findType(mem_el)
            return_type    = return_type_dict['name'] + '*'*return_type_dict['pointerness'] + '&amp;'*return_type_dict['is_reference']
            return_type_id = return_type_dict['id']

            if (return_type == 'void') or (return_type_id == class_el.get('id')):

                # Check that the only argument is another class instance
                args = funcutils.getArgs(mem_el)
                if (len(args) == 1) and (args[0]['id'] == class_el.get('id')):

                    found_assignment_operator = True
    
                    if ('artificial' in mem_el.keys()) and (mem_el.get('artificial')=='1'):
                        is_artificial = True

    return found_assignment_operator, is_artificial

# ====== END: checkAssignmentOperator ========



# ====== checkCopyConstructor ========

def checkCopyConstructor(class_el, return_id=False):

    found_copy_constructor = False
    copy_constr_id = ''

    # Get list of all class members
    class_members = utils.getMemberElements(class_el, include_artificial=True)

    # Look for copy constructor
    for mem_el in class_members:
        if (mem_el.tag == 'Constructor'):

            if (mem_el.get('access') == 'protected') or (mem_el.get('access') == 'private'):
                return found_copy_constructor, copy_constr_id

            # Check that the only argument is another class instance
            args = funcutils.getArgs(mem_el)
            if (len(args) == 1) and (args[0]['id'] == class_el.get('id')):

                found_copy_constructor = True
                copy_constr_id = mem_el.get('id')

    if return_id:
        return found_copy_constructor, copy_constr_id
    else:
        return found_copy_constructor

# ====== END: checkCopyConstructor ========



# ====== toWrapperType ========

def toWrapperType(input_type_name, remove_reference=False, remove_pointers=False, include_namespace=False, include_global_namespace=False ):

    type_name = input_type_name

    # Search for '*' and '&amp;'
    n_pointers = type_name.count('*')
    is_ref     = bool('&amp;' in type_name)

    # Remove '*' and '&amp;'
    type_name = type_name.replace('*','').replace('&amp;','')

    # Split into namespace, short_type_name 
    namespace, short_type_name = utils.removeNamespace(type_name, return_namespace=True)

    if include_global_namespace:
        namespace = '::' + namespace

    # Insert wrapper class prefix
    short_type_name = gb.wrapper_class_prefix + short_type_name

    # Add '*' and '&amp;'
    if remove_pointers:
        pass
    else:
        short_type_name = short_type_name + '*'*n_pointers

    if remove_reference:
        pass
    else:
        short_type_name = short_type_name + '&amp;'*is_ref

    # Return result
    if (include_namespace) and (namespace != ''):
        return namespace + '::' + short_type_name
    else:
        return short_type_name

# ====== END: toWrapperType ========



# ====== toAbstractType ========

def toAbstractType(input_type_name, include_namespace=True, add_pointer=False, remove_reference=False, remove_pointers=False):

    # FIXME:
    # Should this function also translate template argument types?
    # Example: TypeA&lt;TypeB&gt;  --&gt;  Abstract__TypeA&lt;Abstract__TypeB&gt;

    type_name = input_type_name

    # Remove template bracket
    type_name_notempl = utils.removeTemplateBracket(type_name)

    # Search for '*' and '&amp;'
    n_pointers = type_name_notempl.count('*')
    is_ref     = bool('&amp;' in type_name_notempl)

    # Get namespace
    namespace, type_name_short = utils.removeNamespace(type_name, return_namespace=True)

    if is_ref and remove_reference:
        type_name_short = type_name_short.replace('&amp;','')

    if (n_pointers &gt; 0) and remove_pointers:
        type_name_short = type_name_short.replace('*','')

    if namespace == '':
        type_name = gb.abstr_class_prefix + type_name_short
    else:
        type_name = (namespace+'::')*include_namespace  + gb.abstr_class_prefix + type_name_short


    if add_pointer:
        if is_ref and not remove_reference:
            type_name = type_name.rstrip('&amp;') + '*&amp;'
        else:
            type_name = type_name + '*'

    # Return result
    return type_name

# ====== END: toAbstractType ========



# ====== getClassNameDict ========

def getClassNameDict(class_el, abstract=False):

    class_name = {}

    xml_id = class_el.get('id')
    if 'name' not in class_el.keys():
        raise KeyError('XML element %s does not contain the key &quot;name&quot;.' % (xml_id))

    namespaces_list = utils.getNamespaces(class_el, include_self=True)
    class_name['long_templ'] = '::'.join(namespaces_list)

    class_name['long']        = class_name['long_templ'].split('&lt;',1)[0]
    class_name['short_templ'] = class_el.get('name')
    class_name['short']       = class_name['short_templ'].split('&lt;',1)[0]

    if abstract:
        abstr_class_name = {}
        abstr_class_name['long_templ']  = getAbstractClassName(class_name['long_templ'], prefix=gb.abstr_class_prefix)
        abstr_class_name['long']        = abstr_class_name['long_templ'].split('&lt;',1)[0]
        abstr_class_name['short_templ'] = getAbstractClassName(class_name['long_templ'], prefix=gb.abstr_class_prefix, short=True)
        abstr_class_name['short']       = abstr_class_name['short_templ'].split('&lt;',1)[0]

        return abstr_class_name

    else:
        return class_name

# ====== END: getClassNameDict ========



# ====== constrWrapperDecl ========

def constrWrapperDecl(class_name, abstr_class_name, loaded_parent_classes, class_variables, class_functions, class_constructors, construct_assignment_operator, has_copy_constructor, indent=' '*cfg.indent):

    decl_code = ''

    short_wrapper_class_name = toWrapperType(class_name['short'])
    wrapper_class_name = toWrapperType(class_name['long'], include_namespace=True)

    # Construct inheritance line 
    inheritance_line = ''
    for parent_dict in loaded_parent_classes:
        inheritance_line += 'virtual '*parent_dict['virtual'] + parent_dict['access'] + ' ' + parent_dict['class_name']['short'] + ', '
    inheritance_line = inheritance_line.rstrip(', ')

    # If no other parent classes, add WrapperBase
    if inheritance_line == '':
        # inheritance_line = ' : public virtual WrapperBase'
        inheritance_line = ' : public WrapperBase'
    else:
        inheritance_line = ' : ' + inheritance_line

    # Class declaration line
    decl_code += '\n'
    decl_code += 'class ' + class_name['short'] + inheritance_line + '\n'

    # Class body
    decl_code += '{\n'

    #
    # Variables:
    #
    decl_code += 2*indent + '// Member variables: \n'

    # Add a static function pointer for each factory function
    decl_code += indent + 'public:\n'
    decl_code += 2*indent + '// -- Static factory pointers: \n'
    factory_counter = 0
    for i, constr_el in enumerate(class_constructors):

       
        # We need pointers for all the overloaded factory functions (generated due to default value arguments)
        n_overloads = funcutils.numberOfDefaultArgs(constr_el)

        # Identify arguments, translate argument type of loaded classes
        # and construct the argument bracket
        args = funcutils.getArgs(constr_el)

        # One factory function pointer for each set of default arguments
        for remove_n_args in range(n_overloads+1):

            # Check that the constructor is acceptable
            if funcutils.ignoreFunction(constr_el, limit_pointerness=True, remove_n_args=remove_n_args):
                continue

            if remove_n_args == 0:
                use_args = args
            else:
                use_args = args[:-remove_n_args]

            args_bracket = funcutils.constrArgsBracket(use_args, include_arg_name=False, include_arg_type=True, include_namespace=True)

            # Factory pointer name
            factory_ptr_name = '__factory' + str(factory_counter)

            # Construct factory pointer code
            decl_code += 2*indent + 'static ' + abstr_class_name['short'] + '* (*' + factory_ptr_name + ')' + args_bracket + ';\n'

            # Increment factory counter
            factory_counter += 1

    # Add references to all public variables
    decl_code += '\n'
    decl_code += 2*indent + '// -- Other member variables: \n'
    current_access = ''
    for var_el in class_variables:

        # Accessor
        accessor = var_el.get('access')
        if accessor != current_access:
            decl_code += indent + accessor + ':\n'
            current_access = accessor

        # Variable name
        var_name = var_el.get('name')

        # Determine variable type
        var_type_dict = utils.findType(var_el)
        pointerness      = var_type_dict['pointerness']
        is_ref           = var_type_dict['is_reference']
        var_kw           = var_type_dict['cv_qualifiers']
        var_array_limits = var_type_dict['array_limits']
        is_array         = var_type_dict['is_array']

        var_array_limits_str = ''.join(['[%i]' % i for i in var_array_limits])
       

        var_kw_str = ' '.join(var_kw) + ' '*bool(len(var_kw))
        
        var_type      = var_type_dict['name'] + '*'*pointerness + '&amp;'*is_ref

        var_is_loaded_class = utils.isLoadedClass(var_el)
        var_is_known_class  = utils.isKnownClass(var_el)

        # # FIXME: At the moment there are problems with member variables that are pointer-to-loaded-class. For now, skip them:
        # if var_is_loaded_class and pointerness &gt; 0:
        #     print('WARNING: The member variable %s is of a loaded type and has pointerness &gt; 0. This BOSS cannot yet handle. Ignored for now...' % var_name)
        #     continue


        if var_is_loaded_class:
            
            use_var_type = var_type
            
            if not is_ref:
                use_var_type = var_type + '&amp;'

            decl_code += 2*indent + var_kw_str + use_var_type + ' ' + var_name + var_array_limits_str  + ';\n'
    
        else:
            if var_is_known_class:
                var_type = '::' + var_type

            if is_ref:
                use_var_type = var_type
            else:
                if not is_array:
                    use_var_type = var_type + '&amp;'
                else:
                    use_var_type = var_type

            if is_array:
                decl_code += 2*indent + var_kw_str + use_var_type + ' (&amp;' + var_name +')' + var_array_limits_str  + ';\n'
            else:
                decl_code += 2*indent + var_kw_str + use_var_type + ' ' + var_name + ';\n'


    #
    # Functions:
    #
    decl_code += '\n'
    decl_code += 2*indent + '// Member functions: \n'

    # Add wrappers for all member functions, including operator functions
    # and overloaded versions of functions with default value arguments

    current_access = ''
    for func_el in class_functions:

        # Accessor
        accessor = func_el.get('access')
        if accessor != current_access:
            decl_code += indent + accessor + ':\n'
            current_access = accessor

        # Check if this is an operator function
        is_operator = False
        if func_el.tag == 'OperatorMethod':
            is_operator = True

        # Check if this function makes use of any loaded types
        uses_loaded_type = funcutils.usesLoadedType(func_el)

        # Function name
        if is_operator:
            func_name = 'operator' + func_el.get('name')
        else:
            func_name = func_el.get('name')

        # Skip the assignment operator (we implement out own later on)
        if func_name == 'operator=':
            continue

        # Check for const function
        is_const = utils.isConstFunction(func_el)

        # Determine return type
        return_type_dict = utils.findType(func_el)
        return_type_el = return_type_dict['el']
        pointerness    = return_type_dict['pointerness']
        is_ref         = return_type_dict['is_reference']
        return_type_kw = return_type_dict['cv_qualifiers']
        
        return_kw_str  = ' '.join(return_type_kw) + ' '*bool(len(return_type_kw))
        
        return_is_loaded    = utils.isLoadedClass(return_type_el)

        return_type   = return_type_dict['name'] + '*'*pointerness + '&amp;'*is_ref


        # If return type is a known class, add '::' for absolute namespace.
        if (not return_is_loaded) and utils.isKnownClass(return_type_el):
            return_type = '::' + return_type 

        # If return-by-value, then a const qualifier on the return value is meaningless
        # (will result in a compiler warning)
        if (pointerness == 0) and (is_ref == False) and ('const' in return_type_kw):
            return_kw_str = return_kw_str.replace('const', '')

        # Arguments
        args = funcutils.getArgs(func_el)

        # One function for each set of default arguments
        n_overloads = funcutils.numberOfDefaultArgs(func_el)
        for remove_n_args in range(n_overloads+1):

            # Check that the function is acceptable
            if funcutils.ignoreFunction(func_el, remove_n_args=remove_n_args):
                continue

            if remove_n_args == 0:
                use_args = args
            else:
                use_args = args[:-remove_n_args]

            # Argument bracket
            args_bracket = funcutils.constrArgsBracket(use_args, include_arg_name=True, include_arg_type=True, include_namespace=True)

            # Name of function to call (in abstract class)
            if is_operator:
                if uses_loaded_type:
                    call_func_name = 'operator_' + gb.operator_names[func_el.get('name')] + gb.code_suffix
                else:
                    call_func_name = 'operator' + func_el.get('name')    
            else:
                # call_func_name = func_name + gb.code_suffix
                if uses_loaded_type or (remove_n_args&gt;0):
                    call_func_name = func_name + gb.code_suffix 
                else:
                    call_func_name = func_name


            # Write declaration line
            decl_code += 2*indent + return_kw_str + return_type + ' ' + func_name + args_bracket + is_const*' const' + ';\n'
            decl_code += '\n'


    #
    # Add all constructors here...
    #


    # Add wrappers for all original constructors except the copy constructor
    temp_code = ''
    current_access = ''
    for i, constr_el in enumerate(class_constructors):

        # Accessor
        accessor = constr_el.get('access')
        if accessor != current_access:
            temp_code += indent + accessor + ':\n'
            current_access = accessor

        # Identify arguments
        args = funcutils.getArgs(constr_el)
        factory_args = funcutils.constrWrapperArgs(args, add_ref=True)

        # If default arguments are use, we need overloaded constructors to connect to the overloaded
        # factory function pointers
        n_overloads = funcutils.numberOfDefaultArgs(constr_el)

        # One constructor for each set of default arguments
        for remove_n_args in range(n_overloads+1):

            # Check that the constructor is acceptable
            if funcutils.ignoreFunction(constr_el, limit_pointerness=True, remove_n_args=remove_n_args):
                continue

            if remove_n_args == 0:
                use_args         = args
                factory_use_args = factory_args
            else:
                use_args         = args[:-remove_n_args]
                factory_use_args = factory_args[:-remove_n_args]

            args_bracket = funcutils.constrArgsBracket(use_args, include_arg_name=True, include_arg_type=True, include_namespace=True, use_wrapper_class=False)

            temp_code += 2*indent + class_name['short'] + args_bracket + ';\n'

    if temp_code != '':
        decl_code += '\n'
        decl_code += 2*indent + '// Wrappers for original constructors: \n'    
        decl_code += temp_code + '\n'

    if current_access != 'public':
        decl_code += indent + 'public:\n'


    # Add special constructor based on abstract pointer
    decl_code += 2*indent + '// Special pointer-based constructor: \n'
    decl_code += 2*indent + class_name['short'] + '(' + abstr_class_name['short'] +'* in);\n'
    # decl_code += 2*indent + class_name['short'] + '(const ' + abstr_class_name['long'] +'* in);\n'


    # Add copy constructor
    if has_copy_constructor:
        decl_code += '\n'
        decl_code += 2*indent + '// Copy constructor: \n'
        decl_code += 2*indent + class_name['short'] + '(const ' + class_name['short'] +'&amp; in);\n'

    # 
    # Add assignment operator
    #
    if construct_assignment_operator:
        decl_code += '\n'
        decl_code += 2*indent + '// Assignment operator: \n'
        decl_code += 2*indent + class_name['short'] + '&amp; ' + 'operator=(const ' + class_name['short'] +'&amp; in);\n'


    #
    # Add destructor
    #
    decl_code += '\n'
    decl_code += 2*indent + '// Destructor: \n'
    # decl_code += 2*indent + 'virtual ~' + class_name['short'] + '();\n'
    decl_code += 2*indent + '~' + class_name['short'] + '();\n'


    #
    # Add get_BEptr function
    #
    decl_code += '\n'
    # decl_code += indent + 'private:\n'
    decl_code += 2*indent + '// Returns correctly casted pointer to Abstract class: \n'
    decl_code += 2*indent + abstr_class_name['short'] +'* get_BEptr() const;\n'


    # Close class body
    decl_code += '\n'
    decl_code += '};\n'    


    # Add namespace
    namespace, class_name_short = utils.removeNamespace(class_name['long'], return_namespace=True)

    if namespace == '':
        namespace_list = []
    else:
        namespace_list = namespace.split('::')

    n_indents = len(namespace_list)

    decl_code_with_ns  = ''
    decl_code_with_ns += utils.constrNamespace(namespace_list,'open')
    decl_code_with_ns += utils.addIndentation(decl_code, cfg.indent*n_indents)
    decl_code_with_ns += utils.constrNamespace(namespace_list,'close')

    # Return result
    return decl_code_with_ns

# ====== END: constrWrapperDecl ========




# ====== constrWrapperDef ========

def constrWrapperDef(class_name, abstr_class_name, loaded_parent_classes, class_variables, class_functions, class_constructors, construct_assignment_operator, has_copy_constructor, indent=' '*cfg.indent, do_inline=False):

    def_code = ''

    short_wrapper_class_name = toWrapperType(class_name['short'])
    wrapper_class_name = toWrapperType(class_name['long'], include_namespace=True)

    # Functions:
    def_code += '\n'
    def_code += '// Member functions: \n'

    # Add wrappers for all member functions, including operator functions
    # and overloaded versions of functions with default value arguments

    for func_el in class_functions:

        # Check if this is an operator function
        is_operator = False
        if func_el.tag == 'OperatorMethod':
            is_operator = True

        # Check if this function makes use of any loaded types
        uses_loaded_type = funcutils.usesLoadedType(func_el)

        # Function name
        if is_operator:
            func_name = 'operator' + func_el.get('name')
        else:
            func_name = func_el.get('name')

        # Skip the assignment operator (we implement out own later on)
        if func_name == 'operator=':
            continue

        # Check for const function
        is_const = utils.isConstFunction(func_el)


        # Determine return type
        return_type_dict = utils.findType(func_el)
        return_type_el = return_type_dict['el']
        pointerness    = return_type_dict['pointerness']
        is_ref         = return_type_dict['is_reference']
        return_type_kw = return_type_dict['cv_qualifiers']
        
        return_kw_str  = ' '.join(return_type_kw) + ' '*bool(len(return_type_kw))
        
        return_is_loaded    = utils.isLoadedClass(return_type_el)

        return_type   = return_type_dict['name'] + '*'*pointerness + '&amp;'*is_ref


        # If return type is a known class, add '::' for absolute namespace.
        if (not return_is_loaded) and utils.isKnownClass(return_type_el):
            return_type = '::' + return_type 


        # If return-by-value, then a const qualifier on the return value is meaningless
        # (will result in a compiler warning)
        if (pointerness == 0) and (is_ref == False) and ('const' in return_type_kw):
            return_kw_str = return_kw_str.replace('const', '')

        # Arguments
        args = funcutils.getArgs(func_el)


        # One function for each set of default arguments
        n_overloads = funcutils.numberOfDefaultArgs(func_el)
        for remove_n_args in range(n_overloads+1):

            # Check that the function is acceptable
            if funcutils.ignoreFunction(func_el, limit_pointerness=True, remove_n_args=remove_n_args):
                continue

            if remove_n_args == 0:
                use_args = args
            else:
                use_args = args[:-remove_n_args]

            # Arguments bracket
            args_bracket = funcutils.constrArgsBracket(use_args, include_arg_name=True, include_arg_type=True, include_namespace=True)

            # Name of function to call (in abstract class)
            if is_operator:
                if uses_loaded_type:
                    call_func_name = 'operator_' + gb.operator_names[func_el.get('name')] + gb.code_suffix
                else:
                    call_func_name = 'operator' + func_el.get('name')    
            else:
                if uses_loaded_type or (remove_n_args&gt;0):
                    call_func_name = func_name + gb.code_suffix 
                else:
                    call_func_name = func_name


            # Write declaration line
            def_code += do_inline*'inline ' + return_kw_str + return_type + ' ' + class_name['short'] + '::' + func_name + args_bracket + is_const*' const' + '\n'

            # Write function body
            def_code += '{\n'

            if return_type == 'void':
                def_code += indent
            else:
                def_code += indent + 'return '

            args_bracket_notypes = funcutils.constrArgsBracket(use_args, include_arg_name=True, include_arg_type=False, wrapper_to_pointer=True)

            if return_is_loaded: 

                abs_return_type_simple = toAbstractType(return_type, include_namespace=True, remove_reference=True, remove_pointers=True)
                return_type_simple     = return_type.replace('*','').replace('&amp;','')

                if is_const:
                    get_BEptr_call = 'const_cast&lt;const ' + abstr_class_name['short'] +'*&gt;(get_BEptr())'
                else:
                    get_BEptr_call = 'get_BEptr()'

                # Return-by-reference
                if is_ref:
                    if 'const' in return_type_kw:
                        def_code += 'const_cast&lt;' + abs_return_type_simple + '&amp;&gt;(' + get_BEptr_call + '-&gt;' + call_func_name + args_bracket_notypes + ').get_init_wref();\n'
                    else:
                        def_code += get_BEptr_call + '-&gt;' + call_func_name + args_bracket_notypes + '.get_init_wref();\n'
                
                # Return-by-pointer
                elif (not is_ref) and (pointerness &gt; 0):  
                    if 'const' in return_type_kw:
                        def_code += 'const_cast&lt;' + abs_return_type_simple + '*&gt;(' + get_BEptr_call + '-&gt;' + call_func_name + args_bracket_notypes + ')-&gt;get_init_wptr();\n'
                    else:
                        def_code += get_BEptr_call + '-&gt;' + call_func_name + args_bracket_notypes + '-&gt;get_init_wptr();\n'
                
                # Return-by-value
                else:
                    if 'const' in return_type_kw:
                        # def_code += return_type + '( const_cast&lt;' + abs_return_type_simple + '*&gt;(' + get_BEptr_call + '-&gt;' + call_func_name + args_bracket_notypes + ')-&gt;get_init_wref() );\n'
                        def_code += return_type + '( const_cast&lt;' + abs_return_type_simple + '*&gt;(' + get_BEptr_call + '-&gt;' + call_func_name + args_bracket_notypes + ') );\n'
                    else:
                        # def_code += return_type + '( ' + get_BEptr_call + '-&gt;' + call_func_name + args_bracket_notypes + '-&gt;get_init_wref() );\n'
                        def_code += return_type + '( ' + get_BEptr_call + '-&gt;' + call_func_name + args_bracket_notypes + ' );\n'
           
            else:                
                def_code += 'get_BEptr()-&gt;' + call_func_name + args_bracket_notypes + ';\n'

            def_code += '}\n'
            def_code += '\n'


    #
    # Add all constructors here...
    #

    # First generate some code common to all constructors

    common_init_list_code   = ''

    common_constructor_body = ''
    if gb.debug_mode:
        common_constructor_body += indent + 'std::cerr &lt;&lt; &quot;DEBUG: &quot; &lt;&lt; this &lt;&lt; &quot; ' + short_wrapper_class_name + ' ctor&quot; &lt;&lt; std::endl;\n'
    common_constructor_body += indent + 'get_BEptr()-&gt;set_wptr(this);\n'
    common_constructor_body += indent + 'get_BEptr()-&gt;set_delete_wrapper(false);\n'

    # mem_var_init_body = ''
    has_loaded_class_mem_var = False
    
    for var_el in class_variables:

        # Get info
        var_name = var_el.get('name')

        var_type_dict = utils.findType(var_el)
        var_type_name = var_type_dict['name']
        var_type_el   = var_type_dict['el']
        pointerness   = var_type_dict['pointerness']
        is_ref        = var_type_dict['is_reference']

        var_type = var_type_dict['name'] + '*'*pointerness + '&amp;'*is_ref
        
        var_is_loaded_class = utils.isLoadedClass(var_type_el)

        # wrapper_type_name = toWrapperType(var_type, remove_reference=True, remove_pointers=True, include_namespace=True)
        var_abstr_class_name = getClassNameDict(var_type_el, abstract=True)
        # var_wrapper_base_class_name = 'WrapperBase&lt;' + var_abstr_class_name['long'] + '&gt;'

        # # FIXME: At the moment there are problems with member variables that are pointer-to-loaded-class. For now, skip them:
        # if var_is_loaded_class and pointerness &gt; 0:
        #     print('WARNING: The member variable %s is of a loaded type and has pointerness &gt; 0. This BOSS cannot yet handle. Ignored for now...' % var_name)
        #     continue

        # Construct common initialization list
        if var_is_loaded_class:
            if pointerness == 0:
                common_init_list_code += indent + var_name + '( get_BEptr()-&gt;' + var_name + '_ref' + gb.code_suffix + '().get_init_wref()),\n'
            elif pointerness == 1:
                common_init_list_code += indent + var_name + '( get_BEptr()-&gt;' + var_name + '_ref' + gb.code_suffix + '()-&gt;get_init_wptr()),\n'
                # common_init_list_code += indent + var_name + '(wrapperbase::BEptr-&gt;' + var_name + '_ref' + gb.code_suffix + '()),\n'
            else:
                raise Exception('The BOSS wrapper class system cannot presently handle member variables that have a pointerness &gt; 1')
        else:
            common_init_list_code += indent + var_name + '( get_BEptr()-&gt;' + var_name + '_ref' + gb.code_suffix + '()),\n'


    # Clean up initialization list
    if common_init_list_code != '':
        common_init_list_code = common_init_list_code.rstrip(',\n') + '\n'


    # Add wrappers for all original constructors except the copy constructor
    temp_code = ''
    factory_counter = 0
    for i, constr_el in enumerate(class_constructors):

        # Identify arguments
        args = funcutils.getArgs(constr_el)
        factory_args = funcutils.constrWrapperArgs(args, add_ref=True)

        # If default arguments are used, we need overloaded constructors to connect to the overloaded
        # factory function pointers
        n_overloads = funcutils.numberOfDefaultArgs(constr_el)

        # One constructor for each set of default arguments
        for remove_n_args in range(n_overloads+1):

            # Check that the constructor is acceptable
            if funcutils.ignoreFunction(constr_el, limit_pointerness=True, remove_n_args=remove_n_args):
                continue

            if remove_n_args == 0:
                use_args         = args
                factory_use_args = factory_args
            else:
                use_args         = args[:-remove_n_args]
                factory_use_args = factory_args[:-remove_n_args]

            args_bracket = funcutils.constrArgsBracket(use_args, include_arg_name=True, include_arg_type=True, include_namespace=True, use_wrapper_class=False)
            args_bracket_notypes = funcutils.constrArgsBracket(use_args, include_arg_name=True, include_arg_type=False, wrapper_to_pointer=False)
            factory_args_bracket = funcutils.constrArgsBracket(factory_use_args, include_arg_name=False, include_arg_type=True, include_namespace=True)

            # Factory pointer name
            factory_ptr_name = '__factory' + str(factory_counter)

            temp_code += 'inline ' + class_name['short'] + '::' + class_name['short'] + args_bracket + ' :\n'

            parent_class_init_list = ''
            # parent_class_init_list += indent + 'WrapperBase(' + factory_ptr_name + args_bracket_notypes + '),\n'
            for parent_dict in loaded_parent_classes:
                parent_class_init_list += indent + parent_dict['class_name']['short'] + '(' + factory_ptr_name + args_bracket_notypes + '),\n'
            if parent_class_init_list == '':
                parent_class_init_list += indent + 'WrapperBase(' + factory_ptr_name + args_bracket_notypes + '),\n'

            if common_init_list_code != '':
                temp_code += parent_class_init_list + common_init_list_code
            else:
                temp_code += parent_class_init_list.rstrip(',\n') + '\n'
            temp_code += '{\n'
            temp_code += common_constructor_body
            temp_code += '}\n'

            temp_code += '\n'

            # Increment factory counter
            factory_counter += 1

    if temp_code != '':
        def_code += '\n'
        def_code += '// Wrappers for original constructors: \n'    
        def_code += temp_code


    # Add special constructor based on abstract class pointer.
    def_code += '// Special pointer-based constructor: \n'
    def_code += do_inline*'inline ' + class_name['short'] + '::' + class_name['short'] + '(' + abstr_class_name['short'] +'* in) :\n'

    parent_class_init_list = ''
    # parent_class_init_list += indent + 'WrapperBase(in),\n'
    for parent_dict in loaded_parent_classes:
        parent_class_init_list += indent + parent_dict['class_name']['short'] + '(in),\n'
    if parent_class_init_list == '':
        parent_class_init_list += indent + 'WrapperBase(in),\n'

    if common_init_list_code != '':
        def_code += parent_class_init_list + common_init_list_code
    else:
        def_code += parent_class_init_list.rstrip(',\n') + '\n'
    def_code += '{\n'
    def_code += common_constructor_body
    def_code += '}\n'

    # # Const version of constructor from abstract class pointer
    # def_code += do_inline*'inline ' + class_name['long'] + '::' + class_name['short'] + '(const ' + abstr_class_name['long'] +'* in) :\n'

    # parent_class_init_list = ''
    # for parent_dict in loaded_parent_classes:
    #     parent_class_init_list += indent + parent_dict['class_name']['short'] + '(in),\n'
    # if parent_class_init_list == '':
    #     parent_class_init_list += indent + 'WrapperBase(in),\n'

    # if common_init_list_code != '':
    #     def_code += parent_class_init_list + common_init_list_code
    # else:
    #     def_code += parent_class_init_list.rstrip(',\n') + '\n'
    # def_code += '{\n'
    # def_code += common_constructor_body
    # def_code += '}\n'



    # Add copy constructor
    if has_copy_constructor:
        def_code += '\n'
        def_code += '// Copy constructor: \n'
        def_code += do_inline*'inline ' + class_name['short'] + '::' + class_name['short'] + '(const ' + class_name['short'] +'&amp; in) :\n'

        parent_class_init_list = ''
        # parent_class_init_list += indent + 'WrapperBase(in.get_BEptr()-&gt;pointer_copy' + gb.code_suffix + '()),\n'
        for parent_dict in loaded_parent_classes:
            parent_class_init_list += indent + parent_dict['class_name']['short'] + '(in.get_BEptr()-&gt;pointer_copy' + gb.code_suffix + '()),\n'
        if parent_class_init_list == '':
            parent_class_init_list += indent + 'WrapperBase(in.get_BEptr()-&gt;pointer_copy' + gb.code_suffix + '()),\n'

        if common_init_list_code != '':
            def_code += parent_class_init_list + common_init_list_code
        else:
            def_code += parent_class_init_list.rstrip(',\n') + '\n'
        def_code += '{\n'
        def_code += common_constructor_body
        def_code += '}\n'


    # 
    # Add assignment operator
    #
    if construct_assignment_operator:
        def_code += '\n'
        def_code += '// Assignment operator: \n'
        def_code += do_inline*'inline ' + class_name['short'] + '&amp; ' + class_name['short'] + '::operator=(const ' + class_name['short'] +'&amp; in)\n'
        def_code += '{\n'
        def_code +=   indent + 'if (this != &amp;in)\n'
        def_code +=   indent + '{\n'
        def_code += 2*indent + 'get_BEptr()-&gt;pointer_assign' + gb.code_suffix + '(in.get_BEptr());\n'
        def_code +=   indent + '}\n'
        def_code +=   indent + 'return *this;\n'
        def_code += '}\n\n'
    

    # 
    # Add destructor
    #
    def_code += '\n'
    def_code += '// Destructor: \n'
    def_code += do_inline*'inline ' + class_name['short'] + '::~' + class_name['short'] + '()\n'
    def_code += '{\n'
    if gb.debug_mode:
        def_code += indent + 'std::cerr &lt;&lt; &quot;DEBUG: &quot; &lt;&lt; this &lt;&lt; &quot; ' + short_wrapper_class_name + ' dtor (BEGIN)&quot; &lt;&lt; std::endl;\n'
    def_code +=   indent + 'if (get_BEptr() != 0)\n'
    def_code +=   indent + '{\n'
    def_code += 2*indent + 'get_BEptr()-&gt;set_delete_wrapper(false);\n'
    def_code += 2*indent + 'if (can_delete_BEptr())\n'
    def_code += 2*indent + '{\n'
    def_code += 3*indent + 'delete BEptr;\n'
    def_code += 3*indent + 'BEptr = 0;\n'
    def_code += 2*indent + '}\n'
    def_code +=   indent + '}\n'
    def_code +=   indent + 'set_delete_BEptr(false);\n'
    if gb.debug_mode:
        def_code += indent + 'std::cerr &lt;&lt; &quot;DEBUG: &quot; &lt;&lt; this &lt;&lt; &quot; ' + short_wrapper_class_name + ' dtor (END)&quot; &lt;&lt; std::endl;\n'
    def_code += '}\n'


    #
    # Add get_BEptr function
    #
    def_code += '\n'
    def_code += '// Returns correctly casted pointer to Abstract class: \n'
    def_code += do_inline*'inline ' + abstr_class_name['short'] +'* ' + class_name['long'] + '::get_BEptr() const\n'
    def_code += '{\n'
    def_code += indent + 'return dynamic_cast&lt;' + abstr_class_name['short'] + '*&gt;(BEptr);\n'
    def_code += '}\n'

    
    # Add namespace
    namespace, class_name_short = utils.removeNamespace(class_name['long'], return_namespace=True)

    if namespace == '':
        namespace_list = []
    else:
        namespace_list = namespace.split('::')

    n_indents = len(namespace_list)

    def_code_with_ns  = ''
    def_code_with_ns += utils.constrNamespace(namespace_list,'open')
    def_code_with_ns += utils.addIndentation(def_code, cfg.indent*n_indents)
    def_code_with_ns += utils.constrNamespace(namespace_list,'close')


    # Return 
    return def_code_with_ns

# ====== END: constrWrapperDef ========



# ====== pureVirtualMembers ========

def pureVirtualMembers(class_el):

    # Return a list with the names of all pure virtual member functions of a class.

    check_member_elements = utils.getMemberElements(class_el)
    pure_virtual_members = []

    for mem_el in check_member_elements:
        if mem_el.tag in ['Constructor', 'Destructor', 'Method', 'OperatorMethod']:
            if ('pure_virtual' in mem_el.keys()) and (mem_el.get('pure_virtual')=='1'):
                pure_virtual_members.append(mem_el.get('name'))

    return pure_virtual_members

# ====== END: pureVirtualMembers ========



# ====== generateWrapperHeaderCode ========

# Generate a header file with a GAMBIT wrapper class.

def generateWrapperHeaderCode(class_el, class_name, abstr_class_name, namespaces, 
                          short_abstr_class_fname,
                          construct_assignment_operator, has_copy_constructor,
                          copy_constructor_id=''):

    # Useful variables
    indent = ' '*cfg.indent

    # Useful lists
    class_variables    = []
    class_functions    = utils.getMemberFunctions(class_el, include_artificial=False, include_inherited=cfg.wrap_inherited_members, 
                                                            only_accepted=True, limit_pointerness=True, include_operators=True)
    class_constructors = []
    class_members      = utils.getMemberElements(class_el, include_artificial=False)
    class_members_full = utils.getMemberElements(class_el, include_artificial=True)
    for mem_el in class_members:

        if (mem_el.tag in ('Field', 'Variable')) and (mem_el.get('access') == 'public'):
            if isAcceptedMemberVariable(mem_el):
                class_variables.append(mem_el)
        else:
            pass

    for mem_el in class_members_full:

        # Skip the copy constructor
        if has_copy_constructor and (mem_el.get('id') == copy_constructor_id):
            continue

        # Store constructor if acceptable
        if (mem_el.tag == 'Constructor') and (mem_el.get('access') == 'public'):
            class_constructors.append(mem_el)

    # Create a list of dicts with info on the (loaded) parent classes
    loaded_parent_classes = utils.getParentClasses(class_el, only_loaded_classes=True)


    #
    # Start code generation
    #

    decl_code = constrWrapperDecl(class_name, abstr_class_name, loaded_parent_classes, class_variables, class_functions, class_constructors, construct_assignment_operator, has_copy_constructor, indent=indent)
    def_code  = constrWrapperDef(class_name, abstr_class_name, loaded_parent_classes, class_variables, class_functions, class_constructors, construct_assignment_operator, has_copy_constructor, indent=indent, do_inline=True)

    # Insert tags for the GAMBIT namespace
    decl_code = '\n__START_GAMBIT_NAMESPACE__\n' + decl_code + '\n__END_GAMBIT_NAMESPACE__\n'
    def_code  = '\n__START_GAMBIT_NAMESPACE__\n' + def_code  + '\n__END_GAMBIT_NAMESPACE__\n'

    # Insert include statements needed by GAMBIT 
    backend_undef_incl_statement  = '#include &quot;' + os.path.join(gb.gambit_backend_incl_dir, 'backend_undefs.hpp') + '&quot;\n'
    identification_incl_statement = '#include &quot;' + 'identification.hpp' + '&quot;\n'

    decl_code = identification_incl_statement + decl_code + '\n' + backend_undef_incl_statement
    def_code  = identification_incl_statement + def_code + '\n' + backend_undef_incl_statement


    
    #
    # Add #include statements for the declaration code
    #

    decl_code_include_statements = []

    # - Header where NULL is defined
    decl_code_include_statements.append( '#include &lt;cstddef&gt;' )

    # - If debug_mode, include &lt;iostream&gt; for some output
    if gb.debug_mode:
        decl_code_include_statements.append( '#include &lt;iostream&gt;' )        

    # - Header with forward declarations to all wrapper classes
    decl_code_include_statements.append( '#include &quot;' + gb.frwd_decls_wrp_fname + cfg.header_extension + '&quot;')

    # - Base class for all wrapper classes
    decl_code_include_statements.append( '#include &quot;' + os.path.join(gb.gambit_backend_incl_dir, 'wrapperbase.hpp') + '&quot;')

    # - Abstract class for the original class
    decl_code_include_statements.append( '#include &quot;' + gb.new_header_files[class_name['long']]['abstract'] + '&quot;' )

    # - Wrapper parent classes
    for parent_dict in loaded_parent_classes:
        decl_code_include_statements.append('#include &quot;' + gb.new_header_files[ parent_dict['class_name']['long'] ]['wrapper_decl'] + '&quot;')

    # - Any other types (excluding the current wrapper class)
    decl_code_include_statements += utils.getIncludeStatements(class_el, convert_loaded_to='wrapper_decl', exclude_types=[class_name], use_full_path=False, forward_declared='exclude')

    # Remove duplicates and construct code
    decl_code_include_statements = list( OrderedDict.fromkeys(decl_code_include_statements) )
    decl_code_include_statements = utils.orderIncludeStatements(decl_code_include_statements)
    decl_include_statements_code = '\n'.join(decl_code_include_statements) + 2*'\n'
    decl_code = decl_include_statements_code + decl_code


    #
    # Add #include statements for the definition code
    #

    def_code_include_statements = []

    # - Any other types (excluding the current wrapper class)
    def_code_include_statements += utils.getIncludeStatements(class_el, convert_loaded_to='wrapper_decl', exclude_types=[class_name], use_full_path=False, forward_declared='include')

    # Remove duplicates and construct code
    def_code_include_statements = list( OrderedDict.fromkeys(def_code_include_statements) )
    def_code_include_statements = utils.orderIncludeStatements(def_code_include_statements)
    def_include_statements_code = '\n'.join(def_code_include_statements) + 2*'\n'
    def_code = def_include_statements_code + def_code


    # Return code
    return decl_code, def_code

# ====== END: generateWrapperHeaderCode ========



# ====== findClassNamePosition ========

# Find the position of a class name  

def findClassNamePosition(class_el, file_content_nocomments):

    class_name = getClassNameDict(class_el)

    # Find the index of the \n after the first line of the class declaration
    line_number = int(class_el.get('line'))
    newline_pos = utils.findNewLinePos(file_content_nocomments, line_number)

    # Find position of class name
    search_limit = newline_pos
    while search_limit &gt; -1:
        class_name_pos = file_content_nocomments[:search_limit].rfind(class_name['short'])
        pre_char  = file_content_nocomments[class_name_pos-1]
        post_char = file_content_nocomments[class_name_pos+len(class_name['short'])]
        if (pre_char in [' ','\n','\t']) and (post_char in [' ', ':', '\n', '&lt;', '{']):
            break
        else:
            search_limit = class_name_pos

    return class_name_pos

# ====== END: findClassNamePosition ========



# ====== isAcceptedMemberVariable ========

def isAcceptedMemberVariable(mem_el):

    is_accepted = True

    if not utils.isAcceptedType(mem_el):
        reason = &quot;Non-accepted type.&quot;
        infomsg.IgnoredMemberVariable(mem_el.get('name'), reason).printMessage()
        is_accepted = False
        return is_accepted

    # Should this member be ditched?
    if 'name' in mem_el.keys():
        namespaces_list = utils.getNamespaces(mem_el, include_self=True)
        full_name = '::'.join(namespaces_list)
        if full_name in cfg.ditch:
            is_accepted = False
            return is_accepted

    # BOSS cannot yet handle member variables that are pointer-to-loaded-class.
    type_dict = utils.findType(mem_el)
    type_name = type_dict['name']
    pointerness = type_dict['pointerness']

    if utils.isLoadedClass(mem_el) and pointerness &gt; 0:
        reason = &quot;BOSS cannot yet handle member variables of type pointer-to-loaded-class.&quot;
        infomsg.IgnoredMemberVariable(mem_el.get('name'), reason).printMessage()
        is_accepted = False
        return is_accepted

    return is_accepted

# ====== END: isAcceptedMemberVariable ========
</code></pre><hr><p>Updated on 2022-07-20 at 17:18:48 +0000</p><div class=edit-page><a href=https://github.com/RC1242RC/gambit_gh_pages/blob/master/content/en/documentation/code/Files/classutils_8py.md><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828.0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>Edit this page on GitHub</a></div></main></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Powered by <a class=text-muted href=https://www.netlify.com/>Netlify</a>, <a class=text-muted href=https://gohugo.io/>Hugo</a>, and <a class=text-muted href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline><li class=list-inline-item><a href=/main_development/license/>License</a></li></ul></div></div></div></footer><script src=/main_development/js/bootstrap.min.54bf0932b8a36d0e152b1635b099a6ef1394d35327e2437550a075c9c8ed1bd8aed5847c21b36fc02ed24014c031d9ca24017b0c78b1639d7e2fa8329898b842.js integrity="sha512-VL8JMrijbQ4VKxY1sJmm7xOU01Mn4kN1UKB1ycjtG9iu1YR8IbNvwC7SQBTAMdnKJAF7DHixY51+L6gymJi4Qg==" crossorigin=anonymous defer></script>
<script src=/main_development/js/highlight.min.5b48bc253dc75aeea5fb366ecf700f4925e2b6eb1a1466f2124b722d68148d67bc0a9365d2b8ad9c585161b46372d23b08509a16f1fd518542b894756d4752d0.js integrity="sha512-W0i8JT3HWu6l+zZuz3APSSXitusaFGbyEktyLWgUjWe8CpNl0ritnFhRYbRjctI7CFCaFvH9UYVCuJR1bUdS0A==" crossorigin=anonymous defer></script>
<script src=/main_development/main.min.40265e9a032aeba5eaf67baac3cbbc22667a7533215d326eeb3e9f4d5e4be40f9ff4dcd22949db73ae527ca26a19d7998091a8973c82af760b2c0daa335190ed.js integrity="sha512-QCZemgMq66Xq9nuqw8u8ImZ6dTMhXTJu6z6fTV5L5A+f9NzSKUnbc65SfKJqGdeZgJGolzyCr3YLLA2qM1GQ7Q==" crossorigin=anonymous defer></script>
<script src=https://rc1242rc.github.io/main_development/index.min.2e958d3be0c5b27cae804290be7a3d5ff0b6d3ca87ab76eeeeb88dbe22b3f251bcc80b638457f7977802ccdc9ff51bd15b8e424e00a8ab3a22c4c1ab6824d4ad.js integrity="sha512-LpWNO+DFsnyugEKQvno9X/C208qHq3bu7riNviKz8lG8yAtjhFf3l3gCzNyf9RvRW45CTgCoqzoixMGraCTUrQ==" crossorigin=anonymous defer></script></body></html>