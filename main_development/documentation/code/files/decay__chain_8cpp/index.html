<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=https://rc1242rc.github.io/main_development/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://rc1242rc.github.io/main_development/fonts/vendor/jost/jost-v4-latin-500.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://rc1242rc.github.io/main_development/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><script>(()=>{var e=localStorage.getItem("theme");e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><link rel=stylesheet href=https://rc1242rc.github.io/main_development/main.1fa2debdf0a1b20e7268d11906902449af896197928a5bdae9dca95b629cdd73746db3d8c6afacb7320d9deb149a318c764669d08a1ddfd34a657ab2aeab866a.css integrity="sha512-H6LevfChsg5yaNEZBpAkSa+JYZeSilva6dypW2Kc3XN0bbPYxq+stzINnesUmjGMdkZp0Iod39NKZXqyrquGag==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>file src/decay_chain.cpp - GAMBIT</title><meta name=description content="[No description available]"><link rel=canonical href=https://rc1242rc.github.io/main_development/documentation/code/files/decay__chain_8cpp/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="file src/decay_chain.cpp"><meta property="og:description" content="[No description available]"><meta property="og:url" content="https://rc1242rc.github.io/main_development/documentation/code/files/decay__chain_8cpp/"><meta property="og:site_name" content="GAMBIT"><meta property="og:image" content="https://rc1242rc.github.io/main_development/gambit_logo.png"><meta property="og:image:alt" content="GAMBIT"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content><meta name=twitter:creator content><meta name=twitter:title content="file src/decay_chain.cpp"><meta name=twitter:description content="[No description available]"><meta name=twitter:image content="https://rc1242rc.github.io/main_development/gambit_logo.png"><meta name=twitter:image:alt content="file src/decay_chain.cpp"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://rc1242rc.github.io/#/schema/organization/1","name":"Doks","url":"https://rc1242rc.github.io/","sameAs":["https://github.com/GambitBSM"],"logo":{"@type":"ImageObject","@id":"https://rc1242rc.github.io/#/schema/image/1","url":"https://rc1242rc.github.io/logo-doks.png","width":450,"height":416,"caption":"Doks"},"image":{"@id":"https://rc1242rc.github.io/#/schema/image/1"}},{"@type":"WebSite","@id":"https://rc1242rc.github.io/#/schema/website/1","url":"https://rc1242rc.github.io/","name":"GAMBIT","description":"Documentation for the Global And Modular BSM Inference Tool","publisher":{"@id":"https://rc1242rc.github.io/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://rc1242rc.github.io/main_development/documentation/code/files/decay__chain_8cpp/","url":"https://rc1242rc.github.io/main_development/documentation/code/files/decay__chain_8cpp/","name":"file src\/decay_chain.cpp","description":"[No description available]","isPartOf":{"@id":"https://rc1242rc.github.io/#/schema/website/1"},"about":{"@id":"https://rc1242rc.github.io/#/schema/organization/1"},"datePublished":"0001-01-01T00:00:00CET","dateModified":"0001-01-01T00:00:00CET","breadcrumb":{"@id":"https://rc1242rc.github.io/main_development/documentation/code/files/decay__chain_8cpp/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://rc1242rc.github.io/main_development/documentation/code/files/decay__chain_8cpp/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://rc1242rc.github.io/main_development/documentation/code/files/decay__chain_8cpp/"]}]},{"@type":"BreadcrumbList","@id":"https://rc1242rc.github.io/main_development/documentation/code/files/decay__chain_8cpp/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/main_development","url":"https://rc1242rc.github.io/main_development","name":"Home"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/main_development/documentation/","url":"https://rc1242rc.github.io/main_development/documentation/","name":"Documentation"}},{"@type":"ListItem","position":4,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/main_development/documentation/code/","url":"https://rc1242rc.github.io/main_development/documentation/code/","name":"Code"}},{"@type":"ListItem","position":5,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/main_development/documentation/code/files/","url":"https://rc1242rc.github.io/main_development/documentation/code/files/","name":"Files"}},{"@type":"ListItem","position":6,"item":{"@id":"https://rc1242rc.github.io/main_development/documentation/code/files/decay__chain_8cpp/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://rc1242rc.github.io/main_development/documentation/code/files/decay__chain_8cpp/#/schema/image/2","url":"https://rc1242rc.github.io/main_development/gambit_logo.png","contentUrl":"https://rc1242rc.github.io/main_development/gambit_logo.png","caption":"file src\/decay_chain.cpp"}]}]}</script><meta name=theme-color content="#fff"><link rel=icon href=https://rc1242rc.github.io/main_development/favicon.ico sizes=any><link rel=icon type=image/svg+xml href=https://rc1242rc.github.io/main_development/favicon.svg><link rel=apple-touch-icon sizes=180x180 href=https://rc1242rc.github.io/main_development/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://rc1242rc.github.io/main_development/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://rc1242rc.github.io/main_development/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://rc1242rc.github.io/main_development/site.webmanifest></head><body class="documentation single light"><div class=sticky-top><div class=header-bar></div><header class="navbar navbar-expand-md navbar-light doks-navbar"><nav class="container-xxl flex-wrap flex-md-nowrap" aria-label="Main navigation"><a class="navbar-brand p-0 me-auto" href=/ aria-label=GAMBIT><img class=logo-light src=/images/gambit_logo.png width=50px>
<img class="logo-dark d-none" src=/images/gambit_logo.png width=50px>
GAMBIT</a>
<button class="btn btn-menu order-2 d-block d-lg-none" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasDoks aria-controls=offcanvasDoks aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><div class="offcanvas offcanvas-end border-0 py-lg-1" tabindex=-1 id=offcanvasDoks data-bs-backdrop=true aria-labelledby=offcanvasDoksLabel><div class="header-bar d-lg-none"></div><div class="offcanvas-header d-lg-none"><h2 class="h5 offcanvas-title ps-2" id=offcanvasDoksLabel><a class=text-dark href=/>GAMBIT</a></h2><button type=button class="btn-close text-reset me-2" data-bs-dismiss=offcanvas aria-label="Close main menu"></button></div><div class="offcanvas-body p-4 p-lg-0"><ul class="nav flex-column flex-lg-row align-items-lg-center mt-2 mt-lg-0 ms-lg-2 me-lg-auto"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Documentation
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/main_development/documentation/installation/introduction/>Installation</a></li><li><a class=dropdown-item href=/main_development/documentation/examples/colliderbit>Examples</a></li><li><a class=dropdown-item href=/main_development/documentation/help/faqs/>Help</a></li><li><a class=dropdown-item href=/main_development/documentation/code/index_classes>Code Reference</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Community
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/main_development/community/publications/>Publications</a></li><li><a class=dropdown-item href=/main_development/community/talks/>Talks</a></li><li><a class=dropdown-item href=/main_development/community/members/>Members</a></li><li><a class=dropdown-item href=/main_development/community/code_of_conduct/>Code of Conduct</a></li><li><a class=dropdown-item href=/main_development/community/contact/>Contact</a></li></ul></li></ul><hr class="text-black-50 my-4 d-lg-none"><form class="doks-search position-relative flex-grow-1 ms-lg-auto me-lg-2"><input id=search class="form-control is-search" type=search placeholder="Search site..." aria-label="Search site..." autocomplete=off><div id=suggestions class="shadow bg-white rounded d-none"></div></form><hr class="text-black-50 my-4 d-lg-none"><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=https://github.com/GambitBSM><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><small class="ms-2 d-lg-none">GitHub</small></a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn btn-doks-light dropdown-toggle" id=doks-versions data-bs-toggle=dropdown aria-expanded=false data-bs-display=static aria-label="Toggle version menu">
<span class=d-none>Doks</span> Main Development
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=doks-versions><li><a class=dropdown-item href=Main%20Development/documentation/code/index_classes/>Main Development</a></li><li><a class=dropdown-item href=TestBit/documentation/code/index_classes/>TestBit</a></li></ul></div></div></div></nav></header></div><div class="wrap container-xxl" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class=docs-links aria-label="Main navigation"><ul class="list-unstyled collapsible-sidebar"><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-installation aria-expanded=false>
Installation</button><div class=collapse id=section-installation><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/main_development/documentation/installation/introduction/>Getting Started</a></li><li><a class="docs-link rounded" href=/main_development/documentation/installation/docker_usage/>Docker Usage</a></li><li><a class="docs-link rounded" href=/main_development/documentation/installation/installation_for_linux/>Installation for Linux</a></li><li><a class="docs-link rounded" href=/main_development/documentation/installation/installation_for_windows/>Installation for Windows</a></li><li><a class="docs-link rounded" href=/main_development/documentation/installation/installation_for_macos/>Installation for macOS</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-examples aria-expanded=false>
Examples</button><div class=collapse id=section-examples><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/main_development/documentation/examples/colliderbit/>ColliderBit</a></li><li><a class="docs-link rounded" href=/main_development/documentation/examples/anotherbit/>AnotherBit</a></li><li><a class="docs-link rounded" href=/main_development/documentation/examples/anotherbit2/>AnotherBit2</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-help aria-expanded=false>
Help</button><div class=collapse id=section-help><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/main_development/documentation/help/faqs/>FAQs</a></li><li><a class="docs-link rounded" href=/main_development/documentation/help/compiler_matrix/>Compiler Matrix</a></li><li><a class="docs-link rounded" href=/main_development/documentation/help/known_issues/>Known Issues</a></li><li><a class="docs-link rounded" href=/main_development/documentation/help/configuration_examples/>Configuration Examples</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-code aria-expanded=false>
Code Reference</button><div class=collapse id=section-code><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/main_development/documentation/code/index_classes/>Classes</a></li><li><a class="docs-link rounded" href=/main_development/documentation/code/index_files/>Files</a></li><li><a class="docs-link rounded" href=/main_development/documentation/code/index_pages/>Pages</a></li><li><a class="docs-link rounded" href=/main_development/documentation/code/index_namespaces/>Namespaces</a></li></ul></div></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=d-xl-none><button class="btn btn-outline-primary btn-sm doks-toc-toggle collapsed" type=button data-bs-toggle=collapse data-bs-target=#onThisPage aria-controls=doks-docs-nav aria-expanded=false aria-label="Toggle On this page navigation">
<span>On this page</span>
<span><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"/><polyline points="7 6 12 11 17 6"/></svg><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"/><polyline points="17 18 12 13 7 18"/></svg></span></button><div class=collapse id=onThisPage><div class="card card-body mt-3 py-1"><div class=page-links><nav id=TableOfContents><ul><li><ul><li><a href=#namespaces>Namespaces</a></li><li><a href=#detailed-description>Detailed Description</a></li><li><a href=#source-code>Source code</a></li></ul></li></ul></nav></div></div></div></div><div class="page-links d-none d-xl-block"><h3>On this page</h3><nav id=TableOfContents><ul><li><ul><li><a href=#namespaces>Namespaces</a></li><li><a href=#detailed-description>Detailed Description</a></li><li><a href=#source-code>Source code</a></li></ul></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9 mx-xl-auto"><h1>file src/decay_chain.cpp</h1><p class=lead></p><p>[No description available] <a href=#detailed-description>More&mldr;</a></p><h2 id=namespaces>Namespaces <a href=#namespaces class=anchor aria-hidden=true>#</a></h2><table><thead><tr><th>Name</th></tr></thead><tbody><tr><td><strong><a href=/documentation/code/namespaces/namespacegambit/>Gambit</a></strong><br>TODO: see if we can use this one:</td></tr><tr><td><strong><a href=/documentation/code/namespaces/namespacegambit_1_1darkbit/>Gambit::DarkBit</a></strong></td></tr><tr><td><strong><a href=/documentation/code/namespaces/namespacegambit_1_1darkbit_1_1decaychain/>Gambit::DarkBit::DecayChain</a></strong></td></tr></tbody></table><h2 id=detailed-description>Detailed Description <a href=#detailed-description class=anchor aria-hidden=true>#</a></h2><p><strong>Author</strong>: Lars A. Dal (<a href=mailto:l.a.dal@fys.uio.no>l.a.dal@fys.uio.no</a>)</p><p><strong>Date</strong>:</p><ul><li>2014 Oct, Nov, Dec</li><li>2015 Jan</li></ul><p>Implementation of classes and functions for decay chain setup Currently only accepts 2-body decays in each step, and assumes that particles decay isotropically in their CM system (like scalars). Does not allow massless particles as intermediate states.</p><hr><p>Authors (add name and date if you modify):</p><hr><h2 id=source-code>Source code <a href=#source-code class=anchor aria-hidden=true>#</a></h2><pre><code>//   GAMBIT: Global and Modular BSM Inference Tool
//   *********************************************

#include &quot;gambit/Elements/gambit_module_headers.hpp&quot;
#include &quot;gambit/DarkBit/DarkBit_rollcall.hpp&quot;

//#define DARKBIT_DEBUG

namespace Gambit
{
  namespace DarkBit
  {
    namespace DecayChain
    {
      using std::ostringstream;
      using std::set;
      using std::endl;
      using std::pair;

      //  *********************************************
      //  3-vector related
      //  *********************************************

      double vec3::length() const
      {
        return sqrt(vals[0]*vals[0]+vals[1]*vals[1]+vals[2]*vals[2]);
      }
      void vec3::normalize()
      {
        double l = length();
        for(int i=0;i&lt;3;i++)
        {
          vals[i] /= l;
        }
      }
      void vec3::normalize(const double len)
      {
        double l = length();
        for(int i=0;i&lt;3;i++)
        {
          vals[i] *= len/l;
        }
      }
      vec3 operator* (double x, const vec3 &amp;y)
      {
        vec3 retVec = y;
        for(int i=0;i&lt;3;i++)
        {
          retVec[i] *= x;
        }
        return retVec;
      }
      vec3 operator* (const vec3 &amp;y, double x)
      {
        vec3 retVec = y;
        for(int i=0;i&lt;3;i++)
        {
          retVec[i] *= x;
        }
        return retVec;
      }
      vec3 operator/ (const vec3 &amp;y, double x)
      {
        vec3 retVec = y;
        for(int i=0;i&lt;3;i++)
        {
          retVec[i] /= x;
        }
        return retVec;
      }
      std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const vec3&amp; v)
      {
        os &lt;&lt; v[0] &lt;&lt; &quot;, &quot; &lt;&lt; v[1]  &lt;&lt; &quot;, &quot; &lt;&lt; v[2];
        return os;
      }
      double dot(const vec3 &amp;a, const vec3 &amp;b)
      {
        return a[0]*b[0]+a[1]*b[1]+a[2]*b[2];
      }


      //  *********************************************
      //  4-vector related
      //  *********************************************

      vec4 operator* (double x, const vec4 &amp;y)
      {
        vec4 retVec = y;
        for(int i=0;i&lt;4;i++)
        {
          retVec[i] *= x;
        }
        return retVec;
      }
      vec4 operator* (const vec4 &amp;y, double x)
      {
        vec4 retVec = y;
        for(int i=0;i&lt;4;i++)
        {
          retVec[i] *= x;
        }
        return retVec;
      }
      vec4 operator+ (const vec4 &amp;x, const vec4 &amp;y)
      {
        vec4 retVec = x;
        for(int i=0;i&lt;4;i++)
        {
          retVec[i] += y[i];
        }
        return retVec;
      }
      vec4 operator- (const vec4 &amp;x, const vec4 &amp;y)
      {
        vec4 retVec = x;
        for(int i=0;i&lt;4;i++)
        {
          retVec[i] -= y[i];
        }
        return retVec;
      }
      std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const vec4&amp; v)
      {
        os &lt;&lt;
          &quot;(&quot; &lt;&lt; v[0] &lt;&lt; &quot;, &quot; &lt;&lt; v[1]  &lt;&lt; &quot;, &quot; &lt;&lt; v[2] &lt;&lt; &quot;, &quot; &lt;&lt; v[3] &lt;&lt;&quot;)&quot;;
        return os;
      }
      double dot(const vec4 &amp;a, const vec4 &amp;b)
      {
        return a[0]*b[0]-a[1]*b[1]-a[2]*b[2]-a[3]*b[3];
      }
      vec4 Ep4vec(const vec3 p, double m)
      {
        double E = sqrt(dot(p,p)+m*m);
        return vec4(E,p);
      }


      //  *********************************************
      //  4x4 matrix related
      //  *********************************************

      mat4::mat4(
          double v00, double v01, double v02, double v03,
          double v10, double v11, double v12, double v13,
          double v20, double v21, double v22, double v23,
          double v30, double v31, double v32, double v33)
      {
        vals[0][0] = v00;
        vals[0][1] = v01;
        vals[0][2] = v02;
        vals[0][3] = v03;
        vals[1][0] = v10;
        vals[1][1] = v11;
        vals[1][2] = v12;
        vals[1][3] = v13;
        vals[2][0] = v20;
        vals[2][1] = v21;
        vals[2][2] = v22;
        vals[2][3] = v23;
        vals[3][0] = v30;
        vals[3][1] = v31;
        vals[3][2] = v32;
        vals[3][3] = v33;
      }
      mat4::mat4(double v)
      {
        vals[0][0] = v;
        vals[0][1] = v;
        vals[0][2] = v;
        vals[0][3] = v;
        vals[1][0] = v;
        vals[1][1] = v;
        vals[1][2] = v;
        vals[1][3] = v;
        vals[2][0] = v;
        vals[2][1] = v;
        vals[2][2] = v;
        vals[2][3] = v;
        vals[3][0] = v;
        vals[3][1] = v;
        vals[3][2] = v;
        vals[3][3] = v;
      }
      mat4 mat4::identity()
      {
        return mat4(1,0,0,0,
            0,1,0,0,
            0,0,1,0,
            0,0,0,1);
      }
      vec4 operator* (const mat4 &amp;m, const vec4 &amp;v)
      {
        vec4 out(0);
        for(int i=0;i&lt;4;i++)
        {
          for(int j=0;j&lt;4;j++)
          {
            out[i] += m.vals[i][j]*v[j];
          }
        }
        return out;
      }
      mat4 operator* (const mat4 &amp;m1, const mat4 &amp;m2)
      {
        mat4 out(0);
        for(int i=0;i&lt;4;i++)
        {
          for(int j=0;j&lt;4;j++)
          {
            for(int k=0; k&lt;4; k++)
            {
              out.vals[i][j] += m1.vals[i][k]*m2.vals[k][j];
            }
          }
        }
        return out;
      }
      std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const mat4&amp; m)
      {
        for(int i=0;i&lt;4;i++)
        {
          for(int j=0;j&lt;4;j++)
          {
            os &lt;&lt; m.vals[i][j] &lt;&lt; &quot;, &quot;;
          }
          if(i!=3)
            os &lt;&lt; endl;
        }
        return os;
      }


      //  *********************************************
      //  Utility functions
      //  *********************************************

      double rand_m1_1()
      {
        return -1.0 + 2.0 * rand_0_1();
      }
      vec3 randOnSphere()
      {
        // Marsaglia 1972 rejection method
        double r1,r2;
        do
        {
          r1 = rand_m1_1();
          r2 = rand_m1_1();
        }
        while(r1*r1+r2*r2 &gt;=1.0);
        vec3 v;
        v[0] = 2.0*r1*sqrt(1-r1*r1-r2*r2);
        v[1] = 2.0*r2*sqrt(1-r1*r1-r2*r2);
        v[2] = 1.0-2.0*(r1*r1+r2*r2);
        return v;
      }
      void lorentzMatrix(const vec3 &amp;beta_xyz, mat4 &amp;mat)
      {
        double b = beta_xyz.length();
        double bm2 = b==0 ? 0 : 1.0/(b*b);
        const double &amp;bx = beta_xyz[0];
        const double &amp;by = beta_xyz[1];
        const double &amp;bz = beta_xyz[2];
        double g = 1.0/sqrt(1-b*b);
        mat =  mat4(    g,      -g*bx,              -g*by,              -g*bz,
            -g*bx,  1+(g-1)*bx*bx*bm2,  (g-1)*bx*by*bm2,    (g-1)*bx*bz*bm2,
            -g*by,  (g-1)*by*bx*bm2,    1+(g-1)*by*by*bm2,  (g-1)*by*bz*bm2,
            -g*bz,  (g-1)*bz*bx*bm2,    (g-1)*bz*by*bm2,    1+(g-1)*bz*bz*bm2);
      }
      void lorentzMatrix(const vec3 &amp;beta_xyz, mat4 &amp;mat, double gamma)
      {
        double b = beta_xyz.length();
        double bm2 = b==0 ? 0 : 1.0/(b*b);
        const double &amp;bx = beta_xyz[0];
        const double &amp;by = beta_xyz[1];
        const double &amp;bz = beta_xyz[2];
        double &amp;g = gamma;
        mat =  mat4(    g,      -g*bx,              -g*by,              -g*bz,
            -g*bx,  1+(g-1)*bx*bx*bm2,  (g-1)*bx*by*bm2,    (g-1)*bx*bz*bm2,
            -g*by,  (g-1)*by*bx*bm2,    1+(g-1)*by*by*bm2,  (g-1)*by*bz*bm2,
            -g*bz,  (g-1)*bz*bx*bm2,    (g-1)*bz*by*bm2,    1+(g-1)*bz*bz*bm2);
      }
      vec4 lorentzBoost(const vec4 &amp;inVec, const vec3 &amp;beta_xyz)
      {
        mat4 lorentz;
        lorentzMatrix(beta_xyz, lorentz);
        return lorentz*inVec;
      }
      vec4 p_parentFrame(const vec4 &amp;inVec, const vec4 &amp;p_parent)
      {
        vec3 beta_xyz = -p_parent.xyz()/p_parent[0];
        return lorentzBoost(inVec, beta_xyz);
      }
      void boostMatrixParentFrame(mat4 &amp;mat, vec4 &amp;p_parent, double m)
      {
        vec3 beta_xyz = -p_parent.xyz()/p_parent[0];
        double gamma = p_parent[0]/m;
        lorentzMatrix(beta_xyz, mat,gamma);
      }
      double invariantMass(const vec4 &amp;a, const vec4 &amp;b)
      {
        vec4 tmp = a+b;
        return sqrt(dot(tmp,tmp));
      }


      //  *********************************************
      //  DecayTableEntry functions
      //  *********************************************

      int DecayTableEntry::findChannelIdx(double pick) const
      {
        if(!randInit)
        {
          piped_warnings.request(LOCAL_INFO,
            &quot;Generating rand table at runtime. This should have happened\n&quot;
            &quot;during initialization, and might not be threadsafe here.&quot;);
          generateRandTable();
        }
        vector&lt;double&gt;::const_iterator pos = upper_bound(randLims.begin(),
            randLims.end(),pick);
        return pos - randLims.begin();
      }
      bool DecayTableEntry::randomDecay(const TH_Channel* &amp;decay) const
      {
        if(!hasEnabledDecays()) return false;
        double pick = rand_0_1();
        int idx = findChannelIdx(pick);
        decay = enabledDecays[idx];
        return true;
      }
      void DecayTableEntry::generateRandTable() const
      {
        randLims.clear();
        double tmp=0;
        for(vector&lt;const TH_Channel*&gt;::const_iterator
            it = enabledDecays.begin(); it != enabledDecays.end(); ++it)
        {
          tmp += DecayTable::getWidth(*it)/enabledWidth;
          randLims.push_back(tmp);
        }
        randInit=true;
      }
      void DecayTableEntry::update()
      {
        totalWidth = 0;
        enabledWidth = 0;
        for(vector&lt;const TH_Channel*&gt;::const_iterator
            it = enabledDecays.begin(); it != enabledDecays.end(); ++it)
        {
          enabledWidth += DecayTable::getWidth(*it);
          totalWidth   += DecayTable::getWidth(*it);
        }
        for(vector&lt;const TH_Channel*&gt;::const_iterator
            it = disabledDecays.begin(); it != disabledDecays.end(); ++it)
        {
          totalWidth   += DecayTable::getWidth(*it);
        }
        totalWidth += invisibleWidth;
        if(randInit) generateRandTable();
      }
      bool DecayTableEntry::isEnabled(const TH_Channel *in) const
      {
        for(vector&lt;const TH_Channel*&gt;::const_iterator
            it = enabledDecays.begin(); it != enabledDecays.end(); ++it)
        {
          if((*it) == in) return true;
        }
        return false;
      }
      bool DecayTableEntry::isDisabled(const TH_Channel *in) const
      {
        for(vector&lt;const TH_Channel*&gt;::const_iterator
            it = disabledDecays.begin(); it != disabledDecays.end(); ++it)
        {
          if((*it) == in) return true;
        }
        return false;
      }
      bool DecayTableEntry::isRegistered (const TH_Channel *in) const
      {
        if(isEnabled(in)) return true;
        if(isDisabled(in)) return true;
        return false;
      }
      void DecayTableEntry::addChannel(const TH_Channel *in)
      {
        if(in-&gt;nFinalStates &gt; 2)
        {
          piped_warnings.request(LOCAL_INFO,
            &quot;Trying to add decay with &gt;2 final states to DecayTableEntry.\n&quot;
            &quot;Channel added as disabled.&quot;);
          addDisabled(in);
          return;
        }
        enabledDecays.push_back(in);
        totalWidth   += DecayTable::getWidth(in);
        enabledWidth += DecayTable::getWidth(in);
      }
      void DecayTableEntry::addDisabled(const TH_Channel *in)
      {
        disabledDecays.push_back(in);
        totalWidth   += DecayTable::getWidth(in);
      }
      void DecayTableEntry::setInvisibleWidth(double width)
      {
        invisibleWidth = width;
        totalWidth  += width;
      }
      bool DecayTableEntry::enableDecay(const TH_Channel *in)
      {
        // N&gt;2 body decays currently not possible.
        if(in-&gt;nFinalStates &gt; 2)
        {
          piped_warnings.request(LOCAL_INFO,
            &quot;Trying to enable decay with &gt;2 final states in decay chain.\n&quot;
            &quot;Request ignored.&quot;);
          return false;
        }
        bool found = false;
        for(vector&lt;const TH_Channel*&gt;::iterator
            it = disabledDecays.begin(); it != disabledDecays.end(); ++it)
        {
          if((*it) == in)
          {
            found = true;
            disabledDecays.erase(it);
          }
        }
        if(!found) return false;
        enabledDecays.push_back(in);
        enabledWidth += DecayTable::getWidth(in);
        // Re-generate Monte Carlo table if necessary
        if(randInit) generateRandTable();
        return true;
      }
      bool DecayTableEntry::disableDecay(const TH_Channel *in)
      {
        bool found = false;
        for(vector&lt;const TH_Channel*&gt;::iterator it = enabledDecays.begin();
            it != enabledDecays.end(); ++it)
        {
          if((*it) == in)
          {
            found = true;
            enabledDecays.erase(it);
          }
        }
        if(!found) return false;
        disabledDecays.push_back(in);
        enabledWidth -= DecayTable::getWidth(in);
        // Re-generate Monte Carlo table if necessary
        if(randInit) generateRandTable();
        return true;
      }
      double DecayTableEntry::getEnabledBranching() const
      {
        return hasEnabledDecays() ? enabledWidth/getTotalWidth() : 0.0;
      }
      void DecayTableEntry::forceTotalWidth(bool enabled, double width)
      {
        useForcedTotalWidth = enabled;
        forcedTotalWidth = width;
      }
      double DecayTableEntry::getTotalWidth() const
      {
        return useForcedTotalWidth ? forcedTotalWidth : totalWidth;
      }
      bool DecayTableEntry::hasEnabledDecays() const
      {
        return (enabledDecays.size()&gt;0);
      }

      //  *********************************************
      //  DecayTable functions
      //  *********************************************

      DecayTable::DecayTable(const TH_ProcessCatalog &amp;cat,
          const SimYieldTable &amp;tab, set&lt;string&gt; disabledList)
      {
#ifdef DARKBIT_DEBUG
        std::cout &lt;&lt; &quot;Importing CascadeMC DecayTable from process catalog...&quot; &lt;&lt; std::endl;
#endif
        set&lt;string&gt; finalStates;
        // Register all decaying particles and their decays
        for(vector&lt;TH_Process&gt;::const_iterator it = cat.processList.begin();
            it != cat.processList.end(); ++it)
        {
          // Only interested in decay processes
          if(it-&gt;isAnnihilation) continue;

          string pID = it-&gt;particle1ID;
          double m = cat.getParticleProperty(pID).mass;
          bool stable = ((it-&gt;channelList).size()&lt;1);
#ifdef DARKBIT_DEBUG
          std::cout &lt;&lt; &quot;Importing &quot; &lt;&lt; pID &lt;&lt; std::endl;
#endif
          if(disabledList.count(pID)==1) stable = true;
          // If tabulated spectra exist for decays of this particle, consider
          // it stable for the purpose of decay chain generation.
          if(tab.hasAnyChannel(pID)) stable = true;
//          if(!stable and (width &lt;=0.0))
//          {
//             piped_warnings.request(LOCAL_INFO,
//               &quot;Unstable particle &quot;+pID+&quot; with zero width in decay table. Treating it as stable in cascade decays.&quot;);
//             stable = true;
//          }
          // Create DecayTableEntry and insert decay channels
          DecayTableEntry entry(pID,m,stable);
          for(vector&lt;TH_Channel&gt;::const_iterator it2 = (
                it-&gt;channelList).begin(); it2 != (it-&gt;channelList).end(); ++it2)
          {
            // N&gt;2 body decays currently not supported, but should be included
            // as disabled to get the correct total width.
            if((it2-&gt;nFinalStates) &gt; 2)
            {
              entry.addDisabled(&amp;(*it2));
            }
            else
            {
              entry.addChannel(&amp;(*it2));
            }
            for(vector&lt;string&gt;::const_iterator
                it3 = (it2-&gt;finalStateIDs).begin();
                it3 != (it2-&gt;finalStateIDs).end(); ++it3)
            {
              finalStates.insert(*it3);
            }
          }
          entry.setInvisibleWidth(it-&gt;genRateMisc-&gt;bind()-&gt;eval());
          if(!stable and entry.enabledDecays.size() == 0)
          {
            piped_warnings.request(LOCAL_INFO,
              &quot;Unstable particle &quot;+pID+&quot; has no available decay channels. Treating it as stable in cascade decays.&quot;);
            entry.stable = true;
          }
          addEntry(pID,entry);
        }
        // Flag channels where all final final states are stable as endpoints.
        // Loop over all particles
        for(unordered_map&lt;string,DecayTableEntry&gt;::iterator it = table.begin();
            it != table.end(); ++it)
        {
          // Loop over all decays
          for(vector&lt;const TH_Channel*&gt;::const_iterator
              it2 = (it-&gt;second.enabledDecays).begin();
              it2 != (it-&gt;second.enabledDecays).end(); ++it2)
          {
            bool isEndpoint = true;
            // Loop over all final states
            for(vector&lt;string&gt;::const_iterator
                it3 = ((*it2)-&gt;finalStateIDs).begin();
                it3 != ((*it2)-&gt;finalStateIDs).end(); ++it3)
            {
              // All (and only) decaying particles are registered so far. If
              // particle is registered, it's not stable.
              if(hasEntry(*it3))
              {
                if(!table[*it3].stable)
                {
                  isEndpoint = false;
                  break;
                }
              }
            }
            it-&gt;second.endpointFlags[*it2] = isEndpoint;
          }
          it-&gt;second.generateRandTable();
        }
        // Iterate over final states and register particles that have not
        // already been registered (because they are considered stable).
        for(set&lt;string&gt;::iterator it = finalStates.begin();
            it != finalStates.end(); ++it)
        {
          if(!hasEntry(*it))
          {
            double m = cat.getParticleProperty(*it).mass;
            addEntry(*it,m,true);
          }
        }
#ifdef DARKBIT_DEBUG
        std::cout &lt;&lt; &quot;...done&quot; &lt;&lt; std::endl;
#endif
      }
      bool DecayTable::hasEntry(string index) const
      {
        return table.find(index) != table.end();
      }
      void DecayTable::addEntry(string pID, double m, bool stable)
      {
        table.insert (
            pair&lt;string,DecayTableEntry&gt;(pID,DecayTableEntry(pID,m,stable)) );
      }
      void DecayTable::addEntry(string pID, DecayTableEntry entry)
      {
        table.insert ( pair&lt;string,DecayTableEntry&gt;(pID,entry) );
      }
      bool DecayTable::randomDecay(string pID, const TH_Channel* &amp;decay) const
      {
        bool ans=false;
        try
        {
          ans=(table.at(pID)).randomDecay(decay);
        }
        catch (std::out_of_range&amp; e)
        {
          throw(Piped_exceptions::description(LOCAL_INFO,
                &quot;No partcile &quot;+pID+&quot; in decay table.&quot;));
        }
        return ans;
      }
      const DecayTableEntry&amp; DecayTable::operator[](string i) const
      {
        const DecayTableEntry *ent = NULL;
        try
        {
          ent= &amp;table.at(i);
        }
        catch (std::out_of_range&amp; e)
        {
          throw(Piped_exceptions::description(LOCAL_INFO,
                &quot;No partcile &quot;+i+&quot; in decay table.&quot;));
        }
        return *ent;
      }
      double DecayTable::getWidth(const TH_Channel *ch)
      {
        return ch-&gt;genRate-&gt;bind()-&gt;eval();
      }
      void DecayTable::printTable() const
      {
#ifdef DARKBIT_DEBUG
        std::cout &lt;&lt; std::endl;
        std::cout &lt;&lt; &quot;***********************&quot; &lt;&lt; endl;
        std::cout &lt;&lt; &quot;CMC DecayTable printout&quot; &lt;&lt; endl;
        std::cout &lt;&lt; &quot;***********************&quot; &lt;&lt; endl;
        std::cout &lt;&lt; std::endl;
        for(unordered_map&lt;string,DecayTableEntry&gt;::const_iterator
            it = table.begin(); it != table.end(); ++it)
        {
          std::cout &lt;&lt; &quot;Particle: &quot; &lt;&lt;(it-&gt;first) &lt;&lt; endl;
          std::cout &lt;&lt; &quot;Set stable: &quot; &lt;&lt; (it-&gt;second).stable &lt;&lt; endl;
          std::cout &lt;&lt; &quot;Mass: &quot; &lt;&lt;(it-&gt;second).m &lt;&lt; endl;
          std::cout &lt;&lt; &quot;Total width: &quot; &lt;&lt; (it-&gt;second.getTotalWidth())&lt;&lt; endl;
          std::cout &lt;&lt; &quot;Enabled branching ratio: &quot;
            &lt;&lt; (it-&gt;second.getEnabledBranching()) &lt;&lt; endl;
          std::cout &lt;&lt; &quot;Enabled decays:&quot; &lt;&lt; endl;
          for(vector&lt;const TH_Channel*&gt;::const_iterator
              it2 = (it-&gt;second.enabledDecays).begin();
              it2 != (it-&gt;second.enabledDecays).end(); ++it2)
          {
            std::cout &lt;&lt; &quot;  &quot;;
            for(vector&lt;string&gt;::const_iterator
                it3 = ((*it2)-&gt;finalStateIDs).begin();
                it3 != ((*it2)-&gt;finalStateIDs).end(); ++it3)
            {
              std::cout &lt;&lt; *it3 &lt;&lt; &quot;, &quot;;
            }
            std::cout &lt;&lt; &quot;Width: &quot; &lt;&lt; getWidth(*it2) &lt;&lt; endl;
          }
          std::cout &lt;&lt; &quot;Disabled decays:&quot; &lt;&lt; endl;
          for(vector&lt;const TH_Channel*&gt;::const_iterator
              it2 = (it-&gt;second.disabledDecays).begin();
              it2 != (it-&gt;second.disabledDecays).end(); ++it2)
          {
            std::cout &lt;&lt; &quot;  &quot;;
            for(vector&lt;string&gt;::const_iterator
                it3 = ((*it2)-&gt;finalStateIDs).begin();
                it3 != ((*it2)-&gt;finalStateIDs).end(); ++it3)
            {
              std::cout &lt;&lt; *it3 &lt;&lt; &quot;, &quot;;
            }
            std::cout &lt;&lt; &quot;Width: &quot; &lt;&lt; getWidth(*it2) &lt;&lt; endl;
          }
          std::cout &lt;&lt; std::endl;
        }
#endif
      }


      //  *********************************************
      //  ChainParticle functions
      //  *********************************************

      ChainParticle::ChainParticle(
          vec3 ipLab, const DecayTable *dc, string pID) :
        m((*dc)[pID].m), weight(1), decayTable(dc), pID(pID),
        chainGeneration(0), abortedDecay(false), isEndpoint(false),
        nChildren(0), parent(NULL)
      {
        p_parent=Ep4vec(ipLab,m);
        boostMatrixParentFrame(boostToParentFrame,p_parent,m);
        boostToLabFrame = boostToParentFrame;
      }
      void ChainParticle::generateDecayChainMC(int maxSteps, double Emin)
      {
        if(nChildren!=0)
        {
          piped_warnings.request(LOCAL_INFO,
            &quot;Overwriting existing decay in decay chain.&quot;);
          cutChain();
        }
        // Stable particles flagged as endpoints
        if((*decayTable)[pID].stable)
        {
          isEndpoint = true;
        }
        // Check whether or not to proceed with decay
        else if( ((maxSteps &lt; 0) or (int(chainGeneration) &lt; maxSteps))
            and ((Emin &lt; 0) or (E_Lab()&gt; Emin)) )
        {
          const TH_Channel *chn;
          bool canDecay = decayTable-&gt;randomDecay(pID, chn);
          if(!canDecay)
          {
            piped_warnings.request(LOCAL_INFO,
              &quot;Unable to pick allowed decay for &quot;+ pID+&quot;. Keeping particle stable.&quot;);
            abortedDecay = true;
            return;
          }
          // Only 2-body decays are currently allowed
          if((chn-&gt;nFinalStates) != 2)
          {
            string err;
            err = &quot;Invalid decay channel in decay table.\n&quot;;
            err+= &quot;N!=2 body decays are currently not supported in cascade decays.\n&quot;;
            throw(Piped_exceptions::description(LOCAL_INFO,err));
            return;
          }
          nChildren = 2; // chn-&gt;nFinalStates;
          // Kinematics for 2-body decays
          double m1 = (*decayTable)[(chn-&gt;finalStateIDs)[0]].m;
          double m2 = (*decayTable)[(chn-&gt;finalStateIDs)[1]].m;
          if(m1+m2&gt;m)
          {
            ostringstream err;
            err &lt;&lt;
              &quot;Kinematically impossible decay in decay chain:\n&quot; &lt;&lt;
              pID &lt;&lt; &quot;-&gt; &quot; &lt;&lt;
              ((chn-&gt;finalStateIDs)[0]) &lt;&lt; &quot;, &quot; &lt;&lt; ((chn-&gt;finalStateIDs)[1]) &lt;&lt; &quot;\n&quot; &lt;&lt;
              &quot;Please check your process catalog.&quot; &lt;&lt; endl;
            err &lt;&lt; &quot;Relevant particle masses: &quot; &lt;&lt; m &lt;&lt; &quot; -&gt; &quot; &lt;&lt; m1 &lt;&lt; &quot; + &quot; &lt;&lt; m2;
            throw(Piped_exceptions::description(LOCAL_INFO, err.str()));
          }
          const double &amp;Etot = m;
          double E1 = 0.5*(Etot*Etot+m1*m1-m2*m2)/Etot;
          double E2 = Etot-E1;
          double abs_p = sqrt(E1*E1-m1*m1);
          // Assume isotropic decay in CM frame (no spin correlations).
          vec3 dir = randOnSphere();
          vec4 p1(E1, abs_p*dir);
          vec4 p2(E2,-abs_p*dir);
          // Weight from not including all possible decay channels
          double wt = weight*(*decayTable)[pID].getEnabledBranching();
          children.push_back(new ChainParticle(p1, m1, wt, decayTable, this,
                chainGeneration+1, chn-&gt;finalStateIDs[0]));
          children.push_back(new ChainParticle(p2, m2, wt, decayTable, this,
                chainGeneration+1, chn-&gt;finalStateIDs[1]));
          // Reached chain endpoint. Don't attempt further decays
          if((*decayTable)[pID].endpointFlags.at(chn))
          {
            isEndpoint = true;
          }
          // Continue chain from child links.
          else
          {
            for(int i=0;i&lt;nChildren;i++)
            {
              children[i]-&gt;generateDecayChainMC(maxSteps, Emin);
            }
          }
        }
        else
        {
          abortedDecay = true;
        }
      }
      void ChainParticle::reDrawAngles()
      {
        if(nChildren==2)
        {
          double m1 = children[0]-&gt;m;
          vec3  dir = randOnSphere();
          double E1 = children[0]-&gt;p_parent[0];
          double E2 = children[1]-&gt;p_parent[0];
          double abs_p = sqrt(E1*E1-m1*m1);
          vec4 p1(E1, abs_p*dir);
          vec4 p2(E2,-abs_p*dir);
          children[0]-&gt;update(p1);
          children[1]-&gt;update(p2);
          children[0]-&gt;reDrawAngles();
          children[1]-&gt;reDrawAngles();
        }
      }
      void ChainParticle::cutChain()
      {
        for(int i=0;i&lt;nChildren; i++) delete children[i];
        children.clear();
        nChildren = 0;
      }
      vec4 ChainParticle::p_to_Lab(const vec4 &amp;p) const
      {
        return boostToLabFrame*p;
      }
      vec4 ChainParticle::p_Lab() const
      {
        if(chainGeneration==0) return p_parent;
        return parent-&gt;boostToLabFrame*p_parent;
      }
      double ChainParticle::E_Lab() const
      {
        if(chainGeneration==0) return p_parent[0];
        double E = 0;
        for(int j=0;j&lt;4;j++)
        {
          E += (parent-&gt;boostToLabFrame).vals[0][j]*p_parent[j];
        }
        return E;
      }
      void ChainParticle::collectEndpointStates(vector&lt;const ChainParticle*&gt;
          &amp;endpointStates, bool includeAborted, string ipID) const
      {
        if(abortedDecay)
        {
          if(includeAborted &amp;&amp; ((ipID==&quot;&quot;) || (ipID==pID)))
            endpointStates.push_back(this);
        }
        else
        {
          if(nChildren!=0 and !isEndpoint)
          {
            for(vector&lt;ChainParticle*&gt;::const_iterator it=children.begin();
                it!=children.end(); ++it)
            {
              (*it)-&gt;collectEndpointStates(endpointStates,includeAborted,pID);
            }
          }
          else if((ipID==&quot;&quot;) or (ipID==pID) or isEndpoint)
          {
            endpointStates.push_back(this);
          }
        }
      }
      const ChainParticle* ChainParticle::operator[](int i) const
      {
        if(i&lt;nChildren)
          return children[i];
        else
        {
          throw(Piped_exceptions::description(LOCAL_INFO,
                &quot;Trying to access non-existing decay chain entry.&quot;));
          return this;
        }
      }
      const ChainParticle* ChainParticle::getParent() const
      {
        return parent;
      }
      double ChainParticle::E_parentFrame() const
      {
        return p_parent[0];
      }
      void ChainParticle::printChain() const
      {
        std::cout &lt;&lt; &quot;*********************&quot; &lt;&lt; endl;
        std::cout &lt;&lt; &quot;Decay chain printout:&quot; &lt;&lt; endl;
        std::cout &lt;&lt; &quot;---------------------&quot; &lt;&lt; endl;
        std::cout &lt;&lt; &quot;Generation &quot; &lt;&lt; chainGeneration &lt;&lt; &quot;:&quot; &lt;&lt; endl;
        std::cout &lt;&lt; &quot;0  &quot; &lt;&lt; pID &lt;&lt; &quot;, p = &quot; &lt;&lt; p_Lab() &lt;&lt;
          &quot;, Weight: &quot; &lt;&lt; weight  &lt;&lt; endl;
        std::cout &lt;&lt; &quot;---------------------&quot; &lt;&lt; endl;
        if(nChildren&gt;0)
        {
          bool run = false;
          int gen = chainGeneration+1;
          do
          {
            std::cout &lt;&lt; &quot;Generation &quot; &lt;&lt; gen &lt;&lt;&quot;:&quot; &lt;&lt; endl;
            run= false;
            for(int i=0;i&lt;nChildren;i++)
            {
              vector&lt;int&gt; ancestry;
              ancestry.push_back(0);
              ancestry.push_back(i);
              bool more = children[i]-&gt;printChain(gen,ancestry);
              run = more || run;
            }
            gen++;
            std::cout &lt;&lt; &quot;---------------------&quot; &lt;&lt; endl;
          }
          while(run);
        }
      }
      bool ChainParticle::printChain(int generation, vector&lt;int&gt; ancestry) const
      {
        if(generation &lt; chainGeneration) return false;
        if(generation &gt; chainGeneration)
        {
          bool more = false;
          for(int i=0;i&lt;nChildren;i++)
          {
            vector&lt;int&gt; ancestry2 = ancestry;
            ancestry2.push_back(i);
            if(children[i]-&gt;printChain(generation,ancestry2)) more = true;
          }
          return more;
        }
        for(vector&lt;int&gt;::const_iterator it=ancestry.begin();
            it!=ancestry.end(); ++it)
        {
          std::cout &lt;&lt; *it &lt;&lt; &quot;  &quot;;
        }
        std::cout &lt;&lt; pID  &lt;&lt; &quot;, p = &quot; &lt;&lt; p_Lab() &lt;&lt; &quot;, Weight: &quot; &lt;&lt; weight  &lt;&lt; endl;
        if(nChildren&gt;0) return true;
        return false;
      }
      void ChainParticle::getBoost(double&amp; gamma, double&amp; beta) const
      {
        const mat4&amp; b=boostToLabFrame;
        gamma = b.vals[0][0];
        beta = sqrt(b.vals[0][1]*b.vals[0][1]+b.vals[0][2]*b.vals[0][2]+
            b.vals[0][3]*b.vals[0][3])/gamma;
      }
      ChainParticle::~ChainParticle()
      {
        for(int i=0;i&lt;nChildren; i++) delete children[i];
      }
      void ChainParticle::update(vec4 &amp;ip_parent)
      {
        p_parent = ip_parent;
        boostMatrixParentFrame(boostToParentFrame,p_parent,m);
        boostToLabFrame = parent-&gt;boostToLabFrame*boostToParentFrame;
      }
      ChainParticle::ChainParticle(const vec4 &amp;pp, double m, double weight,
          const DecayTable *dc, ChainParticle *parent, int chainGeneration,
          string pID) :
        m(m), weight(weight), decayTable(dc), p_parent(pp), pID(pID),
        chainGeneration(chainGeneration), abortedDecay(false),
        isEndpoint(false), nChildren(0), parent(parent)
      {
        boostMatrixParentFrame(boostToParentFrame,p_parent,m);
        boostToLabFrame = parent-&gt;boostToLabFrame*boostToParentFrame;
      }

    } // namespace DecayChain
  } // namespace DarkBit
} // namespace Gambit
</code></pre><hr><p>Updated on 2022-07-20 at 17:18:45 +0000</p><div class=edit-page><a href=https://github.com/RC1242RC/gambit_gh_pages/blob/master/content/en/documentation/code/Files/decay__chain_8cpp.md><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828.0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>Edit this page on GitHub</a></div></main></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Powered by <a class=text-muted href=https://www.netlify.com/>Netlify</a>, <a class=text-muted href=https://gohugo.io/>Hugo</a>, and <a class=text-muted href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline><li class=list-inline-item><a href=/main_development/license/>License</a></li></ul></div></div></div></footer><script src=/main_development/js/bootstrap.min.54bf0932b8a36d0e152b1635b099a6ef1394d35327e2437550a075c9c8ed1bd8aed5847c21b36fc02ed24014c031d9ca24017b0c78b1639d7e2fa8329898b842.js integrity="sha512-VL8JMrijbQ4VKxY1sJmm7xOU01Mn4kN1UKB1ycjtG9iu1YR8IbNvwC7SQBTAMdnKJAF7DHixY51+L6gymJi4Qg==" crossorigin=anonymous defer></script>
<script src=/main_development/js/highlight.min.5b48bc253dc75aeea5fb366ecf700f4925e2b6eb1a1466f2124b722d68148d67bc0a9365d2b8ad9c585161b46372d23b08509a16f1fd518542b894756d4752d0.js integrity="sha512-W0i8JT3HWu6l+zZuz3APSSXitusaFGbyEktyLWgUjWe8CpNl0ritnFhRYbRjctI7CFCaFvH9UYVCuJR1bUdS0A==" crossorigin=anonymous defer></script>
<script src=/main_development/main.min.40265e9a032aeba5eaf67baac3cbbc22667a7533215d326eeb3e9f4d5e4be40f9ff4dcd22949db73ae527ca26a19d7998091a8973c82af760b2c0daa335190ed.js integrity="sha512-QCZemgMq66Xq9nuqw8u8ImZ6dTMhXTJu6z6fTV5L5A+f9NzSKUnbc65SfKJqGdeZgJGolzyCr3YLLA2qM1GQ7Q==" crossorigin=anonymous defer></script>
<script src=https://rc1242rc.github.io/main_development/index.min.2e958d3be0c5b27cae804290be7a3d5ff0b6d3ca87ab76eeeeb88dbe22b3f251bcc80b638457f7977802ccdc9ff51bd15b8e424e00a8ab3a22c4c1ab6824d4ad.js integrity="sha512-LpWNO+DFsnyugEKQvno9X/C208qHq3bu7riNviKz8lG8yAtjhFf3l3gCzNyf9RvRW45CTgCoqzoixMGraCTUrQ==" crossorigin=anonymous defer></script></body></html>