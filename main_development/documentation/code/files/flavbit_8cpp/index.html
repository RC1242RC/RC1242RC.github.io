<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=https://rc1242rc.github.io/main_development/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://rc1242rc.github.io/main_development/fonts/vendor/jost/jost-v4-latin-500.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://rc1242rc.github.io/main_development/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><script>(()=>{var e=localStorage.getItem("theme");e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><link rel=stylesheet href=https://rc1242rc.github.io/main_development/main.1fa2debdf0a1b20e7268d11906902449af896197928a5bdae9dca95b629cdd73746db3d8c6afacb7320d9deb149a318c764669d08a1ddfd34a657ab2aeab866a.css integrity="sha512-H6LevfChsg5yaNEZBpAkSa+JYZeSilva6dypW2Kc3XN0bbPYxq+stzINnesUmjGMdkZp0Iod39NKZXqyrquGag==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>file src/FlavBit.cpp - GAMBIT</title><meta name=description content="[No description available]"><link rel=canonical href=https://rc1242rc.github.io/main_development/documentation/code/files/flavbit_8cpp/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="file src/FlavBit.cpp"><meta property="og:description" content="[No description available]"><meta property="og:url" content="https://rc1242rc.github.io/main_development/documentation/code/files/flavbit_8cpp/"><meta property="og:site_name" content="GAMBIT"><meta property="og:image" content="https://rc1242rc.github.io/main_development/gambit_logo.png"><meta property="og:image:alt" content="GAMBIT"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content><meta name=twitter:creator content><meta name=twitter:title content="file src/FlavBit.cpp"><meta name=twitter:description content="[No description available]"><meta name=twitter:image content="https://rc1242rc.github.io/main_development/gambit_logo.png"><meta name=twitter:image:alt content="file src/FlavBit.cpp"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://rc1242rc.github.io/#/schema/organization/1","name":"Doks","url":"https://rc1242rc.github.io/","sameAs":["https://github.com/GambitBSM"],"logo":{"@type":"ImageObject","@id":"https://rc1242rc.github.io/#/schema/image/1","url":"https://rc1242rc.github.io/logo-doks.png","width":450,"height":416,"caption":"Doks"},"image":{"@id":"https://rc1242rc.github.io/#/schema/image/1"}},{"@type":"WebSite","@id":"https://rc1242rc.github.io/#/schema/website/1","url":"https://rc1242rc.github.io/","name":"GAMBIT","description":"Documentation for the Global And Modular BSM Inference Tool","publisher":{"@id":"https://rc1242rc.github.io/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://rc1242rc.github.io/main_development/documentation/code/files/flavbit_8cpp/","url":"https://rc1242rc.github.io/main_development/documentation/code/files/flavbit_8cpp/","name":"file src\/FlavBit.cpp","description":"[No description available]","isPartOf":{"@id":"https://rc1242rc.github.io/#/schema/website/1"},"about":{"@id":"https://rc1242rc.github.io/#/schema/organization/1"},"datePublished":"0001-01-01T00:00:00CET","dateModified":"0001-01-01T00:00:00CET","breadcrumb":{"@id":"https://rc1242rc.github.io/main_development/documentation/code/files/flavbit_8cpp/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://rc1242rc.github.io/main_development/documentation/code/files/flavbit_8cpp/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://rc1242rc.github.io/main_development/documentation/code/files/flavbit_8cpp/"]}]},{"@type":"BreadcrumbList","@id":"https://rc1242rc.github.io/main_development/documentation/code/files/flavbit_8cpp/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/main_development","url":"https://rc1242rc.github.io/main_development","name":"Home"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/main_development/documentation/","url":"https://rc1242rc.github.io/main_development/documentation/","name":"Documentation"}},{"@type":"ListItem","position":4,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/main_development/documentation/code/","url":"https://rc1242rc.github.io/main_development/documentation/code/","name":"Code"}},{"@type":"ListItem","position":5,"item":{"@type":"WebPage","@id":"https://rc1242rc.github.io/main_development/documentation/code/files/","url":"https://rc1242rc.github.io/main_development/documentation/code/files/","name":"Files"}},{"@type":"ListItem","position":6,"item":{"@id":"https://rc1242rc.github.io/main_development/documentation/code/files/flavbit_8cpp/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://rc1242rc.github.io/main_development/documentation/code/files/flavbit_8cpp/#/schema/image/2","url":"https://rc1242rc.github.io/main_development/gambit_logo.png","contentUrl":"https://rc1242rc.github.io/main_development/gambit_logo.png","caption":"file src\/FlavBit.cpp"}]}]}</script><meta name=theme-color content="#fff"><link rel=icon href=https://rc1242rc.github.io/main_development/favicon.ico sizes=any><link rel=icon type=image/svg+xml href=https://rc1242rc.github.io/main_development/favicon.svg><link rel=apple-touch-icon sizes=180x180 href=https://rc1242rc.github.io/main_development/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://rc1242rc.github.io/main_development/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://rc1242rc.github.io/main_development/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://rc1242rc.github.io/main_development/site.webmanifest></head><body class="documentation single light"><div class=sticky-top><div class=header-bar></div><header class="navbar navbar-expand-md navbar-light doks-navbar"><nav class="container-xxl flex-wrap flex-md-nowrap" aria-label="Main navigation"><a class="navbar-brand p-0 me-auto" href=/ aria-label=GAMBIT><img class=logo-light src=gambit_logo.png width=50px>
<img class="logo-dark d-none" src=gambit_logo.png width=50px>
GAMBIT</a>
<button class="btn btn-menu order-2 d-block d-lg-none" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasDoks aria-controls=offcanvasDoks aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><div class="offcanvas offcanvas-end border-0 py-lg-1" tabindex=-1 id=offcanvasDoks data-bs-backdrop=true aria-labelledby=offcanvasDoksLabel><div class="header-bar d-lg-none"></div><div class="offcanvas-header d-lg-none"><h2 class="h5 offcanvas-title ps-2" id=offcanvasDoksLabel><a class=text-dark href=/>GAMBIT</a></h2><button type=button class="btn-close text-reset me-2" data-bs-dismiss=offcanvas aria-label="Close main menu"></button></div><div class="offcanvas-body p-4 p-lg-0"><ul class="nav flex-column flex-lg-row align-items-lg-center mt-2 mt-lg-0 ms-lg-2 me-lg-auto"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Documentation
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/main_development/documentation/installation/introduction/>Installation</a></li><li><a class=dropdown-item href=/main_development/documentation/examples/colliderbit>Examples</a></li><li><a class=dropdown-item href=/main_development/documentation/help/faqs/>Help</a></li><li><a class=dropdown-item href=/main_development/documentation/code/index_classes>Code Reference</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Community
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/main_development/community/publications/>Publications</a></li><li><a class=dropdown-item href=/main_development/community/talks/>Talks</a></li><li><a class=dropdown-item href=/main_development/community/members/>Members</a></li><li><a class=dropdown-item href=/main_development/community/code_of_conduct/>Code of Conduct</a></li><li><a class=dropdown-item href=/main_development/community/contact/>Contact</a></li></ul></li></ul><hr class="text-black-50 my-4 d-lg-none"><form class="doks-search position-relative flex-grow-1 ms-lg-auto me-lg-2"><input id=search class="form-control is-search" type=search placeholder="Search site..." aria-label="Search site..." autocomplete=off><div id=suggestions class="shadow bg-white rounded d-none"></div></form><hr class="text-black-50 my-4 d-lg-none"><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=https://github.com/GambitBSM><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><small class="ms-2 d-lg-none">GitHub</small></a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn btn-doks-light dropdown-toggle" id=doks-versions data-bs-toggle=dropdown aria-expanded=false data-bs-display=static aria-label="Toggle version menu">
<span class=d-none>Doks</span> Main Development
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=doks-versions><li><a class=dropdown-item href=/%7b%7b%20replace%20$version%20%27%20%27%20%27_%27%20%7d%7d/documentation/code/index_classes/>Main Development</a></li><li><a class=dropdown-item href=/%7b%7b%20replace%20$version%20%27%20%27%20%27_%27%20%7d%7d/documentation/code/index_classes/>TestBit</a></li></ul></div></div></div></nav></header></div><div class="wrap container-xxl" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class=docs-links aria-label="Main navigation"><ul class="list-unstyled collapsible-sidebar"><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-installation aria-expanded=false>
Installation</button><div class=collapse id=section-installation><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/main_development/documentation/installation/introduction/>Getting Started</a></li><li><a class="docs-link rounded" href=/main_development/documentation/installation/docker_usage/>Docker Usage</a></li><li><a class="docs-link rounded" href=/main_development/documentation/installation/installation_for_linux/>Installation for Linux</a></li><li><a class="docs-link rounded" href=/main_development/documentation/installation/installation_for_windows/>Installation for Windows</a></li><li><a class="docs-link rounded" href=/main_development/documentation/installation/installation_for_macos/>Installation for macOS</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-examples aria-expanded=false>
Examples</button><div class=collapse id=section-examples><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/main_development/documentation/examples/colliderbit/>ColliderBit</a></li><li><a class="docs-link rounded" href=/main_development/documentation/examples/anotherbit/>AnotherBit</a></li><li><a class="docs-link rounded" href=/main_development/documentation/examples/anotherbit2/>AnotherBit2</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-help aria-expanded=false>
Help</button><div class=collapse id=section-help><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/main_development/documentation/help/faqs/>FAQs</a></li><li><a class="docs-link rounded" href=/main_development/documentation/help/compiler_matrix/>Compiler Matrix</a></li><li><a class="docs-link rounded" href=/main_development/documentation/help/known_issues/>Known Issues</a></li><li><a class="docs-link rounded" href=/main_development/documentation/help/configuration_examples/>Configuration Examples</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-code aria-expanded=false>
Code Reference</button><div class=collapse id=section-code><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/main_development/documentation/code/index_classes/>Classes</a></li><li><a class="docs-link rounded" href=/main_development/documentation/code/index_files/>Files</a></li><li><a class="docs-link rounded" href=/main_development/documentation/code/index_pages/>Pages</a></li><li><a class="docs-link rounded" href=/main_development/documentation/code/index_namespaces/>Namespaces</a></li></ul></div></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=d-xl-none><button class="btn btn-outline-primary btn-sm doks-toc-toggle collapsed" type=button data-bs-toggle=collapse data-bs-target=#onThisPage aria-controls=doks-docs-nav aria-expanded=false aria-label="Toggle On this page navigation">
<span>On this page</span>
<span><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"/><polyline points="7 6 12 11 17 6"/></svg><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"/><polyline points="17 18 12 13 7 18"/></svg></span></button><div class=collapse id=onThisPage><div class="card card-body mt-3 py-1"><div class=page-links><nav id=TableOfContents><ul><li><ul><li><a href=#namespaces>Namespaces</a></li><li><a href=#classes>Classes</a></li><li><a href=#defines>Defines</a></li><li><a href=#detailed-description>Detailed Description</a></li><li><a href=#macros-documentation>Macros Documentation</a><ul><li><a href=#define-the_rest>define THE_REST</a></li><li><a href=#define-si_single_prediction_function>define SI_SINGLE_PREDICTION_FUNCTION</a></li><li><a href=#define-si_single_prediction_function_bins>define SI_SINGLE_PREDICTION_FUNCTION_BINS</a></li><li><a href=#define-si_multi_prediction_function>define SI_MULTI_PREDICTION_FUNCTION</a></li><li><a href=#define-si_multi_prediction_function_bins>define SI_MULTI_PREDICTION_FUNCTION_BINS</a></li><li><a href=#define-heplike_gaussian_1d_likelihood>define HEPLIKE_GAUSSIAN_1D_LIKELIHOOD</a></li></ul></li><li><a href=#source-code>Source code</a></li></ul></li></ul></nav></div></div></div></div><div class="page-links d-none d-xl-block"><h3>On this page</h3><nav id=TableOfContents><ul><li><ul><li><a href=#namespaces>Namespaces</a></li><li><a href=#classes>Classes</a></li><li><a href=#defines>Defines</a></li><li><a href=#detailed-description>Detailed Description</a></li><li><a href=#macros-documentation>Macros Documentation</a><ul><li><a href=#define-the_rest>define THE_REST</a></li><li><a href=#define-si_single_prediction_function>define SI_SINGLE_PREDICTION_FUNCTION</a></li><li><a href=#define-si_single_prediction_function_bins>define SI_SINGLE_PREDICTION_FUNCTION_BINS</a></li><li><a href=#define-si_multi_prediction_function>define SI_MULTI_PREDICTION_FUNCTION</a></li><li><a href=#define-si_multi_prediction_function_bins>define SI_MULTI_PREDICTION_FUNCTION_BINS</a></li><li><a href=#define-heplike_gaussian_1d_likelihood>define HEPLIKE_GAUSSIAN_1D_LIKELIHOOD</a></li></ul></li><li><a href=#source-code>Source code</a></li></ul></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9 mx-xl-auto"><h1>file src/FlavBit.cpp</h1><p class=lead></p><p>[No description available] <a href=#detailed-description>More&mldr;</a></p><h2 id=namespaces>Namespaces <a href=#namespaces class=anchor aria-hidden=true>#</a></h2><table><thead><tr><th>Name</th></tr></thead><tbody><tr><td><strong><a href=/documentation/code/namespaces/namespaceyaml/>YAML</a></strong></td></tr><tr><td><strong><a href=/documentation/code/namespaces/namespacegambit/>Gambit</a></strong><br>TODO: see if we can use this one:</td></tr><tr><td><strong><a href=/documentation/code/namespaces/namespacegambit_1_1flavbit/>Gambit::FlavBit</a></strong></td></tr></tbody></table><h2 id=classes>Classes <a href=#classes class=anchor aria-hidden=true>#</a></h2><table><thead><tr><th></th><th>Name</th></tr></thead><tbody><tr><td>struct</td><td><strong><a href=/documentation/code/classes/structyaml_1_1convert_3_01gambit_1_1nuiscorr_01_4/>YAML::convert&lt; Gambit::nuiscorr ></a></strong><br>YAML conversion structure for SuperIso SM nuisance data.</td></tr></tbody></table><h2 id=defines>Defines <a href=#defines class=anchor aria-hidden=true>#</a></h2><table><thead><tr><th></th><th>Name</th></tr></thead><tbody><tr><td></td><td><strong><a href=/documentation/code/files/flavbit_8cpp/#define-the-rest>THE_REST</a></strong>(bins)</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/flavbit_8cpp/#define-si-single-prediction-function>SI_SINGLE_PREDICTION_FUNCTION</a></strong>(name)</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/flavbit_8cpp/#define-si-single-prediction-function-bins>SI_SINGLE_PREDICTION_FUNCTION_BINS</a></strong>(name, bins)</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/flavbit_8cpp/#define-si-multi-prediction-function>SI_MULTI_PREDICTION_FUNCTION</a></strong>(name)</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/flavbit_8cpp/#define-si-multi-prediction-function-bins>SI_MULTI_PREDICTION_FUNCTION_BINS</a></strong>(name, bins, exp)</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/flavbit_8cpp/#define-heplike-gaussian-1d-likelihood>HEPLIKE_GAUSSIAN_1D_LIKELIHOOD</a></strong>(name, file)<br>HEPLike single-observable likelihood.</td></tr></tbody></table><h2 id=detailed-description>Detailed Description <a href=#detailed-description class=anchor aria-hidden=true>#</a></h2><p><strong>Author</strong>:</p><ul><li>Nazila Mahmoudi</li><li>Marcin Chrzaszcz</li><li>Anders Kvellestad (<a href=mailto:anders.kvellestad@fys.uio.no>anders.kvellestad@fys.uio.no</a>)</li><li>Pat Scott (<a href=mailto:pat.scott@uq.edu.au>pat.scott@uq.edu.au</a>)</li><li>Tomas Gonzalo (<a href=mailto:t.e.gonzalo@fys.uio.no>t.e.gonzalo@fys.uio.no</a>)</li><li>Jihyun Bhom (<a href=mailto:jihyun.bhom@ifj.edu.pl>jihyun.bhom@ifj.edu.pl</a>)</li><li>Markus Prim (<a href=mailto:markus.prim@kit.edu>markus.prim@kit.edu</a>)</li></ul><p><strong>Date</strong>:</p><ul><li>2013 Oct</li><li>2014</li><li>2015 Feb</li><li>2016 Jul</li><li>2018 Jan</li><li>2019 Aug</li><li>2015 May</li><li>2015 July</li><li>2015 August</li><li>2016 July</li><li>2016 August</li><li>2016 October</li><li>2018 Jan</li><li>2020 Jan</li><li>2020 Feb</li><li>2020 May</li><li>2013 Nov</li><li>2015 May, June</li><li>2016 Aug</li><li>2017 March</li><li>2019 Oct</li><li>2020 Feb</li><li>2017 July</li><li>2019 July</li><li>2019 Nov</li><li>2019 Dec</li><li>2020 Jan</li><li>2020 Feb</li><li>2019 Aug</li><li>2019 Nov</li><li>2020 Jan</li></ul><p>Functions of module FlavBit</p><hr><p>Authors (add name and date if you modify):</p><hr><h2 id=macros-documentation>Macros Documentation <a href=#macros-documentation class=anchor aria-hidden=true>#</a></h2><h3 id=define-the_rest>define THE_REST <a href=#define-the_rest class=anchor aria-hidden=true>#</a></h3><pre><code>#define THE_REST(
    bins
)
      static const std::vector&lt;str&gt; SI_obslist =                    \
       translate_flav_obs(&quot;FlavBit&quot;, &quot;SuperIso&quot;, FB_obslist,        \
       Utils::p2dot(bins));                                         \
      static bool use_SM_covariance =                               \
       runOptions-&gt;getValueOrDef&lt;bool&gt;(false, &quot;use_SM_covariance&quot;); \
      static bool SM_covariance_cached = false;                     \
      SuperIso_prediction_helper(                                   \
        FB_obslist,                                                 \
        SI_obslist,                                                 \
        result,                                                     \
        *Dep::SuperIso_modelinfo,                                   \
        *Dep::SuperIso_nuisance,                                    \
        BEreq::get_predictions_nuisance.pointer(),                  \
        BEreq::observables.pointer(),                               \
        BEreq::convert_correlation.pointer(),                       \
        BEreq::get_th_covariance_nuisance.pointer(),                \
        use_SM_covariance,                                          \
        SM_covariance_cached                                        \
    );                                                              \
    SM_covariance_cached = true;
</code></pre><h3 id=define-si_single_prediction_function>define SI_SINGLE_PREDICTION_FUNCTION <a href=#define-si_single_prediction_function class=anchor aria-hidden=true>#</a></h3><pre><code>#define SI_SINGLE_PREDICTION_FUNCTION(
    name
)
    void CAT(SuperIso_prediction_,name)(flav_prediction&amp; result)         \
    {                                                                    \
      using namespace CAT(Pipes::SuperIso_prediction_,name);             \
      static const std::vector&lt;str&gt; FB_obslist = {#name};                \
      THE_REST(&quot;&quot;)                                                       \
    }                                                                    \
</code></pre><h3 id=define-si_single_prediction_function_bins>define SI_SINGLE_PREDICTION_FUNCTION_BINS <a href=#define-si_single_prediction_function_bins class=anchor aria-hidden=true>#</a></h3><pre><code>#define SI_SINGLE_PREDICTION_FUNCTION_BINS(
    name,
    bins
)
    void CAT_3(SuperIso_prediction_,name,bins)(flav_prediction&amp; result)  \
    {                                                                    \
      using namespace CAT_3(Pipes::SuperIso_prediction_,name,bins);      \
      static const std::vector&lt;str&gt; FB_obslist = {#name};                \
      THE_REST(#bins)                                                    \
    }                                                                    \
</code></pre><h3 id=define-si_multi_prediction_function>define SI_MULTI_PREDICTION_FUNCTION <a href=#define-si_multi_prediction_function class=anchor aria-hidden=true>#</a></h3><pre><code>#define SI_MULTI_PREDICTION_FUNCTION(
    name
)
    void CAT(SuperIso_prediction_,name)(flav_prediction&amp; result)         \
    {                                                                    \
      using namespace CAT(Pipes::SuperIso_prediction_,name);             \
      static const std::vector&lt;str&gt; FB_obslist =                         \
       Downstream::subcaps-&gt;getNames();                                  \
      if (FB_obslist.empty()) FlavBit_error().raise(LOCAL_INFO,          \
       &quot;Missing subcapabilities for SuperIso_prediction_&quot;#name&quot;.&quot;);      \
      THE_REST(&quot;&quot;)                                                       \
    }                                                                    \
</code></pre><h3 id=define-si_multi_prediction_function_bins>define SI_MULTI_PREDICTION_FUNCTION_BINS <a href=#define-si_multi_prediction_function_bins class=anchor aria-hidden=true>#</a></h3><pre><code>#define SI_MULTI_PREDICTION_FUNCTION_BINS(
    name,
    bins,
    exp
)
    void CAT_4(SuperIso_prediction_,name,bins,exp)(flav_prediction&amp;      \
     result)                                                             \
    {                                                                    \
      using namespace CAT_4(Pipes::SuperIso_prediction_,name,bins,exp);  \
      static const std::vector&lt;str&gt; FB_obslist =                         \
       Downstream::subcaps-&gt;getNames();                                  \
      if (FB_obslist.empty()) FlavBit_error().raise(LOCAL_INFO,          \
       &quot;Missing subcapabilities for SuperIso_prediction_&quot;#name&quot;.&quot;);      \
      THE_REST(#bins)                                                    \
    }                                                                    \
</code></pre><h3 id=define-heplike_gaussian_1d_likelihood>define HEPLIKE_GAUSSIAN_1D_LIKELIHOOD <a href=#define-heplike_gaussian_1d_likelihood class=anchor aria-hidden=true>#</a></h3><pre><code>#define HEPLIKE_GAUSSIAN_1D_LIKELIHOOD(
    name,
    file
)
    void CAT_3(HEPLike_,name,_LogLikelihood)(double &amp;result)                      \
    {                                                                             \
      using namespace CAT_3(Pipes::HEPLike_,name,_LogLikelihood);                 \
      static const std::string inputfile = path_to_latest_heplike_data() + file;  \
      static HepLike_default::HL_Gaussian gaussian(inputfile);                    \
      static bool first = true;                                                   \
                                                                                  \
      if (first)                                                                  \
      {                                                                           \
        if (flav_debug) std::cout &lt;&lt; &quot;Debug: Reading HepLike data file: &quot; &lt;&lt;      \
         inputfile &lt;&lt; endl;                                                       \
        gaussian.Read();                                                          \
        first = false;                                                            \
      }                                                                           \
                                                                                  \
      double theory = CAT(Dep::prediction_,name)-&gt;central_values.begin()-&gt;second; \
      double theory_variance = CAT(Dep::prediction_,name)-&gt;covariance.begin()-&gt;   \
       second.begin()-&gt;second;                                                    \
      result = gaussian.GetLogLikelihood(theory, theory_variance);                \
                                                                                  \
      if (flav_debug) std::cout &lt;&lt; &quot;HEPLike_&quot; &lt;&lt; #name                            \
       &lt;&lt; &quot;_LogLikelihood result: &quot; &lt;&lt; result &lt;&lt; std::endl;                       \
    }                                                                             \
</code></pre><p>HEPLike single-observable likelihood.</p><h2 id=source-code>Source code <a href=#source-code class=anchor aria-hidden=true>#</a></h2><pre><code>//   GAMBIT: Global and Modular BSM Inference Tool
//   *********************************************

#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;map&gt;

#include &quot;gambit/Elements/gambit_module_headers.hpp&quot;
#include &quot;gambit/FlavBit/FlavBit_rollcall.hpp&quot;
#include &quot;gambit/FlavBit/FlavBit_types.hpp&quot;
#include &quot;gambit/FlavBit/Flav_reader.hpp&quot;
#include &quot;gambit/FlavBit/flav_utils.hpp&quot;
#include &quot;gambit/FlavBit/flav_loop_functions.hpp&quot;
#include &quot;gambit/Elements/translator.hpp&quot;
#include &quot;gambit/Utils/statistics.hpp&quot;
#include &quot;gambit/cmake/cmake_variables.hpp&quot;


//#define FLAVBIT_DEBUG
//#define FLAVBIT_DEBUG_LL

namespace YAML
{
  template&lt;&gt;
  struct convert&lt;Gambit::nuiscorr&gt;
  {
    static Node encode(const Gambit::nuiscorr&amp; rhs)
    {
      Node node;
      node.push_back(rhs.obs1);
      node.push_back(rhs.obs2);
      node.push_back(rhs.value);
      return node;
    }
    static bool decode(const Node&amp; node, Gambit::nuiscorr&amp; rhs)
    {
      if(!node.IsSequence() || node.size() != 3) return false;
      std::string obs1 = node[0].as&lt;std::string&gt;();
      std::string obs2 = node[1].as&lt;std::string&gt;();
      obs1.resize(49);
      obs2.resize(49);
      strcpy(rhs.obs1, obs1.c_str());
      strcpy(rhs.obs2, obs2.c_str());
      rhs.value = node[2].as&lt;double&gt;();
      return true;
    }
  };
}

namespace Gambit
{

  namespace FlavBit
  {

    using namespace std;
    namespace ublas = boost::numeric::ublas;

    const bool flav_debug =
    #ifdef FLAVBIT_DEBUG
      true;
    #else
      false;
    #endif

    const bool flav_debug_LL =
    #ifdef FLAVBIT_DEBUG_LL
      true;
    #else
      false;
    #endif

    Utils::translator translate_flav_obs(GAMBIT_DIR &quot;/FlavBit/data/observables_key.yaml&quot;);

    const int ncorrnuis = 463;
    const nuiscorr (&amp;nuiscorr_help(nuiscorr (&amp;arr)[ncorrnuis], const std::vector&lt;nuiscorr&gt;&amp; v))[ncorrnuis] { std::copy(v.begin(), v.end(), arr); return arr; }
    nuiscorr arr[ncorrnuis];
    const nuiscorr (&amp;corrnuis)[ncorrnuis] = nuiscorr_help(arr, YAML::LoadFile(GAMBIT_DIR &quot;/FlavBit/data/SM_nuisance_correlations.yaml&quot;)[&quot;correlation_matrix&quot;].as&lt;std::vector&lt;nuiscorr&gt;&gt;());

    void print(flav_prediction prediction , vector&lt;std::string &gt; names)
    {
      for(unsigned i=0; i&lt;names.size(); i++)
      {
        cout&lt;&lt;names[i]&lt;&lt;&quot;: &quot;&lt;&lt;prediction.central_values[names[i]]&lt;&lt;endl;
      }
      cout&lt;&lt;&quot;Covariance:&quot;&lt;&lt;endl;
      for( unsigned i=0; i&lt;names.size(); i++)
      {
        stringstream row;
        for( unsigned j=0; j&lt;names.size(); j++)
        {
          row&lt;&lt;(prediction.covariance)[names[i]]  [names[j]]&lt;&lt;&quot; &quot;;
        }
        cout&lt;&lt;row.str()&lt;&lt;endl;
      }
    }

    void Kstarll_Theory2Experiment_translation(flav_observable_map&amp; prediction, int generation)
    {
      // Only works for ll = ee and ll = mumu
      if (generation &lt; 1 or generation &gt; 2)
       FlavBit_error().raise(LOCAL_INFO, &quot;Kstarll_Theory2Experiment_translation called with generation not 1 or 2&quot;);
      const vector&lt;std::string&gt; all_names[2] = {{&quot;AT_Im&quot;} , {&quot;S4&quot;, &quot;S7&quot;, &quot;S9&quot;}};
      const vector&lt;std::string&gt;&amp; names = all_names[generation-1];
      for (unsigned i=0; i &lt; names.size(); i++)
      {
        auto search = prediction.find(names[i]);
        if (search != prediction.end())
        {
          prediction[names[i]]=(-1.)*prediction[names[i]];
        }
      }
    }

    void Kstarll_Theory2Experiment_translation(flav_covariance_map&amp; prediction, int generation)
    {
      // Only works for ll = ee and ll = mumu
      if (generation &lt; 1 or generation &gt; 2)
       FlavBit_error().raise(LOCAL_INFO, &quot;Kstarll_Theory2Experiment_translation called with generation not 1 or 2&quot;);

      const vector&lt;std::string&gt; names[2] = {{&quot;AT_Im&quot;} , {&quot;S4&quot;, &quot;S7&quot;, &quot;S9&quot;}};
      vector&lt;std::string&gt; names_exist;

      for (unsigned i=0; i &lt; names[generation-1].size(); i++)
      {
        auto search_i = prediction.find(names[generation-1][i]);
        if (search_i != prediction.end()) names_exist.push_back(names[generation-1][i]);
      }
      //changing the rows:
      for (unsigned i=0; i &lt;  names_exist.size(); i++)
      {
        string name1=names_exist[i];
        std::map&lt;const std::string, double&gt; row=prediction[name1];
        for (std::map&lt;const std::string, double&gt;::iterator it=row.begin(); it !=row.end(); it++)
        {
          prediction[name1][it-&gt;first]=(-1.)*prediction[name1][it-&gt;first];
        }
      }
      // changing the columns:
      for (flav_covariance_map::iterator it=prediction.begin(); it !=prediction.end(); it++)
      {
        string name_columns=it-&gt;first;
        for (unsigned i=0; i &lt;  names_exist.size(); i++)
        {
          string name1=names_exist[i];
          prediction[name_columns][name1]=(-1)*prediction[name_columns][name1];
        }
      }
    }

    str path_to_latest_heplike_data()
    {
      std::vector&lt;str&gt; working_data = Backends::backendInfo().working_versions(&quot;HepLikeData&quot;);
      if (working_data.empty()) FlavBit_error().raise(LOCAL_INFO, &quot;No working HepLikeData installations detected.&quot;);
      std::sort(working_data.begin(), working_data.end());
      return Backends::backendInfo().corrected_path(&quot;HepLikeData&quot;, working_data.back());
    }

    void SuperIso_fill(parameters &amp;result)
    {
      using namespace Pipes::SuperIso_fill;
      using namespace std;

      SLHAstruct spectrum;
      // Obtain SLHAea object from spectrum
      if (ModelInUse(&quot;WC&quot;)  || ModelInUse(&quot;WC_LR&quot;) || ModelInUse(&quot;WC_LUV&quot;) )
      {
        spectrum = Dep::SM_spectrum-&gt;getSLHAea(2);
      }
      else if (ModelInUse(&quot;MSSM63atMGUT&quot;) or ModelInUse(&quot;MSSM63atQ&quot;))
      {
        spectrum = Dep::MSSM_spectrum-&gt;getSLHAea(2);
        // Add the MODSEL block if it is not provided by the spectrum object.
        SLHAea_add(spectrum,&quot;MODSEL&quot;,1, 0, &quot;General MSSM&quot;, false);
      }
      else
      {
        FlavBit_error().raise(LOCAL_INFO, &quot;Unrecognised model.&quot;);
      }

      BEreq::Init_param(&amp;result);

      int ie,je;

      result.model=-1;
      if (!spectrum[&quot;MODSEL&quot;].empty())
      {
        if (spectrum[&quot;MODSEL&quot;][1].is_data_line()) result.model=SLHAea::to&lt;int&gt;(spectrum[&quot;MODSEL&quot;][1][1]);
        if (spectrum[&quot;MODSEL&quot;][3].is_data_line()) result.NMSSM=SLHAea::to&lt;int&gt;(spectrum[&quot;MODSEL&quot;][3][1]);
        if (spectrum[&quot;MODSEL&quot;][4].is_data_line()) result.RV=SLHAea::to&lt;int&gt;(spectrum[&quot;MODSEL&quot;][4][1]);
        if (spectrum[&quot;MODSEL&quot;][5].is_data_line()) result.CPV=SLHAea::to&lt;int&gt;(spectrum[&quot;MODSEL&quot;][5][1]);
        if (spectrum[&quot;MODSEL&quot;][6].is_data_line()) result.FV=SLHAea::to&lt;int&gt;(spectrum[&quot;MODSEL&quot;][6][1]);
        if (spectrum[&quot;MODSEL&quot;][12].is_data_line()) result.Q=SLHAea::to&lt;double&gt;(spectrum[&quot;MODSEL&quot;][12][1]);
      }

      if (result.NMSSM != 0) result.model=result.NMSSM;
      if (result.RV != 0) result.model=-2;
      if (result.CPV != 0) result.model=-2;

      if (!spectrum[&quot;SMINPUTS&quot;].empty())
      {
        if (spectrum[&quot;SMINPUTS&quot;][1].is_data_line()) result.inv_alpha_em=SLHAea::to&lt;double&gt;(spectrum[&quot;SMINPUTS&quot;][1][1]);
        if (spectrum[&quot;SMINPUTS&quot;][2].is_data_line()) result.Gfermi=SLHAea::to&lt;double&gt;(spectrum[&quot;SMINPUTS&quot;][2][1]);
        if (spectrum[&quot;SMINPUTS&quot;][3].is_data_line()) result.alphas_MZ=SLHAea::to&lt;double&gt;(spectrum[&quot;SMINPUTS&quot;][3][1]);
        if (spectrum[&quot;SMINPUTS&quot;][4].is_data_line()) result.mass_Z=SLHAea::to&lt;double&gt;(spectrum[&quot;SMINPUTS&quot;][4][1]);
        if (spectrum[&quot;SMINPUTS&quot;][5].is_data_line()) result.mass_b=SLHAea::to&lt;double&gt;(spectrum[&quot;SMINPUTS&quot;][5][1]);
        if (spectrum[&quot;SMINPUTS&quot;][6].is_data_line()) result.mass_top_pole=SLHAea::to&lt;double&gt;(spectrum[&quot;SMINPUTS&quot;][6][1]);
        if (spectrum[&quot;SMINPUTS&quot;][7].is_data_line()) result.mass_tau_pole=SLHAea::to&lt;double&gt;(spectrum[&quot;SMINPUTS&quot;][7][1]);
        if (spectrum[&quot;SMINPUTS&quot;][8].is_data_line()) result.mass_nut=SLHAea::to&lt;double&gt;(spectrum[&quot;SMINPUTS&quot;][8][1]);
        if (spectrum[&quot;SMINPUTS&quot;][11].is_data_line()) result.mass_e=SLHAea::to&lt;double&gt;(spectrum[&quot;SMINPUTS&quot;][11][1]);
        if (spectrum[&quot;SMINPUTS&quot;][12].is_data_line()) result.mass_nue=SLHAea::to&lt;double&gt;(spectrum[&quot;SMINPUTS&quot;][12][1]);
        if (spectrum[&quot;SMINPUTS&quot;][13].is_data_line()) result.mass_mu=SLHAea::to&lt;double&gt;(spectrum[&quot;SMINPUTS&quot;][13][1]);
        if (spectrum[&quot;SMINPUTS&quot;][14].is_data_line()) result.mass_num=SLHAea::to&lt;double&gt;(spectrum[&quot;SMINPUTS&quot;][14][1]);
        if (spectrum[&quot;SMINPUTS&quot;][21].is_data_line()) result.mass_d=SLHAea::to&lt;double&gt;(spectrum[&quot;SMINPUTS&quot;][21][1]);
        if (spectrum[&quot;SMINPUTS&quot;][22].is_data_line()) result.mass_u=SLHAea::to&lt;double&gt;(spectrum[&quot;SMINPUTS&quot;][22][1]);
        if (spectrum[&quot;SMINPUTS&quot;][23].is_data_line()) result.mass_s=SLHAea::to&lt;double&gt;(spectrum[&quot;SMINPUTS&quot;][23][1]);
        if (spectrum[&quot;SMINPUTS&quot;][24].is_data_line()) result.mass_c=SLHAea::to&lt;double&gt;(spectrum[&quot;SMINPUTS&quot;][24][1]);result.scheme_c_mass=1;
      }

      if (!spectrum[&quot;VCKMIN&quot;].empty())
      {
        if (spectrum[&quot;VCKMIN&quot;][1].is_data_line()) result.CKM_lambda=SLHAea::to&lt;double&gt;(spectrum[&quot;VCKMIN&quot;][1][1]);
        if (spectrum[&quot;VCKMIN&quot;][2].is_data_line()) result.CKM_A=SLHAea::to&lt;double&gt;(spectrum[&quot;VCKMIN&quot;][2][1]);
        if (spectrum[&quot;VCKMIN&quot;][3].is_data_line()) result.CKM_rhobar=SLHAea::to&lt;double&gt;(spectrum[&quot;VCKMIN&quot;][3][1]);
        if (spectrum[&quot;VCKMIN&quot;][4].is_data_line()) result.CKM_etabar=SLHAea::to&lt;double&gt;(spectrum[&quot;VCKMIN&quot;][4][1]);
      }

      if (!spectrum[&quot;UPMNSIN&quot;].empty())
      {
        if (spectrum[&quot;UPMNSIN&quot;][1].is_data_line()) result.PMNS_theta12=SLHAea::to&lt;double&gt;(spectrum[&quot;UPMNSIN&quot;][1][1]);
        if (spectrum[&quot;UPMNSIN&quot;][2].is_data_line()) result.PMNS_theta23=SLHAea::to&lt;double&gt;(spectrum[&quot;UPMNSIN&quot;][2][1]);
        if (spectrum[&quot;UPMNSIN&quot;][3].is_data_line()) result.PMNS_theta13=SLHAea::to&lt;double&gt;(spectrum[&quot;UPMNSIN&quot;][3][1]);
        if (spectrum[&quot;UPMNSIN&quot;][4].is_data_line()) result.PMNS_delta13=SLHAea::to&lt;double&gt;(spectrum[&quot;UPMNSIN&quot;][4][1]);
        if (spectrum[&quot;UPMNSIN&quot;][5].is_data_line()) result.PMNS_alpha1=SLHAea::to&lt;double&gt;(spectrum[&quot;UPMNSIN&quot;][5][1]);
        if (spectrum[&quot;UPMNSIN&quot;][6].is_data_line()) result.PMNS_alpha2=SLHAea::to&lt;double&gt;(spectrum[&quot;UPMNSIN&quot;][6][1]);
      }

      if (!spectrum[&quot;MINPAR&quot;].empty())
      {
        if (spectrum[&quot;MINPAR&quot;][3].is_data_line()) result.tan_beta=SLHAea::to&lt;double&gt;(spectrum[&quot;MINPAR&quot;][3][1]);
        switch(result.model)
        {
          case 1:
            if (spectrum[&quot;MINPAR&quot;][1].is_data_line()) result.m0=SLHAea::to&lt;double&gt;(spectrum[&quot;MINPAR&quot;][1][1]);
            if (spectrum[&quot;MINPAR&quot;][2].is_data_line()) result.m12=SLHAea::to&lt;double&gt;(spectrum[&quot;MINPAR&quot;][2][1]);
            if (spectrum[&quot;MINPAR&quot;][4].is_data_line()) result.sign_mu=SLHAea::to&lt;double&gt;(spectrum[&quot;MINPAR&quot;][4][1]);
            if (spectrum[&quot;MINPAR&quot;][5].is_data_line()) result.A0=SLHAea::to&lt;double&gt;(spectrum[&quot;MINPAR&quot;][5][1]);
            break;

          case 2:
            if (spectrum[&quot;MINPAR&quot;][1].is_data_line()) result.Lambda=SLHAea::to&lt;double&gt;(spectrum[&quot;MINPAR&quot;][1][1]);
            if (spectrum[&quot;MINPAR&quot;][2].is_data_line()) result.Mmess=SLHAea::to&lt;double&gt;(spectrum[&quot;MINPAR&quot;][2][1]);
            if (spectrum[&quot;MINPAR&quot;][4].is_data_line()) result.sign_mu=SLHAea::to&lt;double&gt;(spectrum[&quot;MINPAR&quot;][4][1]);
            if (spectrum[&quot;MINPAR&quot;][5].is_data_line()) result.N5=SLHAea::to&lt;double&gt;(spectrum[&quot;MINPAR&quot;][5][1]);
            if (spectrum[&quot;MINPAR&quot;][6].is_data_line()) result.cgrav=SLHAea::to&lt;double&gt;(spectrum[&quot;MINPAR&quot;][6][1]);
            break;

          case 3:
            if (spectrum[&quot;MINPAR&quot;][1].is_data_line()) result.m32=SLHAea::to&lt;double&gt;(spectrum[&quot;MINPAR&quot;][1][1]);
            if (spectrum[&quot;MINPAR&quot;][2].is_data_line()) result.m0=SLHAea::to&lt;double&gt;(spectrum[&quot;MINPAR&quot;][2][1]);
            if (spectrum[&quot;MINPAR&quot;][4].is_data_line()) result.sign_mu=SLHAea::to&lt;double&gt;(spectrum[&quot;MINPAR&quot;][4][1]);
            break;

          default:
            if (spectrum[&quot;MINPAR&quot;][3].is_data_line()) result.tan_beta=SLHAea::to&lt;double&gt;(spectrum[&quot;MINPAR&quot;][3][1]);
        }
      }

      if (!spectrum[&quot;EXTPAR&quot;].empty())
      {
        if (spectrum[&quot;EXTPAR&quot;][0].is_data_line()) result.Min=SLHAea::to&lt;double&gt;(spectrum[&quot;EXTPAR&quot;][0][1]);
        if (spectrum[&quot;EXTPAR&quot;][1].is_data_line()) result.M1_Min=SLHAea::to&lt;double&gt;(spectrum[&quot;EXTPAR&quot;][1][1]);
        if (spectrum[&quot;EXTPAR&quot;][2].is_data_line()) result.M2_Min=SLHAea::to&lt;double&gt;(spectrum[&quot;EXTPAR&quot;][2][1]);
        if (spectrum[&quot;EXTPAR&quot;][3].is_data_line()) result.M3_Min=SLHAea::to&lt;double&gt;(spectrum[&quot;EXTPAR&quot;][3][1]);
        if (spectrum[&quot;EXTPAR&quot;][11].is_data_line()) result.At_Min=SLHAea::to&lt;double&gt;(spectrum[&quot;EXTPAR&quot;][11][1]);
        if (spectrum[&quot;EXTPAR&quot;][12].is_data_line()) result.Ab_Min=SLHAea::to&lt;double&gt;(spectrum[&quot;EXTPAR&quot;][12][1]);
        if (spectrum[&quot;EXTPAR&quot;][13].is_data_line()) result.Atau_Min=SLHAea::to&lt;double&gt;(spectrum[&quot;EXTPAR&quot;][13][1]);
        if (spectrum[&quot;EXTPAR&quot;][21].is_data_line()) result.M2H1_Min=SLHAea::to&lt;double&gt;(spectrum[&quot;EXTPAR&quot;][21][1]);
        if (spectrum[&quot;EXTPAR&quot;][22].is_data_line()) result.M2H2_Min=SLHAea::to&lt;double&gt;(spectrum[&quot;EXTPAR&quot;][22][1]);
        if (spectrum[&quot;EXTPAR&quot;][23].is_data_line()) result.mu_Min=SLHAea::to&lt;double&gt;(spectrum[&quot;EXTPAR&quot;][23][1]);
        if (spectrum[&quot;EXTPAR&quot;][24].is_data_line()) result.M2A_Min=SLHAea::to&lt;double&gt;(spectrum[&quot;EXTPAR&quot;][24][1]);
        if (spectrum[&quot;EXTPAR&quot;][25].is_data_line()) result.tb_Min=SLHAea::to&lt;double&gt;(spectrum[&quot;EXTPAR&quot;][25][1]);
        if (spectrum[&quot;EXTPAR&quot;][26].is_data_line()) result.mA_Min=SLHAea::to&lt;double&gt;(spectrum[&quot;EXTPAR&quot;][26][1]);
        if (spectrum[&quot;EXTPAR&quot;][31].is_data_line()) result.MeL_Min=SLHAea::to&lt;double&gt;(spectrum[&quot;EXTPAR&quot;][31][1]);
        if (spectrum[&quot;EXTPAR&quot;][32].is_data_line()) result.MmuL_Min=SLHAea::to&lt;double&gt;(spectrum[&quot;EXTPAR&quot;][32][1]);
        if (spectrum[&quot;EXTPAR&quot;][33].is_data_line()) result.MtauL_Min=SLHAea::to&lt;double&gt;(spectrum[&quot;EXTPAR&quot;][33][1]);
        if (spectrum[&quot;EXTPAR&quot;][34].is_data_line()) result.MeR_Min=SLHAea::to&lt;double&gt;(spectrum[&quot;EXTPAR&quot;][34][1]);
        if (spectrum[&quot;EXTPAR&quot;][35].is_data_line()) result.MmuR_Min=SLHAea::to&lt;double&gt;(spectrum[&quot;EXTPAR&quot;][35][1]);
        if (spectrum[&quot;EXTPAR&quot;][36].is_data_line()) result.MtauR_Min=SLHAea::to&lt;double&gt;(spectrum[&quot;EXTPAR&quot;][36][1]);
        if (spectrum[&quot;EXTPAR&quot;][41].is_data_line()) result.MqL1_Min=SLHAea::to&lt;double&gt;(spectrum[&quot;EXTPAR&quot;][41][1]);
        if (spectrum[&quot;EXTPAR&quot;][42].is_data_line()) result.MqL2_Min=SLHAea::to&lt;double&gt;(spectrum[&quot;EXTPAR&quot;][42][1]);
        if (spectrum[&quot;EXTPAR&quot;][43].is_data_line()) result.MqL3_Min=SLHAea::to&lt;double&gt;(spectrum[&quot;EXTPAR&quot;][43][1]);
        if (spectrum[&quot;EXTPAR&quot;][44].is_data_line()) result.MuR_Min=SLHAea::to&lt;double&gt;(spectrum[&quot;EXTPAR&quot;][44][1]);
        if (spectrum[&quot;EXTPAR&quot;][45].is_data_line()) result.McR_Min=SLHAea::to&lt;double&gt;(spectrum[&quot;EXTPAR&quot;][45][1]);
        if (spectrum[&quot;EXTPAR&quot;][46].is_data_line()) result.MtR_Min=SLHAea::to&lt;double&gt;(spectrum[&quot;EXTPAR&quot;][46][1]);
        if (spectrum[&quot;EXTPAR&quot;][47].is_data_line()) result.MdR_Min=SLHAea::to&lt;double&gt;(spectrum[&quot;EXTPAR&quot;][47][1]);
        if (spectrum[&quot;EXTPAR&quot;][48].is_data_line()) result.MsR_Min=SLHAea::to&lt;double&gt;(spectrum[&quot;EXTPAR&quot;][48][1]);
        if (spectrum[&quot;EXTPAR&quot;][49].is_data_line()) result.MbR_Min=SLHAea::to&lt;double&gt;(spectrum[&quot;EXTPAR&quot;][49][1]);
        if (spectrum[&quot;EXTPAR&quot;][51].is_data_line()) result.N51=SLHAea::to&lt;double&gt;(spectrum[&quot;EXTPAR&quot;][51][1]);
        if (spectrum[&quot;EXTPAR&quot;][52].is_data_line()) result.N52=SLHAea::to&lt;double&gt;(spectrum[&quot;EXTPAR&quot;][52][1]);
        if (spectrum[&quot;EXTPAR&quot;][53].is_data_line()) result.N53=SLHAea::to&lt;double&gt;(spectrum[&quot;EXTPAR&quot;][53][1]);
        if (spectrum[&quot;EXTPAR&quot;][61].is_data_line()) result.lambdaNMSSM_Min=SLHAea::to&lt;double&gt;(spectrum[&quot;EXTPAR&quot;][61][1]);
        if (spectrum[&quot;EXTPAR&quot;][62].is_data_line()) result.kappaNMSSM_Min=SLHAea::to&lt;double&gt;(spectrum[&quot;EXTPAR&quot;][62][1]);
        if (spectrum[&quot;EXTPAR&quot;][63].is_data_line()) result.AlambdaNMSSM_Min=SLHAea::to&lt;double&gt;(spectrum[&quot;EXTPAR&quot;][63][1]);
        if (spectrum[&quot;EXTPAR&quot;][64].is_data_line()) result.AkappaNMSSM_Min=SLHAea::to&lt;double&gt;(spectrum[&quot;EXTPAR&quot;][64][1]);
        if (spectrum[&quot;EXTPAR&quot;][65].is_data_line()) result.lambdaSNMSSM_Min=SLHAea::to&lt;double&gt;(spectrum[&quot;EXTPAR&quot;][65][1]);
        if (spectrum[&quot;EXTPAR&quot;][66].is_data_line()) result.xiFNMSSM_Min=SLHAea::to&lt;double&gt;(spectrum[&quot;EXTPAR&quot;][66][1]);
        if (spectrum[&quot;EXTPAR&quot;][67].is_data_line()) result.xiSNMSSM_Min=SLHAea::to&lt;double&gt;(spectrum[&quot;EXTPAR&quot;][67][1]);
        if (spectrum[&quot;EXTPAR&quot;][68].is_data_line()) result.mupNMSSM_Min=SLHAea::to&lt;double&gt;(spectrum[&quot;EXTPAR&quot;][68][1]);
        if (spectrum[&quot;EXTPAR&quot;][69].is_data_line()) result.mSp2NMSSM_Min=SLHAea::to&lt;double&gt;(spectrum[&quot;EXTPAR&quot;][69][1]);
        if (spectrum[&quot;EXTPAR&quot;][70].is_data_line()) result.mS2NMSSM_Min=SLHAea::to&lt;double&gt;(spectrum[&quot;EXTPAR&quot;][70][1]);
      }

      if (!spectrum[&quot;MASS&quot;].empty())
      {
        if (spectrum[&quot;MASS&quot;][1].is_data_line()) result.mass_d=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][1][1]);
        if (spectrum[&quot;MASS&quot;][2].is_data_line()) result.mass_u=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][2][1]);
        if (spectrum[&quot;MASS&quot;][3].is_data_line()) result.mass_s=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][3][1]);
        if (spectrum[&quot;MASS&quot;][4].is_data_line()) result.mass_c_pole=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][4][1]);
        if (spectrum[&quot;MASS&quot;][6].is_data_line()) result.mass_t=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][6][1]);
        if (spectrum[&quot;MASS&quot;][11].is_data_line()) result.mass_e=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][11][1]);
        if (spectrum[&quot;MASS&quot;][12].is_data_line()) result.mass_nue=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][12][1]);
        if (spectrum[&quot;MASS&quot;][13].is_data_line()) result.mass_mu=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][13][1]);
        if (spectrum[&quot;MASS&quot;][14].is_data_line()) result.mass_num=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][14][1]);
        if (spectrum[&quot;MASS&quot;][15].is_data_line()) result.mass_tau=result.mass_tau_pole=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][15][1]);
        if (spectrum[&quot;MASS&quot;][16].is_data_line()) result.mass_nut=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][16][1]);
        if (spectrum[&quot;MASS&quot;][21].is_data_line()) result.mass_gluon=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][21][1]);
        if (spectrum[&quot;MASS&quot;][22].is_data_line()) result.mass_photon=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][22][1]);
        if (spectrum[&quot;MASS&quot;][23].is_data_line()) result.mass_Z0=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][23][1]);
        if (spectrum[&quot;MASS&quot;][24].is_data_line()) result.mass_W=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][24][1]);
        if (spectrum[&quot;MASS&quot;][25].is_data_line()) result.mass_h0=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][25][1]);
        if (spectrum[&quot;MASS&quot;][35].is_data_line()) result.mass_H0=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][35][1]);
        if (spectrum[&quot;MASS&quot;][36].is_data_line()) result.mass_A0=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][36][1]);
        if (spectrum[&quot;MASS&quot;][37].is_data_line()) result.mass_H=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][37][1]);
        if (spectrum[&quot;MASS&quot;][39].is_data_line()) result.mass_graviton=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][39][1]);
        if (spectrum[&quot;MASS&quot;][45].is_data_line()) result.mass_H03=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][45][1]);
        if (spectrum[&quot;MASS&quot;][46].is_data_line()) result.mass_A02=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][46][1]);
        if (spectrum[&quot;MASS&quot;][1000001].is_data_line()) result.mass_dnl=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][1000001][1]);
        if (spectrum[&quot;MASS&quot;][1000002].is_data_line()) result.mass_upl=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][1000002][1]);
        if (spectrum[&quot;MASS&quot;][1000003].is_data_line()) result.mass_stl=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][1000003][1]);
        if (spectrum[&quot;MASS&quot;][1000004].is_data_line()) result.mass_chl=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][1000004][1]);
        if (spectrum[&quot;MASS&quot;][1000005].is_data_line()) result.mass_b1=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][1000005][1]);
        if (spectrum[&quot;MASS&quot;][1000006].is_data_line()) result.mass_t1=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][1000006][1]);
        if (spectrum[&quot;MASS&quot;][1000011].is_data_line()) result.mass_el=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][1000011][1]);
        if (spectrum[&quot;MASS&quot;][1000012].is_data_line()) result.mass_nuel=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][1000012][1]);
        if (spectrum[&quot;MASS&quot;][1000013].is_data_line()) result.mass_mul=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][1000013][1]);
        if (spectrum[&quot;MASS&quot;][1000014].is_data_line()) result.mass_numl=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][1000014][1]);
        if (spectrum[&quot;MASS&quot;][1000015].is_data_line()) result.mass_tau1=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][1000015][1]);
        if (spectrum[&quot;MASS&quot;][1000016].is_data_line()) result.mass_nutl=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][1000016][1]);
        if (spectrum[&quot;MASS&quot;][1000021].is_data_line()) result.mass_gluino=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][1000021][1]);
        if (spectrum[&quot;MASS&quot;][1000022].is_data_line()) result.mass_neut[1]=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][1000022][1]);
        if (spectrum[&quot;MASS&quot;][1000023].is_data_line()) result.mass_neut[2]=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][1000023][1]);
        if (spectrum[&quot;MASS&quot;][1000024].is_data_line()) result.mass_cha1=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][1000024][1]);
        if (spectrum[&quot;MASS&quot;][1000025].is_data_line()) result.mass_neut[3]=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][1000025][1]);
        if (spectrum[&quot;MASS&quot;][1000035].is_data_line()) result.mass_neut[4]=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][1000035][1]);
        if (spectrum[&quot;MASS&quot;][1000037].is_data_line()) result.mass_cha2=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][1000037][1]);
        if (spectrum[&quot;MASS&quot;][1000039].is_data_line()) result.mass_gravitino=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][1000039][1]);
        if (spectrum[&quot;MASS&quot;][1000045].is_data_line()) result.mass_neut[5]=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][1000045][1]);
        if (spectrum[&quot;MASS&quot;][2000001].is_data_line()) result.mass_dnr=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][2000001][1]);
        if (spectrum[&quot;MASS&quot;][2000002].is_data_line()) result.mass_upr=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][2000002][1]);
        if (spectrum[&quot;MASS&quot;][2000003].is_data_line()) result.mass_str=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][2000003][1]);
        if (spectrum[&quot;MASS&quot;][2000004].is_data_line()) result.mass_chr=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][2000004][1]);
        if (spectrum[&quot;MASS&quot;][2000005].is_data_line()) result.mass_b2=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][2000005][1]);
        if (spectrum[&quot;MASS&quot;][2000006].is_data_line()) result.mass_t2=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][2000006][1]);
        if (spectrum[&quot;MASS&quot;][2000011].is_data_line()) result.mass_er=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][2000011][1]);
        if (spectrum[&quot;MASS&quot;][2000012].is_data_line()) result.mass_nuer=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][2000012][1]);
        if (spectrum[&quot;MASS&quot;][2000013].is_data_line()) result.mass_mur=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][2000013][1]);
        if (spectrum[&quot;MASS&quot;][2000014].is_data_line()) result.mass_numr=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][2000014][1]);
        if (spectrum[&quot;MASS&quot;][2000015].is_data_line()) result.mass_tau2=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][2000015][1]);
        if (spectrum[&quot;MASS&quot;][2000016].is_data_line()) result.mass_nutr=SLHAea::to&lt;double&gt;(spectrum[&quot;MASS&quot;][2000016][1]);
      }

      // The following blocks will only appear for SUSY models so let's not waste time checking them if we're not scanning one of those.
      if (ModelInUse(&quot;MSSM63atMGUT&quot;) or ModelInUse(&quot;MSSM63atQ&quot;))
      {
        // The scale doesn't come through in MODSEL with all spectrum generators
        result.Q = Dep::MSSM_spectrum-&gt;get_HE().GetScale();

        if (!spectrum[&quot;ALPHA&quot;].empty()) if (spectrum[&quot;ALPHA&quot;].back().is_data_line()) result.alpha=SLHAea::to&lt;double&gt;(spectrum[&quot;ALPHA&quot;].back().at(0));

        if (!spectrum[&quot;STOPMIX&quot;].empty()) for (ie=1;ie&lt;=2;ie++) for (je=1;je&lt;=2;je++)
         if (spectrum[&quot;STOPMIX&quot;][max(ie,je)].is_data_line()) result.stop_mix[ie][je]=SLHAea::to&lt;double&gt;(spectrum[&quot;STOPMIX&quot;].at(ie,je)[2]);
        if (!spectrum[&quot;SBOTMIX&quot;].empty()) for (ie=1;ie&lt;=2;ie++) for (je=1;je&lt;=2;je++)
         if (spectrum[&quot;SBOTMIX&quot;][max(ie,je)].is_data_line()) result.sbot_mix[ie][je]=SLHAea::to&lt;double&gt;(spectrum[&quot;SBOTMIX&quot;].at(ie,je)[2]);
        if (!spectrum[&quot;STAUMIX&quot;].empty()) for (ie=1;ie&lt;=2;ie++) for (je=1;je&lt;=2;je++)
         if (spectrum[&quot;STAUMIX&quot;][max(ie,je)].is_data_line()) result.stau_mix[ie][je]=SLHAea::to&lt;double&gt;(spectrum[&quot;STAUMIX&quot;].at(ie,je)[2]);
        if (!spectrum[&quot;NMIX&quot;].empty()) for (ie=1;ie&lt;=4;ie++) for (je=1;je&lt;=4;je++)
         if (spectrum[&quot;NMIX&quot;][max(ie,je)].is_data_line()) result.neut_mix[ie][je]=SLHAea::to&lt;double&gt;(spectrum[&quot;NMIX&quot;].at(ie,je)[2]);
        if (!spectrum[&quot;NMNMIX&quot;].empty()) for (ie=1;ie&lt;=5;ie++) for (je=1;je&lt;=5;je++)
         if (spectrum[&quot;NMNMIX&quot;][max(ie,je)].is_data_line()) result.neut_mix[ie][je]=SLHAea::to&lt;double&gt;(spectrum[&quot;NMNMIX&quot;].at(ie,je)[2]);
        if (!spectrum[&quot;UMIX&quot;].empty()) for (ie=1;ie&lt;=2;ie++) for (je=1;je&lt;=2;je++)
         if (spectrum[&quot;UMIX&quot;][max(ie,je)].is_data_line()) result.charg_Umix[ie][je]=SLHAea::to&lt;double&gt;(spectrum[&quot;UMIX&quot;].at(ie,je)[2]);
        if (!spectrum[&quot;VMIX&quot;].empty()) for (ie=1;ie&lt;=2;ie++) for (je=1;je&lt;=2;je++)
         if (spectrum[&quot;VMIX&quot;][max(ie,je)].is_data_line()) result.charg_Vmix[ie][je]=SLHAea::to&lt;double&gt;(spectrum[&quot;VMIX&quot;].at(ie,je)[2]);

        if (!spectrum[&quot;GAUGE&quot;].empty())
        {
          if (spectrum[&quot;GAUGE&quot;][1].is_data_line()) result.gp_Q=SLHAea::to&lt;double&gt;(spectrum[&quot;GAUGE&quot;][1][1]);
          if (spectrum[&quot;GAUGE&quot;][2].is_data_line()) result.g2_Q=SLHAea::to&lt;double&gt;(spectrum[&quot;GAUGE&quot;][2][1]);
          if (spectrum[&quot;GAUGE&quot;][3].is_data_line()) result.g3_Q=SLHAea::to&lt;double&gt;(spectrum[&quot;GAUGE&quot;][3][1]);
        }

        if (!spectrum[&quot;YU&quot;].empty()) for (ie=1;ie&lt;=3;ie++) if (spectrum[&quot;YU&quot;][ie].is_data_line()) result.yut[ie]=SLHAea::to&lt;double&gt;(spectrum[&quot;YU&quot;].at(ie,ie)[2]);
        if (!spectrum[&quot;YD&quot;].empty()) for (ie=1;ie&lt;=3;ie++) if (spectrum[&quot;YD&quot;][ie].is_data_line()) result.yub[ie]=SLHAea::to&lt;double&gt;(spectrum[&quot;YD&quot;].at(ie,ie)[2]);
        if (!spectrum[&quot;YE&quot;].empty()) for (ie=1;ie&lt;=3;ie++) if (spectrum[&quot;YE&quot;][ie].is_data_line()) result.yutau[ie]=SLHAea::to&lt;double&gt;(spectrum[&quot;YE&quot;].at(ie,ie)[2]);

        if (!spectrum[&quot;HMIX&quot;].empty())
        {
          if (spectrum[&quot;HMIX&quot;][1].is_data_line()) result.mu_Q=SLHAea::to&lt;double&gt;(spectrum[&quot;HMIX&quot;][1][1]);
          if (spectrum[&quot;HMIX&quot;][2].is_data_line()) result.tanb_GUT=SLHAea::to&lt;double&gt;(spectrum[&quot;HMIX&quot;][2][1]);
          if (spectrum[&quot;HMIX&quot;][3].is_data_line()) result.Higgs_VEV=SLHAea::to&lt;double&gt;(spectrum[&quot;HMIX&quot;][3][1]);
          if (spectrum[&quot;HMIX&quot;][4].is_data_line()) result.mA2_Q=SLHAea::to&lt;double&gt;(spectrum[&quot;HMIX&quot;][4][1]);
        }

        if (!spectrum[&quot;NMHMIX&quot;].empty()) for (ie=1;ie&lt;=3;ie++) for (je=1;je&lt;=3;je++)
         if (spectrum[&quot;NMHMIX&quot;][max(ie,je)].is_data_line()) result.H0_mix[ie][je]=SLHAea::to&lt;double&gt;(spectrum[&quot;NMHMIX&quot;].at(ie,je)[2]);

        if (!spectrum[&quot;NMAMIX&quot;].empty()) for (ie=1;ie&lt;=2;ie++) for (je=1;je&lt;=2;je++)
         if (spectrum[&quot;NMAMIX&quot;][max(ie,je)].is_data_line()) result.A0_mix[ie][je]=SLHAea::to&lt;double&gt;(spectrum[&quot;NMAMIX&quot;].at(ie,je)[2]);

        if (!spectrum[&quot;MSOFT&quot;].empty())
        {
          if (!spectrum[&quot;MSOFT&quot;].front().empty()) result.MSOFT_Q=SLHAea::to&lt;double&gt;(spectrum[&quot;MSOFT&quot;].front().at(3));
          if (spectrum[&quot;MSOFT&quot;][1].is_data_line()) result.M1_Q=SLHAea::to&lt;double&gt;(spectrum[&quot;MSOFT&quot;][1][1]);
          if (spectrum[&quot;MSOFT&quot;][2].is_data_line()) result.M2_Q=SLHAea::to&lt;double&gt;(spectrum[&quot;MSOFT&quot;][2][1]);
          if (spectrum[&quot;MSOFT&quot;][3].is_data_line()) result.M3_Q=SLHAea::to&lt;double&gt;(spectrum[&quot;MSOFT&quot;][3][1]);
          if (spectrum[&quot;MSOFT&quot;][21].is_data_line()) result.M2H1_Q=SLHAea::to&lt;double&gt;(spectrum[&quot;MSOFT&quot;][21][1]);
          if (spectrum[&quot;MSOFT&quot;][22].is_data_line()) result.M2H2_Q=SLHAea::to&lt;double&gt;(spectrum[&quot;MSOFT&quot;][22][1]);
          if (spectrum[&quot;MSOFT&quot;][31].is_data_line()) result.MeL_Q=SLHAea::to&lt;double&gt;(spectrum[&quot;MSOFT&quot;][31][1]);
          if (spectrum[&quot;MSOFT&quot;][32].is_data_line()) result.MmuL_Q=SLHAea::to&lt;double&gt;(spectrum[&quot;MSOFT&quot;][32][1]);
          if (spectrum[&quot;MSOFT&quot;][33].is_data_line()) result.MtauL_Q=SLHAea::to&lt;double&gt;(spectrum[&quot;MSOFT&quot;][33][1]);
          if (spectrum[&quot;MSOFT&quot;][34].is_data_line()) result.MeR_Q=SLHAea::to&lt;double&gt;(spectrum[&quot;MSOFT&quot;][34][1]);
          if (spectrum[&quot;MSOFT&quot;][35].is_data_line()) result.MmuR_Q=SLHAea::to&lt;double&gt;(spectrum[&quot;MSOFT&quot;][35][1]);
          if (spectrum[&quot;MSOFT&quot;][36].is_data_line()) result.MtauR_Q=SLHAea::to&lt;double&gt;(spectrum[&quot;MSOFT&quot;][36][1]);
          if (spectrum[&quot;MSOFT&quot;][41].is_data_line()) result.MqL1_Q=SLHAea::to&lt;double&gt;(spectrum[&quot;MSOFT&quot;][41][1]);
          if (spectrum[&quot;MSOFT&quot;][42].is_data_line()) result.MqL2_Q=SLHAea::to&lt;double&gt;(spectrum[&quot;MSOFT&quot;][42][1]);
          if (spectrum[&quot;MSOFT&quot;][43].is_data_line()) result.MqL3_Q=SLHAea::to&lt;double&gt;(spectrum[&quot;MSOFT&quot;][43][1]);
          if (spectrum[&quot;MSOFT&quot;][44].is_data_line()) result.MuR_Q=SLHAea::to&lt;double&gt;(spectrum[&quot;MSOFT&quot;][44][1]);
          if (spectrum[&quot;MSOFT&quot;][45].is_data_line()) result.McR_Q=SLHAea::to&lt;double&gt;(spectrum[&quot;MSOFT&quot;][45][1]);
          if (spectrum[&quot;MSOFT&quot;][46].is_data_line()) result.MtR_Q=SLHAea::to&lt;double&gt;(spectrum[&quot;MSOFT&quot;][46][1]);
          if (spectrum[&quot;MSOFT&quot;][47].is_data_line()) result.MdR_Q=SLHAea::to&lt;double&gt;(spectrum[&quot;MSOFT&quot;][47][1]);
          if (spectrum[&quot;MSOFT&quot;][48].is_data_line()) result.MsR_Q=SLHAea::to&lt;double&gt;(spectrum[&quot;MSOFT&quot;][48][1]);
          if (spectrum[&quot;MSOFT&quot;][49].is_data_line()) result.MbR_Q=SLHAea::to&lt;double&gt;(spectrum[&quot;MSOFT&quot;][49][1]);
        }

        if (!spectrum[&quot;AU&quot;].empty())
        {
          if (spectrum[&quot;AU&quot;][1].is_data_line()) result.A_u=SLHAea::to&lt;double&gt;(spectrum[&quot;AU&quot;].at(1,1)[2]);
          if (spectrum[&quot;AU&quot;][2].is_data_line()) result.A_c=SLHAea::to&lt;double&gt;(spectrum[&quot;AU&quot;].at(2,2)[2]);
          if (spectrum[&quot;AU&quot;][3].is_data_line()) result.A_t=SLHAea::to&lt;double&gt;(spectrum[&quot;AU&quot;].at(3,3)[2]);
        }

        if (!spectrum[&quot;AD&quot;].empty())
        {
          if (spectrum[&quot;AD&quot;][1].is_data_line()) result.A_d=SLHAea::to&lt;double&gt;(spectrum[&quot;AD&quot;].at(1,1)[2]);
          if (spectrum[&quot;AD&quot;][2].is_data_line()) result.A_s=SLHAea::to&lt;double&gt;(spectrum[&quot;AD&quot;].at(2,2)[2]);
          if (spectrum[&quot;AD&quot;][3].is_data_line()) result.A_b=SLHAea::to&lt;double&gt;(spectrum[&quot;AD&quot;].at(3,3)[2]);
        }

        if (!spectrum[&quot;AE&quot;].empty())
        {
          if (spectrum[&quot;AE&quot;][1].is_data_line()) result.A_e=SLHAea::to&lt;double&gt;(spectrum[&quot;AE&quot;].at(1,1)[2]);
          if (spectrum[&quot;AE&quot;][2].is_data_line()) result.A_mu=SLHAea::to&lt;double&gt;(spectrum[&quot;AE&quot;].at(2,2)[2]);
          if (spectrum[&quot;AE&quot;][3].is_data_line()) result.A_tau=SLHAea::to&lt;double&gt;(spectrum[&quot;AE&quot;].at(3,3)[2]);
        }

        if (!spectrum[&quot;NMSSMRUN&quot;].empty())
        {
          if (spectrum[&quot;NMSSMRUN&quot;][1].is_data_line()) result.lambdaNMSSM=SLHAea::to&lt;double&gt;(spectrum[&quot;NMSSMRUN&quot;][1][1]);
          if (spectrum[&quot;NMSSMRUN&quot;][2].is_data_line()) result.kappaNMSSM=SLHAea::to&lt;double&gt;(spectrum[&quot;NMSSMRUN&quot;][2][1]);
          if (spectrum[&quot;NMSSMRUN&quot;][3].is_data_line()) result.AlambdaNMSSM=SLHAea::to&lt;double&gt;(spectrum[&quot;NMSSMRUN&quot;][3][1]);
          if (spectrum[&quot;NMSSMRUN&quot;][4].is_data_line()) result.AkappaNMSSM=SLHAea::to&lt;double&gt;(spectrum[&quot;NMSSMRUN&quot;][4][1]);
          if (spectrum[&quot;NMSSMRUN&quot;][5].is_data_line()) result.lambdaSNMSSM=SLHAea::to&lt;double&gt;(spectrum[&quot;NMSSMRUN&quot;][5][1]);
          if (spectrum[&quot;NMSSMRUN&quot;][6].is_data_line()) result.xiFNMSSM=SLHAea::to&lt;double&gt;(spectrum[&quot;NMSSMRUN&quot;][6][1]);
          if (spectrum[&quot;NMSSMRUN&quot;][7].is_data_line()) result.xiSNMSSM=SLHAea::to&lt;double&gt;(spectrum[&quot;NMSSMRUN&quot;][7][1]);
          if (spectrum[&quot;NMSSMRUN&quot;][8].is_data_line()) result.mupNMSSM=SLHAea::to&lt;double&gt;(spectrum[&quot;NMSSMRUN&quot;][8][1]);
          if (spectrum[&quot;NMSSMRUN&quot;][9].is_data_line()) result.mSp2NMSSM=SLHAea::to&lt;double&gt;(spectrum[&quot;NMSSMRUN&quot;][9][1]);
          if (spectrum[&quot;NMSSMRUN&quot;][10].is_data_line()) result.mS2NMSSM=SLHAea::to&lt;double&gt;(spectrum[&quot;NMSSMRUN&quot;][10][1]);
        }

        if (!spectrum[&quot;USQMIX&quot;].empty()) for (ie=1;ie&lt;=6;ie++) for (je=1;je&lt;=6;je++)
         if (spectrum[&quot;USQMIX&quot;][max(ie,je)].is_data_line()) result.sU_mix[ie][je]=SLHAea::to&lt;double&gt;(spectrum[&quot;USQMIX&quot;].at(ie,je)[2]);
        if (!spectrum[&quot;DSQMIX&quot;].empty()) for (ie=1;ie&lt;=6;ie++) for (je=1;je&lt;=6;je++)
         if (spectrum[&quot;DSQMIX&quot;][max(ie,je)].is_data_line()) result.sD_mix[ie][je]=SLHAea::to&lt;double&gt;(spectrum[&quot;DSQMIX&quot;].at(ie,je)[2]);
        if (!spectrum[&quot;SELMIX&quot;].empty()) for (ie=1;ie&lt;=6;ie++) for (je=1;je&lt;=6;je++)
         if (spectrum[&quot;SELMIX&quot;][max(ie,je)].is_data_line()) result.sE_mix[ie][je]=SLHAea::to&lt;double&gt;(spectrum[&quot;SELMIX&quot;].at(ie,je)[2]);
        if (!spectrum[&quot;SNUMIX&quot;].empty()) for (ie=1;ie&lt;=3;ie++) for (je=1;je&lt;=3;je++)
         if (spectrum[&quot;SNUMIX&quot;][max(ie,je)].is_data_line()) result.sNU_mix[ie][je]=SLHAea::to&lt;double&gt;(spectrum[&quot;SNUMIX&quot;].at(ie,je)[2]);

        if (!spectrum[&quot;MSQ2&quot;].empty()) for (ie=1;ie&lt;=3;ie++) for (je=1;je&lt;=3;je++)
         if (spectrum[&quot;MSQ2&quot;][max(ie,je)].is_data_line()) result.sCKM_msq2[ie][je]=SLHAea::to&lt;double&gt;(spectrum[&quot;MSQ2&quot;].at(ie,je)[2]);
        if (!spectrum[&quot;MSL2&quot;].empty()) for (ie=1;ie&lt;=3;ie++) for (je=1;je&lt;=3;je++)
         if (spectrum[&quot;MSL2&quot;][max(ie,je)].is_data_line()) result.sCKM_msl2[ie][je]=SLHAea::to&lt;double&gt;(spectrum[&quot;MSL2&quot;].at(ie,je)[2]);
        if (!spectrum[&quot;MSD2&quot;].empty()) for (ie=1;ie&lt;=3;ie++) for (je=1;je&lt;=3;je++)
         if (spectrum[&quot;MSD2&quot;][max(ie,je)].is_data_line()) result.sCKM_msd2[ie][je]=SLHAea::to&lt;double&gt;(spectrum[&quot;MSD2&quot;].at(ie,je)[2]);
        if (!spectrum[&quot;MSU2&quot;].empty()) for (ie=1;ie&lt;=3;ie++) for (je=1;je&lt;=3;je++)
         if (spectrum[&quot;MSU2&quot;][max(ie,je)].is_data_line()) result.sCKM_msu2[ie][je]=SLHAea::to&lt;double&gt;(spectrum[&quot;MSU2&quot;].at(ie,je)[2]);
        if (!spectrum[&quot;MSE2&quot;].empty()) for (ie=1;ie&lt;=3;ie++) for (je=1;je&lt;=3;je++)
         if (spectrum[&quot;MSE2&quot;][max(ie,je)].is_data_line()) result.sCKM_mse2[ie][je]=SLHAea::to&lt;double&gt;(spectrum[&quot;MSE2&quot;].at(ie,je)[2]);

        if (!spectrum[&quot;IMVCKM&quot;].empty()) for (ie=1;ie&lt;=3;ie++) for (je=1;je&lt;=3;je++)
         if (spectrum[&quot;IMVCKM&quot;][max(ie,je)].is_data_line()) result.IMCKM[ie][je]=SLHAea::to&lt;double&gt;(spectrum[&quot;IMVCKM&quot;].at(ie,je)[2]);
        if (!spectrum[&quot;IMVCKM&quot;].empty()) for (ie=1;ie&lt;=3;ie++) for (je=1;je&lt;=3;je++)
         if (spectrum[&quot;IMVCKM&quot;][max(ie,je)].is_data_line()) result.IMCKM[ie][je]=SLHAea::to&lt;double&gt;(spectrum[&quot;IMVCKM&quot;].at(ie,je)[2]);

        if (!spectrum[&quot;UPMNS&quot;].empty()) for (ie=1;ie&lt;=3;ie++) for (je=1;je&lt;=3;je++)
         if (spectrum[&quot;UPMNS&quot;][max(ie,je)].is_data_line()) result.PMNS_U[ie][je]=SLHAea::to&lt;double&gt;(spectrum[&quot;UPMNS&quot;].at(ie,je)[2]);

        if (!spectrum[&quot;TU&quot;].empty()) for (ie=1;ie&lt;=3;ie++) for (je=1;je&lt;=3;je++)
         if (spectrum[&quot;TU&quot;][max(ie,je)].is_data_line()) result.TU[ie][je]=SLHAea::to&lt;double&gt;(spectrum[&quot;TU&quot;].at(ie,je)[2]);
        if (!spectrum[&quot;TD&quot;].empty()) for (ie=1;ie&lt;=3;ie++) for (je=1;je&lt;=3;je++)
         if (spectrum[&quot;TD&quot;][max(ie,je)].is_data_line()) result.TD[ie][je]=SLHAea::to&lt;double&gt;(spectrum[&quot;TD&quot;].at(ie,je)[2]);
        if (!spectrum[&quot;TE&quot;].empty()) for (ie=1;ie&lt;=3;ie++) for (je=1;je&lt;=3;je++)
         if (spectrum[&quot;TE&quot;][max(ie,je)].is_data_line()) result.TE[ie][je]=SLHAea::to&lt;double&gt;(spectrum[&quot;TE&quot;].at(ie,je)[2]);
      }

      else if (ModelInUse(&quot;WC&quot;)  || ModelInUse(&quot;WC_LR&quot;) || ModelInUse(&quot;WC_LUV&quot;) )
      {
        // The Higgs mass doesn't come through in the SLHAea object, as that's only for SLHA2 SM inputs.
        result.mass_h0 = Dep::SM_spectrum-&gt;get(Par::Pole_Mass, &quot;h0_1&quot;);
        // Set the scale.
        result.Q = result.mass_Z;
      }

      if(byVal(result.mass_c_pole)&gt;0.&amp;&amp;byVal(result.scheme_c_mass)&lt;0)
      {
        if(byVal(result.mass_c_pole)&lt;1.5) result.mass_c=BEreq::mcmc_from_pole(byVal(result.mass_c_pole),1,&amp;result);
        else if(byVal(result.mass_c_pole)&lt;1.75) result.mass_c=BEreq::mcmc_from_pole(byVal(result.mass_c_pole),2,&amp;result);
        else result.mass_c=BEreq::mcmc_from_pole(byVal(result.mass_c_pole),3,&amp;result);
      }

      BEreq::slha_adjust(&amp;result);

      // Set the Z and W widths
      result.width_Z = Dep::Z_decay_rates-&gt;width_in_GeV;
      result.width_W = Dep::W_plus_decay_rates-&gt;width_in_GeV;

      for(int ie=1;ie&lt;=30;ie++) result.deltaC[ie]=result.deltaCp[ie]=0.;
      for(int ie=1;ie&lt;=6;ie++) result.deltaCQ[ie]=result.deltaCQp[ie]=0.;

      // If requested, override the SuperIso b pole mass with the SpecBit value and recompute the 1S b mass.
      if (runOptions-&gt;getValueOrDef&lt;bool&gt;(false, &quot;take_b_pole_mass_from_spectrum&quot;))
      {
        if (ModelInUse(&quot;MSSM63atMGUT&quot;) or ModelInUse(&quot;MSSM63atQ&quot;))
        {
          result.mass_h0 = Dep::MSSM_spectrum-&gt;get(Par::Pole_Mass, &quot;h0_1&quot;);
        }
        else if (ModelInUse(&quot;WC&quot;) || ModelInUse(&quot;WC_LUV&quot;) || ModelInUse(&quot;WC_LR&quot;) )
        {
          result.mass_h0 = Dep::SM_spectrum-&gt;get(Par::Pole_Mass, &quot;h0_1&quot;);
        }
        result.mass_b_1S = BEreq::mb_1S(&amp;result);
      }

      if (ModelInUse(&quot;WC&quot;))
      {

        // Tell SuperIso to do its Wilson coefficient calculations for the SM.
        // We will adjust them with our BSM deviations in backend convenience
        // functions before we send them to SuperIso's observable calculation functions.
        result.SM = 1;

        // So far our model only deals with 5 operators: O_7, O_9, O_10, Q_1 and Q_2.
        result.Re_DeltaC7  = *Param[&quot;Re_DeltaC7&quot;];
        result.Im_DeltaC7  = *Param[&quot;Im_DeltaC7&quot;];
        result.Re_DeltaC9  = *Param[&quot;Re_DeltaC9&quot;];
        result.Im_DeltaC9  = *Param[&quot;Im_DeltaC9&quot;];
        result.Re_DeltaC10 = *Param[&quot;Re_DeltaC10&quot;];
        result.Im_DeltaC10 = *Param[&quot;Im_DeltaC10&quot;];
        result.Re_DeltaCQ1 = *Param[&quot;Re_DeltaCQ1&quot;];
        result.Im_DeltaCQ1 = *Param[&quot;Im_DeltaCQ1&quot;];
        result.Re_DeltaCQ2 = *Param[&quot;Re_DeltaCQ2&quot;];
        result.Im_DeltaCQ2 = *Param[&quot;Im_DeltaCQ2&quot;];

        /* Lines below are valid only in the flavour universal case
           deltaC[1..10] = Cmu[1..10], deltaC[11..20] = Ce[1..10], deltaC[21..30] = Ctau[1..10]
           deltaCQ[1,2] = CQmu[1,2], deltaCQ[1,2] = CQe[1,2], deltaCQ[1,2] = CQtau[1,2] */

        result.deltaC[7]=result.deltaC[17]=result.deltaC[27]=std::complex&lt;double&gt;(result.Re_DeltaC7, result.Im_DeltaC7);
        result.deltaC[9]=result.deltaC[19]=result.deltaC[29]=std::complex&lt;double&gt;(result.Re_DeltaC9, result.Im_DeltaC9);
        result.deltaC[10]=result.deltaC[20]=result.deltaC[30]=std::complex&lt;double&gt;(result.Re_DeltaC10, result.Im_DeltaC10);

        result.deltaCQ[1]=result.deltaCQ[3]=result.deltaCQ[5]=std::complex&lt;double&gt;(result.Re_DeltaCQ1, result.Im_DeltaCQ1);
        result.deltaCQ[2]=result.deltaCQ[4]=result.deltaCQ[6]=std::complex&lt;double&gt;(result.Re_DeltaCQ2, result.Im_DeltaCQ2);
      }

      if (ModelInUse(&quot;WC_LR&quot;))
      {
        result.SM = 1;

        result.Re_DeltaC7  = *Param[&quot;Re_DeltaC7&quot;];
        result.Im_DeltaC7  = *Param[&quot;Im_DeltaC7&quot;];
        result.Re_DeltaC9  = *Param[&quot;Re_DeltaC9&quot;];
        result.Im_DeltaC9  = *Param[&quot;Im_DeltaC9&quot;];
        result.Re_DeltaC10 = *Param[&quot;Re_DeltaC10&quot;];
        result.Im_DeltaC10 = *Param[&quot;Im_DeltaC10&quot;];
        result.Re_DeltaCQ1 = *Param[&quot;Re_DeltaCQ1&quot;];
        result.Im_DeltaCQ1 = *Param[&quot;Im_DeltaCQ1&quot;];
        result.Re_DeltaCQ2 = *Param[&quot;Re_DeltaCQ2&quot;];
        result.Im_DeltaCQ2 = *Param[&quot;Im_DeltaCQ2&quot;];

        result.Re_DeltaC7_Prime  = *Param[&quot;Re_DeltaC7_Prime&quot;];
        result.Im_DeltaC7_Prime  = *Param[&quot;Im_DeltaC7_Prime&quot;];
        result.Re_DeltaC9_Prime  = *Param[&quot;Re_DeltaC9_Prime&quot;];
        result.Im_DeltaC9_Prime  = *Param[&quot;Im_DeltaC9_Prime&quot;];
        result.Re_DeltaC10_Prime = *Param[&quot;Re_DeltaC10_Prime&quot;];
        result.Im_DeltaC10_Prime = *Param[&quot;Im_DeltaC10_Prime&quot;];
        result.Re_DeltaCQ1_Prime = *Param[&quot;Re_DeltaCQ1_Prime&quot;];
        result.Im_DeltaCQ1_Prime = *Param[&quot;Im_DeltaCQ1_Prime&quot;];
        result.Re_DeltaCQ2_Prime = *Param[&quot;Re_DeltaCQ2_Prime&quot;];
        result.Im_DeltaCQ2_Prime = *Param[&quot;Im_DeltaCQ2_Prime&quot;];

        // left handed:
        result.deltaC[7]=result.deltaC[17]=result.deltaC[27]=std::complex&lt;double&gt;(result.Re_DeltaC7, result.Im_DeltaC7);
        result.deltaC[9]=result.deltaC[19]=result.deltaC[29]=std::complex&lt;double&gt;(result.Re_DeltaC9, result.Im_DeltaC9);
        result.deltaC[10]=result.deltaC[20]=result.deltaC[30]=std::complex&lt;double&gt;(result.Re_DeltaC10, result.Im_DeltaC10);
        result.deltaCQ[1]=result.deltaCQ[3]=result.deltaCQ[5]=std::complex&lt;double&gt;(result.Re_DeltaCQ1, result.Im_DeltaCQ1);
        result.deltaCQ[2]=result.deltaCQ[4]=result.deltaCQ[6]=std::complex&lt;double&gt;(result.Re_DeltaCQ2, result.Im_DeltaCQ2);

        // right handed:
        result.deltaCp[7]=result.deltaCp[17]=result.deltaCp[27]=std::complex&lt;double&gt;(result.Re_DeltaC7_Prime, result.Im_DeltaC7_Prime);
        result.deltaCp[9]=result.deltaCp[19]=result.deltaCp[29]=std::complex&lt;double&gt;(result.Re_DeltaC9_Prime, result.Im_DeltaC9_Prime);
        result.deltaCp[10]=result.deltaCp[20]=result.deltaCp[30]=std::complex&lt;double&gt;(result.Re_DeltaC10_Prime, result.Im_DeltaC10_Prime);
        result.deltaCQp[1]=result.deltaCQp[3]=result.deltaCQp[5]=std::complex&lt;double&gt;(result.Re_DeltaCQ1_Prime, result.Im_DeltaCQ1_Prime);
        result.deltaCQp[2]=result.deltaCQp[4]=result.deltaCQp[6]=std::complex&lt;double&gt;(result.Re_DeltaCQ2_Prime, result.Im_DeltaCQ2_Prime);
      }

      else if (ModelInUse(&quot;WC_LUV&quot;))
      {
        result.SM = 1;

        // So far our model only deals with 5 operators: O_7, O_9, O_10, Q_1 and Q_2.
        result.Re_DeltaC7_mu  = *Param[&quot;Re_DeltaC7_mu&quot;];
        result.Im_DeltaC7_mu  = *Param[&quot;Im_DeltaC7_mu&quot;];
        result.Re_DeltaC9_mu  = *Param[&quot;Re_DeltaC9_mu&quot;];
        result.Im_DeltaC9_mu  = *Param[&quot;Im_DeltaC9_mu&quot;];
        result.Re_DeltaC10_mu = *Param[&quot;Re_DeltaC10_mu&quot;];
        result.Im_DeltaC10_mu = *Param[&quot;Im_DeltaC10_mu&quot;];
        result.Re_DeltaCQ1_mu = *Param[&quot;Re_DeltaCQ1_mu&quot;];
        result.Im_DeltaCQ1_mu = *Param[&quot;Im_DeltaCQ1_mu&quot;];
        result.Re_DeltaCQ2_mu = *Param[&quot;Re_DeltaCQ2_mu&quot;];
        result.Im_DeltaCQ2_mu = *Param[&quot;Im_DeltaCQ2_mu&quot;];

        result.Re_DeltaC7_e  = *Param[&quot;Re_DeltaC7_e&quot;];
        result.Im_DeltaC7_e  = *Param[&quot;Im_DeltaC7_e&quot;];
        result.Re_DeltaC9_e  = *Param[&quot;Re_DeltaC9_e&quot;];
        result.Im_DeltaC9_e  = *Param[&quot;Im_DeltaC9_e&quot;];
        result.Re_DeltaC10_e = *Param[&quot;Re_DeltaC10_e&quot;];
        result.Im_DeltaC10_e = *Param[&quot;Im_DeltaC10_e&quot;];
        result.Re_DeltaCQ1_e = *Param[&quot;Re_DeltaCQ1_e&quot;];
        result.Im_DeltaCQ1_e = *Param[&quot;Im_DeltaCQ1_e&quot;];
        result.Re_DeltaCQ2_e = *Param[&quot;Re_DeltaCQ2_e&quot;];
        result.Im_DeltaCQ2_e = *Param[&quot;Im_DeltaCQ2_e&quot;];

        result.Re_DeltaC7_tau  = *Param[&quot;Re_DeltaC7_tau&quot;];
        result.Im_DeltaC7_tau  = *Param[&quot;Im_DeltaC7_tau&quot;];
        result.Re_DeltaC9_tau  = *Param[&quot;Re_DeltaC9_tau&quot;];
        result.Im_DeltaC9_tau  = *Param[&quot;Im_DeltaC9_tau&quot;];
        result.Re_DeltaC10_tau = *Param[&quot;Re_DeltaC10_tau&quot;];
        result.Im_DeltaC10_tau = *Param[&quot;Im_DeltaC10_tau&quot;];
        result.Re_DeltaCQ1_tau = *Param[&quot;Re_DeltaCQ1_tau&quot;];
        result.Im_DeltaCQ1_tau = *Param[&quot;Im_DeltaCQ1_tau&quot;];
        result.Re_DeltaCQ2_tau = *Param[&quot;Re_DeltaCQ2_tau&quot;];
        result.Im_DeltaCQ2_tau = *Param[&quot;Im_DeltaCQ2_tau&quot;];

        /* Lines below are valid in the flavour NON-universal case
           deltaC[1..10] = Cmu[1..10], deltaC[11..20] = Ce[1..10], deltaC[21..30] = Ctau[1..10]
           deltaCQ[1,2] = CQmu[1,2], deltaCQ[1,2] = CQe[1,2], deltaCQ[1,2] = CQtau[1,2] */

        result.deltaC[7]=std::complex&lt;double&gt;(result.Re_DeltaC7_mu, result.Im_DeltaC7_mu);
        result.deltaC[9]=std::complex&lt;double&gt;(result.Re_DeltaC9_mu, result.Im_DeltaC9_mu);
        result.deltaC[10]=std::complex&lt;double&gt;(result.Re_DeltaC10_mu, result.Im_DeltaC10_mu);
        result.deltaCQ[1]=std::complex&lt;double&gt;(result.Re_DeltaCQ1_mu, result.Im_DeltaCQ1_mu);
        result.deltaCQ[2]=std::complex&lt;double&gt;(result.Re_DeltaCQ2_mu, result.Im_DeltaCQ2_mu);

        result.deltaC[17]=std::complex&lt;double&gt;(result.Re_DeltaC7_e, result.Im_DeltaC7_e);
        result.deltaC[19]=std::complex&lt;double&gt;(result.Re_DeltaC9_e, result.Im_DeltaC9_e);
        result.deltaC[20]=std::complex&lt;double&gt;(result.Re_DeltaC10_e, result.Im_DeltaC10_e);
        result.deltaCQ[3]=std::complex&lt;double&gt;(result.Re_DeltaCQ1_e, result.Im_DeltaCQ1_e);
        result.deltaCQ[4]=std::complex&lt;double&gt;(result.Re_DeltaCQ2_e, result.Im_DeltaCQ2_e);

        result.deltaC[27]=std::complex&lt;double&gt;(result.Re_DeltaC7_tau, result.Im_DeltaC7_tau);
        result.deltaC[29]=std::complex&lt;double&gt;(result.Re_DeltaC9_tau, result.Im_DeltaC9_tau);
        result.deltaC[30]=std::complex&lt;double&gt;(result.Re_DeltaC10_tau, result.Im_DeltaC10_tau);
        result.deltaCQ[5]=std::complex&lt;double&gt;(result.Re_DeltaCQ1_tau, result.Im_DeltaCQ1_tau);
        result.deltaCQ[6]=std::complex&lt;double&gt;(result.Re_DeltaCQ2_tau, result.Im_DeltaCQ2_tau);
      }

      if (flav_debug) cout&lt;&lt;&quot;Finished SuperIso_fill&quot;&lt;&lt;endl;
    }

    void SuperIso_nuisance_fill(nuisance &amp;nuislist)
    {
      using namespace Pipes::SuperIso_nuisance_fill;
      if (flav_debug) cout&lt;&lt;&quot;Starting SuperIso_nuisance_fill&quot;&lt;&lt;endl;

      parameters const&amp; param = *Dep::SuperIso_modelinfo;

      BEreq::set_nuisance(&amp;nuislist);
      BEreq::set_nuisance_value_from_param(&amp;nuislist,&amp;param);

      /* Here the nuisance parameters which should not be used for the correlation calculation have to be given a zero standard deviation.
         E.g. nuislist.mass_b.dev=0.; */

      if (flav_debug) cout&lt;&lt;&quot;Finished SuperIso_nuisance_fill&quot;&lt;&lt;endl;
    }

    void update_obs_list(std::vector&lt;str&gt;&amp; obs_list, const std::vector&lt;str&gt;&amp; HL_obs_list)
    {
      std::vector&lt;str&gt; FB_obs_list = translate_flav_obs(&quot;HEPLike&quot;, &quot;FlavBit&quot;, HL_obs_list);
      std::vector&lt;str&gt; temp;
      for (auto it = FB_obs_list.begin(); it != FB_obs_list.end(); ++it)
      {
        if (std::find(obs_list.begin(), obs_list.end(), *it) != obs_list.end())
        {
          temp.push_back(*it);
        }
      }
      obs_list = temp;
    }

    std::vector&lt;double&gt; get_obs_theory(const flav_prediction&amp; prediction, const std::vector&lt;std::string&gt;&amp; observables)
    {
      if(flav_debug) std::cout&lt;&lt;&quot;In get_obs_theory() function&quot;&lt;&lt;std::endl;
      std::vector&lt;double&gt; obs_theory;
      obs_theory.reserve(observables.size());
      for (unsigned int i = 0; i &lt; observables.size(); ++i)
      {
        if(flav_debug) std::cout&lt;&lt;&quot;Trying to find: &quot;&lt;&lt;observables[i]&lt;&lt;std::endl;
        obs_theory.push_back(prediction.central_values.at(observables[i]));
      }
      return obs_theory;
    };

    boost::numeric::ublas::matrix&lt;double&gt; get_obs_covariance(const flav_prediction&amp; prediction, const std::vector&lt;std::string&gt;&amp; observables)
    {
      boost::numeric::ublas::matrix&lt;double&gt; obs_covariance(observables.size(), observables.size());
      for (unsigned int i = 0; i &lt; observables.size(); ++i)
      {
        for (unsigned int j = 0; j &lt; observables.size(); ++j)
        {
          obs_covariance(i, j) = prediction.covariance.at(observables[i]).at(observables[j]);
        }
      }
      return obs_covariance;
    };

    void SuperIso_prediction_helper(const std::vector&lt;std::string&gt;&amp; FB_obslist, const std::vector&lt;std::string&gt;&amp; SI_obslist, flav_prediction&amp; result,
                                    const parameters&amp; param, const nuisance&amp; nuislist,
                                    void (*get_predictions_nuisance)(char**, int*, double**, const parameters*, const nuisance*),
                                    void (*observables)(int, obsname*, int, double*, double*, const nuisance*, char**, const parameters*),
                                    void (*convert_correlation)(nuiscorr*, int, double**, char**, int),
                                    void (*get_th_covariance_nuisance)(double***, char**, int*, const parameters*, const nuisance*, double**),
                                    bool useSMCovariance,
                                    bool SMCovarianceCached
                                    )
    {
      if (flav_debug)
      {
        cout &lt;&lt; &quot;Starting SuperIso_prediction&quot; &lt;&lt; std::endl;
        cout &lt;&lt; &quot;Changing convention. Before:&quot;&lt;&lt;endl;
        print(result,{&quot;S3&quot;, &quot;S4&quot;, &quot;S5&quot;, &quot;S8&quot;, &quot;S9&quot;, &quot;AT_Im&quot;});
      }

      int nObservables = SI_obslist.size();
      if (flav_debug) std::cout&lt;&lt;&quot;Observables: &quot;&lt;&lt;std::endl;

      char obsnames[nObservables][50];
      for(int iObservable = 0; iObservable &lt; nObservables; iObservable++)
      {
        strcpy(obsnames[iObservable], SI_obslist[iObservable].c_str());
        if( flav_debug) std::cout&lt;&lt;SI_obslist[iObservable].c_str()&lt;&lt;std::endl;
      }

      // ---------- CENTRAL VALUES ----------
      double *result_central;

      // Reserve memory
      result_central = (double *) calloc(nObservables, sizeof(double));

      // Needed for SuperIso backend
      get_predictions_nuisance((char**)obsnames, &amp;nObservables, &amp;result_central, &amp;param, &amp;nuislist);

      // Compute the central values
      for(int iObservable = 0; iObservable &lt; nObservables; ++iObservable)
      {
        result.central_values[FB_obslist[iObservable]] = result_central[iObservable];
      }

      // Free memory
      free(result_central);
      result_central = NULL;

      if (flav_debug)
      {
        for(int iObservable = 0; iObservable &lt; nObservables; ++iObservable)
        {
          printf(&quot;%s=%.4e\n&quot;, obsnames[iObservable], result.central_values[FB_obslist[iObservable]]);
        }
      }

      //Switch the observables to LHCb convention
      Kstarll_Theory2Experiment_translation(result.central_values, 1);
      Kstarll_Theory2Experiment_translation(result.central_values, 2);

      // If we need to compute the covariance, either because we're doing it for every point or we haven't cached the SM value, do it.
      if (not useSMCovariance or not SMCovarianceCached)
      {

        // ---------- COVARIANCE ----------
        static bool first = true;
        static const int nNuisance=161;
        static char namenuisance[nNuisance+1][50];
        static double **corr=(double  **) malloc((nNuisance+1)*sizeof(double *));  // Nuisance parameter correlations

        if (first)
        {
          observables(0, NULL, 0, NULL, NULL, &amp;nuislist, (char **)namenuisance, &amp;param); // Initialization of namenuisance

          // Reserve memory
          for(int iObservable = 0; iObservable &lt;= nNuisance; ++iObservable)
          {
            corr[iObservable]=(double *) malloc((nNuisance+1)*sizeof(double));
          }

          // Needed for SuperIso backend
          convert_correlation((nuiscorr *)corrnuis, byVal(ncorrnuis), (double **)corr, (char **)namenuisance, byVal(nNuisance));

          first = false;
        }

        double **result_covariance;

        if (useSMCovariance)
        {
          // Copy the parameters and set all Wilson Coefficients to 0 (SM values)
          parameters param_SM = param;
          for(int ie=1;ie&lt;=30;ie++)
          {
            param_SM.deltaC[ie]=0.;
            param_SM.deltaCp[ie]=0.;
          }
          for(int ie=1;ie&lt;=6;ie++)
          {
            param_SM.deltaCQ[ie]=0.;
            param_SM.deltaCQp[ie]=0.;
          }
          // Use the SM values of the parameters to calculate the SM theory covariance.
          get_th_covariance_nuisance(&amp;result_covariance, (char**)obsnames, &amp;nObservables, &amp;param_SM, &amp;nuislist, (double **)corr);
        }
        else
        {
          // Calculate covariance at the new physics point.
          get_th_covariance_nuisance(&amp;result_covariance, (char**)obsnames, &amp;nObservables, &amp;param, &amp;nuislist, (double **)corr);
        }

        // Fill the covariance matrix in the result structure
        for(int iObservable=0; iObservable &lt; nObservables; ++iObservable)
        {
          for(int jObservable = 0; jObservable &lt; nObservables; ++jObservable)
          {
            result.covariance[FB_obslist[iObservable]][FB_obslist[jObservable]] = result_covariance[iObservable][jObservable];
          }
        }

        //Switch the covariances to LHCb convention
        Kstarll_Theory2Experiment_translation(result.covariance, 1);
        Kstarll_Theory2Experiment_translation(result.covariance, 2);

        // We are not freeing the memory because we made the variable static.
        // Just keeping this for reference on how to clean up the allocated
        // memory in case of non-static calculation of **corr.
        // Free memory
        //for(int iObservable = 0; iObservable &lt;= nNuisance; ++iObservable) free(corr[iObservable]);
        //free(corr);
      }

      if (flav_debug)
      {
        for(int iObservable=0; iObservable &lt; nObservables; ++iObservable)
        {
          for(int jObservable = iObservable; jObservable &lt; nObservables; ++jObservable)
          {
            printf(&quot;Covariance %s - %s: %.4e\n&quot;,
              obsnames[iObservable], obsnames[jObservable], result.covariance[FB_obslist[iObservable]][FB_obslist[jObservable]]);
           }
        }
        cout &lt;&lt; &quot;Changing convention. After:&quot;&lt;&lt;endl;
        print(result,{&quot;S3&quot;, &quot;S4&quot;, &quot;S5&quot;, &quot;S8&quot;, &quot;S9&quot;, &quot;AT_Im&quot;});
        std::cout &lt;&lt; &quot;Finished SuperIso_prediction&quot; &lt;&lt; std::endl;
      }

    }


    #define THE_REST(bins)                                          \
      static const std::vector&lt;str&gt; SI_obslist =                    \
       translate_flav_obs(&quot;FlavBit&quot;, &quot;SuperIso&quot;, FB_obslist,        \
       Utils::p2dot(bins));                                         \
      static bool use_SM_covariance =                               \
       runOptions-&gt;getValueOrDef&lt;bool&gt;(false, &quot;use_SM_covariance&quot;); \
      static bool SM_covariance_cached = false;                     \
      SuperIso_prediction_helper(                                   \
        FB_obslist,                                                 \
        SI_obslist,                                                 \
        result,                                                     \
        *Dep::SuperIso_modelinfo,                                   \
        *Dep::SuperIso_nuisance,                                    \
        BEreq::get_predictions_nuisance.pointer(),                  \
        BEreq::observables.pointer(),                               \
        BEreq::convert_correlation.pointer(),                       \
        BEreq::get_th_covariance_nuisance.pointer(),                \
        use_SM_covariance,                                          \
        SM_covariance_cached                                        \
    );                                                              \
    SM_covariance_cached = true;

    #define SI_SINGLE_PREDICTION_FUNCTION(name)                          \
    void CAT(SuperIso_prediction_,name)(flav_prediction&amp; result)         \
    {                                                                    \
      using namespace CAT(Pipes::SuperIso_prediction_,name);             \
      static const std::vector&lt;str&gt; FB_obslist = {#name};                \
      THE_REST(&quot;&quot;)                                                       \
    }                                                                    \

    #define SI_SINGLE_PREDICTION_FUNCTION_BINS(name,bins)                \
    void CAT_3(SuperIso_prediction_,name,bins)(flav_prediction&amp; result)  \
    {                                                                    \
      using namespace CAT_3(Pipes::SuperIso_prediction_,name,bins);      \
      static const std::vector&lt;str&gt; FB_obslist = {#name};                \
      THE_REST(#bins)                                                    \
    }                                                                    \

    #define SI_MULTI_PREDICTION_FUNCTION(name)                           \
    void CAT(SuperIso_prediction_,name)(flav_prediction&amp; result)         \
    {                                                                    \
      using namespace CAT(Pipes::SuperIso_prediction_,name);             \
      static const std::vector&lt;str&gt; FB_obslist =                         \
       Downstream::subcaps-&gt;getNames();                                  \
      if (FB_obslist.empty()) FlavBit_error().raise(LOCAL_INFO,          \
       &quot;Missing subcapabilities for SuperIso_prediction_&quot;#name&quot;.&quot;);      \
      THE_REST(&quot;&quot;)                                                       \
    }                                                                    \

    #define SI_MULTI_PREDICTION_FUNCTION_BINS(name,bins,exp)             \
    void CAT_4(SuperIso_prediction_,name,bins,exp)(flav_prediction&amp;      \
     result)                                                             \
    {                                                                    \
      using namespace CAT_4(Pipes::SuperIso_prediction_,name,bins,exp);  \
      static const std::vector&lt;str&gt; FB_obslist =                         \
       Downstream::subcaps-&gt;getNames();                                  \
      if (FB_obslist.empty()) FlavBit_error().raise(LOCAL_INFO,          \
       &quot;Missing subcapabilities for SuperIso_prediction_&quot;#name&quot;.&quot;);      \
      THE_REST(#bins)                                                    \
    }                                                                    \

    SI_SINGLE_PREDICTION_FUNCTION(B2taunu)
    SI_SINGLE_PREDICTION_FUNCTION(b2sgamma)

    SI_SINGLE_PREDICTION_FUNCTION(B2Kstargamma)
    SI_SINGLE_PREDICTION_FUNCTION(BRBXsmumu_lowq2)
    SI_SINGLE_PREDICTION_FUNCTION(BRBXsmumu_highq2)
    SI_SINGLE_PREDICTION_FUNCTION(AFBBXsmumu_lowq2)
    SI_SINGLE_PREDICTION_FUNCTION(AFBBXsmumu_highq2)

    SI_SINGLE_PREDICTION_FUNCTION_BINS(Bs2phimumuBr,_1_6)
    SI_SINGLE_PREDICTION_FUNCTION_BINS(Bs2phimumuBr,_15_19)
    SI_SINGLE_PREDICTION_FUNCTION_BINS(B2KstarmumuBr,_0p1_0p98)
    SI_SINGLE_PREDICTION_FUNCTION_BINS(B2KstarmumuBr,_1p1_2p5)
    SI_SINGLE_PREDICTION_FUNCTION_BINS(B2KstarmumuBr,_2p5_4)
    SI_SINGLE_PREDICTION_FUNCTION_BINS(B2KstarmumuBr,_4_6)
    SI_SINGLE_PREDICTION_FUNCTION_BINS(B2KstarmumuBr,_6_8)
    SI_SINGLE_PREDICTION_FUNCTION_BINS(B2KstarmumuBr,_15_19)
    SI_SINGLE_PREDICTION_FUNCTION_BINS(B2KmumuBr,_0p05_2)
    SI_SINGLE_PREDICTION_FUNCTION_BINS(B2KmumuBr,_2_4p3)
    SI_SINGLE_PREDICTION_FUNCTION_BINS(B2KmumuBr,_4p3_8p68)
    SI_SINGLE_PREDICTION_FUNCTION_BINS(B2KmumuBr,_14p18_16)
    SI_SINGLE_PREDICTION_FUNCTION_BINS(B2KmumuBr,_16_18)
    SI_SINGLE_PREDICTION_FUNCTION_BINS(B2KmumuBr,_18_22)
    // TODO: these should be re-activated once RK and RKstar can be extracted from a future version of SuperIso using the check_nameobs function.
    //SI_SINGLE_PREDICTION_FUNCTION_BINS(RK_LHCb,_1p1_6)
    //SI_SINGLE_PREDICTION_FUNCTION_BINS(RKstar_LHCb,_0p045_1p1)
    //SI_SINGLE_PREDICTION_FUNCTION_BINS(RKstar_LHCb,_1p1_6)

    // The sub-capabilities that may be received from likelihood functions in order to feed them valid observables are listed
    // below. In principle though, these functions will accept as sub-capabilities *any* recognised SuperIso observable names.
    // The recognised observable names can be found in the check_nameobs function in src/chi2.c in SuperIso.
    SI_MULTI_PREDICTION_FUNCTION(B2mumu)                                // Typical subcaps: BRuntag_Bsmumu, BR_Bdmumu
    //SI_MULTI_PREDICTION_FUNCTION(RDRDstar)                            // TODO: Typical subcaps: RD, RDstar
    SI_MULTI_PREDICTION_FUNCTION_BINS(B2KstarmumuAng,_0p1_2,_Atlas)     // Typical subcaps: FL, S3, S4, S5, S7, S8
    SI_MULTI_PREDICTION_FUNCTION_BINS(B2KstarmumuAng,_2_4,_Atlas)       // Typical subcaps: FL, S3, S4, S5, S7, S8
    SI_MULTI_PREDICTION_FUNCTION_BINS(B2KstarmumuAng,_4_8,_Atlas)       // Typical subcaps: FL, S3, S4, S5, S7, S8
    SI_MULTI_PREDICTION_FUNCTION_BINS(B2KstarmumuAng,_1_2,_CMS)         // Typical subcaps: P1, P5prime
    SI_MULTI_PREDICTION_FUNCTION_BINS(B2KstarmumuAng,_2_4p3,_CMS)       // Typical subcaps: P1, P5prime
    SI_MULTI_PREDICTION_FUNCTION_BINS(B2KstarmumuAng,_4p3_6,_CMS)       // Typical subcaps: P1, P5prime
    SI_MULTI_PREDICTION_FUNCTION_BINS(B2KstarmumuAng,_6_8p68,_CMS)      // Typical subcaps: P1, P5prime
    SI_MULTI_PREDICTION_FUNCTION_BINS(B2KstarmumuAng,_10p09_12p86,_CMS) // Typical subcaps: P1, P5prime
    SI_MULTI_PREDICTION_FUNCTION_BINS(B2KstarmumuAng,_14p18_16,_CMS)    // Typical subcaps: P1, P5prime
    SI_MULTI_PREDICTION_FUNCTION_BINS(B2KstarmumuAng,_16_19,_CMS)       // Typical subcaps: P1, P5prime
    SI_MULTI_PREDICTION_FUNCTION_BINS(B2KstarmumuAng,_0p1_4,_Belle)     // Typical subcaps: P4prime, P5prime
    SI_MULTI_PREDICTION_FUNCTION_BINS(B2KstarmumuAng,_4_8,_Belle)       // Typical subcaps: P4prime, P5prime
    SI_MULTI_PREDICTION_FUNCTION_BINS(B2KstarmumuAng,_10p9_12p9,_Belle) // Typical subcaps: P4prime, P5prime
    SI_MULTI_PREDICTION_FUNCTION_BINS(B2KstarmumuAng,_14p18_19,_Belle)  // Typical subcaps: P4prime, P5prime
    SI_MULTI_PREDICTION_FUNCTION_BINS(B2KstarmumuAng,_0p1_0p98,_LHCb)   // Typical subcaps: FL, AFB, S3, S4, S5, S7, S8, S9
    SI_MULTI_PREDICTION_FUNCTION_BINS(B2KstarmumuAng,_1p1_2p5,_LHCb)    // Typical subcaps: FL, AFB, S3, S4, S5, S7, S8, S9
    SI_MULTI_PREDICTION_FUNCTION_BINS(B2KstarmumuAng,_2p5_4,_LHCb)      // Typical subcaps: FL, AFB, S3, S4, S5, S7, S8, S9
    SI_MULTI_PREDICTION_FUNCTION_BINS(B2KstarmumuAng,_4_6,_LHCb)        // Typical subcaps: FL, AFB, S3, S4, S5, S7, S8, S9
    SI_MULTI_PREDICTION_FUNCTION_BINS(B2KstarmumuAng,_6_8,_LHCb)        // Typical subcaps: FL, AFB, S3, S4, S5, S7, S8, S9
    SI_MULTI_PREDICTION_FUNCTION_BINS(B2KstarmumuAng,_15_19,_LHCb)      // Typical subcaps: FL, AFB, S3, S4, S5, S7, S8, S9
    SI_MULTI_PREDICTION_FUNCTION_BINS(B2KstareeAng,_0p0008_0p257,_LHCb) // Typical subcaps: FLee, AT_Re, AT_2, AT_Im

    #undef SI_PRED_HELPER_CALL
    #undef SI_SINGLE_PREDICTION_FUNCTION
    #undef SI_SINGLE_PREDICTION_FUNCTION_BINS
    #undef SI_MULTI_PREDICTION_FUNCTION
    #undef SI_MULTI_PREDICTION_FUNCTION_BINS


    void SuperIso_prediction_Btaunu(double &amp;result)
    {
      using namespace Pipes::SuperIso_prediction_Btaunu;
      if (flav_debug) cout&lt;&lt;&quot;Starting SuperIso_prediction_Btaunu&quot;&lt;&lt;endl;

      parameters const&amp; param = *Dep::SuperIso_modelinfo;
      result = BEreq::Btaunu(&amp;param);

      if (flav_debug) printf(&quot;BR(B-&gt;tau nu)=%.3e\n&quot;,result);
      if (flav_debug) cout&lt;&lt;&quot;Finished SuperIso_prediction_Btaunu&quot;&lt;&lt;endl;
    }


    void SuperIso_prediction_Dstaunu(double &amp;result)
    {
      using namespace Pipes::SuperIso_prediction_Dstaunu;
      if (flav_debug) cout&lt;&lt;&quot;Starting SuperIso_prediction_Dstaunu&quot;&lt;&lt;endl;

      parameters const&amp; param = *Dep::SuperIso_modelinfo;
      result = BEreq::Dstaunu(&amp;param);

      if (flav_debug) printf(&quot;BR(Ds-&gt;tau nu)=%.3e\n&quot;,result);
      if (flav_debug) cout&lt;&lt;&quot;Finished SuperIso_prediction_Dstaunu&quot;&lt;&lt;endl;
    }


    void SuperIso_prediction_Dsmunu(double &amp;result)
    {
      using namespace Pipes::SuperIso_prediction_Dsmunu;
      if (flav_debug) cout&lt;&lt;&quot;Starting SuperIso_prediction_Dsmunu&quot;&lt;&lt;endl;

      parameters const&amp; param = *Dep::SuperIso_modelinfo;
      result = BEreq::Dsmunu(&amp;param);

      if (flav_debug) printf(&quot;BR(Ds-&gt;mu nu)=%.3e\n&quot;,result);
      if (flav_debug) cout&lt;&lt;&quot;Finished SuperIso_prediction_Dsmunu&quot;&lt;&lt;endl;
    }


    void SuperIso_prediction_Dmunu(double &amp;result)
    {
      using namespace Pipes::SuperIso_prediction_Dmunu;
      if (flav_debug) cout&lt;&lt;&quot;Starting SuperIso_prediction_Dmunu&quot;&lt;&lt;endl;

      parameters const&amp; param = *Dep::SuperIso_modelinfo;
      result = BEreq::Dmunu(&amp;param);

      if (flav_debug) printf(&quot;BR(D-&gt;mu nu)=%.3e\n&quot;,result);
      if (flav_debug) cout&lt;&lt;&quot;Finished SuperIso_prediction_Dmunu&quot;&lt;&lt;endl;
    }


    void SuperIso_prediction_BDtaunu(double &amp;result)
    {
      using namespace Pipes::SuperIso_prediction_BDtaunu;
      if (flav_debug) cout&lt;&lt;&quot;Starting SuperIso_prediction_BDtaunu&quot;&lt;&lt;endl;

      parameters const&amp; param = *Dep::SuperIso_modelinfo;
      if (param.model &lt; 0) FlavBit_error().raise(LOCAL_INFO, &quot;Unsupported model.&quot;);

      double q2_min_tau_D  = 3.16; // 1.776**2
      double q2_max_tau_D  = 11.6;   // (5.28-1.869)**2
      int gen_tau_D        = 3;
      int charge_tau_D     = 0;// D* is the charged version
      double obs_tau_D[3];

      result=BEreq::BRBDlnu(byVal(gen_tau_D), byVal( charge_tau_D), byVal(q2_min_tau_D), byVal(q2_max_tau_D), byVal(obs_tau_D), &amp;param);

      if (flav_debug) printf(&quot;BR(B-&gt; D tau nu )=%.3e\n&quot;,result);
      if (flav_debug) cout&lt;&lt;&quot;Finished SuperIso_prediction_BDtaunu&quot;&lt;&lt;endl;
    }


    void SuperIso_prediction_BDmunu(double &amp;result)
    {
      using namespace Pipes::SuperIso_prediction_BDmunu;
      if (flav_debug) cout&lt;&lt;&quot;Starting SuperIso_prediction_BDmunu&quot;&lt;&lt;endl;

      parameters const&amp; param = *Dep::SuperIso_modelinfo;
      if (param.model &lt; 0) FlavBit_error().raise(LOCAL_INFO, &quot;Unsupported model.&quot;);

      double q2_min_mu_D=  0.012; // 0.105*0.105
      double q2_max_mu_D=  11.6;   // (5.28-1.869)**2
      int gen_mu_D        =2;
      int charge_mu_D     =0;// D* is the charged version
      double obs_mu_D[3];

      result= BEreq::BRBDlnu(byVal(gen_mu_D), byVal( charge_mu_D), byVal(q2_min_mu_D), byVal(q2_max_mu_D), byVal(obs_mu_D), &amp;param);

      if (flav_debug) printf(&quot;BR(B-&gt;D mu nu)=%.3e\n&quot;,result);
      if (flav_debug) cout&lt;&lt;&quot;Finished SuperIso_prediction_BDmunu&quot;&lt;&lt;endl;
    }


    void SuperIso_prediction_BDstartaunu(double &amp;result)
    {
      using namespace Pipes::SuperIso_prediction_BDstartaunu;
      if (flav_debug) cout&lt;&lt;&quot;Starting SuperIso_prediction_BDstartaunu&quot;&lt;&lt;endl;

      parameters const&amp; param = *Dep::SuperIso_modelinfo;
      if (param.model &lt; 0) FlavBit_error().raise(LOCAL_INFO, &quot;Unsupported model.&quot;);

      double q2_min_tau_Dstar = 3.16; // 1.776**2
      double q2_max_tau_Dstar = 10.67;   //(5.279-2.01027)*(5.279-2.01027);
      int gen_tau_Dstar        =3;
      int charge_tau_Dstar     =1;// D* is the charged version
      double obs_tau_Dstar[4];

      result= BEreq::BRBDstarlnu(byVal(gen_tau_Dstar), byVal( charge_tau_Dstar), byVal(q2_min_tau_Dstar), byVal(q2_max_tau_Dstar), byVal(obs_tau_Dstar), &amp;param);

      if (flav_debug) printf(&quot;BR(B-&gt;Dstar tau nu)=%.3e\n&quot;,result);
      if (flav_debug) cout&lt;&lt;&quot;Finished SuperIso_prediction_BDstartaunu&quot;&lt;&lt;endl;
    }


    void SuperIso_prediction_BDstarmunu(double &amp;result)
    {
      using namespace Pipes::SuperIso_prediction_BDstarmunu;
      if (flav_debug) cout&lt;&lt;&quot;Starting SuperIso_prediction_BDstarmunu&quot;&lt;&lt;endl;

      parameters const&amp; param = *Dep::SuperIso_modelinfo;
      if (param.model &lt; 0) FlavBit_error().raise(LOCAL_INFO, &quot;Unsupported model.&quot;);

      double q2_min_mu_Dstar = 0.012; // 0.105*0.105
      double q2_max_mu_Dstar = 10.67;   //(5.279-2.01027)*(5.279-2.01027);
      int gen_mu_Dstar        =2;
      int charge_mu_Dstar     =1;// D* is the charged version
      double obs_mu_Dstar[4];

      result=BEreq::BRBDstarlnu(byVal(gen_mu_Dstar), byVal( charge_mu_Dstar), byVal(q2_min_mu_Dstar), byVal(q2_max_mu_Dstar), byVal(obs_mu_Dstar), &amp;param);

      if (flav_debug) printf(&quot;BR(B-&gt;Dstar mu nu)=%.3e\n&quot;,result);
      if (flav_debug) cout&lt;&lt;&quot;Finished SuperIso_prediction_BDstarmunu&quot;&lt;&lt;endl;
    }


    void SuperIso_prediction_RD(double &amp;result)
    {
      using namespace Pipes::SuperIso_prediction_RD;
      if (flav_debug) cout&lt;&lt;&quot;Starting SuperIso_prediction_RD&quot;&lt;&lt;endl;

      parameters const&amp; param = *Dep::SuperIso_modelinfo;
      result = BEreq::BDtaunu_BDenu(&amp;param);

      if (flav_debug) printf(&quot;BR(B-&gt;D tau nu)/BR(B-&gt;D e nu)=%.3e\n&quot;,result);
      if (flav_debug) cout&lt;&lt;&quot;Finished SuperIso_prediction_RD&quot;&lt;&lt;endl;
    }


    void SuperIso_prediction_RDstar(double &amp;result)
    {
      using namespace Pipes::SuperIso_prediction_RDstar;
      if (flav_debug) cout&lt;&lt;&quot;Starting SuperIso_prediction_RDstar&quot;&lt;&lt;endl;

      parameters const&amp; param = *Dep::SuperIso_modelinfo;
      result = BEreq::BDstartaunu_BDstarenu(&amp;param);

      if (flav_debug) printf(&quot;BR(B-&gt;D* tau nu)/BR(B-&gt;D* e nu)=%.3e\n&quot;,result);
      if (flav_debug) cout&lt;&lt;&quot;Finished SuperIso_prediction_RD*&quot;&lt;&lt;endl;
    }


    void SuperIso_prediction_Rmu(double &amp;result)
    {
      using namespace Pipes::SuperIso_prediction_Rmu;
      if (flav_debug) cout&lt;&lt;&quot;Starting SuperIso_prediction_Rmu&quot;&lt;&lt;endl;

      parameters const&amp; param = *Dep::SuperIso_modelinfo;
      result = BEreq::Kmunu_pimunu(&amp;param);

      if (flav_debug) printf(&quot;R_mu=BR(K-&gt;mu nu)/BR(pi-&gt;mu nu)=%.3e\n&quot;,result);
      if (flav_debug) cout&lt;&lt;&quot;Finished SuperIso_prediction_Rmu&quot;&lt;&lt;endl;
    }


    void SuperIso_prediction_Rmu23(double &amp;result)
    {
      using namespace Pipes::SuperIso_prediction_Rmu23;
      if (flav_debug) cout&lt;&lt;&quot;Starting SuperIso_prediction_Rmu23&quot;&lt;&lt;endl;

      parameters const&amp; param = *Dep::SuperIso_modelinfo;
      result = BEreq::Rmu23(&amp;param);

      if (flav_debug) printf(&quot;Rmu23=%.3e\n&quot;,result);
      if (flav_debug) cout&lt;&lt;&quot;Finished SuperIso_prediction_Rmu23&quot;&lt;&lt;endl;
    }


    void SuperIso_prediction_delta0(double &amp;result)
    {
      using namespace Pipes::SuperIso_prediction_delta0;
      if (flav_debug) cout&lt;&lt;&quot;Starting SuperIso_prediction_delta0&quot;&lt;&lt;endl;

      parameters const&amp; param = *Dep::SuperIso_modelinfo;
      result=BEreq::modified_delta0(&amp;param);

      if (flav_debug) printf(&quot;Delta0(B-&gt;K* gamma)=%.3e\n&quot;,result);
      if (flav_debug) cout&lt;&lt;&quot;Finished SuperIso_prediction_delta0&quot;&lt;&lt;endl;
    }


    void SuperIso_prediction_A_BXsmumu_zero(double &amp;result)
    {
      using namespace Pipes::SuperIso_prediction_A_BXsmumu_zero;
      if (flav_debug) cout&lt;&lt;&quot;Starting SuperIso_prediction_A_BXsmumu_zero&quot;&lt;&lt;endl;

      parameters const&amp; param = *Dep::SuperIso_modelinfo;
      result=BEreq::A_BXsmumu_zero(&amp;param);

      if (flav_debug) printf(&quot;AFB(B-&gt;Xs mu mu)_zero=%.3e\n&quot;,result);
      if (flav_debug) cout&lt;&lt;&quot;Finished SuperIso_prediction_A_BXsmumu_zero&quot;&lt;&lt;endl;
    }


    void SuperIso_prediction_BRBXstautau_highq2(double &amp;result)
    {
      using namespace Pipes::SuperIso_prediction_BRBXstautau_highq2;
      if (flav_debug) cout&lt;&lt;&quot;Starting SuperIso_prediction_BRBXstautau_highq2&quot;&lt;&lt;endl;

      parameters const&amp; param = *Dep::SuperIso_modelinfo;
      result=BEreq::BRBXstautau_highq2(&amp;param);

      if (flav_debug) printf(&quot;BR(B-&gt;Xs tau tau)_highq2=%.3e\n&quot;,result);
      if (flav_debug) cout&lt;&lt;&quot;Finished SuperIso_prediction_BRBXstautau_highq2&quot;&lt;&lt;endl;
    }


    void SuperIso_prediction_A_BXstautau_highq2(double &amp;result)
    {
      using namespace Pipes::SuperIso_prediction_A_BXstautau_highq2;
      if (flav_debug) cout&lt;&lt;&quot;Starting SuperIso_prediction_A_BXstautau_highq2&quot;&lt;&lt;endl;

      parameters const&amp; param = *Dep::SuperIso_modelinfo;
      result=BEreq::A_BXstautau_highq2(&amp;param);

      if (flav_debug) printf(&quot;AFB(B-&gt;Xs tau tau)_highq2=%.3e\n&quot;,result);
      if (flav_debug) cout&lt;&lt;&quot;Finished SuperIso_prediction_A_BXstautau_highq2&quot;&lt;&lt;endl;
    }

    // RK* for RHN, using same approximations as RK, low q^2
    void RHN_RKstar_0045_11(double &amp;result)
    {
      using namespace Pipes::RHN_RKstar_0045_11;
      SMInputs sminputs = *Dep::SMINPUTS;
      Eigen::Matrix3cd Theta = *Dep::SeesawI_Theta;
      std::vector&lt;double&gt; mN = {*Param[&quot;M_1&quot;],*Param[&quot;M_2&quot;],*Param[&quot;M_3&quot;]};
      double mt = *Param[&quot;mT&quot;];

      if (flav_debug) cout &lt;&lt; &quot;Starting RHN_RKstar_0045_11&quot; &lt;&lt; endl;

      const double mW = sminputs.mW;
      const double sinW2 = sqrt(1.0 - pow(sminputs.mW/sminputs.mZ,2));

      // NNLL calculation of SM Wilson coefficients from 1712.01593 and 0811.1214
      const double C10_SM = -4.103;
      const double C9_SM = 4.211;

      // Wilson coefficients for the RHN model, from 1706.07570
      std::complex&lt;double&gt; C10_mu = {0.0, 0.0}, C10_e = {0.0, 0.0};
      for(int i=0; i&lt;3; i++)
      {
        C10_mu += 1.0/(4.0*sinW2)*Theta.adjoint()(i,1)*Theta(1,i) * LoopFunctions::E(pow(mt/mW,2),pow(mN[i]/mW,2));
        C10_e += 1.0/(4.0*sinW2)*Theta.adjoint()(i,0)*Theta(0,i) * LoopFunctions::E(pow(mt/mW,2),pow(mN[i]/mW,2));
      }
      std::complex&lt;double&gt; C9_mu = - C10_mu, C9_e = -C10_e;

      // Aproximated solution from eq A.3 in 1408.4097
      result =  std::norm(C10_SM + C10_mu) + std::norm(C9_SM + C9_mu);
      result /= std::norm(C10_SM + C10_e) + std::norm(C9_SM + C9_e);

      if (flav_debug) cout &lt;&lt; &quot;RK = &quot; &lt;&lt; result &lt;&lt; endl;
      if (flav_debug) cout &lt;&lt; &quot;Finished RHN_RKstar_0045_11&quot; &lt;&lt; endl;

    }

    // RK* for RHN, using same approximations as RK, intermediate q^2
    void RHN_RKstar_11_60(double &amp;result)
    {
      using namespace Pipes::RHN_RKstar_11_60;
      SMInputs sminputs = *Dep::SMINPUTS;
      Eigen::Matrix3cd Theta = *Dep::SeesawI_Theta;
      std::vector&lt;double&gt; mN = {*Param[&quot;M_1&quot;],*Param[&quot;M_2&quot;],*Param[&quot;M_3&quot;]};
      double mt = *Param[&quot;mT&quot;];

      if (flav_debug) cout &lt;&lt; &quot;Starting RHN_RKstar_11_60&quot; &lt;&lt; endl;

      const double mW = sminputs.mW;
      const double sinW2 = sqrt(1.0 - pow(sminputs.mW/sminputs.mZ,2));

      // NNLL calculation of SM Wilson coefficients from 1712.01593 and 0811.1214
      const double C10_SM = -4.103;
      const double C9_SM = 4.211;

      // Wilson coefficients for the RHN model, from 1706.07570
      std::complex&lt;double&gt; C10_mu = {0.0, 0.0}, C10_e = {0.0, 0.0};
      for(int i=0; i&lt;3; i++)
      {
        C10_mu += 1.0/(4.0*sinW2)*Theta.adjoint()(i,1)*Theta(1,i) * LoopFunctions::E(pow(mt/mW,2),pow(mN[i]/mW,2));
        C10_e += 1.0/(4.0*sinW2)*Theta.adjoint()(i,0)*Theta(0,i) * LoopFunctions::E(pow(mt/mW,2),pow(mN[i]/mW,2));
      }
      std::complex&lt;double&gt; C9_mu = - C10_mu, C9_e = -C10_e;

      // Aproximated solution from eq A.3 in 1408.4097
      result =  std::norm(C10_SM + C10_mu) + std::norm(C9_SM + C9_mu);
      result /= std::norm(C10_SM + C10_e) + std::norm(C9_SM + C9_e);

      if (flav_debug) cout &lt;&lt; &quot;RK = &quot; &lt;&lt; result &lt;&lt; endl;
      if (flav_debug) cout &lt;&lt; &quot;Finished RHN_RKstar_11_60&quot; &lt;&lt; endl;

    }

    void RHN_RK(double &amp;result)
    {
      using namespace Pipes::RHN_RK;
      SMInputs sminputs = *Dep::SMINPUTS;
      Eigen::Matrix3cd Theta = *Dep::SeesawI_Theta;
      std::vector&lt;double&gt; mN = {*Param[&quot;M_1&quot;],*Param[&quot;M_2&quot;],*Param[&quot;M_3&quot;]};
      double mt = *Param[&quot;mT&quot;];

      if (flav_debug) cout &lt;&lt; &quot;Starting RHN_RK&quot; &lt;&lt; endl;

      const double mW = sminputs.mW;
      const double sinW2 = sqrt(1.0 - pow(sminputs.mW/sminputs.mZ,2));

      // NNLL calculation of SM Wilson coefficients from 1712.01593 and 0811.1214
      const double C10_SM = -4.103;
      const double C9_SM = 4.211;

      // Wilson coefficients for the RHN model, from 1706.07570
      std::complex&lt;double&gt; C10_mu = {0.0, 0.0}, C10_e = {0.0, 0.0};
      for(int i=0; i&lt;3; i++)
      {
        C10_mu += 1.0/(4.0*sinW2)*Theta.adjoint()(i,1)*Theta(1,i) * LoopFunctions::E(pow(mt/mW,2),pow(mN[i]/mW,2));
        C10_e += 1.0/(4.0*sinW2)*Theta.adjoint()(i,0)*Theta(0,i) * LoopFunctions::E(pow(mt/mW,2),pow(mN[i]/mW,2));
      }
      std::complex&lt;double&gt; C9_mu = - C10_mu, C9_e = -C10_e;

      // Aproximated solution from eq A.3 in 1408.4097
      result =  std::norm(C10_SM + C10_mu) + std::norm(C9_SM + C9_mu);
      result /= std::norm(C10_SM + C10_e) + std::norm(C9_SM + C9_e);

      if (flav_debug) cout &lt;&lt; &quot;RK = &quot; &lt;&lt; result &lt;&lt; endl;
      if (flav_debug) cout &lt;&lt; &quot;Finished RHN_RK&quot; &lt;&lt; endl;
    }

    void SuperIso_prediction_AI_BKstarmumu(double &amp;result)
    {
      using namespace Pipes::SuperIso_prediction_AI_BKstarmumu;
      if (flav_debug) cout&lt;&lt;&quot;Starting SuperIso_prediction_AI_BKstarmumu&quot;&lt;&lt;endl;

      parameters const&amp; param = *Dep::SuperIso_modelinfo;
      result=BEreq::modified_AI_BKstarmumu(&amp;param);

      if (flav_debug) printf(&quot;A_I(B-&gt;K* mu mu)_lowq2=%.3e\n&quot;,result);
      if (flav_debug) cout&lt;&lt;&quot;Finished SuperIso_prediction_AI_BKstarmumu&quot;&lt;&lt;endl;
    }


    void SuperIso_prediction_AI_BKstarmumu_zero(double &amp;result)
    {
      using namespace Pipes::SuperIso_prediction_AI_BKstarmumu_zero;

      if (flav_debug) cout&lt;&lt;&quot;Starting SuperIso_prediction_AI_BKstarmumu_zero&quot;&lt;&lt;endl;

      parameters const&amp; param = *Dep::SuperIso_modelinfo;
      result=BEreq::modified_AI_BKstarmumu_zero(&amp;param);

      if (flav_debug) printf(&quot;A_I(B-&gt;K* mu mu)_zero=%.3e\n&quot;,result);
      if (flav_debug) cout&lt;&lt;&quot;Finished SuperIso_prediction_AI_BKstarmumu_zero&quot;&lt;&lt;endl;
    }


    void FeynHiggs_FlavourObs(fh_FlavourObs_container &amp;result)
    {
      using namespace Pipes::FeynHiggs_FlavourObs;

      if (flav_debug) cout&lt;&lt;&quot;Starting FeynHiggs_FlavourObs&quot;&lt;&lt;endl;

      fh_real bsgMSSM;     // B -&gt; Xs gamma in MSSM
      fh_real bsgSM;       // B -&gt; Xs gamma in SM
      fh_real deltaMsMSSM; // delta Ms in MSSM
      fh_real deltaMsSM;   // delta Ms in SM
      fh_real bsmumuMSSM;  // Bs -&gt; mu mu in MSSM
      fh_real bsmumuSM;    // Bs -&gt; mu mu in SM

      int error = 1;
      BEreq::FHFlavour(error, bsgMSSM, bsgSM,
           deltaMsMSSM, deltaMsSM,
           bsmumuMSSM, bsmumuSM);

      fh_FlavourObs_container FlavourObs;
      FlavourObs.Bsg_MSSM = bsgMSSM;
      FlavourObs.Bsg_SM = bsgSM;
      FlavourObs.deltaMs_MSSM = deltaMsMSSM;
      FlavourObs.deltaMs_SM = deltaMsSM;
      FlavourObs.Bsmumu_MSSM = bsmumuMSSM;
      FlavourObs.Bsmumu_SM = bsmumuSM;

      result = FlavourObs;
      if (flav_debug) cout&lt;&lt;&quot;Finished FeynHiggs_FlavourObs&quot;&lt;&lt;endl;
    }


    void FeynHiggs_prediction_bsgamma(double &amp;result)
    {
      result = Pipes::FeynHiggs_prediction_bsgamma::Dep::FlavourObs-&gt;Bsg_MSSM;
    }
    void FeynHiggs_prediction_Bsmumu (double &amp;result)
    {
      result = Pipes::FeynHiggs_prediction_Bsmumu::Dep::FlavourObs-&gt;Bsmumu_MSSM;
    }
    void FeynHiggs_prediction_DeltaMs(double &amp;result)
    {
      result = Pipes::FeynHiggs_prediction_DeltaMs::Dep::FlavourObs-&gt;deltaMs_MSSM;
    }

    void deltaMB_likelihood(double &amp;result)
    {
      using namespace Pipes::deltaMB_likelihood;
      static bool th_err_absolute, first = true;
      static double exp_meas, exp_DeltaMs_err, th_err;

      if (flav_debug) cout &lt;&lt; &quot;Starting Delta_Ms_likelihood&quot;&lt;&lt;endl;

      if (first)
      {
        Flav_reader fread(GAMBIT_DIR  &quot;/FlavBit/data&quot;);
        fread.debug_mode(flav_debug);
        if (flav_debug) cout&lt;&lt;&quot;Initialised Flav reader in Delta_Ms_likelihood&quot;&lt;&lt;endl;
        fread.read_yaml_measurement(&quot;flav_data.yaml&quot;, &quot;DeltaMs&quot;);
        fread.initialise_matrices(); // here we have a single measurement ;) so let's be sneaky:
        exp_meas = fread.get_exp_value()(0,0);
        exp_DeltaMs_err = sqrt(fread.get_exp_cov()(0,0));
        th_err = fread.get_th_err()(0,0).first;
        th_err_absolute = fread.get_th_err()(0,0).second;
        first = false;
      }

      if (flav_debug) cout &lt;&lt; &quot;Experiment: &quot; &lt;&lt; exp_meas &lt;&lt; &quot; &quot; &lt;&lt; exp_DeltaMs_err &lt;&lt; &quot; &quot; &lt;&lt; th_err &lt;&lt; endl;

      // Now we do the stuff that actually depends on the parameters
      double theory_prediction = *Dep::prediction_DeltaMs;
      double theory_DeltaMs_err = th_err * (th_err_absolute ? 1.0 : std::abs(theory_prediction));
      if (flav_debug) cout&lt;&lt;&quot;Theory prediction: &quot;&lt;&lt;theory_prediction&lt;&lt;&quot; +/- &quot;&lt;&lt;theory_DeltaMs_err&lt;&lt;endl;

      bool profile = runOptions-&gt;getValueOrDef&lt;bool&gt;(false, &quot;profile_systematics&quot;);

      result = Stats::gaussian_loglikelihood(theory_prediction, exp_meas, theory_DeltaMs_err, exp_DeltaMs_err, profile);
    }

    void SL_measurements(predictions_measurements_covariances &amp;pmc)
    {
      using namespace Pipes::SL_measurements;

      const int n_experiments=8;
      static bool th_err_absolute[n_experiments], first = true;
      static double th_err[n_experiments];

      if (flav_debug) cout&lt;&lt;&quot;Starting SL_measurements&quot;&lt;&lt;endl;

      // Read and calculate things based on the observed data only the first time through, as none of it depends on the model parameters.
      if (first)
      {
        pmc.LL_name=&quot;SL_likelihood&quot;;

        // Read in experimental measuremens
        Flav_reader fread(GAMBIT_DIR  &quot;/FlavBit/data&quot;);
        fread.debug_mode(flav_debug);
        if (flav_debug) cout&lt;&lt;&quot;Initialised Flav reader in SL_measurements&quot;&lt;&lt;endl;

        // B-&gt; tau nu
        fread.read_yaml_measurement(&quot;flav_data.yaml&quot;, &quot;BR_Btaunu&quot;);
        // B-&gt; D mu nu
        fread.read_yaml_measurement(&quot;flav_data.yaml&quot;, &quot;BR_BDmunu&quot;);
        // B-&gt; D* mu nu
        fread.read_yaml_measurement(&quot;flav_data.yaml&quot;, &quot;BR_BDstarmunu&quot;);
        // RD
        fread.read_yaml_measurement(&quot;flav_data.yaml&quot;, &quot;RD&quot;);
        // RDstar
        fread.read_yaml_measurement(&quot;flav_data.yaml&quot;, &quot;RDstar&quot;);
        // Ds-&gt; tau nu
        fread.read_yaml_measurement(&quot;flav_data.yaml&quot;, &quot;BR_Dstaunu&quot;);
        // Ds -&gt; mu nu
        fread.read_yaml_measurement(&quot;flav_data.yaml&quot;, &quot;BR_Dsmunu&quot;);
        // D -&gt; mu nu
        fread.read_yaml_measurement(&quot;flav_data.yaml&quot;, &quot;BR_Dmunu&quot;);

        fread.initialise_matrices();
        pmc.cov_exp=fread.get_exp_cov();
        pmc.value_exp=fread.get_exp_value();

        pmc.value_th.resize(n_experiments,1);
        // Set all entries in the covariance matrix explicitly to zero, as we will only write the diagonal ones later.
        pmc.cov_th = boost::numeric::ublas::zero_matrix&lt;double&gt;(n_experiments,n_experiments);
        for (int i = 0; i &lt; n_experiments; ++i)
        {
          th_err[i] = fread.get_th_err()(i,0).first;
          th_err_absolute[i] = fread.get_th_err()(i,0).second;
        }

        pmc.dim=n_experiments;

        // Init over.
        first = false;
      }

      // R(D) is calculated assuming isospin symmetry
      double theory[8];
      // B-&gt; tau nu SI
      theory[0] = *Dep::Btaunu;
      // B-&gt; D mu nu
      theory[1] = *Dep::BDmunu;
      // B-&gt; D* mu nu
      theory[2] = *Dep::BDstarmunu;
      // RD
      theory[3] = *Dep::RD;
      // RDstar
      theory[4] = *Dep::RDstar;
      // Ds-&gt; tau nu
      theory[5] = *Dep::Dstaunu;
      // Ds -&gt; mu nu
      theory[6] = *Dep::Dsmunu;
      // D -&gt; mu nu
      theory[7] =*Dep::Dmunu;

      for (int i = 0; i &lt; n_experiments; ++i)
      {
        pmc.value_th(i,0) = theory[i];
        pmc.cov_th(i,i) = th_err[i]*th_err[i] * (th_err_absolute[i] ? 1.0 : theory[i]*theory[i]);
      }
      // Add in the correlations between B-&gt; D mu nu and RD
      pmc.cov_th(1,3) = pmc.cov_th(3,1) = -0.55 * th_err[1]*th_err[3] * (th_err_absolute[1] ? 1.0 : theory[1]) * (th_err_absolute[3] ? 1.0 : theory[3]);
      // Add in the correlations between B-&gt; D* mu nu and RD*
      pmc.cov_th(2,4) = pmc.cov_th(4,2) = -0.62 * th_err[2]*th_err[4] * (th_err_absolute[2] ? 1.0 : theory[2]) * (th_err_absolute[4] ? 1.0 : theory[4]);

      pmc.diff.clear();
      for (int i=0;i&lt;n_experiments;++i)
      {
        pmc.diff.push_back(pmc.value_exp(i,0)-pmc.value_th(i,0));
      }

      if (flav_debug) cout&lt;&lt;&quot;Finished SL_measurements&quot;&lt;&lt;endl;

    }


    void SL_likelihood(double &amp;result)
    {
      using namespace Pipes::SL_likelihood;

      if (flav_debug) cout&lt;&lt;&quot;Starting SL_likelihood&quot;&lt;&lt;endl;

      predictions_measurements_covariances pmc = *Dep::SL_M;

      boost::numeric::ublas::matrix&lt;double&gt; cov=pmc.cov_exp;

      // adding theory and experimental covariance
      cov+=pmc.cov_th;

      //calculating a diff
      vector&lt;double&gt; diff;
      diff=pmc.diff;

      boost::numeric::ublas::matrix&lt;double&gt; cov_inv(pmc.dim, pmc.dim);
      InvertMatrix(cov, cov_inv);

      double Chi2=0;
      for (int i=0; i &lt; pmc.dim; ++i)
      {
        for (int j=0; j&lt;pmc.dim; ++j)
        {
          Chi2+= diff[i] * cov_inv(i,j)*diff[j];
        }
      }

      result=-0.5*Chi2;

      if (flav_debug) cout&lt;&lt;&quot;Finished SL_likelihood&quot;&lt;&lt;endl;

      if (flav_debug_LL) cout&lt;&lt;&quot;Likelihood result SL_likelihood  : &quot;&lt;&lt; result&lt;&lt;endl;

    }

    // Helper function
    double G(const double x)
    {
      if(x)
        return (10.0 - 43.0*x + 78.0*pow(x,2) - 49.0*pow(x,3) + 4.0*pow(x,4) + 18.0*pow(x,3)*log(x)) / (3.0*pow(x - 1,4));
      else
        return 10.0/3;
    }

    // Contribution to mu -&gt; e gamma from RHNs
    void RHN_muegamma(double &amp;result)
    {
      using namespace Pipes::RHN_muegamma;
      SMInputs sminputs = *Dep::SMINPUTS;

      Eigen::Matrix3cd m_nu = *Dep::m_nu;
      vector&lt;double&gt; ml = {sminputs.mE, sminputs.mMu, sminputs.mTau};
      vector&lt;double&gt; mnu = {real(m_nu(0,0)), real(m_nu(1,1)), real(m_nu(2,2)), *Param[&quot;M_1&quot;], *Param[&quot;M_2&quot;], *Param[&quot;M_3&quot;]};

      Eigen::Matrix3cd Theta = *Dep::SeesawI_Theta;
      Eigen::Matrix3cd Vnu = *Dep::SeesawI_Vnu;
      Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U;

      for(int i=0; i&lt;3; i++)
        for(int j=0; j&lt;3; j++)
        {
          U(i,j) = Vnu(i,j);
          U(i,j+3) = Theta(i,j);
        }

      result = pow(sminputs.mMu,5)/(4 * sminputs.alphainv);

      // Form factors
      int e = 0, mu = 1;
      complex&lt;double&gt; k2l = FormFactors::K2L(mu, e, sminputs, U, ml, mnu);
      complex&lt;double&gt; k2r = FormFactors::K2R(mu, e, sminputs, U, ml, mnu);

      result *= (norm(k2l) + norm(k2r));

      result /= Dep::mu_minus_decay_rates-&gt;width_in_GeV;

    }

    // Contribution to tau -&gt; e gamma from RHNs
    void RHN_tauegamma(double &amp;result)
    {
      using namespace Pipes::RHN_tauegamma;
      SMInputs sminputs = *Dep::SMINPUTS;

      Eigen::Matrix3cd m_nu = *Dep::m_nu;
      vector&lt;double&gt; ml = {sminputs.mE, sminputs.mMu, sminputs.mTau};
      vector&lt;double&gt; mnu = {real(m_nu(0,0)), real(m_nu(1,1)), real(m_nu(2,2)), *Param[&quot;M_1&quot;], *Param[&quot;M_2&quot;], *Param[&quot;M_3&quot;]};

      Eigen::Matrix3cd Theta = *Dep::SeesawI_Theta;
      Eigen::Matrix3cd Vnu = *Dep::SeesawI_Vnu;
      Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U;

      for(int i=0; i&lt;3; i++)
        for(int j=0; j&lt;3; j++)
        {
          U(i,j) = Vnu(i,j);
          U(i,j+3) = Theta(i,j);
        }

      result = pow(sminputs.mTau,5)/(4*sminputs.alphainv);

      // Form factors
      int e = 0, tau = 2;
      complex&lt;double&gt; k2l = FormFactors::K2L(tau, e, sminputs, U, ml, mnu);
      complex&lt;double&gt; k2r = FormFactors::K2R(tau, e, sminputs, U, ml, mnu);

      result *= (norm(k2l) + norm(k2r));

      result /= Dep::tau_minus_decay_rates-&gt;width_in_GeV;

    }

    // Contribution to tau -&gt; mu gamma from RHNs
    void RHN_taumugamma(double &amp;result)
    {
      using namespace Pipes::RHN_taumugamma;
      SMInputs sminputs = *Dep::SMINPUTS;

      Eigen::Matrix3cd m_nu = *Dep::m_nu;
      vector&lt;double&gt; ml = {sminputs.mE, sminputs.mMu, sminputs.mTau};
      vector&lt;double&gt; mnu = {real(m_nu(0,0)), real(m_nu(1,1)), real(m_nu(2,2)), *Param[&quot;M_1&quot;], *Param[&quot;M_2&quot;], *Param[&quot;M_3&quot;]};

      Eigen::Matrix3cd Theta = *Dep::SeesawI_Theta;
      Eigen::Matrix3cd Vnu = *Dep::SeesawI_Vnu;
      Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U;

      for(int i=0; i&lt;3; i++)
        for(int j=0; j&lt;3; j++)
        {
          U(i,j) = Vnu(i,j);
          U(i,j+3) = Theta(i,j);
        }

      result = pow(sminputs.mTau,5)/(4 * sminputs.alphainv);

      // Form factors
      int mu = 1, tau = 2;
      complex&lt;double&gt; k2l = FormFactors::K2L(tau, mu, sminputs, U, ml, mnu);
      complex&lt;double&gt; k2r = FormFactors::K2R(tau, mu, sminputs, U, ml, mnu);

      result *= (norm(k2l) + norm(k2r));

      result /= Dep::tau_minus_decay_rates-&gt;width_in_GeV;
    }

    // General contribution to l_\alpha^- -&gt; l_\beta^- l_\gamma^- l_\delta^+ from RHNs
    double RHN_l2lll(int alpha, int beta, int gamma, int delta, SMInputs sminputs, Eigen::Matrix3cd Vnu, Eigen::Matrix3cd Theta, Eigen::Matrix3cd m_nu, double M1, double M2, double M3, double mH)
    {
      vector&lt;double&gt; ml = {sminputs.mE, sminputs.mMu, sminputs.mTau};
      vector&lt;double&gt; mnu = {real(m_nu(0,0)), real(m_nu(1,1)), real(m_nu(2,2)), M1, M2, M3};

      Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U;

      for(int i=0; i&lt;3; i++)
        for(int j=0; j&lt;3; j++)
        {
          U(i,j) = Vnu(i,j);
          U(i,j+3) = Theta(i,j);
        }

      // Form factors
      complex&lt;double&gt; k2l = FormFactors::K2L(alpha, beta, sminputs, U, ml, mnu);
      complex&lt;double&gt; k2r = FormFactors::K2R(alpha, beta, sminputs, U, ml, mnu);
      complex&lt;double&gt; k1r = FormFactors::K1R(alpha, beta, sminputs, U, mnu);
      complex&lt;double&gt; asll = FormFactors::ASLL(alpha, beta, gamma, delta, sminputs, U, ml, mnu, mH);
      complex&lt;double&gt; aslr = FormFactors::ASLR(alpha, beta, gamma, delta, sminputs, U, ml, mnu, mH);
      complex&lt;double&gt; asrl = FormFactors::ASRL(alpha, beta, gamma, delta, sminputs, U, ml, mnu, mH);
      complex&lt;double&gt; asrr = FormFactors::ASRR(alpha, beta, gamma, delta, sminputs, U, ml, mnu, mH);
      complex&lt;double&gt; avll = FormFactors::AVLL(alpha, beta, gamma, delta, sminputs, U, ml, mnu);
      complex&lt;double&gt; avlr = FormFactors::AVLR(alpha, beta, gamma, delta, sminputs, U, ml, mnu);
      complex&lt;double&gt; avrl = FormFactors::AVLL(alpha, beta, gamma, delta, sminputs, U, ml, mnu);
      complex&lt;double&gt; avrr = FormFactors::AVRR(alpha, beta, gamma, delta, sminputs, U, ml, mnu);

      complex&lt;double&gt; avhatll = avll;
      complex&lt;double&gt; avhatlr = avlr;
      complex&lt;double&gt; avhatrl = avrl + 4. * pi / sminputs.alphainv * k1r;
      complex&lt;double&gt; avhatrr = avrr + 4. * pi / sminputs.alphainv * k1r;

      double l2lll = 0;
      if(beta == gamma and gamma == delta) // l(alpha)- -&gt; l(beta)- l(beta)- l(beta)+
      {
        l2lll = real(16. * pow(pi,2) / pow(sminputs.alphainv,2) * (norm(k2l) + norm(k2r)) * (16./3.*log(ml[alpha]/ml[beta]) - 22./3.) + 1./24. * (norm(asll) + norm(asrr) + 2.*norm(aslr) + 2.*norm(asrl)) + 1./3. * (2.*norm(avhatll) + 2.*norm(avhatrr) + norm(avhatlr) + norm(avhatrl)) + 4.*pi/(3.*sminputs.alphainv)*(k2l*conj(asrl - 2.*avhatrl - 4.*avhatrr) + conj(k2l)*(asrl - 2.*avhatrl - 4.*avhatrr) + k2r*conj(aslr - 2.*avhatlr - 4.*avhatll) + conj(k2r)*(aslr - 2.*avhatlr - 4.*avhatll)) - 1./6. * (aslr*conj(avhatlr) + asrl*conj(avhatrl) + conj(aslr)*avhatlr + conj(asrl)*avhatrl));
      }
      else if(gamma == delta) // l(alpha)- -&gt; l(beta)- l(gamma)- l(gamma)+
      {
        l2lll = real(16. *pow(pi,2) / pow(sminputs.alphainv,2) * (norm(k2l) + norm(k2r)) * (16./3.*log(ml[alpha]/ml[gamma]) - 8.) + 1./12. *(norm(asll) + norm(asrr) + norm(aslr) + norm(asrl)) + 1./3. * (norm(avhatll) + norm(avhatrr) + norm(avhatlr) + norm(avhatrl)) + 8.*pi/(3.*sminputs.alphainv) * (k2l*conj(avhatrl + avhatrr) + k2r*conj(avhatlr + avhatll) + conj(k2l)*(avhatrl + avhatrr) + conj(k2r)*(avhatlr + avhatll)));
      }
      else if(beta == gamma) // l(alpha)- -&gt; l(beta)- l(beta)- l(delta)+
      {
        l2lll = real(1./24. * (norm(asll) + norm(asrr) + 2.*norm(aslr) + 2.*norm(asrl)) + 1./3.*(2.*norm(avhatll) + 2.*norm(avhatrr) + norm(avhatlr) + norm(avhatrl)) - 1./6.*(aslr*conj(avhatlr) + asrl*conj(avhatrl) + conj(aslr)*avhatlr + conj(asrl)*avhatrl));
      }
      return l2lll;

    }

    // Contribution to mu -&gt; e e e from RHNs
    void RHN_mueee(double &amp;result)
    {
      using namespace Pipes::RHN_mueee;
      SMInputs sminputs = *Dep::SMINPUTS;

      Eigen::Matrix3cd m_nu = *Dep::m_nu;
      Eigen::Matrix3cd Theta = *Dep::SeesawI_Theta;
      Eigen::Matrix3cd Vnu = *Dep::SeesawI_Vnu;

      result = pow(sminputs.mMu,5)/(512*pow(pi,3));

      int e = 0, mu = 1;
      result *=  RHN_l2lll(mu, e, e, e, sminputs, Vnu, Theta, m_nu, *Param[&quot;M_1&quot;], *Param[&quot;M_2&quot;], *Param[&quot;M_3&quot;], *Param[&quot;mH&quot;]);

      result /= Dep::mu_minus_decay_rates-&gt;width_in_GeV;

    }

    // Contribution to tau -&gt; e e e from RHNs
    void RHN_taueee(double &amp;result)
    {
      using namespace Pipes::RHN_taueee;
      SMInputs sminputs = *Dep::SMINPUTS;

      Eigen::Matrix3cd m_nu = *Dep::m_nu;
      Eigen::Matrix3cd Theta = *Dep::SeesawI_Theta;
      Eigen::Matrix3cd Vnu = *Dep::SeesawI_Vnu;

      result = pow(sminputs.mTau,5)/(512*pow(pi,3));

      int e = 0, tau = 2;
      result *=  RHN_l2lll(tau, e, e, e, sminputs, Vnu, Theta, m_nu, *Param[&quot;M_1&quot;], *Param[&quot;M_2&quot;], *Param[&quot;M_3&quot;], *Param[&quot;mH&quot;]);

      result /= Dep::tau_minus_decay_rates-&gt;width_in_GeV;

    }

    // Contribution to tau -&gt; mu mu mu from RHNs
    void RHN_taumumumu(double &amp;result)
    {
      using namespace Pipes::RHN_taumumumu;
      SMInputs sminputs = *Dep::SMINPUTS;

      Eigen::Matrix3cd m_nu = *Dep::m_nu;
      Eigen::Matrix3cd Theta = *Dep::SeesawI_Theta;
      Eigen::Matrix3cd Vnu = *Dep::SeesawI_Vnu;

      result = pow(sminputs.mTau,5)/(512*pow(pi,3));

      int mu = 1, tau = 2;
      result *=  RHN_l2lll(tau, mu, mu, mu, sminputs, Vnu, Theta, m_nu, *Param[&quot;M_1&quot;], *Param[&quot;M_2&quot;], *Param[&quot;M_3&quot;], *Param[&quot;mH&quot;]);

      result /= Dep::tau_minus_decay_rates-&gt;width_in_GeV;

    }

    // Contribution to tau^- -&gt; mu^- e^- e^+ from RHNs
    void RHN_taumuee(double &amp;result)
    {
      using namespace Pipes::RHN_taumuee;
      SMInputs sminputs = *Dep::SMINPUTS;

      Eigen::Matrix3cd m_nu = *Dep::m_nu;
      Eigen::Matrix3cd Theta = *Dep::SeesawI_Theta;
      Eigen::Matrix3cd Vnu = *Dep::SeesawI_Vnu;

      result = pow(sminputs.mTau,5)/(512*pow(pi,3));

      int e = 0, mu = 1, tau = 2;
      result *=  RHN_l2lll(tau, mu, e, e, sminputs, Vnu, Theta, m_nu, *Param[&quot;M_1&quot;], *Param[&quot;M_2&quot;], *Param[&quot;M_3&quot;], *Param[&quot;mH&quot;]);

      result /= Dep::tau_minus_decay_rates-&gt;width_in_GeV;
    }

    // Contribution to tau^- -&gt; e^- e^- mu^+ from RHNs
    void RHN_taueemu(double &amp;result)
    {
      using namespace Pipes::RHN_taueemu;
      SMInputs sminputs = *Dep::SMINPUTS;

      Eigen::Matrix3cd m_nu = *Dep::m_nu;
      Eigen::Matrix3cd Theta = *Dep::SeesawI_Theta;
      Eigen::Matrix3cd Vnu = *Dep::SeesawI_Vnu;

      result = pow(sminputs.mTau,5)/(512*pow(pi,3));

      int e = 0, mu = 1, tau = 2;
      result *=  RHN_l2lll(tau, e, e, mu, sminputs, Vnu, Theta, m_nu, *Param[&quot;M_1&quot;], *Param[&quot;M_2&quot;], *Param[&quot;M_3&quot;], *Param[&quot;mH&quot;]);

      result /= Dep::tau_minus_decay_rates-&gt;width_in_GeV;
    }

    // Contribution to tau^- -&gt; e^- mu^- mu^+ from RHNs
    void RHN_tauemumu(double &amp;result)
    {
      using namespace Pipes::RHN_tauemumu;
      SMInputs sminputs = *Dep::SMINPUTS;

      Eigen::Matrix3cd m_nu = *Dep::m_nu;
      Eigen::Matrix3cd Theta = *Dep::SeesawI_Theta;
      Eigen::Matrix3cd Vnu = *Dep::SeesawI_Vnu;

      result = pow(sminputs.mTau,5)/(512*pow(pi,3));

      int e = 0, mu = 1, tau = 2;
      result *=  RHN_l2lll(tau, e, mu, mu, sminputs, Vnu, Theta, m_nu, *Param[&quot;M_1&quot;], *Param[&quot;M_2&quot;], *Param[&quot;M_3&quot;], *Param[&quot;mH&quot;]);

      result /= Dep::tau_minus_decay_rates-&gt;width_in_GeV;
    }

    // Contribution to tau^- -&gt; mu^- mu^- e^+ from RHNs
    void RHN_taumumue(double &amp;result)
    {
      using namespace Pipes::RHN_taumumue;
      SMInputs sminputs = *Dep::SMINPUTS;

      Eigen::Matrix3cd m_nu = *Dep::m_nu;
      Eigen::Matrix3cd Theta = *Dep::SeesawI_Theta;
      Eigen::Matrix3cd Vnu = *Dep::SeesawI_Vnu;

      result = pow(sminputs.mTau,5)/(512*pow(pi,3));

      int e = 0, mu = 1, tau = 2;
      result *=  RHN_l2lll(tau, mu, mu, e, sminputs, Vnu, Theta, m_nu, *Param[&quot;M_1&quot;], *Param[&quot;M_2&quot;], *Param[&quot;M_3&quot;], *Param[&quot;mH&quot;]);

      result /= Dep::tau_minus_decay_rates-&gt;width_in_GeV;
    }

    // Form factors for to mu - e conversion
    void RHN_mue_FF(const SMInputs sminputs, std::vector&lt;double&gt; &amp;mnu, Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; &amp;U, const double mH, complex&lt;double&gt; &amp;g0SL, complex&lt;double&gt; &amp;g0SR, complex&lt;double&gt; &amp;g0VL, complex&lt;double&gt; &amp;g0VR, complex&lt;double&gt; &amp;g1SL, complex&lt;double&gt; &amp;g1SR, complex&lt;double&gt; &amp;g1VL, complex&lt;double&gt; &amp;g1VR)
    {
      vector&lt;double&gt; ml = {sminputs.mE, sminputs.mMu, sminputs.mTau};

      int e = 0, mu = 1;
      complex&lt;double&gt; k1r = FormFactors::K1R(mu, e, sminputs, U, mnu);
      complex&lt;double&gt; k2l = FormFactors::K2L(mu, e, sminputs, U, ml, mnu);
      complex&lt;double&gt; k2r = FormFactors::K2R(mu, e, sminputs, U, ml, mnu);

      int u = 0, d =0, s = 1;
      complex&lt;double&gt; CVLLu = FormFactors::CVLL(mu, e, u, u, sminputs, U, ml, mnu);
      complex&lt;double&gt; CVLLd = FormFactors::BVLL(mu, e, d, d, sminputs, U, ml, mnu);
      complex&lt;double&gt; CVLLs = FormFactors::BVLL(mu, e, s, s, sminputs, U, ml, mnu);
      complex&lt;double&gt; CVLRu = FormFactors::CVLR(mu, e, u, u, sminputs, U, ml, mnu);
      complex&lt;double&gt; CVLRd = FormFactors::BVLR(mu, e, d, d, sminputs, U, ml, mnu);
      complex&lt;double&gt; CVLRs = FormFactors::BVLR(mu, e, s, s, sminputs, U, ml, mnu);
      complex&lt;double&gt; CVRLu = FormFactors::CVRL(mu, e, u, u, sminputs, U, ml, mnu);
      complex&lt;double&gt; CVRLd = FormFactors::BVRL(mu, e, d, d, sminputs, U, ml, mnu);
      complex&lt;double&gt; CVRLs = FormFactors::BVRL(mu, e, s, s, sminputs, U, ml, mnu);
      complex&lt;double&gt; CVRRu = FormFactors::CVRR(mu, e, u, u, sminputs, U, ml, mnu);
      complex&lt;double&gt; CVRRd = FormFactors::BVRR(mu, e, d, d, sminputs, U, ml, mnu);
      complex&lt;double&gt; CVRRs = FormFactors::BVRR(mu, e, s, s, sminputs, U, ml, mnu);

      complex&lt;double&gt; CSLLu = FormFactors::CSLL(mu, e, u, u, sminputs, U, ml, mnu, mH);
      complex&lt;double&gt; CSLLd = FormFactors::BSLL(mu, e, d, d, sminputs, U, ml, mnu, mH);
      complex&lt;double&gt; CSLLs = FormFactors::BSLL(mu, e, s, s, sminputs, U, ml, mnu, mH);
      complex&lt;double&gt; CSLRu = FormFactors::CSLL(mu, e, u, u, sminputs, U, ml, mnu, mH);
      complex&lt;double&gt; CSLRd = FormFactors::BSLL(mu, e, d, d, sminputs, U, ml, mnu, mH);
      complex&lt;double&gt; CSLRs = FormFactors::BSLL(mu, e, s, s, sminputs, U, ml, mnu, mH);
      complex&lt;double&gt; CSRLu = FormFactors::CSLL(mu, e, u, u, sminputs, U, ml ,mnu, mH);
      complex&lt;double&gt; CSRLd = FormFactors::BSLL(mu, e, d, d, sminputs, U, ml ,mnu, mH);
      complex&lt;double&gt; CSRLs = FormFactors::BSLL(mu, e, s, s, sminputs, U, ml ,mnu, mH);
      complex&lt;double&gt; CSRRu = FormFactors::CSLL(mu, e, u, u, sminputs, U, ml ,mnu, mH);
      complex&lt;double&gt; CSRRd = FormFactors::BSLL(mu, e, d, d, sminputs, U, ml, mnu, mH);
      complex&lt;double&gt; CSRRs = FormFactors::BSLL(mu, e, s, s, sminputs, U, ml ,mnu, mH);

      double Qu = 2./3.;
      complex&lt;double&gt; gVLu = sqrt(2)/sminputs.GF * (4.*pi / sminputs.alphainv * Qu * (0. - k2r) - 0.5*(CVLLu + CVLRu));
      complex&lt;double&gt; gSLu = -1./(sqrt(2)*sminputs.GF)*(CSLLu + CSLRu);
      complex&lt;double&gt; gVRu = sqrt(2)/sminputs.GF * (4.*pi / sminputs.alphainv * Qu * (k1r - k2l) - 0.5*(CVRRu + CVRLu));
      complex&lt;double&gt; gSRu = -1./(sqrt(2)*sminputs.GF)*(CSRRu + CSRLu);

      double Qd = -1./3.;
      complex&lt;double&gt; gVLd = sqrt(2)/sminputs.GF * (4.*pi / sminputs.alphainv * Qd * (0. - k2r) - 0.5*(CVLLd + CVLRd));
      complex&lt;double&gt; gSLd = -1./(sqrt(2)*sminputs.GF)*(CSLLd + CSLRd);
      complex&lt;double&gt; gVRd = sqrt(2)/sminputs.GF * (4.*pi / sminputs.alphainv * Qd * (k1r - k2l) - 0.5*(CVRRd + CVRLd));
      complex&lt;double&gt; gSRd = -1./(sqrt(2)*sminputs.GF)*(CSRRd + CSRLd);

      double Qs = -1./3.;
      complex&lt;double&gt; gVLs = sqrt(2)/sminputs.GF * (4.*pi / sminputs.alphainv * Qs * (0. - k2r) - 0.5*(CVLLs + CVLRs));
      complex&lt;double&gt; gSLs = -1./(sqrt(2)*sminputs.GF)*(CSLLs + CSLRs);
      complex&lt;double&gt; gVRs = sqrt(2)/sminputs.GF * (4.*pi / sminputs.alphainv * Qs * (k1r - k2l) - 0.5*(CVRRs + CVRLs));
      complex&lt;double&gt; gSRs = -1./(sqrt(2)*sminputs.GF)*(CSRRs + CSRLs);

      double GVup = 2, GVdn = 2, GVdp = 1, GVun = 1, GVsp = 0, GVsn = 0;
      double GSup = 5.1, GSdn = 5.1, GSdp = 4.3, GSun = 4.3, GSsp = 2.5, GSsn = 2.5;

      g0SL = 0.5*(gSLu*(GSup + GSun) + gSLd*(GSdp + GSdn) + gSLs*(GSsp + GSsn));
      g0SR = 0.5*(gSRu*(GSup + GSun) + gSRd*(GSdp + GSdn) + gSRs*(GSsp + GSsn));
      g0VL = 0.5*(gVLu*(GVup + GVun) + gVLd*(GVdp + GVdn) + gVLs*(GVsp + GVsn));
      g0VR = 0.5*(gVRu*(GVup + GVun) + gVRd*(GVdp + GVdn) + gVRs*(GVsp + GVsn));
      g1SL = 0.5*(gSLu*(GSup - GSun) + gSLd*(GSdp - GSdn) + gSLs*(GSsp - GSsn));
      g1SR = 0.5*(gSRu*(GSup - GSun) + gSRd*(GSdp - GSdn) + gSRs*(GSsp - GSsn));
      g1VL = 0.5*(gVLu*(GVup - GVun) + gVLd*(GVdp - GVdn) + gVLs*(GVsp - GVsn));
      g1VR = 0.5*(gVRu*(GVup - GVun) + gVRd*(GVdp - GVdn) + gVRs*(GVsp - GVsn));

    }

    // Contribution to mu - e conversion in Ti nuclei from RHNs
    void RHN_mueTi(double &amp;result)
    {
      using namespace Pipes::RHN_mueTi;
      const SMInputs sminputs = *Dep::SMINPUTS;
      Eigen::Matrix3cd m_nu = *Dep::m_nu;
      Eigen::Matrix3cd Vnu = *Dep::SeesawI_Vnu;
      Eigen::Matrix3cd Theta = *Dep::SeesawI_Theta;

      vector&lt;double&gt; mnu = {real(m_nu(0,0)), real(m_nu(1,1)), real(m_nu(2,2)), *Param[&quot;M_1&quot;], *Param[&quot;M_2&quot;], *Param[&quot;M_3&quot;]};
      Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U;

      for(int i=0; i&lt;3; i++)
        for(int j=0; j&lt;3; j++)
        {
          U(i,j) = Vnu(i,j);
          U(i,j+3) = Theta(i,j);
        }

      complex&lt;double&gt; g0SL, g0SR, g0VL, g0VR, g1SL, g1SR, g1VL, g1VR;
      RHN_mue_FF(sminputs, mnu, U, *Param[&quot;mH&quot;], g0SL, g0SR, g0VL, g0VR, g1SL, g1SR, g1VL, g1VR);

      // Parameters for Ti, from Table 1 in 1209.2679 for Ti
      double Z = 22, N = 26;
      double Zeff = 17.6, Fp = 0.54;
      double hbar = 6.582119514e-25; // GeV * s
      double GammaCapt = 2.59e6 * hbar;

      result = (pow(sminputs.GF,2)*pow(sminputs.mMu,5)*pow(Zeff,4)*pow(Fp,2)) / (8.*pow(pi,4)*pow(sminputs.alphainv,3)*Z*GammaCapt) * (norm((Z+N)*(g0VL + g0SL) + (Z-N)*(g1VL + g1SL)) + norm((Z+N)*(g0VR + g0SR) + (Z-N)*(g1VR + g1SR)));

    }

    // Contribution to mu - e conversion in Au nuclei from RHNs
    void RHN_mueAu(double &amp;result)
    {
      using namespace Pipes::RHN_mueAu;
      const SMInputs sminputs = *Dep::SMINPUTS;
      Eigen::Matrix3cd m_nu = *Dep::m_nu;
      Eigen::Matrix3cd Vnu = *Dep::SeesawI_Vnu;
      Eigen::Matrix3cd Theta = *Dep::SeesawI_Theta;

      vector&lt;double&gt; mnu = {real(m_nu(0,0)), real(m_nu(1,1)), real(m_nu(2,2)), *Param[&quot;M_1&quot;], *Param[&quot;M_2&quot;], *Param[&quot;M_3&quot;]};
      Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U;

      for(int i=0; i&lt;3; i++)
        for(int j=0; j&lt;3; j++)
        {
          U(i,j) = Vnu(i,j);
          U(i,j+3) = Theta(i,j);
        }

      complex&lt;double&gt; g0SL, g0SR, g0VL, g0VR, g1SL, g1SR, g1VL, g1VR;
      RHN_mue_FF(sminputs, mnu, U, *Param[&quot;mH&quot;], g0SL, g0SR, g0VL, g0VR, g1SL, g1SR, g1VL, g1VR);


      // Parameters for Au, from Table 1 in 1209.2679 for Au
      double Z = 79, N = 118;
      double Zeff = 33.5, Fp = 0.16;
      double hbar = 6.582119514e-25; // GeV * s
      double GammaCapt = 13.07e6 * hbar;

      result = (pow(sminputs.GF,2)*pow(sminputs.mMu,5)*pow(Zeff,4)*pow(Fp,2)) / (8.*pow(pi,4)*pow(sminputs.alphainv,3)*Z*GammaCapt) * (norm((Z+N)*(g0VL + g0SL) + (Z-N)*(g1VL + g1SL)) + norm((Z+N)*(g0VR + g0SR) + (Z-N)*(g1VR + g1SR)));

    }


    // Contribution to mu - e conversion in Pb nuclei from RHNs
    void RHN_muePb(double &amp;result)
    {
      using namespace Pipes::RHN_muePb;
      const SMInputs sminputs = *Dep::SMINPUTS;
      Eigen::Matrix3cd m_nu = *Dep::m_nu;
      Eigen::Matrix3cd Vnu = *Dep::SeesawI_Vnu;
      Eigen::Matrix3cd Theta = *Dep::SeesawI_Theta;

      vector&lt;double&gt; mnu = {real(m_nu(0,0)), real(m_nu(1,1)), real(m_nu(2,2)), *Param[&quot;M_1&quot;], *Param[&quot;M_2&quot;], *Param[&quot;M_3&quot;]};
      Eigen::Matrix&lt;complex&lt;double&gt;,3,6&gt; U;

      for(int i=0; i&lt;3; i++)
        for(int j=0; j&lt;3; j++)
        {
          U(i,j) = Vnu(i,j);
          U(i,j+3) = Theta(i,j);
        }

      complex&lt;double&gt; g0SL, g0SR, g0VL, g0VR, g1SL, g1SR, g1VL, g1VR;
      RHN_mue_FF(sminputs, mnu, U, *Param[&quot;mH&quot;], g0SL, g0SR, g0VL, g0VR, g1SL, g1SR, g1VL, g1VR);

      // Parameters for Pb, from Table 1 in 1209.2679 for Pb
      double Z = 82, N = 126;
      double Zeff = 34., Fp = 0.15;
      double hbar = 6.582119514e-25; // GeV * s
      double GammaCapt = 13.45e6 * hbar;

      result = (pow(sminputs.GF,2)*pow(sminputs.mMu,5)*pow(Zeff,4)*pow(Fp,2)) / (8.*pow(pi,4)*pow(sminputs.alphainv,3)*Z*GammaCapt) * (norm((Z+N)*(g0VL + g0SL) + (Z-N)*(g1VL + g1SL)) + norm((Z+N)*(g0VR + g0SR) + (Z-N)*(g1VR + g1SR)));
    }


    void l2lgamma_likelihood(double &amp;result)
    {
      using namespace Pipes::l2lgamma_likelihood;

      static bool first = true;
      static boost::numeric::ublas::matrix&lt;double&gt; cov_exp, value_exp;
      static double th_err[3];
      double theory[3];

      // Read and calculate things based on the observed data only the first time through, as none of it depends on the model parameters.
      if (first)
      {
        // Read in experimental measuremens
        Flav_reader fread(GAMBIT_DIR  &quot;/FlavBit/data&quot;);
        fread.debug_mode(flav_debug);

        // mu -&gt; e gamma
        fread.read_yaml_measurement(&quot;flav_data.yaml&quot;, &quot;BR_muegamma&quot;);
        // tau -&gt; e gamma
        fread.read_yaml_measurement(&quot;flav_data.yaml&quot;, &quot;BR_tauegamma&quot;);
        // tau -&gt; mu gamma
        fread.read_yaml_measurement(&quot;flav_data.yaml&quot;, &quot;BR_taumugamma&quot;);

        fread.initialise_matrices();
        cov_exp=fread.get_exp_cov();
        value_exp=fread.get_exp_value();

        for (int i = 0; i &lt; 3; ++i)
          th_err[i] = fread.get_th_err()(i,0).first;

        // Init over.
        first = false;
      }

     theory[0] = *Dep::muegamma;
     if(flav_debug) cout &lt;&lt; &quot;mu- -&gt; e- gamma = &quot; &lt;&lt; theory[0] &lt;&lt; endl;
     theory[1] = *Dep::tauegamma;
     if(flav_debug) cout &lt;&lt; &quot;tau- -&gt; e- gamma = &quot; &lt;&lt; theory[1] &lt;&lt; endl;
     theory[2] = *Dep::taumugamma;
     if(flav_debug) cout &lt;&lt; &quot;tau- -&gt; mu- gamma = &quot; &lt;&lt; theory[2] &lt;&lt; endl;

     result = 0;
     for (int i = 0; i &lt; 3; ++i)
       result += Stats::gaussian_upper_limit(theory[i], value_exp(i,0), th_err[i], sqrt(cov_exp(i,i)), false);

    }

    void l2lll_likelihood(double &amp;result)
    {
      using namespace Pipes::l2lll_likelihood;

      static bool first = true;
      static boost::numeric::ublas::matrix&lt;double&gt; cov_exp, value_exp;
      static double th_err[7];
      double theory[7];


      // Read and calculate things based on the observed data only the first time through, as none of it depends on the model parameters.
      if (first)
      {
        // Read in experimental measuremens
        Flav_reader fread(GAMBIT_DIR  &quot;/FlavBit/data&quot;);
        fread.debug_mode(flav_debug);

        // mu- -&gt; e- e- e+
        fread.read_yaml_measurement(&quot;flav_data.yaml&quot;, &quot;BR_mueee&quot;);
        // tau- -&gt; e- e- e+
        fread.read_yaml_measurement(&quot;flav_data.yaml&quot;, &quot;BR_taueee&quot;);
        // tau- -&gt; mu- mu- mu+
        fread.read_yaml_measurement(&quot;flav_data.yaml&quot;, &quot;BR_taumumumu&quot;);
        // tau- -&gt; mu- e- e+
        fread.read_yaml_measurement(&quot;flav_data.yaml&quot;, &quot;BR_taumuee&quot;);
        // tau- -&gt; e- e- mu+
        fread.read_yaml_measurement(&quot;flav_data.yaml&quot;, &quot;BR_taueemu&quot;);
        // tau- -&gt; e- mu- mu+
        fread.read_yaml_measurement(&quot;flav_data.yaml&quot;, &quot;BR_tauemumu&quot;);
        // tau- -&gt; mu- mu- e+
        fread.read_yaml_measurement(&quot;flav_data.yaml&quot;, &quot;BR_taumumue&quot;);

        fread.initialise_matrices();
        cov_exp=fread.get_exp_cov();
        value_exp=fread.get_exp_value();

        for (int i = 0; i &lt; 7; ++i)
          th_err[i] = fread.get_th_err()(i,0).first;

        // Init over.
        first = false;
      }

     theory[0] = *Dep::mueee;
     if(flav_debug) cout &lt;&lt; &quot;mu-  -&gt; e-  e-  e+  = &quot; &lt;&lt; theory[0] &lt;&lt; endl;
     theory[1] = *Dep::taueee;
     if(flav_debug) cout &lt;&lt; &quot;tau- -&gt; e-  e-  e+  = &quot; &lt;&lt; theory[1] &lt;&lt; endl;
     theory[2] = *Dep::taumumumu;
     if(flav_debug) cout &lt;&lt; &quot;tau- -&gt; mu- mu- mu+ = &quot; &lt;&lt; theory[2] &lt;&lt; endl;
     theory[3] = *Dep::taumuee;
     if(flav_debug) cout &lt;&lt; &quot;tau- -&gt; mu- e-  e-  = &quot; &lt;&lt; theory[3] &lt;&lt; endl;
     theory[4] = *Dep::taueemu;
     if(flav_debug) cout &lt;&lt; &quot;tau- -&gt; e-  e-  mu+ = &quot; &lt;&lt; theory[4] &lt;&lt; endl;
     theory[5] = *Dep::tauemumu;
     if(flav_debug) cout &lt;&lt; &quot;tau- -&gt; e-  mu- mu+ = &quot; &lt;&lt; theory[5] &lt;&lt; endl;
     theory[6] = *Dep::taumumue;
     if(flav_debug) cout &lt;&lt; &quot;tau- -&gt; mu- mu- e+  = &quot; &lt;&lt; theory[6] &lt;&lt; endl;

     result = 0;
     for (int i = 0; i &lt; 7; ++i)
       result += Stats::gaussian_upper_limit(theory[i], value_exp(i,0), th_err[i], sqrt(cov_exp(i,i)), false);

    }

    void mu2e_likelihood(double &amp;result)
    {
      using namespace Pipes::mu2e_likelihood;

      static bool first = true;
      static boost::numeric::ublas::matrix&lt;double&gt; cov_exp, value_exp;
      static int n_measurements = 3;
      static double th_err[3];
      double theory[3];


      // Read and calculate things based on the observed data only the first time through, as none of it depends on the model parameters.
      if (first)
      {
        // Read in experimental measuremens
        Flav_reader fread(GAMBIT_DIR  &quot;/FlavBit/data&quot;);
        fread.debug_mode(flav_debug);

        // mu - e (Ti)
        fread.read_yaml_measurement(&quot;flav_data.yaml&quot;, &quot;R_mueTi&quot;);
        // mu - e (Au)
        fread.read_yaml_measurement(&quot;flav_data.yaml&quot;, &quot;R_mueAu&quot;);
        // mu - e (Pb)
        fread.read_yaml_measurement(&quot;flav_data.yaml&quot;, &quot;R_muePb&quot;);

        fread.initialise_matrices();
        cov_exp=fread.get_exp_cov();
        value_exp=fread.get_exp_value();

        for (int i = 0; i &lt; n_measurements; ++i)
          th_err[i] = fread.get_th_err()(i,0).first;

        // Init over.
        first = false;
      }

      theory[0] = *Dep::mueTi;
      if(flav_debug) cout &lt;&lt; &quot;mu - e (Ti) = &quot; &lt;&lt; theory[0] &lt;&lt; endl;
      theory[1] = *Dep::mueAu;
      if(flav_debug) cout &lt;&lt; &quot;mu - e (Au) = &quot; &lt;&lt; theory[1] &lt;&lt; endl;
      theory[2] = *Dep::muePb;
      if(flav_debug) cout &lt;&lt; &quot;mu - e (Pb) = &quot; &lt;&lt; theory[2] &lt;&lt; endl;

      result = 0;
      for (int i = 0; i &lt; n_measurements; ++i)
        result += Stats::gaussian_upper_limit(theory[i], value_exp(i,0), th_err[i], sqrt(cov_exp(i,i)), false);

    }

    // TODO: Recognised sub-capabilities:
    //    RD
    //    RDstar
    void HEPLike_RDRDstar_LogLikelihood(double&amp; result)
    {
      using namespace Pipes::HEPLike_RDRDstar_LogLikelihood;
      static const std::string inputfile = path_to_latest_heplike_data() + &quot;/data/HFLAV_18/Semileptonic/RD_RDstar.yaml&quot;;
      static HepLike_default::HL_nDimGaussian nDimGaussian(inputfile);
      static bool first = true;
      if (first)
      {
        if (flav_debug) std::cout &lt;&lt; &quot;Debug: Reading HepLike data file: &quot; &lt;&lt; inputfile &lt;&lt; endl;
        nDimGaussian.Read();
        first = false;
      }

      // TODO: SuperIso is not ready to give correlations for these observables. So currently we fall back to the old way.
      //       Below code is for future reference.
      // static std::vector&lt;str&gt; obs_list = Downstream::subcaps-&gt;getNames();
      // flav_prediction prediction = *Dep::prediction_RDRDstar;
      // flav_observable_map theory = prediction.central_values;
      // flav_covariance_map theory_covariance = prediction.covariance;

      // result = nDimGaussian.GetLogLikelihood(get_obs_theory(prediction, obs_list), get_obs_covariance(prediction, obs_list));
      const std::vector&lt;double&gt; theory{*Dep::RD, *Dep::RDstar};
      result = nDimGaussian.GetLogLikelihood(theory /* , theory_covariance */);
      if (flav_debug) std::cout &lt;&lt; &quot;HEPLike_RDRDstar_LogLikelihood result: &quot; &lt;&lt; result &lt;&lt; std::endl;
    }

    #define HEPLIKE_GAUSSIAN_1D_LIKELIHOOD(name, file)                            \
    void CAT_3(HEPLike_,name,_LogLikelihood)(double &amp;result)                      \
    {                                                                             \
      using namespace CAT_3(Pipes::HEPLike_,name,_LogLikelihood);                 \
      static const std::string inputfile = path_to_latest_heplike_data() + file;  \
      static HepLike_default::HL_Gaussian gaussian(inputfile);                    \
      static bool first = true;                                                   \
                                                                                  \
      if (first)                                                                  \
      {                                                                           \
        if (flav_debug) std::cout &lt;&lt; &quot;Debug: Reading HepLike data file: &quot; &lt;&lt;      \
         inputfile &lt;&lt; endl;                                                       \
        gaussian.Read();                                                          \
        first = false;                                                            \
      }                                                                           \
                                                                                  \
      double theory = CAT(Dep::prediction_,name)-&gt;central_values.begin()-&gt;second; \
      double theory_variance = CAT(Dep::prediction_,name)-&gt;covariance.begin()-&gt;   \
       second.begin()-&gt;second;                                                    \
      result = gaussian.GetLogLikelihood(theory, theory_variance);                \
                                                                                  \
      if (flav_debug) std::cout &lt;&lt; &quot;HEPLike_&quot; &lt;&lt; #name                            \
       &lt;&lt; &quot;_LogLikelihood result: &quot; &lt;&lt; result &lt;&lt; std::endl;                       \
    }                                                                             \

    HEPLIKE_GAUSSIAN_1D_LIKELIHOOD(b2sgamma, &quot;/data/HFLAV_18/RD/b2sgamma.yaml&quot;)
    HEPLIKE_GAUSSIAN_1D_LIKELIHOOD(B2Kstargamma, &quot;/data/HFLAV_18/RD/B2Kstar_gamma_BR.yaml&quot;)
    HEPLIKE_GAUSSIAN_1D_LIKELIHOOD(B2taunu, &quot;/data/PDG/Semileptonic/B2TauNu.yaml&quot;)

    void HEPLike_B2mumu_LogLikelihood_CMS(double &amp;result)
    {
      using namespace Pipes::HEPLike_B2mumu_LogLikelihood_CMS;
      static const std::string inputfile = path_to_latest_heplike_data() + &quot;/data/CMS/RD/B2MuMu/CMS-PAS-BPH-16-004.yaml&quot;;
      static std::vector&lt;str&gt; obs_list = Downstream::subcaps-&gt;getNames();
      static HepLike_default::HL_nDimLikelihood nDimLikelihood(inputfile);
      static bool first = true;

      if (obs_list.empty()) FlavBit_error().raise(LOCAL_INFO, &quot;No subcapabilities specified!&quot;);

      if (first)
      {
        if (flav_debug) std::cout &lt;&lt; &quot;Debug: Reading HepLike data file: &quot; &lt;&lt; inputfile &lt;&lt; endl;
        nDimLikelihood.Read();
        update_obs_list(obs_list, nDimLikelihood.GetObservables());
        first = false;
      }

      /* nDimLikelihood does not support theory errors */
      result = nDimLikelihood.GetLogLikelihood(get_obs_theory(*Dep::prediction_B2mumu, obs_list));

      if (flav_debug) std::cout &lt;&lt; &quot;HEPLike_B2mumu_LogLikelihood_CMS result: &quot; &lt;&lt; result &lt;&lt; std::endl;
    }

    void HEPLike_B2mumu_LogLikelihood_Atlas(double &amp;result)
    {
      using namespace Pipes::HEPLike_B2mumu_LogLikelihood_Atlas;
      static const std::string inputfile = path_to_latest_heplike_data() + &quot;/data/ATLAS/RD/B2MuMu/CERN-EP-2018-291.yaml&quot;;
      static std::vector&lt;str&gt; obs_list = Downstream::subcaps-&gt;getNames();
      static HepLike_default::HL_nDimLikelihood nDimLikelihood(inputfile);

      if (obs_list.empty()) FlavBit_error().raise(LOCAL_INFO, &quot;No subcapabilities specified!&quot;);

      static bool first = true;
      if (first)
      {
        if (flav_debug) std::cout &lt;&lt; &quot;Debug: Reading HepLike data file: &quot; &lt;&lt; inputfile &lt;&lt; endl;
        nDimLikelihood.Read();
        update_obs_list(obs_list, nDimLikelihood.GetObservables());
        first = false;
      }

      /* nDimLikelihood does not support theory errors */
      result = nDimLikelihood.GetLogLikelihood(get_obs_theory(*Dep::prediction_B2mumu, obs_list));

      if (flav_debug) std::cout &lt;&lt; &quot;HEPLike_B2mumu_LogLikelihood_Atlas result: &quot; &lt;&lt; result &lt;&lt; std::endl;
    }

    void HEPLike_B2mumu_LogLikelihood_LHCb(double &amp;result)
    {
      using namespace Pipes::HEPLike_B2mumu_LogLikelihood_LHCb;
      static const std::string inputfile = path_to_latest_heplike_data() + &quot;/data/LHCb/RD/B2MuMu/CERN-EP-2017-100.yaml&quot;;
      static std::vector&lt;str&gt; obs_list = Downstream::subcaps-&gt;getNames();
      static HepLike_default::HL_nDimLikelihood nDimLikelihood(inputfile);

      if (obs_list.empty()) FlavBit_error().raise(LOCAL_INFO, &quot;No subcapabilities specified!&quot;);

      static bool first = true;
      if (first)
      {
        if (flav_debug) std::cout &lt;&lt; &quot;Debug: Reading HepLike data file: &quot; &lt;&lt; inputfile &lt;&lt; endl;
        nDimLikelihood.Read();
        update_obs_list(obs_list, nDimLikelihood.GetObservables());
        first = false;
      }

      /* nDimLikelihood does not support theory errors */
      result = nDimLikelihood.GetLogLikelihood(get_obs_theory(*Dep::prediction_B2mumu, obs_list));

      if (flav_debug) std::cout &lt;&lt; &quot;HEPLike_B2mumu_LogLikelihood_LHCb result: &quot; &lt;&lt; result &lt;&lt; std::endl;
    }

    void HEPLike_B2KstarmumuAng_LogLikelihood_Atlas(double &amp;result)
    {
      using namespace Pipes::HEPLike_B2KstarmumuAng_LogLikelihood_Atlas;
      static const std::string inputfile = path_to_latest_heplike_data() + &quot;/data/ATLAS/RD/Bd2KstarMuMu_Angular/CERN-EP-2017-161_q2_&quot;;
      static std::vector&lt;str&gt; obs_list = Downstream::subcaps-&gt;getNames();
      static std::vector&lt;HepLike_default::HL_nDimGaussian&gt; nDimGaussian = {
        HepLike_default::HL_nDimGaussian(inputfile + &quot;0.1_2.0.yaml&quot;),
        HepLike_default::HL_nDimGaussian(inputfile + &quot;2.0_4.0.yaml&quot;),
        HepLike_default::HL_nDimGaussian(inputfile + &quot;4.0_8.0.yaml&quot;),
      };

      if (obs_list.empty()) FlavBit_error().raise(LOCAL_INFO, &quot;No subcapabilities specified!&quot;);

      static bool first = true;
      if (first)
      {
        for (unsigned int i = 0; i &lt; nDimGaussian.size(); ++i)
        {
          if (flav_debug) std::cout &lt;&lt; &quot;Debug: Reading HepLike data file: &quot; &lt;&lt; i &lt;&lt; endl;
          nDimGaussian[i].Read();
        }
        update_obs_list(obs_list, nDimGaussian[0].GetObservables());
        first = false;
      }

      std::vector&lt;flav_prediction&gt; prediction = {
        *Dep::prediction_B2KstarmumuAng_0p1_2_Atlas,
        *Dep::prediction_B2KstarmumuAng_2_4_Atlas,
        *Dep::prediction_B2KstarmumuAng_4_8_Atlas,
      };

      result = 0;
      for (unsigned int i = 0; i &lt; nDimGaussian.size(); i++)
      {
        result += nDimGaussian[i].GetLogLikelihood(get_obs_theory(prediction[i], obs_list), get_obs_covariance(prediction[i], obs_list));
      }
      if (flav_debug) std::cout &lt;&lt; &quot;HEPLike_B2KstarmumuAng_LogLikelihood_Atlas result: &quot; &lt;&lt; result &lt;&lt; std::endl;
    }

    void HEPLike_B2KstarmumuAng_LogLikelihood_CMS(double &amp;result)
    {
      using namespace Pipes::HEPLike_B2KstarmumuAng_LogLikelihood_CMS;
      static const std::string inputfile = path_to_latest_heplike_data() + &quot;/data/CMS/RD/Bd2KstarMuMu_Angular/CERN-EP-2017-240_q2_&quot;;
      static std::vector&lt;str&gt; obs_list = Downstream::subcaps-&gt;getNames();
      static std::vector&lt;HepLike_default::HL_nDimBifurGaussian&gt; nDimBifurGaussian = {
        HepLike_default::HL_nDimBifurGaussian(inputfile+&quot;1.0_2.0.yaml&quot;),
        HepLike_default::HL_nDimBifurGaussian(inputfile+&quot;2.0_4.3.yaml&quot;),
        HepLike_default::HL_nDimBifurGaussian(inputfile+&quot;4.3_6.0.yaml&quot;),
        HepLike_default::HL_nDimBifurGaussian(inputfile+&quot;6.0_8.68.yaml&quot;),
        HepLike_default::HL_nDimBifurGaussian(inputfile+&quot;10.09_12.86.yaml&quot;),
        HepLike_default::HL_nDimBifurGaussian(inputfile+&quot;14.18_16.0.yaml&quot;),
        HepLike_default::HL_nDimBifurGaussian(inputfile+&quot;16.0_19.0.yaml&quot;)
      };

      if (obs_list.empty()) FlavBit_error().raise(LOCAL_INFO, &quot;No subcapabilities specified!&quot;);

      static bool first = true;
      if (first)
      {
        for (unsigned int i = 0; i &lt; nDimBifurGaussian.size(); i++)
        {
          if (flav_debug) std::cout &lt;&lt; &quot;Debug: Reading HepLike data file &quot; &lt;&lt; i &lt;&lt; endl;
          nDimBifurGaussian[i].Read();
        }
        update_obs_list(obs_list, nDimBifurGaussian[0].GetObservables());
        first = false;
      }

      std::vector&lt;flav_prediction&gt; prediction = {
        *Dep::prediction_B2KstarmumuAng_1_2_CMS,
        *Dep::prediction_B2KstarmumuAng_2_4p3_CMS,
        *Dep::prediction_B2KstarmumuAng_4p3_6_CMS,
        *Dep::prediction_B2KstarmumuAng_6_8p68_CMS,
        *Dep::prediction_B2KstarmumuAng_10p09_12p86_CMS,
        *Dep::prediction_B2KstarmumuAng_14p18_16_CMS,
        *Dep::prediction_B2KstarmumuAng_16_19_CMS
      };

      result = 0;
      for (unsigned int i = 0; i &lt; nDimBifurGaussian.size(); i++)
      {
        result += nDimBifurGaussian[i].GetLogLikelihood(get_obs_theory(prediction[i], obs_list), get_obs_covariance(prediction[i], obs_list));
      }

      if (flav_debug) std::cout &lt;&lt; &quot;HEPLike_B2KstarmumuAng_LogLikelihood_CMS result: &quot; &lt;&lt; result &lt;&lt; std::endl;
    }


    void HEPLike_B2KstarmumuAng_LogLikelihood_Belle(double &amp;result)
    {
      using namespace Pipes::HEPLike_B2KstarmumuAng_LogLikelihood_Belle;
      static const std::string inputfile = path_to_latest_heplike_data() + &quot;/data/Belle/RD/Bd2KstarMuMu_Angular/KEK-2016-54_q2_&quot;;
      static std::vector&lt;str&gt; obs_list = Downstream::subcaps-&gt;getNames();
      static std::vector&lt;HepLike_default::HL_nDimBifurGaussian&gt; nDimBifurGaussian = {
        HepLike_default::HL_nDimBifurGaussian(inputfile + &quot;0.1_4.0.yaml&quot;),
        HepLike_default::HL_nDimBifurGaussian(inputfile + &quot;4.0_8.0.yaml&quot;),
        HepLike_default::HL_nDimBifurGaussian(inputfile + &quot;10.09_12.9.yaml&quot;),
        HepLike_default::HL_nDimBifurGaussian(inputfile + &quot;14.18_19.0.yaml&quot;),
      };

      if (obs_list.empty()) FlavBit_error().raise(LOCAL_INFO, &quot;No subcapabilities specified!&quot;);

      static bool first = true;
      if (first)
      {
        for (unsigned int i = 0; i &lt; nDimBifurGaussian.size(); i++)
        {
          if (flav_debug) std::cout &lt;&lt; &quot;Debug: Reading HepLike data file: &quot; &lt;&lt; i &lt;&lt; endl;
          nDimBifurGaussian[i].Read();
        }
        update_obs_list(obs_list, nDimBifurGaussian[0].GetObservables());
        first = false;
      }

      std::vector&lt;flav_prediction&gt; prediction =
      {
        *Dep::prediction_B2KstarmumuAng_0p1_4_Belle,
        *Dep::prediction_B2KstarmumuAng_4_8_Belle,
        *Dep::prediction_B2KstarmumuAng_10p9_12p9_Belle,
        *Dep::prediction_B2KstarmumuAng_14p18_19_Belle,
      };

      result = 0;
      for (unsigned int i = 0; i &lt; nDimBifurGaussian.size(); i++)
      {
        result += nDimBifurGaussian[i].GetLogLikelihood(get_obs_theory(prediction[i], obs_list), get_obs_covariance(prediction[i], obs_list));
      }

      if (flav_debug) std::cout &lt;&lt; &quot;HEPLike_B2KstarmumuAng_LogLikelihood_Belle result: &quot; &lt;&lt; result &lt;&lt; std::endl;
    }

    void HEPLike_B2KstarellellAng_LogLikelihood_Belle(double &amp;result)
    {
      using namespace Pipes::HEPLike_B2KstarellellAng_LogLikelihood_Belle;
      static const std::string inputfile = path_to_latest_heplike_data() + &quot;/data/Belle/RD/Bd2KstarEllEll_Angular/KEK-2016-54_q2_&quot;;
      static std::vector&lt;str&gt; obs_list = Downstream::subcaps-&gt;getNames();
      static std::vector&lt;HepLike_default::HL_nDimBifurGaussian&gt; nDimBifurGaussian =
      {
        HepLike_default::HL_nDimBifurGaussian(inputfile + &quot;0.1_4.0.yaml&quot;),
        HepLike_default::HL_nDimBifurGaussian(inputfile + &quot;4.0_8.0.yaml&quot;),
        HepLike_default::HL_nDimBifurGaussian(inputfile + &quot;10.09_12.9.yaml&quot;),
        HepLike_default::HL_nDimBifurGaussian(inputfile + &quot;14.18_19.0.yaml&quot;),
      };

      if (obs_list.empty()) FlavBit_error().raise(LOCAL_INFO, &quot;No subcapabilities specified!&quot;);

      static bool first = true;
      if (first)
      {
        for (unsigned int i = 0; i &lt; nDimBifurGaussian.size(); i++)
        {
          if (flav_debug) std::cout &lt;&lt; &quot;Debug: Reading HepLike data file: &quot; &lt;&lt; i &lt;&lt; endl;
          nDimBifurGaussian[i].Read();
        }
        update_obs_list(obs_list, nDimBifurGaussian[0].GetObservables());
        first = false;
      }

      std::vector&lt;flav_prediction&gt; prediction =
      {
        *Dep::prediction_B2KstarmumuAng_0p1_4_Belle,
        *Dep::prediction_B2KstarmumuAng_4_8_Belle,
        *Dep::prediction_B2KstarmumuAng_10p9_12p9_Belle,
        *Dep::prediction_B2KstarmumuAng_14p18_19_Belle,
      };

      result = 0;
      for (unsigned int i = 0; i &lt; nDimBifurGaussian.size(); i++)
      {
        result += nDimBifurGaussian[i].GetLogLikelihood(get_obs_theory(prediction[i], obs_list), get_obs_covariance(prediction[i], obs_list));
      }

      if (flav_debug) std::cout &lt;&lt; &quot;HEPLike_B2KstarellellAng_LogLikelihood_Belle result: &quot; &lt;&lt; result &lt;&lt; std::endl;
    }

    void HEPLike_B2KstarmumuAng_LogLikelihood_LHCb(double &amp;result)
    {
      using namespace Pipes::HEPLike_B2KstarmumuAng_LogLikelihood_LHCb;
      static const std::string inputfile = path_to_latest_heplike_data() + &quot;/data/LHCb/RD/Bd2KstarMuMu_Angular/PH-EP-2015-314_q2_&quot;;
      static std::vector&lt;str&gt; obs_list = Downstream::subcaps-&gt;getNames();
      static std::vector&lt;HepLike_default::HL_nDimBifurGaussian&gt; nDimBifurGaussian = {
        HepLike_default::HL_nDimBifurGaussian(inputfile + &quot;0.1_0.98.yaml&quot;),
        HepLike_default::HL_nDimBifurGaussian(inputfile + &quot;1.1_2.5.yaml&quot;),
        HepLike_default::HL_nDimBifurGaussian(inputfile + &quot;2.5_4.0.yaml&quot;),
        HepLike_default::HL_nDimBifurGaussian(inputfile + &quot;4.0_6.0.yaml&quot;),
        HepLike_default::HL_nDimBifurGaussian(inputfile + &quot;6.0_8.0.yaml&quot;),
        HepLike_default::HL_nDimBifurGaussian(inputfile + &quot;15.0_19.yaml&quot;),
      };

      if (obs_list.empty()) FlavBit_error().raise(LOCAL_INFO, &quot;No subcapabilities specified!&quot;);

      static bool first = true;
      if (first)
      {
        for (unsigned int i = 0; i &lt; nDimBifurGaussian.size(); i++)
        {
          if (flav_debug) std::cout &lt;&lt; &quot;Debug: Reading HepLike data file: &quot; &lt;&lt; i &lt;&lt; endl;
          nDimBifurGaussian[i].Read();
        }
        update_obs_list(obs_list, nDimBifurGaussian[0].GetObservables());
        first = false;
      }

      std::vector&lt;flav_prediction&gt; prediction = {
        *Dep::prediction_B2KstarmumuAng_0p1_0p98_LHCb,
        *Dep::prediction_B2KstarmumuAng_1p1_2p5_LHCb,
        *Dep::prediction_B2KstarmumuAng_2p5_4_LHCb,
        *Dep::prediction_B2KstarmumuAng_4_6_LHCb,
        *Dep::prediction_B2KstarmumuAng_6_8_LHCb,
        *Dep::prediction_B2KstarmumuAng_15_19_LHCb,
      };

      result = 0;
      for (unsigned int i = 0; i &lt; nDimBifurGaussian.size(); i++)
      {
        result += nDimBifurGaussian[i].GetLogLikelihood(get_obs_theory(prediction[i], obs_list), get_obs_covariance(prediction[i], obs_list));
      }

      if (flav_debug) std::cout &lt;&lt; &quot;HEPLike_B2KstarmumuAng_LogLikelihood_LHCb result: &quot; &lt;&lt; result &lt;&lt; std::endl;
    }

    void HEPLike_B2KstarmumuAng_LogLikelihood_LHCb_2020(double &amp;result)
    {
      using namespace Pipes::HEPLike_B2KstarmumuAng_LogLikelihood_LHCb_2020;
      static const std::string inputfile = path_to_latest_heplike_data() + &quot;/data/LHCb/RD/Bd2KstarMuMu_Angular/CERN-EP-2020-027_q2_&quot;;
      static std::vector&lt;str&gt; obs_list = Downstream::subcaps-&gt;getNames();
      static std::vector&lt;HepLike_default::HL_nDimGaussian&gt; nDimGaussian = {
        HepLike_default::HL_nDimGaussian(inputfile + &quot;0.1_0.98.yaml&quot;),
        HepLike_default::HL_nDimGaussian(inputfile + &quot;1.1_2.5.yaml&quot;),
        HepLike_default::HL_nDimGaussian(inputfile + &quot;2.5_4.0.yaml&quot;),
        HepLike_default::HL_nDimGaussian(inputfile + &quot;4.0_6.0.yaml&quot;),
        HepLike_default::HL_nDimGaussian(inputfile + &quot;6.0_8.0.yaml&quot;),
        HepLike_default::HL_nDimGaussian(inputfile + &quot;15.0_19.0.yaml&quot;),
      };

      if (obs_list.empty()) FlavBit_error().raise(LOCAL_INFO, &quot;No subcapabilities specified!&quot;);

      static bool first = true;
      if (first)
      {
        for (unsigned int i = 0; i &lt; nDimGaussian.size(); i++)
        {
          if (flav_debug) std::cout &lt;&lt; &quot;Debug: Reading HepLike data file: &quot; &lt;&lt; i &lt;&lt; endl;
          nDimGaussian[i].Read();
        }
        update_obs_list(obs_list, nDimGaussian[0].GetObservables());
        first = false;
      }

      std::vector&lt;flav_prediction&gt; prediction = {
        *Dep::prediction_B2KstarmumuAng_0p1_0p98_LHCb,
        *Dep::prediction_B2KstarmumuAng_1p1_2p5_LHCb,
        *Dep::prediction_B2KstarmumuAng_2p5_4_LHCb,
        *Dep::prediction_B2KstarmumuAng_4_6_LHCb,
        *Dep::prediction_B2KstarmumuAng_6_8_LHCb,
        *Dep::prediction_B2KstarmumuAng_15_19_LHCb,
      };

      result = 0;
      for (unsigned int i = 0; i &lt; nDimGaussian.size(); i++)
      {
        result += nDimGaussian[i].GetLogLikelihood(get_obs_theory(prediction[i], obs_list), get_obs_covariance(prediction[i], obs_list));
      }

      if (flav_debug) std::cout &lt;&lt; &quot;HEPLike_B2KstarmumuAng_LogLikelihood_LHCb 2020 result: &quot; &lt;&lt; result &lt;&lt; std::endl;
    }

    void HEPLike_B2KstareeAng_Lowq2_LogLikelihood_LHCb_2020(double &amp;result)
    {
      using namespace Pipes::HEPLike_B2KstareeAng_Lowq2_LogLikelihood_LHCb_2020;
      static const std::string inputfile = path_to_latest_heplike_data() + &quot;/data/LHCb/RD/Bd2KstarEE_Angular/CERN-EP-2020-176.yaml&quot;;
      static std::vector&lt;str&gt; obs_list = Downstream::subcaps-&gt;getNames();
      if (obs_list.empty()) FlavBit_error().raise(LOCAL_INFO, &quot;No subcapabilities specified!&quot;);
      static HepLike_default::HL_nDimGaussian nDimGaussian(inputfile);
      static bool first = true;
      if (first)
      {
        if (flav_debug) std::cout &lt;&lt; &quot;Debug: Reading HepLike data file: &quot; &lt;&lt; inputfile &lt;&lt; endl;
        nDimGaussian.Read();
        first = false;
      }
      flav_prediction prediction = *Dep::prediction_B2KstareeAng_0p0008_0p257_LHCb;
      if (flav_debug)
      {
        std::cout&lt;&lt;&quot;Have prediction&quot;&lt;&lt;std::endl;
        for (unsigned int i=0; i &lt;obs_list.size(); i++)
        {
          std::cout&lt;&lt;obs_list[i]&lt;&lt;std::endl;
        }
      }

      result = nDimGaussian.GetLogLikelihood(get_obs_theory(prediction, obs_list), get_obs_covariance(prediction, obs_list));

      if (flav_debug) std::cout &lt;&lt; &quot;HEPLike_B2KstareeAng_Lowq_LogLikelihood result: &quot; &lt;&lt; result &lt;&lt; std::endl;
    }

    void HEPLike_Bu2KstarmumuAng_LogLikelihood_LHCb_2020(double &amp;result)
    {
      using namespace Pipes::HEPLike_Bu2KstarmumuAng_LogLikelihood_LHCb_2020;
      static const std::string inputfile = path_to_latest_heplike_data() + &quot;/data/LHCb/RD/Bu2KstarMuMu_Angular/CERN-EP-2020-239_q2_&quot;;
      static std::vector&lt;str&gt; obs_list = Downstream::subcaps-&gt;getNames();
      if (obs_list.empty()) FlavBit_error().raise(LOCAL_INFO, &quot;No subcapabilities specified!&quot;);
      static std::vector&lt;HepLike_default::HL_nDimGaussian&gt; nDimGaussian = {
        HepLike_default::HL_nDimGaussian(inputfile + &quot;0.1_0.98.yaml&quot;),
        HepLike_default::HL_nDimGaussian(inputfile + &quot;1.1_2.5.yaml&quot;),
        HepLike_default::HL_nDimGaussian(inputfile + &quot;2.5_4.0.yaml&quot;),
        HepLike_default::HL_nDimGaussian(inputfile + &quot;4.0_6.0.yaml&quot;),
        HepLike_default::HL_nDimGaussian(inputfile + &quot;6.0_8.0.yaml&quot;),
        HepLike_default::HL_nDimGaussian(inputfile + &quot;15.0_19.0.yaml&quot;),
      };

      static bool first = true;
      if (first)
        {
          for (unsigned int i = 0; i &lt; nDimGaussian.size(); i++)
            {
              if (flav_debug) std::cout &lt;&lt; &quot;Debug: Reading HepLike data file: &quot; &lt;&lt; i &lt;&lt; endl;
              nDimGaussian[i].Read();
            }
          update_obs_list(obs_list, nDimGaussian[0].GetObservables());
          first = false;
        }

      std::vector&lt;flav_prediction&gt; prediction =
      {
        *Dep::prediction_B2KstarmumuAng_0p1_0p98_LHCb,
        *Dep::prediction_B2KstarmumuAng_1p1_2p5_LHCb,
        *Dep::prediction_B2KstarmumuAng_2p5_4_LHCb,
        *Dep::prediction_B2KstarmumuAng_4_6_LHCb,
        *Dep::prediction_B2KstarmumuAng_6_8_LHCb,
        *Dep::prediction_B2KstarmumuAng_15_19_LHCb,
      };

      result = 0;
      for (unsigned int i = 0; i &lt; nDimGaussian.size(); i++)
      {
        result += nDimGaussian[i].GetLogLikelihood(get_obs_theory(prediction[i], obs_list),
         get_obs_covariance(prediction[i], obs_list));
      }

      if (flav_debug) std::cout &lt;&lt; &quot;HEPLike_Bu2KstarmumuAng_LogLikelihood_LHCb 2020 result: &quot; &lt;&lt; result &lt;&lt; std::endl;
    }

    void HEPLike_B2KstarmumuBr_LogLikelihood_LHCb(double &amp;result)
    {
      using namespace Pipes::HEPLike_B2KstarmumuBr_LogLikelihood_LHCb;
      static const std::string inputfile = path_to_latest_heplike_data() + &quot;/data/LHCb/RD/Bd2KstarMuMu_Br/CERN-EP-2016-141_q2_&quot;;
      static std::vector&lt;HepLike_default::HL_BifurGaussian&gt; BifurGaussian = {
        HepLike_default::HL_BifurGaussian(inputfile + &quot;0.1_0.98.yaml&quot;),
        HepLike_default::HL_BifurGaussian(inputfile + &quot;1.1_2.5.yaml&quot;),
        HepLike_default::HL_BifurGaussian(inputfile + &quot;2.5_4.yaml&quot;),
        HepLike_default::HL_BifurGaussian(inputfile + &quot;4_6.yaml&quot;),
        HepLike_default::HL_BifurGaussian(inputfile + &quot;6_8.yaml&quot;),
        HepLike_default::HL_BifurGaussian(inputfile + &quot;15_19.yaml&quot;)
      };

      static bool first = true;
      if (first)
      {
        for (unsigned int i = 0; i &lt; BifurGaussian.size(); i++)
        {
          if (flav_debug) std::cout &lt;&lt; &quot;Debug: Reading HepLike data file &quot; &lt;&lt; i &lt;&lt; endl;
          BifurGaussian[i].Read();
        }
        first = false;
      }

      std::vector&lt;flav_prediction&gt; prediction = {
        *Dep::prediction_B2KstarmumuBr_0p1_0p98,
        *Dep::prediction_B2KstarmumuBr_1p1_2p5,
        *Dep::prediction_B2KstarmumuBr_2p5_4,
        *Dep::prediction_B2KstarmumuBr_4_6,
        *Dep::prediction_B2KstarmumuBr_6_8,
        *Dep::prediction_B2KstarmumuBr_15_19
      };

      result = 0;

      for (unsigned int i = 0; i &lt; BifurGaussian.size(); i++)
      {
        double theory = prediction[i].central_values.begin()-&gt;second;
        double theory_variance = prediction[i].covariance.begin()-&gt;second.begin()-&gt;second;
        result += BifurGaussian[i].GetLogLikelihood(theory, theory_variance);
      }

      if (flav_debug) std::cout &lt;&lt; &quot;HEPLike_B2KstarmumuAng_LogLikelihood_LHCb result: &quot; &lt;&lt; result &lt;&lt; std::endl;
    }

    void HEPLike_B2KmumuBr_LogLikelihood_LHCb(double &amp;result)
    {
      using namespace Pipes::HEPLike_B2KmumuBr_LogLikelihood_LHCb;
      static const std::string inputfile = path_to_latest_heplike_data() + &quot;/data/LHCb/RD/B2KMuMu_Br/CERN-PH-EP-2012-263_q2_&quot;;
      static std::vector&lt;HepLike_default::HL_Gaussian&gt; Gaussian = {
        HepLike_default::HL_Gaussian(inputfile + &quot;0.05_2.yaml&quot;),
        HepLike_default::HL_Gaussian(inputfile + &quot;2_4.3.yaml&quot;),
        HepLike_default::HL_Gaussian(inputfile + &quot;4.3_8.68.yaml&quot;),
        HepLike_default::HL_Gaussian(inputfile + &quot;14.18_16.yaml&quot;),
        HepLike_default::HL_Gaussian(inputfile + &quot;16_18.yaml&quot;),
        HepLike_default::HL_Gaussian(inputfile + &quot;18_22.yaml&quot;)
      };

      static bool first = true;
      if (first)
      {
        for (unsigned int i = 0; i &lt; Gaussian.size(); i++)
        {
          if (flav_debug) std::cout &lt;&lt; &quot;Debug: Reading HepLike data file &quot; &lt;&lt; i &lt;&lt; endl;
          Gaussian[i].Read();
        }
        first = false;
      }

      std::vector&lt;flav_prediction&gt; prediction = {
        *Dep::prediction_B2KmumuBr_0p05_2,
        *Dep::prediction_B2KmumuBr_2_4p3,
        *Dep::prediction_B2KmumuBr_4p3_8p68,
        *Dep::prediction_B2KmumuBr_14p18_16,
        *Dep::prediction_B2KmumuBr_16_18,
        *Dep::prediction_B2KmumuBr_18_22
      };

      result = 0;

      for (unsigned int i = 0; i &lt; Gaussian.size(); i++)
      {
        double theory = prediction[i].central_values.begin()-&gt;second;
        double theory_variance = prediction[i].covariance.begin()-&gt;second.begin()-&gt;second;
        result += Gaussian[i].GetLogLikelihood(theory, theory_variance);
      }

      if (flav_debug) std::cout &lt;&lt; &quot;HEPLike_B2KmumuBR_LogLikelihood_LHCb result: &quot; &lt;&lt; result &lt;&lt; std::endl;
    }


    void HEPLike_Bs2phimumuBr_LogLikelihood(double &amp;result)
    {
      using namespace Pipes::HEPLike_Bs2phimumuBr_LogLikelihood;

      static const std::string inputfile = path_to_latest_heplike_data() + &quot;/data/LHCb/RD/Bs2PhiMuMu_Br/CERN-PH-EP-2015-145_&quot;;
      static std::vector&lt;HepLike_default::HL_BifurGaussian&gt; BifurGaussian = {
        HepLike_default::HL_BifurGaussian(inputfile + &quot;1_6.yaml&quot;),
        HepLike_default::HL_BifurGaussian(inputfile + &quot;15_19.yaml&quot;)
      };

      static bool first = true;
      if (first)
      {
        for (unsigned int i = 0; i &lt; BifurGaussian.size(); i++)
        {
          if (flav_debug) std::cout &lt;&lt; &quot;Debug: Reading HepLike data file &quot; &lt;&lt; i &lt;&lt; endl;
          BifurGaussian[i].Read();
        }
        first = false;
      }

      std::vector&lt;flav_prediction&gt; prediction = {
        *Dep::prediction_Bs2phimumuBr_1_6,
        *Dep::prediction_Bs2phimumuBr_15_19
      };

      result = 0;
      for (unsigned int i = 0; i &lt; BifurGaussian.size(); i++)
      {
        double theory = prediction[i].central_values.begin()-&gt;second;
        double theory_variance = prediction[i].covariance.begin()-&gt;second.begin()-&gt;second;
        result += BifurGaussian[i].GetLogLikelihood(theory, theory_variance);
      }

      if (flav_debug) std::cout &lt;&lt; &quot;HEPLike_Bs2phimumuBr_LogLikelihood result: &quot; &lt;&lt; result &lt;&lt; std::endl;
    }


    void HEPLike_RK_LogLikelihood(double &amp;result)
    {
      using namespace Pipes::HEPLike_RK_LogLikelihood;

      static const std::string inputfile = path_to_latest_heplike_data() + &quot;/data/LHCb/RD/Rk/CERN-EP-2019-043.yaml&quot;;
      static HepLike_default::HL_ProfLikelihood ProfLikelihood(inputfile);

      static bool first = true;
      if (first)
      {
        if (flav_debug) std::cout &lt;&lt; &quot;Debug: Reading HepLike data file: &quot; &lt;&lt; inputfile &lt;&lt; endl;
        ProfLikelihood.Read();

        first = false;
      }

      flav_prediction prediction = *Dep::prediction_RK_LHCb_1p1_6;

      const double theory = prediction.central_values.begin()-&gt;second;
      const double theory_variance = prediction.covariance.begin()-&gt;second.begin()-&gt;second;
      result = ProfLikelihood.GetLogLikelihood(1. + theory, theory_variance);

      if (flav_debug) std::cout &lt;&lt; &quot;HEPLike_RK_LogLikelihood result: &quot; &lt;&lt; result &lt;&lt; std::endl;
    }


    void HEPLike_RKstar_LogLikelihood_LHCb(double &amp;result)
    {

      using namespace Pipes::HEPLike_RKstar_LogLikelihood_LHCb;

      static const std::string inputfile = path_to_latest_heplike_data() + &quot;/data/LHCb/RD/RKstar/CERN-EP-2017-100_q2_&quot;;
      static std::vector&lt;HepLike_default::HL_ProfLikelihood&gt; ProfLikelihood = {
        HepLike_default::HL_ProfLikelihood(inputfile + &quot;0.045_1.1.yaml&quot;),
        HepLike_default::HL_ProfLikelihood(inputfile + &quot;1.1_6.yaml&quot;)
      };

      static bool first = true;
      if (first)
      {
        for (unsigned int i = 0; i &lt; ProfLikelihood.size(); i++)
        {
          if (flav_debug) std::cout &lt;&lt; &quot;Debug: Reading HepLike data file &quot; &lt;&lt; i &lt;&lt; endl;
          ProfLikelihood[i].Read();
        }
        first = false;
      }

      std::vector&lt;flav_prediction&gt; prediction = {
        *Dep::prediction_RKstar_LHCb_0p045_1p1,
        *Dep::prediction_RKstar_LHCb_1p1_6
      };

      result = 0;
      for (unsigned int i = 0; i &lt; ProfLikelihood.size(); i++)
      {
        const double theory = prediction[i].central_values.begin()-&gt;second;
        const double theory_variance = prediction[i].covariance.begin()-&gt;second.begin()-&gt;second;
        result += ProfLikelihood[i].GetLogLikelihood(1. + theory, theory_variance);
      }

      if (flav_debug) std::cout &lt;&lt; &quot;HEPLike_RKstar_LogLikelihood_LHCb result: &quot; &lt;&lt; result &lt;&lt; std::endl;

    }

  }
}
</code></pre><hr><p>Updated on 2022-07-20 at 17:18:45 +0000</p><div class=edit-page><a href=https://github.com/RC1242RC/gambit_gh_pages/blob/master/content/en/documentation/code/Files/FlavBit_8cpp.md><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828.0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>Edit this page on GitHub</a></div></main></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Powered by <a class=text-muted href=https://www.netlify.com/>Netlify</a>, <a class=text-muted href=https://gohugo.io/>Hugo</a>, and <a class=text-muted href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline><li class=list-inline-item><a href=/main_development/license/>License</a></li></ul></div></div></div></footer><script src=/main_development/js/bootstrap.min.54bf0932b8a36d0e152b1635b099a6ef1394d35327e2437550a075c9c8ed1bd8aed5847c21b36fc02ed24014c031d9ca24017b0c78b1639d7e2fa8329898b842.js integrity="sha512-VL8JMrijbQ4VKxY1sJmm7xOU01Mn4kN1UKB1ycjtG9iu1YR8IbNvwC7SQBTAMdnKJAF7DHixY51+L6gymJi4Qg==" crossorigin=anonymous defer></script>
<script src=/main_development/js/highlight.min.5b48bc253dc75aeea5fb366ecf700f4925e2b6eb1a1466f2124b722d68148d67bc0a9365d2b8ad9c585161b46372d23b08509a16f1fd518542b894756d4752d0.js integrity="sha512-W0i8JT3HWu6l+zZuz3APSSXitusaFGbyEktyLWgUjWe8CpNl0ritnFhRYbRjctI7CFCaFvH9UYVCuJR1bUdS0A==" crossorigin=anonymous defer></script>
<script src=/main_development/main.min.40265e9a032aeba5eaf67baac3cbbc22667a7533215d326eeb3e9f4d5e4be40f9ff4dcd22949db73ae527ca26a19d7998091a8973c82af760b2c0daa335190ed.js integrity="sha512-QCZemgMq66Xq9nuqw8u8ImZ6dTMhXTJu6z6fTV5L5A+f9NzSKUnbc65SfKJqGdeZgJGolzyCr3YLLA2qM1GQ7Q==" crossorigin=anonymous defer></script>
<script src=https://rc1242rc.github.io/main_development/index.min.2e958d3be0c5b27cae804290be7a3d5ff0b6d3ca87ab76eeeeb88dbe22b3f251bcc80b638457f7977802ccdc9ff51bd15b8e424e00a8ab3a22c4c1ab6824d4ad.js integrity="sha512-LpWNO+DFsnyugEKQvno9X/C208qHq3bu7riNviKz8lG8yAtjhFf3l3gCzNyf9RvRW45CTgCoqzoixMGraCTUrQ==" crossorigin=anonymous defer></script></body></html>