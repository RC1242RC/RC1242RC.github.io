---
title: 'namespace Gambit::ColliderBit'

description: "[No description available]"

---






[No description available]

## Namespaces

| Name           |
| -------------- |
| **[Gambit::ColliderBit::ATLAS](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit_1_1atlas/)** <br>ATLAS-specific efficiency and smearing functions for super fast detector simulation.  |
| **[Gambit::ColliderBit::CMS](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit_1_1cms/)** <br>CMS-specific efficiency and smearing functions for super fast detector simulation.  |
| **[Gambit::ColliderBit::EventConversion](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit_1_1eventconversion/)**  |

## Classes

|                | Name           |
| -------------- | -------------- |
| struct | **[Gambit::ColliderBit::_gsl_target_func_params](/documentation/code/main/classes/structgambit_1_1colliderbit_1_1__gsl__target__func__params/)** <br>A struct to contain parameters for the GSL optimiser target function.  |
| class | **[Gambit::ColliderBit::ALEPHSelectronLimitAt208GeV](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1alephselectronlimitat208gev/)** <br>A class to contain the limit data from ALEPH_PLB526_2002_206, figure 3a.  |
| class | **[Gambit::ColliderBit::ALEPHSmuonLimitAt208GeV](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1alephsmuonlimitat208gev/)** <br>A class to contain the limit data from ALEPH_PLB526_2002_206, figure 3b.  |
| class | **[Gambit::ColliderBit::ALEPHStauLimitAt208GeV](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1alephstaulimitat208gev/)** <br>A class to contain the limit data from ALEPH_PLB526_2002_206, figure 3c.  |
| class | **[Gambit::ColliderBit::Analysis](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis/)** <br>A class for collider analyses within ColliderBit.  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_13TeV_0LEP_139invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__13tev__0lep__139invfb/)** <br>[ATLAS]() Run 2 0-lepton jet+MET SUSY analysis, with 139/fb of data.  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_13TeV_0LEP_13invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__13tev__0lep__13invfb/)** <br>[ATLAS]() Run 2 0-lepton jet+MET SUSY analysis, with 13/fb of data.  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_13TeV_0LEP_36invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__13tev__0lep__36invfb/)** <br>[ATLAS]() Run 2 0-lepton jet+MET SUSY analysis, with 36/fb of data.  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_13TeV_0LEPStop_36invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__13tev__0lepstop__36invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_13TeV_1LEPStop_36invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__13tev__1lepstop__36invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_13TeV_2bMET_36invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__13tev__2bmet__36invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_13TeV_2LEPStop_139invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__13tev__2lepstop__139invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_13TeV_2LEPStop_36invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__13tev__2lepstop__36invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_13TeV_2LEPStop_exclusive_139invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__13tev__2lepstop__exclusive__139invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_13TeV_2LEPStop_inclusive_139invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__13tev__2lepstop__inclusive__139invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_13TeV_2OSLEP_chargino_139invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__13tev__2oslep__chargino__139invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_13TeV_2OSLEP_chargino_80invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__13tev__2oslep__chargino__80invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_13TeV_2OSLEP_chargino_binned_139invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__13tev__2oslep__chargino__binned__139invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_13TeV_2OSLEP_chargino_binned_80invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__13tev__2oslep__chargino__binned__80invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_13TeV_2OSLEP_chargino_inclusive_139invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__13tev__2oslep__chargino__inclusive__139invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_13TeV_2OSLEP_chargino_inclusive_80invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__13tev__2oslep__chargino__inclusive__80invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_13TeV_2OSLEP_Z_139invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__13tev__2oslep__z__139invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_13TeV_3b_24invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__13tev__3b__24invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_13TeV_3b_36invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__13tev__3b__36invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_13TeV_3b_discoverySR_24invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__13tev__3b__discoverysr__24invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_13TeV_3b_discoverySR_36invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__13tev__3b__discoverysr__36invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_13TeV_4LEP_139invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__13tev__4lep__139invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_13TeV_4LEP_36invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__13tev__4lep__36invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_13TeV_MultiLEP_2Lep0Jets_36invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__13tev__multilep__2lep0jets__36invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_13TeV_MultiLEP_2LepPlusJets_36invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__13tev__multilep__2lepplusjets__36invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_13TeV_MultiLEP_36invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__13tev__multilep__36invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_13TeV_MultiLEP_3Lep_36invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__13tev__multilep__3lep__36invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_13TeV_MultiLEP_confnote_36invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__13tev__multilep__confnote__36invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_13TeV_MultiLEP_strong_139invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__13tev__multilep__strong__139invfb/)** <br>[ATLAS]() Run 2 search for same-sign leptons and jets, with 139/fb of data.  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_13TeV_PhotonGGM_36invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__13tev__photonggm__36invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_13TeV_RJ3L_2Lep2Jets_36invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__13tev__rj3l__2lep2jets__36invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_13TeV_RJ3L_3Lep_36invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__13tev__rj3l__3lep__36invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_13TeV_RJ3L_lowmass_36invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__13tev__rj3l__lowmass__36invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_13TeV_ZGammaGrav_CONFNOTE_80invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__13tev__zgammagrav__confnote__80invfb/)** <br>[ATLAS]() ZH(->photon+gravitino) (79.8 fb^-1)  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_7TeV_1OR2LEPStop_4_7invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__7tev__1or2lepstop__4__7invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_7TeV_2LEPStop_4_7invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__7tev__2lepstop__4__7invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_8TeV_0LEP_20invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__8tev__0lep__20invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_8TeV_0LEPStop_20invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__8tev__0lepstop__20invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_8TeV_1LEPbb_20invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__8tev__1lepbb__20invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_8TeV_1LEPStop_20invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__8tev__1lepstop__20invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_8TeV_2bStop_20invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__8tev__2bstop__20invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_8TeV_2LEPEW_20invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__8tev__2lepew__20invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_8TeV_2LEPStop_20invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__8tev__2lepstop__20invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_ATLAS_8TeV_3LEPEW_20invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__atlas__8tev__3lepew__20invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_CMS_13TeV_0LEP_137invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__cms__13tev__0lep__137invfb/)** <br>[CMS]() Run 2 0-lepton jet+MET SUSY analysis, with 137/fb of data.  |
| class | **[Gambit::ColliderBit::Analysis_CMS_13TeV_0LEP_13invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__cms__13tev__0lep__13invfb/)** <br>[CMS]() Run 2 0-lepton jet+MET SUSY analysis, with 13/fb of data.  |
| class | **[Gambit::ColliderBit::Analysis_CMS_13TeV_0LEP_36invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__cms__13tev__0lep__36invfb/)** <br>[CMS]() Run 2 0-lepton jet+MET SUSY analysis, with 36/fb of data.  |
| class | **[Gambit::ColliderBit::Analysis_CMS_13TeV_1LEPbb_36invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__cms__13tev__1lepbb__36invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_CMS_13TeV_1LEPStop_36invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__cms__13tev__1lepstop__36invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_CMS_13TeV_1Photon1Lepton_36invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__cms__13tev__1photon1lepton__36invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_CMS_13TeV_1Photon1Lepton_emu_combined_36invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__cms__13tev__1photon1lepton__emu__combined__36invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_CMS_13TeV_2LEPsoft_36invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__cms__13tev__2lepsoft__36invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_CMS_13TeV_2LEPsoft_36invfb_nocovar](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__cms__13tev__2lepsoft__36invfb__nocovar/)**  |
| class | **[Gambit::ColliderBit::Analysis_CMS_13TeV_2LEPsoft_stop_36invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__cms__13tev__2lepsoft__stop__36invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_CMS_13TeV_2LEPsoft_stop_36invfb_nocovar](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__cms__13tev__2lepsoft__stop__36invfb__nocovar/)**  |
| class | **[Gambit::ColliderBit::Analysis_CMS_13TeV_2LEPStop_36invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__cms__13tev__2lepstop__36invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_CMS_13TeV_2OSLEP_36invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__cms__13tev__2oslep__36invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_CMS_13TeV_2OSLEP_36invfb_nocovar](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__cms__13tev__2oslep__36invfb__nocovar/)**  |
| class | **[Gambit::ColliderBit::Analysis_CMS_13TeV_2OSLEP_chargino_stop_36invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__cms__13tev__2oslep__chargino__stop__36invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_CMS_13TeV_2OSLEP_confnote_36invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__cms__13tev__2oslep__confnote__36invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_CMS_13TeV_2OSLEP_for_chargino_36invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__cms__13tev__2oslep__for__chargino__36invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_CMS_13TeV_2OSLEP_for_stop_36invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__cms__13tev__2oslep__for__stop__36invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_CMS_13TeV_2Photon_GMSB_36invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__cms__13tev__2photon__gmsb__36invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_CMS_13TeV_2SSLEP_Stop_137invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__cms__13tev__2sslep__stop__137invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_CMS_13TeV_2SSLEP_Stop_36invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__cms__13tev__2sslep__stop__36invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_CMS_13TeV_2SSLEP_Stop_exclusive_36invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__cms__13tev__2sslep__stop__exclusive__36invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_CMS_13TeV_2SSLEP_Stop_inclusive_36invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__cms__13tev__2sslep__stop__inclusive__36invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_CMS_13TeV_MONOJET_36invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__cms__13tev__monojet__36invfb/)** <br>[CMS]() Run 2 monojet analysis (no W/Z region) with 36/fb of data.  |
| class | **[Gambit::ColliderBit::Analysis_CMS_13TeV_MultiLEP_2SSLep_36invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__cms__13tev__multilep__2sslep__36invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_CMS_13TeV_MultiLEP_36invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__cms__13tev__multilep__36invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_CMS_13TeV_MultiLEP_3Lep_36invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__cms__13tev__multilep__3lep__36invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_CMS_13TeV_MultiLEP_Full_2SSLep_36invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__cms__13tev__multilep__full__2sslep__36invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_CMS_13TeV_MultiLEP_Full_36invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__cms__13tev__multilep__full__36invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_CMS_13TeV_MultiLEP_Full_3Lep_36invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__cms__13tev__multilep__full__3lep__36invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_CMS_13TeV_MultiLEP_Full_3Lep_rebinned_36invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__cms__13tev__multilep__full__3lep__rebinned__36invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_CMS_13TeV_Photon_GMSB_36invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__cms__13tev__photon__gmsb__36invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_CMS_8TeV_1LEPDMTOP_20invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__cms__8tev__1lepdmtop__20invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_CMS_8TeV_2LEPDMTOP_20invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__cms__8tev__2lepdmtop__20invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_CMS_8TeV_MONOJET_20invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__cms__8tev__monojet__20invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_CMS_8TeV_MultiLEP_20invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__cms__8tev__multilep__20invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_CMS_8TeV_MultiLEP_3Lep_20invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__cms__8tev__multilep__3lep__20invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_CMS_8TeV_MultiLEP_4Lep_20invfb](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__cms__8tev__multilep__4lep__20invfb/)**  |
| class | **[Gambit::ColliderBit::Analysis_Covariance](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__covariance/)** <br>Dummy analysis code with a hard-coded return including a SR covariance matrix.  |
| class | **[Gambit::ColliderBit::Analysis_Minimum](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis__minimum/)** <br>Basic analysis code for copying.  |
| class | **[Gambit::ColliderBit::AnalysisContainer](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysiscontainer/)** <br>A class for managing collections of [Analysis](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis/) instances.  |
| struct | **[Gambit::ColliderBit::AnalysisData](/documentation/code/main/classes/structgambit_1_1colliderbit_1_1analysisdata/)**  |
| struct | **[Gambit::ColliderBit::AnalysisLogLikes](/documentation/code/main/classes/structgambit_1_1colliderbit_1_1analysisloglikes/)** <br>Container for loglike information for an analysis.  |
| class | **[Gambit::ColliderBit::AnalysisUtil](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysisutil/)**  |
| class | **[Gambit::ColliderBit::BaseCollider](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1basecollider/)** <br>An abstract base class for collider simulators within ColliderBit.  |
| class | **[Gambit::ColliderBit::BaseDetector](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1basedetector/)** <br>An abstract base class for detector simulators within ColliderBit.  |
| class | **[Gambit::ColliderBit::BaseLimitContainer](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1baselimitcontainer/)** <br>Base class for experimental limit curve interpolation.  |
| class | **[Gambit::ColliderBit::BuckFast](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1buckfast/)** <br>A base class for [BuckFast]() simple smearing simulations within ColliderBit.  |
| struct | **[Gambit::ColliderBit::convergence_settings](/documentation/code/main/classes/structgambit_1_1colliderbit_1_1convergence__settings/)** <br>Type for holding Monte Carlo convergence settings.  |
| struct | **[Gambit::ColliderBit::Cutflow](/documentation/code/main/classes/structgambit_1_1colliderbit_1_1cutflow/)** <br>A tracker of numbers & fractions of events passing sequential cuts.  |
| struct | **[Gambit::ColliderBit::Cutflows](/documentation/code/main/classes/structgambit_1_1colliderbit_1_1cutflows/)** <br>A container for several [Cutflow](/documentation/code/main/classes/structgambit_1_1colliderbit_1_1cutflow/) objects, with some convenient batch access.  |
| class | **[Gambit::ColliderBit::DMEFT_analysis_info](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1dmeft__analysis__info/)**  |
| class | **[Gambit::ColliderBit::EventCounter](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1eventcounter/)** <br>A simple class for counting events of type HEPUtils::Event.  |
| class | **[Gambit::ColliderBit::ImageLimit](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1imagelimit/)**  |
| class | **[Gambit::ColliderBit::L3ChargedGauginoSmallDeltaMAnySneutrinoLimitAt188pt6GeV](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1l3chargedgauginosmalldeltamanysneutrinolimitat188pt6gev/)** <br>A class to contain the limit data from L3PLB_482_2000_31, figure 5b.  |
| class | **[Gambit::ColliderBit::L3ChargedGauginoSmallDeltaMWithHeavySneutrinoLimitAt188pt6GeV](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1l3chargedgauginosmalldeltamwithheavysneutrinolimitat188pt6gev/)** <br>A class to contain the limit data from L3PLB_482_2000_31, figure 5a.  |
| class | **[Gambit::ColliderBit::L3ChargedHiggsinoSmallDeltaMLimitAt188pt6GeV](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1l3chargedhiggsinosmalldeltamlimitat188pt6gev/)** <br>A class to contain the limit data from L3PLB_482_2000_31, figure 5c.  |
| class | **[Gambit::ColliderBit::L3CharginoAllChannelsLimitAt188pt6GeV](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1l3charginoallchannelslimitat188pt6gev/)** <br>A class to contain the limit data from L3PLB_472_2000_420, figure 2a.  |
| class | **[Gambit::ColliderBit::L3CharginoLeptonicLimitAt188pt6GeV](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1l3charginoleptoniclimitat188pt6gev/)** <br>A class to contain the limit data from L3PLB_472_2000_420, figure 2b.  |
| class | **[Gambit::ColliderBit::L3NeutralinoAllChannelsLimitAt188pt6GeV](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1l3neutralinoallchannelslimitat188pt6gev/)** <br>A class to contain the limit data from L3PLB_472_2000_420, figure 3a.  |
| class | **[Gambit::ColliderBit::L3NeutralinoLeptonicLimitAt188pt6GeV](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1l3neutralinoleptoniclimitat188pt6gev/)** <br>A class to contain the limit data from L3PLB_472_2000_420, figure 3b.  |
| class | **[Gambit::ColliderBit::L3SelectronLimitAt205GeV](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1l3selectronlimitat205gev/)** <br>A class to contain the limit data from L3_PLB580_2004_37, figure 2a.  |
| class | **[Gambit::ColliderBit::L3SmuonLimitAt205GeV](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1l3smuonlimitat205gev/)** <br>A class to contain the limit data from L3_PLB580_2004_37, figure 2b.  |
| class | **[Gambit::ColliderBit::L3StauLimitAt205GeV](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1l3staulimitat205gev/)** <br>A class to contain the limit data from L3_PLB580_2004_37, figure 2c.  |
| class | **[Gambit::ColliderBit::LineSegment](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1linesegment/)** <br>A simple container for a line segment on an xy plane.  |
| class | **[Gambit::ColliderBit::MC_convergence_checker](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1mc__convergence__checker/)** <br>Helper class for testing for convergence of analyses.  |
| class | **[Gambit::ColliderBit::MC_xsec_container](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1mc__xsec__container/)** <br>A class for holding a total cross-section calculated via MC across multiple threads.  |
| struct | **[Gambit::ColliderBit::MCLoopInfo](/documentation/code/main/classes/structgambit_1_1colliderbit_1_1mcloopinfo/)** <br>Container for event loop status data and settings.  |
| class | **[Gambit::ColliderBit::MT2](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1mt2/)** <br>A useful [MT2]() class for this module.  |
| class | **[Gambit::ColliderBit::OPALCharginoAllChannelsLimitAt208GeV](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1opalcharginoallchannelslimitat208gev/)** <br>A class to contain the limit data from OPAL_EPJC35_2004_1, figure 8b.  |
| class | **[Gambit::ColliderBit::OPALCharginoHadronicLimitAt208GeV](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1opalcharginohadroniclimitat208gev/)** <br>A class to contain the limit data from OPAL_EPJC35_2004_1, figure 5b.  |
| class | **[Gambit::ColliderBit::OPALCharginoLeptonicLimitAt208GeV](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1opalcharginoleptoniclimitat208gev/)** <br>A class to contain the limit data from OPAL_EPJC35_2004_1, figure 7b.  |
| class | **[Gambit::ColliderBit::OPALCharginoSemiLeptonicLimitAt208GeV](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1opalcharginosemileptoniclimitat208gev/)** <br>A class to contain the limit data from OPAL_EPJC35_2004_1, figure 6b.  |
| class | **[Gambit::ColliderBit::OPALDegenerateCharginoLimitAt208GeV](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1opaldegeneratecharginolimitat208gev/)** <br>A class to contain the limit data from OPAL, hep-ex/0210043, figure 5a (in colour)  |
| class | **[Gambit::ColliderBit::OPALNeutralinoHadronicLimitAt208GeV](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1opalneutralinohadroniclimitat208gev/)** <br>A class to contain the limit data from OPAL_EPJC35_2004_1, figure 9b.  |
| class | **[Gambit::ColliderBit::OPALNeutralinoHadronicViaZLimitAt208GeV](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1opalneutralinohadronicviazlimitat208gev/)** <br>A class to contain the limit data from OPAL_EPJC35_2004_1, figure 9b.  |
| class | **[Gambit::ColliderBit::P2](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1p2/)** <br>A simple container for a point on an xy plane.  |
| class | **[Gambit::ColliderBit::Perf_Plot](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1perf__plot/)**  |
| class | **[Gambit::ColliderBit::PID_pair_xsec_container](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1pid__pair__xsec__container/)** <br>A class for holding the production cross-section for final state identified by the pair of PID codes.  |
| class | **[Gambit::ColliderBit::process_xsec_container](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1process__xsec__container/)** <br>A class for holding the cross-section of a single Pythia process (identified by the Pythia process code)  |
| class | **[Gambit::ColliderBit::Py8Collider](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1py8collider/)** <br>A specializable, recyclable class interfacing ColliderBit and Pythia.  |
| class | **[Gambit::ColliderBit::SetHooks](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1sethooks/)** <br>A templated class specific for the UserHooks.  |
| struct | **[Gambit::ColliderBit::SignalRegionData](/documentation/code/main/classes/structgambit_1_1colliderbit_1_1signalregiondata/)** <br>A simple container for the result of one signal region from one analysis.  |
| class | **[Gambit::ColliderBit::xsec_container](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1xsec__container/)** <br>A base class for holding cross-section info within ColliderBit.  |

## Types

|                | Name           |
| -------------- | -------------- |
| enum| **[specialIterations](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#enum-specialiterations)** { BASE_INIT = -1, COLLIDER_INIT = -2, COLLIDER_INIT_OMP = -3, XSEC_CALCULATION = -4, START_SUBPROCESS = -5, COLLECT_CONVERGENCE_DATA = -6, CHECK_CONVERGENCE = -7, END_SUBPROCESS = -8, COLLIDER_FINALIZE = -9, BASE_FINALIZE = -10}<br>Special iteration labels for the loop controlled by operateLHCLoop.  |
| typedef std::vector< [AnalysisData](/documentation/code/main/classes/structgambit_1_1colliderbit_1_1analysisdata/) > | **[AnalysisNumbers](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-analysisnumbers)** <br>Container for data from multiple analyses and SRs.  |
| typedef std::vector< [AnalysisData](/documentation/code/main/classes/structgambit_1_1colliderbit_1_1analysisdata/) * > | **[AnalysisDataPointers](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-analysisdatapointers)**  |
| typedef std::map< std::string, [AnalysisLogLikes](/documentation/code/main/classes/structgambit_1_1colliderbit_1_1analysisloglikes/) > | **[map_str_AnalysisLogLikes](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-map-str-analysisloglikes)** <br>Typedef for a string-to-AnalysisLogLikes map.  |
| typedef std::vector< [AnalysisContainer](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysiscontainer/) > | **[AnalysisContainers](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-analysiscontainers)** <br>Container for multiple analysis containers.  |
| typedef std::chrono::milliseconds | **[ms](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-ms)**  |
| typedef std::chrono::steady_clock | **[steady_clock](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-steady-clock)**  |
| typedef std::chrono::steady_clock::time_point | **[tp](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-tp)**  |
| typedef std::map< std::string, double > | **[timer_map_type](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-timer-map-type)**  |
| typedef std::pair< std::string, SLHAstruct > | **[pair_str_SLHAstruct](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-pair-str-slhastruct)** <br>Typedef for a str-SLHAstruct pair, to pass around SLHA filenames + content.  |
| typedef std::vector< std::pair< int, int > > | **[vec_iipair](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-vec-iipair)** <br>Typedefs related to cross-sections.  |
| typedef std::vector< PID_pair > | **[vec_PID_pair](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-vec-pid-pair)**  |
| typedef std::multimap< int, std::pair< int, int > > | **[multimap_int_iipair](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-multimap-int-iipair)**  |
| typedef std::multimap< int, PID_pair > | **[multimap_int_PID_pair](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-multimap-int-pid-pair)**  |
| typedef std::multimap< PID_pair, int > | **[multimap_PID_pair_int](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-multimap-pid-pair-int)**  |
| typedef std::map< int, [xsec_container](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1xsec__container/) > | **[map_int_xsec](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-map-int-xsec)**  |
| typedef std::map< int, [process_xsec_container](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1process__xsec__container/) > | **[map_int_process_xsec](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-map-int-process-xsec)**  |
| typedef std::map< std::pair< int, int >, [PID_pair_xsec_container](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1pid__pair__xsec__container/) > | **[map_iipair_PID_pair_xsec](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-map-iipair-pid-pair-xsec)**  |
| typedef std::map< PID_pair, [PID_pair_xsec_container](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1pid__pair__xsec__container/) > | **[map_PID_pair_PID_pair_xsec](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-map-pid-pair-pid-pair-xsec)**  |
| typedef HEPUtils::Event | **[HEPUtils_Event](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-heputils-event)** <br>Typedef for a std::function that sets the weight for the input HEPUtils::Event.  |
| typedef std::function< void([HEPUtils_Event](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-heputils-event) &, const [BaseCollider](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1basecollider/) *)> | **[EventWeighterFunctionType](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-eventweighterfunctiontype)**  |
| typedef std::vector< std::vector< double > > | **[MixMatrix](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-mixmatrix)**  |
| typedef std::vector< std::vector< double > > | **[data_type](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-data-type)**  |
| typedef std::vector< const HEPUtils::Particle * > | **[ParticlePtrs](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-particleptrs)** <br>Typedef for a vector of Particle pointers.  |
| typedef std::vector< const HEPUtils::Jet * > | **[JetPtrs](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-jetptrs)** <br>Typedef for a vector of Jet pointers.  |

## Functions

|                | Name           |
| -------------- | -------------- |
| template <typename Vec4T \> <br>FJNS::PseudoJet | **[mk_pseudojet](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-mk-pseudojet)**(const Vec4T & p) |
| template <typename Vec4T \> <br>HEPUtils::P4 | **[mk_p4](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-mk-p4)**(const Vec4T & p) |
| template <typename EventT \> <br>bool | **[fromBottom](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-frombottom)**(int n, const EventT & evt) |
| template <typename EventT \> <br>bool | **[fromTau](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-fromtau)**(int n, const EventT & evt) |
| template <typename EventT \> <br>bool | **[fromHadron](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-fromhadron)**(int n, const EventT & evt) |
| template <typename EventT \> <br>bool | **[isFinalB](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-isfinalb)**(int n, const EventT & evt) |
| template <typename EventT \> <br>bool | **[isFinalTau](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-isfinaltau)**(int n, const EventT & evt) |
| template <typename EventT \> <br>bool | **[isParton](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-isparton)**(int n, const EventT & evt) |
| template <typename EventT \> <br>bool | **[isFinalParton](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-isfinalparton)**(int n, const EventT & evt) |
| template <typename EventT \> <br>bool | **[isFinalPhoton](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-isfinalphoton)**(int n, const EventT & evt) |
| template <typename EventT \> <br>bool | **[isFinalLepton](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-isfinallepton)**(int n, const EventT & evt) |
| void | **[get_sigma_ee_ll](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-get-sigma-ee-ll)**(triplet< double > & result, const double sqrts, const int generation, const int l_chirality, const int lbar_chirality, const double gtol, const double ftol, const bool gpt_error, const bool fpt_error, const Spectrum & spec, const double gammaZ, const bool l_are_gauge_es) |
| void | **[get_sigma_ee_chi00](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-get-sigma-ee-chi00)**(triplet< double > & result, const double sqrts, const int chi_first, const int chi_second, const double tol, const bool pt_error, const Spectrum & spec, const double gammaZ)<br>Retrieve the production cross-section at an e+e- collider for neutralino pairs.  |
| void | **[get_sigma_ee_chipm](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-get-sigma-ee-chipm)**(triplet< double > & result, const double sqrts, const int chi_plus, const int chi_minus, const double tol, const bool pt_error, const Spectrum & spec, const double gammaZ)<br>Retrieve the production cross-section at an e+e- collider for chargino pairs.  |
| double | **[xsec_sleislej](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-xsec-sleislej)**(int pid1, int pid2, double sqrts, double m1, double m2, MixMatrix F, MixMatrix N, const double mN[4], double alpha, double mZ, double gZ, double sin2thetaW, bool warn_on_CP_violating_masses =true) |
| double | **[xsec_neuineuj](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-xsec-neuineuj)**(int pid1, int pid2, double sqrts, double m1, double m2, MixMatrix N, const double mS[2], double tanb, double alpha, double mZ, double gZ, double sin2thetaW) |
| double | **[xsec_chaichaj](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-xsec-chaichaj)**(int pid1, int pid2, double sqrts, double m1, double m2, MixMatrix V, MixMatrix U, double msn, double alpha, double mZ, double gZ, double sin2thetaW) |
| void | **[SLHA2BFM_NN](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-slha2bfm-nn)**(MixMatrix & NN, double tanb, double sin2thetaW)<br>Functions to convert mass matrices between SLHA and BFM conventions ////////////////////////////////////////////////////////////////////.  |
| void | **[SLHA2BFM_VV](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-slha2bfm-vv)**(MixMatrix & VV)<br>Converts the chargino mixing matrix V in SLHA conventions to BFM conventions.  |
| void | **[BFM2SLHA_NN](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-bfm2slha-nn)**(MixMatrix & NN, double tanb, double sin2thetaW)<br>Converts a neutralino mixing matrix in BFM conventions to SLHA conventions, \(\tan\beta\) is as defined in SLHA.  |
| void | **[BFM2SLHA_VV](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-bfm2slha-vv)**(MixMatrix & VV)<br>Converts the chargino mixing matrix V in BFM conventions to SLHA conventions.  |
| MixMatrix | **[multiply](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-multiply)**(MixMatrix A, MixMatrix B)<br>Helper function to multiply matrices.  |
| MixMatrix | **[transpose](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-transpose)**(MixMatrix A)<br>Helper function to find matrix transpose.  |
| void | **[print](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-print)**(MixMatrix A)<br>Helper function to print a matrix.  |
| [P2](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1p2/) | **[operator+](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-operator+)**(const [P2](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1p2/) & a, const [P2](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1p2/) & b) |
| [P2](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1p2/) | **[operator-](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-operator-)**(const [P2](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1p2/) & a, const [P2](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1p2/) & b) |
| [P2](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1p2/) | **[operator*](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-operator*)**(const [P2](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1p2/) & a, double f) |
| [P2](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1p2/) | **[operator*](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-operator*)**(double f, const [P2](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1p2/) & a) |
| [P2](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1p2/) | **[operator/](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-operator/)**(const [P2](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1p2/) & a, double f) |
| std::string | **[to_str](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-to-str)**(const [P2](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1p2/) & p2)<br>Make a string representation of the vector.  |
| std::ostream & | **[operator<<](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-operator<<)**(std::ostream & ostr, const [P2](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1p2/) & p2)<br>Write a string representation of the vector to the provided stream.  |
| std::string | **[to_str](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-to-str)**(const [LineSegment](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1linesegment/) & lineseg)<br>Make a string representation of the [LineSegment]().  |
| std::ostream & | **[operator<<](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-operator<<)**(std::ostream & ostr, const [LineSegment](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1linesegment/) & lineseg)<br>Write a string representation of the vector to the provided stream.  |
| bool | **[amIaJet](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-amiajet)**(const HEPUtils::Jet * jet)<br>Identifier for jets true.  |
| bool | **[amIaBJet](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-amiabjet)**(const HEPUtils::Jet * jet)<br>Indentifier for b-jets true.  |
| bool | **[amIaJet](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-amiajet)**(const HEPUtils::Particle * part)<br>Identifier for jets false.  |
| bool | **[amIaBJet](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-amiabjet)**(const HEPUtils::Particle * part)<br>Indentifier for b-jets true.  |
| template <typename CONTAINER ,typename RMFN \> <br>void | **[iremoveerase](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-iremoveerase)**(CONTAINER & c, const RMFN & fn)<br>Convenience combination of remove_if and erase.  |
| void | **[ifilter_reject](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-ifilter-reject)**([ParticlePtrs](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-particleptrs) & particles, std::function< bool(const Particle *)> rejfn, bool do_delete =true)<br>In-place filter a supplied particle vector by rejecting those which fail a supplied cut.  |
| void | **[ifilter_select](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-ifilter-select)**([ParticlePtrs](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-particleptrs) & particles, std::function< bool(const Particle *)> selfn, bool do_delete =true)<br>In-place filter a supplied particle vector by keeping those which pass a supplied cut.  |
| [ParticlePtrs](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-particleptrs) | **[filter_reject](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-filter-reject)**(const [ParticlePtrs](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-particleptrs) & particles, std::function< bool(const Particle *)> rejfn, bool do_delete =true) |
| [ParticlePtrs](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-particleptrs) | **[filter_select](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-filter-select)**(const [ParticlePtrs](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-particleptrs) & particles, std::function< bool(const Particle *)> selfn, bool do_delete =true)<br>Filter a supplied particle vector by keeping those which pass a supplied cut.  |
| void | **[ifilter_reject](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-ifilter-reject)**([JetPtrs](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-jetptrs) & jets, std::function< bool(const Jet *)> rejfn, bool do_delete =true)<br>In-place filter a supplied jet vector by rejecting those which fail a supplied cut.  |
| void | **[ifilter_select](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-ifilter-select)**([JetPtrs](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-jetptrs) & jets, std::function< bool(const Jet *)> selfn, bool do_delete =true)<br>In-place filter a supplied jet vector by keeping those which pass a supplied cut.  |
| [JetPtrs](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-jetptrs) | **[filter_reject](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-filter-reject)**(const [JetPtrs](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-jetptrs) & jets, std::function< bool(const Jet *)> rejfn, bool do_delete =true) |
| [JetPtrs](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-jetptrs) | **[filter_select](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-filter-select)**(const [JetPtrs](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-jetptrs) & jets, std::function< bool(const Jet *)> selfn, bool do_delete =true)<br>Filter a supplied particle vector by keeping those which pass a supplied cut.  |
| bool | **[random_bool](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-random-bool)**(double eff)<br>Return a random true/false at a success rate given by a number.  |
| bool | **[random_bool](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-random-bool)**(const HEPUtils::BinnedFn1D< double > & effmap, double x)<br>Return a random true/false at a success rate given by a 1D efficiency map.  |
| bool | **[random_bool](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-random-bool)**(const HEPUtils::BinnedFn2D< double > & effmap, double x, double y)<br>Return a random true/false at a success rate given by a 2D efficiency map.  |
| void | **[filtereff](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-filtereff)**(std::vector< const HEPUtils::Particle * > & particles, double eff, bool do_delete =false)<br>Utility function for filtering a supplied particle vector by sampling wrt an efficiency scalar.  |
| void | **[filtereff](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-filtereff)**(std::vector< const HEPUtils::Particle * > & particles, std::function< double(const HEPUtils::Particle *)> eff_fn, bool do_delete =false)<br>Utility function for filtering a supplied particle vector by sampling an efficiency returned by a provided function object.  |
| void | **[filtereff_pt](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-filtereff-pt)**(std::vector< const HEPUtils::Particle * > & particles, const HEPUtils::BinnedFn1D< double > & eff_pt, bool do_delete =false)<br>Utility function for filtering a supplied particle vector by sampling wrt a binned 1D efficiency map in pT.  |
| void | **[filtereff_etapt](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-filtereff-etapt)**(std::vector< const HEPUtils::Particle * > & particles, const HEPUtils::BinnedFn2D< double > & eff_etapt, bool do_delete =false)<br>Utility function for filtering a supplied particle vector by sampling wrt a binned 2D efficiency map in |eta| and pT.  |
| bool | **[has_tag](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-has-tag)**(const HEPUtils::BinnedFn2D< double > & effmap, double eta, double pt) |
| std::map< const HEPUtils::Jet *, bool > | **[generateBTagsMap](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-generatebtagsmap)**(const std::vector< const HEPUtils::Jet * > & jets, double bTagEff, double cMissTagEff, double otherMissTagEff, double pTmin =0., double absEtaMax =DBL_MAX)<br>Return a map<Jet*,bool> containing a generated b-tag for every jet in the input vector.  |
| template <typename NUM1 ,typename NUM2 \> <br>size_t | **[binIndex](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-binindex)**(NUM1 val, const std::vector< NUM2 > & binedges, bool allow_overflow =false) |
| std::vector< double > | **[mk_bin_values](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-mk-bin-values)**(const std::vector< double > & binEdgeValues)<br>Make a vector of central bin values from a vector of bin edge values using linear interpolation.  |
| std::vector< double > | **[makeBinValues](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-makebinvalues)**(const std::vector< double > & binEdgeValues)<br>Alias.  |
| template <typename MOM \> <br>std::vector< std::shared_ptr< HEPUtils::Jet > > | **[get_jets](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-get-jets)**(const std::vector< MOM * > & moms, double R, double ptmin =0 *GeV, FJNS::JetAlgorithm alg =FJNS::antikt_algorithm)<br>Run jet clustering from any P4-compatible momentum type.  |
| bool | **[object_in_cone](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-object-in-cone)**(const HEPUtils::Event & e, const HEPUtils::P4 & p4, double ptmin, double rmax, double rmin =0.05)<br>Check if there's a physics object above ptmin in an annulus rmin..rmax around the given four-momentum p4.  |
| template <typename MOMPTRS1 ,typename MOMPTRS2 \> <br>void | **[removeOverlap](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-removeoverlap)**(MOMPTRS1 & momstofilter, const MOMPTRS2 & momstocmp, double deltaRMax, bool use_rapidity =false, double pTmax =DBL_MAX, double btageff =0) |
| template <typename MOMPTRS1 ,typename MOMPTRS2 \> <br>void | **[removeOverlap](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-removeoverlap)**(MOMPTRS1 & momstofilter, const MOMPTRS2 & momstocmp, double(*)(const double) deltaRMax, bool use_rapidity =false, double pTmax =DBL_MAX, double btageff =0) |
| template <typename MOMPTRS1 \> <br>void | **[removeOverlapIfBjet](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-removeoverlapifbjet)**(MOMPTRS1 & momstofilter, std::vector< const HEPUtils::Jet * > & jets, double deltaRMax, bool use_rapidity =false, double pTmax =DBL_MAX) |
| template <typename CONTAINER ,typename FN \> <br>bool | **[all_of](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-all-of)**(const CONTAINER & c, const FN & f)<br>Non-iterator version of std::all_of.  |
| template <typename CONTAINER ,typename FN \> <br>bool | **[any_of](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-any-of)**(const CONTAINER & c, const FN & f)<br>Non-iterator version of std::any_of.  |
| template <typename CONTAINER ,typename FN \> <br>bool | **[none_of](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-none-of)**(const CONTAINER & c, const FN & f)<br>Non-iterator version of std::none_of.  |
| std::vector< std::vector< const HEPUtils::Particle * > > | **[getSFOSpairs](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-getsfospairs)**(std::vector< const HEPUtils::Particle * > particles)<br>Utility function for returning a collection of same-flavour, oppsosite-sign particle pairs.  |
| std::vector< std::vector< const HEPUtils::Particle * > > | **[getOSpairs](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-getospairs)**(std::vector< const HEPUtils::Particle * > particles)<br>Utility function for returning a collection of oppsosite-sign particle pairs.  |
| std::vector< std::vector< const HEPUtils::Particle * > > | **[getSSpairs](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-getsspairs)**(std::vector< const HEPUtils::Particle * > particles)<br>Utility function for returning a collection of same-sign particle pairs.  |
| void | **[sortBy](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-sortby)**([ParticlePtrs](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-particleptrs) & particles, std::function< bool(const Particle *, const Particle *)> cmpfn)<br>Particle-sorting function.  |
| bool | **[cmpParticlesByPt](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-cmpparticlesbypt)**(const HEPUtils::Particle * lep1, const HEPUtils::Particle * lep2)<br>Comparison function to give a particles sorting order decreasing by pT.  |
| void | **[sortByPt](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-sortbypt)**([ParticlePtrs](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-particleptrs) & particles) |
| void | **[sortBy](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-sortby)**([JetPtrs](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-jetptrs) & jets, std::function< bool(const Jet *, const Jet *)> cmpfn)<br>Jet-sorting function.  |
| bool | **[cmpJetsByPt](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-cmpjetsbypt)**(const HEPUtils::Jet * jet1, const HEPUtils::Jet * jet2)<br>Comparison function to give a jets sorting order decreasing by pT.  |
| void | **[sortByPt](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-sortbypt)**([JetPtrs](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-jetptrs) & jets) |
| int | **[countPt](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-countpt)**(const std::vector< const Particle * > & particles, double pTlim)<br>Count number of particles that have pT > pTlim.  |
| int | **[countPt](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-countpt)**(const std::vector< const Jet * > & jets, double pTlim)<br>Count number of jets that have pT > pTlim.  |
| double | **[scalarSumPt](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-scalarsumpt)**(const std::vector< const Particle * > & particles, double pTlim =0.)<br>Scalar sum pT of particles with pT > pTlim (default pTlim = 0)  |
| double | **[scalarSumPt](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-scalarsumpt)**(const std::vector< const Jet * > & jets, double pTlim =0.)<br>Scalar sum pT of jets.  |
| void | **[LEP208_SLHA1_convention_xsec_selselbar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep208-slha1-convention-xsec-selselbar)**(triplet< double > & result) |
| void | **[LEP208_SLHA1_convention_xsec_selserbar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep208-slha1-convention-xsec-selserbar)**(triplet< double > & result) |
| void | **[LEP208_SLHA1_convention_xsec_serserbar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep208-slha1-convention-xsec-serserbar)**(triplet< double > & result) |
| void | **[LEP208_SLHA1_convention_xsec_serselbar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep208-slha1-convention-xsec-serselbar)**(triplet< double > & result) |
| void | **[LEP208_SLHA1_convention_xsec_se1se1bar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep208-slha1-convention-xsec-se1se1bar)**(triplet< double > & result) |
| void | **[LEP208_SLHA1_convention_xsec_se1se2bar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep208-slha1-convention-xsec-se1se2bar)**(triplet< double > & result) |
| void | **[LEP208_SLHA1_convention_xsec_se2se2bar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep208-slha1-convention-xsec-se2se2bar)**(triplet< double > & result) |
| void | **[LEP208_SLHA1_convention_xsec_se2se1bar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep208-slha1-convention-xsec-se2se1bar)**(triplet< double > & result) |
| void | **[LEP208_SLHA1_convention_xsec_smulsmulbar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep208-slha1-convention-xsec-smulsmulbar)**(triplet< double > & result) |
| void | **[LEP208_SLHA1_convention_xsec_smulsmurbar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep208-slha1-convention-xsec-smulsmurbar)**(triplet< double > & result) |
| void | **[LEP208_SLHA1_convention_xsec_smursmurbar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep208-slha1-convention-xsec-smursmurbar)**(triplet< double > & result) |
| void | **[LEP208_SLHA1_convention_xsec_smursmulbar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep208-slha1-convention-xsec-smursmulbar)**(triplet< double > & result) |
| void | **[LEP208_SLHA1_convention_xsec_smu1smu1bar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep208-slha1-convention-xsec-smu1smu1bar)**(triplet< double > & result) |
| void | **[LEP208_SLHA1_convention_xsec_smu1smu2bar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep208-slha1-convention-xsec-smu1smu2bar)**(triplet< double > & result) |
| void | **[LEP208_SLHA1_convention_xsec_smu2smu2bar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep208-slha1-convention-xsec-smu2smu2bar)**(triplet< double > & result) |
| void | **[LEP208_SLHA1_convention_xsec_smu2smu1bar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep208-slha1-convention-xsec-smu2smu1bar)**(triplet< double > & result) |
| void | **[LEP208_SLHA1_convention_xsec_staulstaulbar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep208-slha1-convention-xsec-staulstaulbar)**(triplet< double > & result) |
| void | **[LEP208_SLHA1_convention_xsec_staulstaurbar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep208-slha1-convention-xsec-staulstaurbar)**(triplet< double > & result) |
| void | **[LEP208_SLHA1_convention_xsec_staurstaurbar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep208-slha1-convention-xsec-staurstaurbar)**(triplet< double > & result) |
| void | **[LEP208_SLHA1_convention_xsec_staurstaulbar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep208-slha1-convention-xsec-staurstaulbar)**(triplet< double > & result) |
| void | **[LEP208_SLHA1_convention_xsec_stau1stau1bar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep208-slha1-convention-xsec-stau1stau1bar)**(triplet< double > & result) |
| void | **[LEP208_SLHA1_convention_xsec_stau1stau2bar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep208-slha1-convention-xsec-stau1stau2bar)**(triplet< double > & result) |
| void | **[LEP208_SLHA1_convention_xsec_stau2stau2bar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep208-slha1-convention-xsec-stau2stau2bar)**(triplet< double > & result) |
| void | **[LEP208_SLHA1_convention_xsec_stau2stau1bar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep208-slha1-convention-xsec-stau2stau1bar)**(triplet< double > & result) |
| void | **[LEP208_SLHA1_convention_xsec_chi00_11](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep208-slha1-convention-xsec-chi00-11)**(triplet< double > & result) |
| void | **[LEP208_SLHA1_convention_xsec_chi00_12](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep208-slha1-convention-xsec-chi00-12)**(triplet< double > & result) |
| void | **[LEP208_SLHA1_convention_xsec_chi00_13](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep208-slha1-convention-xsec-chi00-13)**(triplet< double > & result) |
| void | **[LEP208_SLHA1_convention_xsec_chi00_14](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep208-slha1-convention-xsec-chi00-14)**(triplet< double > & result) |
| void | **[LEP208_SLHA1_convention_xsec_chi00_22](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep208-slha1-convention-xsec-chi00-22)**(triplet< double > & result) |
| void | **[LEP208_SLHA1_convention_xsec_chi00_23](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep208-slha1-convention-xsec-chi00-23)**(triplet< double > & result) |
| void | **[LEP208_SLHA1_convention_xsec_chi00_24](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep208-slha1-convention-xsec-chi00-24)**(triplet< double > & result) |
| void | **[LEP208_SLHA1_convention_xsec_chi00_33](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep208-slha1-convention-xsec-chi00-33)**(triplet< double > & result) |
| void | **[LEP208_SLHA1_convention_xsec_chi00_34](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep208-slha1-convention-xsec-chi00-34)**(triplet< double > & result) |
| void | **[LEP208_SLHA1_convention_xsec_chi00_44](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep208-slha1-convention-xsec-chi00-44)**(triplet< double > & result) |
| void | **[LEP208_SLHA1_convention_xsec_chipm_11](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep208-slha1-convention-xsec-chipm-11)**(triplet< double > & result) |
| void | **[LEP208_SLHA1_convention_xsec_chipm_12](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep208-slha1-convention-xsec-chipm-12)**(triplet< double > & result) |
| void | **[LEP208_SLHA1_convention_xsec_chipm_22](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep208-slha1-convention-xsec-chipm-22)**(triplet< double > & result) |
| void | **[LEP208_SLHA1_convention_xsec_chipm_21](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep208-slha1-convention-xsec-chipm-21)**(triplet< double > & result) |
| void | **[LEP205_SLHA1_convention_xsec_selselbar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep205-slha1-convention-xsec-selselbar)**(triplet< double > & result) |
| void | **[LEP205_SLHA1_convention_xsec_selserbar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep205-slha1-convention-xsec-selserbar)**(triplet< double > & result) |
| void | **[LEP205_SLHA1_convention_xsec_serserbar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep205-slha1-convention-xsec-serserbar)**(triplet< double > & result) |
| void | **[LEP205_SLHA1_convention_xsec_serselbar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep205-slha1-convention-xsec-serselbar)**(triplet< double > & result) |
| void | **[LEP205_SLHA1_convention_xsec_se1se1bar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep205-slha1-convention-xsec-se1se1bar)**(triplet< double > & result) |
| void | **[LEP205_SLHA1_convention_xsec_se1se2bar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep205-slha1-convention-xsec-se1se2bar)**(triplet< double > & result) |
| void | **[LEP205_SLHA1_convention_xsec_se2se2bar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep205-slha1-convention-xsec-se2se2bar)**(triplet< double > & result) |
| void | **[LEP205_SLHA1_convention_xsec_se2se1bar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep205-slha1-convention-xsec-se2se1bar)**(triplet< double > & result) |
| void | **[LEP205_SLHA1_convention_xsec_smulsmulbar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep205-slha1-convention-xsec-smulsmulbar)**(triplet< double > & result) |
| void | **[LEP205_SLHA1_convention_xsec_smulsmurbar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep205-slha1-convention-xsec-smulsmurbar)**(triplet< double > & result) |
| void | **[LEP205_SLHA1_convention_xsec_smursmurbar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep205-slha1-convention-xsec-smursmurbar)**(triplet< double > & result) |
| void | **[LEP205_SLHA1_convention_xsec_smursmulbar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep205-slha1-convention-xsec-smursmulbar)**(triplet< double > & result) |
| void | **[LEP205_SLHA1_convention_xsec_smu1smu1bar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep205-slha1-convention-xsec-smu1smu1bar)**(triplet< double > & result) |
| void | **[LEP205_SLHA1_convention_xsec_smu1smu2bar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep205-slha1-convention-xsec-smu1smu2bar)**(triplet< double > & result) |
| void | **[LEP205_SLHA1_convention_xsec_smu2smu2bar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep205-slha1-convention-xsec-smu2smu2bar)**(triplet< double > & result) |
| void | **[LEP205_SLHA1_convention_xsec_smu2smu1bar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep205-slha1-convention-xsec-smu2smu1bar)**(triplet< double > & result) |
| void | **[LEP205_SLHA1_convention_xsec_staulstaulbar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep205-slha1-convention-xsec-staulstaulbar)**(triplet< double > & result) |
| void | **[LEP205_SLHA1_convention_xsec_staulstaurbar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep205-slha1-convention-xsec-staulstaurbar)**(triplet< double > & result) |
| void | **[LEP205_SLHA1_convention_xsec_staurstaurbar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep205-slha1-convention-xsec-staurstaurbar)**(triplet< double > & result) |
| void | **[LEP205_SLHA1_convention_xsec_staurstaulbar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep205-slha1-convention-xsec-staurstaulbar)**(triplet< double > & result) |
| void | **[LEP205_SLHA1_convention_xsec_stau1stau1bar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep205-slha1-convention-xsec-stau1stau1bar)**(triplet< double > & result) |
| void | **[LEP205_SLHA1_convention_xsec_stau1stau2bar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep205-slha1-convention-xsec-stau1stau2bar)**(triplet< double > & result) |
| void | **[LEP205_SLHA1_convention_xsec_stau2stau2bar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep205-slha1-convention-xsec-stau2stau2bar)**(triplet< double > & result) |
| void | **[LEP205_SLHA1_convention_xsec_stau2stau1bar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep205-slha1-convention-xsec-stau2stau1bar)**(triplet< double > & result) |
| void | **[LEP205_SLHA1_convention_xsec_chi00_11](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep205-slha1-convention-xsec-chi00-11)**(triplet< double > & result) |
| void | **[LEP205_SLHA1_convention_xsec_chi00_12](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep205-slha1-convention-xsec-chi00-12)**(triplet< double > & result) |
| void | **[LEP205_SLHA1_convention_xsec_chi00_13](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep205-slha1-convention-xsec-chi00-13)**(triplet< double > & result) |
| void | **[LEP205_SLHA1_convention_xsec_chi00_14](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep205-slha1-convention-xsec-chi00-14)**(triplet< double > & result) |
| void | **[LEP205_SLHA1_convention_xsec_chi00_22](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep205-slha1-convention-xsec-chi00-22)**(triplet< double > & result) |
| void | **[LEP205_SLHA1_convention_xsec_chi00_23](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep205-slha1-convention-xsec-chi00-23)**(triplet< double > & result) |
| void | **[LEP205_SLHA1_convention_xsec_chi00_24](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep205-slha1-convention-xsec-chi00-24)**(triplet< double > & result) |
| void | **[LEP205_SLHA1_convention_xsec_chi00_33](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep205-slha1-convention-xsec-chi00-33)**(triplet< double > & result) |
| void | **[LEP205_SLHA1_convention_xsec_chi00_34](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep205-slha1-convention-xsec-chi00-34)**(triplet< double > & result) |
| void | **[LEP205_SLHA1_convention_xsec_chi00_44](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep205-slha1-convention-xsec-chi00-44)**(triplet< double > & result) |
| void | **[LEP205_SLHA1_convention_xsec_chipm_11](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep205-slha1-convention-xsec-chipm-11)**(triplet< double > & result) |
| void | **[LEP205_SLHA1_convention_xsec_chipm_12](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep205-slha1-convention-xsec-chipm-12)**(triplet< double > & result) |
| void | **[LEP205_SLHA1_convention_xsec_chipm_22](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep205-slha1-convention-xsec-chipm-22)**(triplet< double > & result) |
| void | **[LEP205_SLHA1_convention_xsec_chipm_21](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep205-slha1-convention-xsec-chipm-21)**(triplet< double > & result) |
| void | **[LEP188_SLHA1_convention_xsec_selselbar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep188-slha1-convention-xsec-selselbar)**(triplet< double > & result) |
| void | **[LEP188_SLHA1_convention_xsec_selserbar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep188-slha1-convention-xsec-selserbar)**(triplet< double > & result) |
| void | **[LEP188_SLHA1_convention_xsec_serserbar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep188-slha1-convention-xsec-serserbar)**(triplet< double > & result) |
| void | **[LEP188_SLHA1_convention_xsec_serselbar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep188-slha1-convention-xsec-serselbar)**(triplet< double > & result) |
| void | **[LEP188_SLHA1_convention_xsec_se1se1bar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep188-slha1-convention-xsec-se1se1bar)**(triplet< double > & result) |
| void | **[LEP188_SLHA1_convention_xsec_se1se2bar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep188-slha1-convention-xsec-se1se2bar)**(triplet< double > & result) |
| void | **[LEP188_SLHA1_convention_xsec_se2se2bar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep188-slha1-convention-xsec-se2se2bar)**(triplet< double > & result) |
| void | **[LEP188_SLHA1_convention_xsec_se2se1bar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep188-slha1-convention-xsec-se2se1bar)**(triplet< double > & result) |
| void | **[LEP188_SLHA1_convention_xsec_smulsmulbar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep188-slha1-convention-xsec-smulsmulbar)**(triplet< double > & result) |
| void | **[LEP188_SLHA1_convention_xsec_smulsmurbar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep188-slha1-convention-xsec-smulsmurbar)**(triplet< double > & result) |
| void | **[LEP188_SLHA1_convention_xsec_smursmurbar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep188-slha1-convention-xsec-smursmurbar)**(triplet< double > & result) |
| void | **[LEP188_SLHA1_convention_xsec_smursmulbar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep188-slha1-convention-xsec-smursmulbar)**(triplet< double > & result) |
| void | **[LEP188_SLHA1_convention_xsec_smu1smu1bar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep188-slha1-convention-xsec-smu1smu1bar)**(triplet< double > & result) |
| void | **[LEP188_SLHA1_convention_xsec_smu1smu2bar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep188-slha1-convention-xsec-smu1smu2bar)**(triplet< double > & result) |
| void | **[LEP188_SLHA1_convention_xsec_smu2smu2bar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep188-slha1-convention-xsec-smu2smu2bar)**(triplet< double > & result) |
| void | **[LEP188_SLHA1_convention_xsec_smu2smu1bar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep188-slha1-convention-xsec-smu2smu1bar)**(triplet< double > & result) |
| void | **[LEP188_SLHA1_convention_xsec_staulstaulbar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep188-slha1-convention-xsec-staulstaulbar)**(triplet< double > & result) |
| void | **[LEP188_SLHA1_convention_xsec_staulstaurbar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep188-slha1-convention-xsec-staulstaurbar)**(triplet< double > & result) |
| void | **[LEP188_SLHA1_convention_xsec_staurstaurbar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep188-slha1-convention-xsec-staurstaurbar)**(triplet< double > & result) |
| void | **[LEP188_SLHA1_convention_xsec_staurstaulbar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep188-slha1-convention-xsec-staurstaulbar)**(triplet< double > & result) |
| void | **[LEP188_SLHA1_convention_xsec_stau1stau1bar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep188-slha1-convention-xsec-stau1stau1bar)**(triplet< double > & result) |
| void | **[LEP188_SLHA1_convention_xsec_stau1stau2bar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep188-slha1-convention-xsec-stau1stau2bar)**(triplet< double > & result) |
| void | **[LEP188_SLHA1_convention_xsec_stau2stau2bar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep188-slha1-convention-xsec-stau2stau2bar)**(triplet< double > & result) |
| void | **[LEP188_SLHA1_convention_xsec_stau2stau1bar](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep188-slha1-convention-xsec-stau2stau1bar)**(triplet< double > & result) |
| void | **[LEP188_SLHA1_convention_xsec_chi00_11](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep188-slha1-convention-xsec-chi00-11)**(triplet< double > & result) |
| void | **[LEP188_SLHA1_convention_xsec_chi00_12](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep188-slha1-convention-xsec-chi00-12)**(triplet< double > & result) |
| void | **[LEP188_SLHA1_convention_xsec_chi00_13](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep188-slha1-convention-xsec-chi00-13)**(triplet< double > & result) |
| void | **[LEP188_SLHA1_convention_xsec_chi00_14](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep188-slha1-convention-xsec-chi00-14)**(triplet< double > & result) |
| void | **[LEP188_SLHA1_convention_xsec_chi00_22](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep188-slha1-convention-xsec-chi00-22)**(triplet< double > & result) |
| void | **[LEP188_SLHA1_convention_xsec_chi00_23](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep188-slha1-convention-xsec-chi00-23)**(triplet< double > & result) |
| void | **[LEP188_SLHA1_convention_xsec_chi00_24](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep188-slha1-convention-xsec-chi00-24)**(triplet< double > & result) |
| void | **[LEP188_SLHA1_convention_xsec_chi00_33](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep188-slha1-convention-xsec-chi00-33)**(triplet< double > & result) |
| void | **[LEP188_SLHA1_convention_xsec_chi00_34](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep188-slha1-convention-xsec-chi00-34)**(triplet< double > & result) |
| void | **[LEP188_SLHA1_convention_xsec_chi00_44](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep188-slha1-convention-xsec-chi00-44)**(triplet< double > & result) |
| void | **[LEP188_SLHA1_convention_xsec_chipm_11](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep188-slha1-convention-xsec-chipm-11)**(triplet< double > & result) |
| void | **[LEP188_SLHA1_convention_xsec_chipm_12](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep188-slha1-convention-xsec-chipm-12)**(triplet< double > & result) |
| void | **[LEP188_SLHA1_convention_xsec_chipm_22](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep188-slha1-convention-xsec-chipm-22)**(triplet< double > & result) |
| void | **[LEP188_SLHA1_convention_xsec_chipm_21](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep188-slha1-convention-xsec-chipm-21)**(triplet< double > & result) |
| void | **[ALEPH_Selectron_Conservative_LLike](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-aleph-selectron-conservative-llike)**(double & result) |
| void | **[ALEPH_Smuon_Conservative_LLike](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-aleph-smuon-conservative-llike)**(double & result) |
| void | **[ALEPH_Stau_Conservative_LLike](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-aleph-stau-conservative-llike)**(double & result) |
| void | **[L3_Selectron_Conservative_LLike](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-l3-selectron-conservative-llike)**(double & result) |
| void | **[L3_Smuon_Conservative_LLike](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-l3-smuon-conservative-llike)**(double & result) |
| void | **[L3_Stau_Conservative_LLike](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-l3-stau-conservative-llike)**(double & result) |
| void | **[L3_Neutralino_All_Channels_Conservative_LLike](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-l3-neutralino-all-channels-conservative-llike)**(double & result) |
| void | **[L3_Neutralino_Leptonic_Conservative_LLike](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-l3-neutralino-leptonic-conservative-llike)**(double & result) |
| void | **[L3_Chargino_All_Channels_Conservative_LLike](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-l3-chargino-all-channels-conservative-llike)**(double & result) |
| void | **[L3_Chargino_Leptonic_Conservative_LLike](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-l3-chargino-leptonic-conservative-llike)**(double & result) |
| void | **[OPAL_Chargino_Hadronic_Conservative_LLike](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-opal-chargino-hadronic-conservative-llike)**(double & result) |
| void | **[OPAL_Chargino_SemiLeptonic_Conservative_LLike](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-opal-chargino-semileptonic-conservative-llike)**(double & result) |
| void | **[OPAL_Chargino_Leptonic_Conservative_LLike](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-opal-chargino-leptonic-conservative-llike)**(double & result) |
| void | **[OPAL_Degenerate_Chargino_Conservative_LLike](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-opal-degenerate-chargino-conservative-llike)**(double & result) |
| void | **[OPAL_Chargino_All_Channels_Conservative_LLike](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-opal-chargino-all-channels-conservative-llike)**(double & result) |
| void | **[OPAL_Neutralino_Hadronic_Conservative_LLike](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-opal-neutralino-hadronic-conservative-llike)**(double & result) |
| double | **[I1](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-i1)**(double s, double m1, double m2, double mk, double ml) |
| double | **[I2](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-i2)**(double s, double m1, double m2, double mk, double ml) |
| double | **[I3](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-i3)**(double s, double m1, double m2, double mk) |
| [Analysis](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysis/) * | **[mkAnalysis](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-mkanalysis)**(const str & name)<br>Factory definition.  |
| str | **[getDetector](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-getdetector)**(const str & name)<br>Return the detector to be used for a given analysis name, checking that the analysis exists.  |
| std::ostream & | **[operator<<](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-operator<<)**(std::ostream & os, const [Cutflow](/documentation/code/main/classes/structgambit_1_1colliderbit_1_1cutflow/) & cf)<br>Print a [Cutflow]() to a stream.  |
| std::ostream & | **[operator<<](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-operator<<)**(std::ostream & os, const [Cutflows](/documentation/code/main/classes/structgambit_1_1colliderbit_1_1cutflows/) & cfs)<br>Print a [Cutflows]() to a stream.  |
| template <typename EventT \> <br>void | **[convertParticleEvent](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-convertparticleevent)**(const EventT & pevt, HEPUtils::Event & result, double antiktR, double jet_pt_min) |
| template <typename EventT \> <br>void | **[convertPartonEvent](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-convertpartonevent)**(const EventT & pevt, HEPUtils::Event & result, double antiktR, double jet_pt_min)<br>Convert a partonic (no hadrons) EventT into an unsmeared HEPUtils::Event.  |
| const multimap_PID_pair_int & | **[all_PID_pairs_to_process_codes](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-all-pid-pairs-to-process-codes)**() |
| template <typename PythiaT ,typename hepmc_writerT \> <br>void | **[dropHepMCEventPy8Collider](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-drophepmceventpy8collider)**(const PythiaT * Pythia, const [safe_ptr](/documentation/code/main/classes/classgambit_1_1safe__ptr/)< Options > & runOptions)<br>Drop a HepMC file for the event.  |
| template <typename PythiaT ,typename EventT ,typename hepmc_writerT \> <br>void | **[generateEventPy8Collider](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-generateeventpy8collider)**(HEPUtils::Event & event, const [MCLoopInfo](/documentation/code/main/classes/structgambit_1_1colliderbit_1_1mcloopinfo/) & RunMC, const [Py8Collider](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1py8collider/)< PythiaT, EventT, hepmc_writerT > & HardScatteringSim, const EventWeighterFunctionType & EventWeighterFunction, const int iteration, void(*)() wrapup, const [safe_ptr](/documentation/code/main/classes/classgambit_1_1safe__ptr/)< Options > & runOptions)<br>Generate a hard scattering event with Pythia.  |
| template <typename PythiaT ,typename EventT ,typename hepmc_writerT \> <br>void | **[getPy8Collider](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-getpy8collider)**([Py8Collider](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1py8collider/)< PythiaT, EventT, hepmc_writerT > & result, const [MCLoopInfo](/documentation/code/main/classes/structgambit_1_1colliderbit_1_1mcloopinfo/) & RunMC, const SLHAstruct & slha, const str model_suffix, const int iteration, void(*)() wrapup, const Options & runOptions)<br>Retrieve a Pythia hard-scattering Monte Carlo simulation.  |
| [LineSegment](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1linesegment/) | **[makeLine](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-makeline)**(const [P2](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1p2/) & pt1, const [P2](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1p2/) & pt2)<br>Factory function for lines.  |
| double | **[addInQuad](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-addinquad)**(const double & a, const double & b)<br>Add two numbers in quadrature.  |
| bool | **[sortByPT13](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-sortbypt13)**(const HEPUtils::Jet * jet1, const HEPUtils::Jet * jet2) |
| bool | **[sortByPT13_sharedptr](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-sortbypt13-sharedptr)**(std::shared_ptr< HEPUtils::Jet > jet1, std::shared_ptr< HEPUtils::Jet > jet2) |
| bool | **[sortByMass](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-sortbymass)**(const HEPUtils::Jet * jet1, const HEPUtils::Jet * jet2) |
| bool | **[sortByMass_sharedptr](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-sortbymass-sharedptr)**(std::shared_ptr< HEPUtils::Jet > jet1, std::shared_ptr< HEPUtils::Jet > jet2) |
| double | **[calcMT](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-calcmt)**(HEPUtils::P4 jetMom, HEPUtils::P4 metMom) |
| bool | **[sortByPT_1l](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-sortbypt-1l)**(const HEPUtils::Jet * jet1, const HEPUtils::Jet * jet2) |
| bool | **[sortByPT_1l_sharedptr](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-sortbypt-1l-sharedptr)**(std::shared_ptr< HEPUtils::Jet > jet1, std::shared_ptr< HEPUtils::Jet > jet2) |
| bool | **[sortByMass_1l](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-sortbymass-1l)**(const HEPUtils::Jet * jet1, const HEPUtils::Jet * jet2) |
| bool | **[sortByMass_1l_sharedptr](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-sortbymass-1l-sharedptr)**(std::shared_ptr< HEPUtils::Jet > jet1, std::shared_ptr< HEPUtils::Jet > jet2) |
| double | **[calcMT_1l](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-calcmt-1l)**(HEPUtils::P4 jetMom, HEPUtils::P4 metMom) |
| bool | **[sortByPT_j](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-sortbypt-j)**(const HEPUtils::Jet * jet1, const HEPUtils::Jet * jet2) |
| bool | **[sortByPT_l](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-sortbypt-l)**(const HEPUtils::Particle * lep1, const HEPUtils::Particle * lep2) |
| bool | **[sortByPT_jet](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-sortbypt-jet)**(const HEPUtils::Jet * jet1, const HEPUtils::Jet * jet2) |
| bool | **[sortByPT_lep](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-sortbypt-lep)**(const HEPUtils::Particle * lep1, const HEPUtils::Particle * lep2) |
| bool | **[sortByPT_RJ3L](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-sortbypt-rj3l)**(const HEPUtils::Jet * jet1, const HEPUtils::Jet * jet2) |
| bool | **[sortLepByPT_RJ3L](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-sortlepbypt-rj3l)**(const HEPUtils::Particle * lep1, const HEPUtils::Particle * lep2) |
| bool | **[SortLeptons](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-sortleptons)**(const pair< TLorentzVector, int > lv1, const pair< TLorentzVector, int > lv2) |
| bool | **[SortJets](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-sortjets)**(const TLorentzVector jv1, const TLorentzVector jv2) |
| | **[DEFINE_ANALYSIS_FACTORY](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-define-analysis-factory)**(ATLAS_13TeV_ZGammaGrav_CONFNOTE_80invfb ) |
| bool | **[sortByPT](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-sortbypt)**(const HEPUtils::Jet * jet1, const HEPUtils::Jet * jet2) |
| bool | **[sortByPT_2lep](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-sortbypt-2lep)**(const HEPUtils::Particle * lep1, const HEPUtils::Particle * lep2) |
| double | **[Phi_mpi_pi](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-phi-mpi-pi)**(double x) |
| double | **[_Phi_mpi_pi](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function--phi-mpi-pi)**(double x) |
| void | **[_setEventWeight_unity](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function--seteventweight-unity)**(HEPUtils::Event & event, const [BaseCollider](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1basecollider/) * )<br>A function that sets the event weight to unity, with zero uncertainty.  |
| void | **[setEventWeight_unity](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-seteventweight-unity)**(EventWeighterFunctionType & result) |
| void | **[_setEventWeight_fromCrossSection](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function--seteventweight-fromcrosssection)**(HEPUtils::Event & event, const [BaseCollider](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1basecollider/) * HardScatteringSim_ptr, const map_int_process_xsec & ProcessCrossSectionsMap, const int use_trust_level)<br>A function that sets the event weight based on the process cross-sections.  |
| void | **[setEventWeight_fromCrossSection](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-seteventweight-fromcrosssection)**(EventWeighterFunctionType & result) |
| void | **[getDummyColliderObservable](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-getdummycolliderobservable)**(double & result)<br>Dummy observable that creates a dependency on TestModel1D.  |
| void | **[operateLHCLoop](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-operatelhcloop)**([MCLoopInfo](/documentation/code/main/classes/structgambit_1_1colliderbit_1_1mcloopinfo/) & result)<br>LHC Loop Manager.  |
| void | **[getLHCEventLoopInfo](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-getlhceventloopinfo)**(map_str_dbl & result)<br>Store some information about the event generation.  |
| void | **[CollectAnalyses](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-collectanalyses)**(AnalysisDataPointers & result)<br>Loop over all analyses and collect them in one place.  |
| void | **[set_CS](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-set-cs)**([hb_ModelParameters](/documentation/code/main/classes/structgambit_1_1hb__modelparameters/) & result, const HiggsCouplingsTable & couplings, int n_neutral_higgses)<br>Helper function to set HiggsBounds/Signals parameters cross-section ratios from a GAMBIT HiggsCouplingsTable.  |
| void | **[set_SMLikeHiggs_ModelParameters](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-set-smlikehiggs-modelparameters)**(const SubSpectrum & spec, const HiggsCouplingsTable & couplings, [hb_ModelParameters](/documentation/code/main/classes/structgambit_1_1hb__modelparameters/) & result)<br>Helper function for populating a HiggsBounds/Signals ModelParameters object for SM-like Higgs.  |
| void | **[SMLikeHiggs_ModelParameters](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-smlikehiggs-modelparameters)**([hb_ModelParameters](/documentation/code/main/classes/structgambit_1_1hb__modelparameters/) & result)<br>SM-like (SM + possible invisibles) Higgs model parameters for HiggsBounds/Signals.  |
| void | **[MSSMLikeHiggs_ModelParameters](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-mssmlikehiggs-modelparameters)**([hb_ModelParameters](/documentation/code/main/classes/structgambit_1_1hb__modelparameters/) & result)<br>MSSM-like (MSSM + NMSSM + ...) Higgs model parameters for HiggsBounds/Signals.  |
| void | **[calc_HB_LEP_LogLike](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-calc-hb-lep-loglike)**(double & result)<br>Get a LEP chisq from HiggsBounds.  |
| void | **[calc_HS_LHC_LogLike](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-calc-hs-lhc-loglike)**(double & result)<br>Get an LHC chisq from HiggsSignals.  |
| void | **[FeynHiggs_HiggsProd](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-feynhiggs-higgsprod)**([fh_HiggsProd_container](/documentation/code/main/classes/structgambit_1_1fh__higgsprod__container/) & result)<br>Higgs production cross-sections from FeynHiggs.  |
| [AnalysisLogLikes](/documentation/code/main/classes/structgambit_1_1colliderbit_1_1analysisloglikes/) | **[calc_loglikes_for_analysis](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-calc-loglikes-for-analysis)**(const [AnalysisData](/documentation/code/main/classes/structgambit_1_1colliderbit_1_1analysisdata/) & adata, bool USE_COVAR, bool USE_MARG, bool combine_nocovar_SRs, bool set_zero_loglike)<br>Forward declaration of funtion in LHC_likelihoods.  |
| void | **[fill_analysis_info_map](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-fill-analysis-info-map)**()<br>Forward declarations of functions in this file.  |
| void | **[DMEFT_results](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-dmeft-results)**(AnalysisDataPointers & result)<br>Results from DMEFT analyses before any modification of the MET spectrum.  |
| void | **[get_all_DMEFT_signal_yields](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-get-all-dmeft-signal-yields)**(std::vector< double > & sr_nums, const [DMEFT_analysis_info](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1dmeft__analysis__info/) & analysis_info, const Spectrum & spec)<br>Fill the input vector with the total DMEFT signal prediction for each SR in the given LHC analysis.  |
| void | **[get_DMEFT_signal_yields_dim6_operator](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-get-dmeft-signal-yields-dim6-operator)**(std::vector< double > & signal_yields, const str, const [DMEFT_analysis_info](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1dmeft__analysis__info/) & analysis_info, double m, double O1, double O2, double lambda)<br>Fill the input vector with the DMEFT signal prediction for a given set of dim-6 operators.  |
| void | **[get_DMEFT_signal_yields_dim7_operator](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-get-dmeft-signal-yields-dim7-operator)**(std::vector< double > & signal_yields, const str, const [DMEFT_analysis_info](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1dmeft__analysis__info/) & analysis_info, double m, double O, double lambda)<br>Fill the input vector with the DMEFT signal prediction for a given dim-7 operator.  |
| void | **[DMEFT_results_profiled](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-dmeft-results-profiled)**(AnalysisDataPointers & result)<br>Results from DMEFT analyses after profiling over the 'a' parameter in the smooth cut-off of the MET spectrum.  |
| void | **[DMEFT_results_cutoff](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-dmeft-results-cutoff)**(AnalysisDataPointers & result)<br>Results from DMEFT analyses after imposing a hard cut-off of the MET spectrum.  |
| void | **[signal_modifier_function](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-signal-modifier-function)**([AnalysisData](/documentation/code/main/classes/structgambit_1_1colliderbit_1_1analysisdata/) & adata, double lambda, double a) |
| void | **[signal_cutoff_function](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-signal-cutoff-function)**([AnalysisData](/documentation/code/main/classes/structgambit_1_1colliderbit_1_1analysisdata/) & adata, double lambda) |
| void | **[_gsl_target_func](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function--gsl-target-func)**(const size_t, const double * a, void * fparams, double * fval)<br>A target function for the GSL optimiser.  |
| void | **[calc_DMEFT_profiled_LHC_nuisance_params](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-calc-dmeft-profiled-lhc-nuisance-params)**(map_str_dbl & result) |
| void | **[InterpolatedMCInfo](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-interpolatedmcinfo)**([MCLoopInfo](/documentation/code/main/classes/structgambit_1_1colliderbit_1_1mcloopinfo/) & result) |
| double | **[limit_LLike](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-limit-llike)**(double x, double x95, double sigma)<br>LEP limit likelihood function.  |
| bool | **[is_xsec_sane](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-is-xsec-sane)**(const triplet< double > & xsecWithError)<br>LEP limit debugging function.  |
| void | **[LEP207_SLHA1_convention_xsec_chi00_11](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-lep207-slha1-convention-xsec-chi00-11)**(triplet< double > & result) |
| void | **[L3_Gravitino_LLike](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-l3-gravitino-llike)**(double & result) |
| void | **[getActiveProcessCodes](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-getactiveprocesscodes)**(std::vector< int > & result)<br>Get the list of active collider process codes.  |
| void | **[getAnalysisContainer](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-getanalysiscontainer)**([AnalysisContainer](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysiscontainer/) & result, const str & detname, const [MCLoopInfo](/documentation/code/main/classes/structgambit_1_1colliderbit_1_1mcloopinfo/) & RunMC, const [xsec_container](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1xsec__container/) & TotalCrossSection, int iteration)<br>Retrieve an analysis container for a specific detector.  |
| void | **[getBuckFastATLAS](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-getbuckfastatlas)**([BaseDetector](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1basedetector/) *& result)<br>Retrieve a [BuckFast]() sim of [ATLAS]().  |
| void | **[getBuckFastCMS](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-getbuckfastcms)**([BaseDetector](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1basedetector/) *& result)<br>Retrieve a [BuckFast]() sim of [CMS]().  |
| void | **[getBuckFastIdentity](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-getbuckfastidentity)**([BaseDetector](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1basedetector/) *& result)<br>Retrieve an Identity [BuckFast]() sim (no sim)  |
| void | **[getHepMCEvent](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-gethepmcevent)**(HEPUtils::Event & result)<br>A nested function that reads in HepMC event files and converts them to HEPUtils::Event format.  |
| void | **[getLHEvent](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-getlhevent)**(HEPUtils::Event & result)<br>A nested function that reads in Les Houches Event files and converts them to HEPUtils::Event format.  |
| std::pair< double, double > | **[convert_xsecs_to_fb](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-convert-xsecs-to-fb)**(double input_xsec, double input_xsec_uncert, str input_unit, bool input_fractional_uncert) |
| void | **[getPIDPairCrossSectionsMap_prospino](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-getpidpaircrosssectionsmap-prospino)**(map_PID_pair_PID_pair_xsec & result) |
| [PID_pair_xsec_container](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1pid__pair__xsec__container/) | **[silly_pid_xsec_constructor](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-silly-pid-xsec-constructor)**(PID_pair pid_pair, double xsec_val)<br>Test functions for provding PIDPairCrossSectionsMap (cross-sections in fb)  |
| void | **[getPIDPairCrossSectionsMap_testing](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-getpidpaircrosssectionsmap-testing)**(map_PID_pair_PID_pair_xsec & result) |
| void | **[getProcessCrossSectionsMap](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-getprocesscrosssectionsmap)**(map_int_process_xsec & result)<br>Get a map between Pythia process codes and cross-sections.  |
| void | **[getEvGenCrossSection](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-getevgencrosssection)**([MC_xsec_container](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1mc__xsec__container/) & result)<br>Compute a cross-section from Monte Carlo.  |
| void | **[getEvGenCrossSection_as_base](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-getevgencrosssection-as-base)**([xsec_container](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1xsec__container/) & result)<br>Return [MC_xsec_container]() as the base [xsec_container]().  |
| void | **[getNLLFastCrossSection](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-getnllfastcrosssection)**([xsec_container](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1xsec__container/) & result)<br>Get a cross-section from NLL-FAST.  |
| bool | **[checkOptions_getYAMLCrossSection](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-checkoptions-getyamlcrosssection)**(const Options & runOptions, const str calling_function, std::pair< str, str > & xsec_pnames, str & input_unit, bool & input_fractional_uncert, str & errmsg)<br>A helper function to check the YAML options for getYAMLCrossSection and getYAMLCrossSection_SLHA.  |
| void | **[getYAMLCrossSection](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-getyamlcrosssection)**([xsec_container](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1xsec__container/) & result)<br>A function that reads the total cross-section from the input file, but builds up the number of events from the event loop.  |
| void | **[getYAMLCrossSection_SLHA](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-getyamlcrosssection-slha)**([xsec_container](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1xsec__container/) & result)<br>A function that reads a list of (SLHA file, total cross-section) pairs from the input YAML file.  |
| void | **[getYAMLCrossSection_param](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-getyamlcrosssection-param)**([xsec_container](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1xsec__container/) & result) |
| void | **[getTotalCrossSectionAsMap](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-gettotalcrosssectionasmap)**(map_str_dbl & result)<br>Get cross-section info as map_str_dbl (for simple printing)  |
| void | **[getPIDPairCrossSectionsInfo](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-getpidpaircrosssectionsinfo)**(map_str_dbl & result)<br>Output PID pair cross-sections as a str-dbl map, for easy printing.  |
| void | **[doCrossSectionConsistencyCheck](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-docrosssectionconsistencycheck)**(bool & result) |
| void | **[calc_LHC_signals](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-calc-lhc-signals)**(map_str_dbl & result)<br>Loop over all analyses and fill a map of predicted counts.  |
| void | **[_gsl_calc_Analysis_MinusLogLike](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function--gsl-calc-analysis-minusloglike)**(const size_t n, const double * unit_nuisances_dbl, void * fixedparamspack, double * fval) |
| void | **[_gsl_calc_Analysis_MinusLogLikeGrad](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function--gsl-calc-analysis-minusloglikegrad)**(const size_t n, const double * unit_nuisances_dbl, void * fixedparamspack, double * fgrad)<br>Loglike gradient-function wrapper to provide the signature for GSL multimin.  |
| void | **[_gsl_calc_Analysis_MinusLogLikeAndGrad](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function--gsl-calc-analysis-minusloglikeandgrad)**(const size_t n, const double * unit_nuisances_dbl, void * fixedparamspack, double * fval, double * fgrad) |
| std::vector< double > | **[_gsl_mkpackedarray](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function--gsl-mkpackedarray)**(const Eigen::ArrayXd & n_preds, const Eigen::ArrayXd & n_obss, const Eigen::ArrayXd & sqrtevals, const Eigen::MatrixXd & evecs) |
| double | **[profile_loglike_cov](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-profile-loglike-cov)**(const Eigen::ArrayXd & n_preds, const Eigen::ArrayXd & n_obss, const Eigen::ArrayXd & sqrtevals, const Eigen::MatrixXd & evecs) |
| double | **[marg_loglike_nulike1sr](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-marg-loglike-nulike1sr)**(const Eigen::ArrayXd & n_preds, const Eigen::ArrayXd & n_obss, const Eigen::ArrayXd & sqrtevals) |
| double | **[marg_loglike_cov](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-marg-loglike-cov)**(const Eigen::ArrayXd & n_preds, const Eigen::ArrayXd & n_obss, const Eigen::ArrayXd & sqrtevals, const Eigen::MatrixXd & evecs) |
| void | **[calc_LHC_LogLikes](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-calc-lhc-loglikes)**([map_str_AnalysisLogLikes](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-map-str-analysisloglikes) & result)<br>Loop over all analyses and fill a map of [AnalysisLogLikes]() objects.  |
| void | **[get_LHC_LogLike_per_analysis](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-get-lhc-loglike-per-analysis)**(map_str_dbl & result)<br>Extract the combined log likelihood for each analysis.  |
| void | **[get_LHC_LogLike_per_SR](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-get-lhc-loglike-per-sr)**(map_str_dbl & result)<br>Extract the log likelihood for each SR.  |
| void | **[get_LHC_LogLike_SR_labels](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-get-lhc-loglike-sr-labels)**(map_str_str & result)<br>Extract the labels for the SRs used in the analysis loglikes.  |
| void | **[get_LHC_LogLike_SR_indices](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-get-lhc-loglike-sr-indices)**(map_str_dbl & result) |
| void | **[calc_combined_LHC_LogLike](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-calc-combined-lhc-loglike)**(double & result)<br>Compute the total likelihood combining all analyses.  |
| void | **[calc_LHC_LogLike_scan_guide](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-calc-lhc-loglike-scan-guide)**(double & result) |
| void | **[getNextSLHAFileNameAndContent](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-getnextslhafilenameandcontent)**([pair_str_SLHAstruct](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-pair-str-slhastruct) & result) |
| void | **[getAndReplaceSLHAContent](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-getandreplaceslhacontent)**([pair_str_SLHAstruct](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#typedef-pair-str-slhastruct) & result) |
| void | **[getSLHAFileElements](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-getslhafileelements)**(map_str_dbl & result) |
| void | **[getSLHA1Spectrum](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-getslha1spectrum)**(SLHAstruct & result) |
| void | **[getSLHA2Spectrum](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-getslha2spectrum)**(SLHAstruct & result) |
| void | **[calc_susy_spectrum_scan_guide](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-calc-susy-spectrum-scan-guide)**(double & result) |
| void | **[getActiveProcessCodeToPIDPairsMap](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-getactiveprocesscodetopidpairsmap)**(multimap_int_PID_pair & result) |
| void | **[getActivePIDPairs](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-getactivepidpairs)**(vec_PID_pair & result)<br>Get a list of all the PID pairs related to active process codes.  |
| void | **[runAnalyses](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-runanalyses)**(AnalysisDataPointers & result, const str & , const [MCLoopInfo](/documentation/code/main/classes/structgambit_1_1colliderbit_1_1mcloopinfo/) & RunMC, const [AnalysisContainer](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1analysiscontainer/) & Container, const HEPUtils::Event & SmearedEvent, int iteration, void(*)() wrapup)<br>Run all the analyses in a given container.  |
| void | **[smearEvent](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#function-smearevent)**(HEPUtils::Event & result, const HEPUtils::Event & HardScatteringEvent, const [BaseDetector](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1basedetector/) & detector, const [MCLoopInfo](/documentation/code/main/classes/structgambit_1_1colliderbit_1_1mcloopinfo/) & RunMC, const int iteration, const str & detname)<br>Smear an event.  |

## Attributes

|                | Name           |
| -------------- | -------------- |
| const multimap_int_PID_pair | **[all_process_codes_to_PID_pairs](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#variable-all-process-codes-to-pid-pairs)**  |
| constexpr double | **[sqrtsGeV](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#variable-sqrtsgev)**  |
| const double | **[GeV](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#variable-gev)** <br>Unit conversions (multiply to construct in standard units, divide to decode to that unit)  |
| const double | **[MeV](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#variable-mev)**  |
| const double | **[TeV](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#variable-tev)**  |
| std::map< str, [DMEFT_analysis_info](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1dmeft__analysis__info/) > | **[analysis_info_map](/documentation/code/main/namespaces/namespacegambit_1_1colliderbit/#variable-analysis-info-map)**  |

## Types Documentation

### enum specialIterations

| Enumerator | Value | Description |
| ---------- | ----- | ----------- |
| BASE_INIT | -1|   |
| COLLIDER_INIT | -2|   |
| COLLIDER_INIT_OMP | -3|   |
| XSEC_CALCULATION | -4|   |
| START_SUBPROCESS | -5|   |
| COLLECT_CONVERGENCE_DATA | -6|   |
| CHECK_CONVERGENCE | -7|   |
| END_SUBPROCESS | -8|   |
| COLLIDER_FINALIZE | -9|   |
| BASE_FINALIZE | -10|   |



Special iteration labels for the loop controlled by operateLHCLoop. 

### typedef AnalysisNumbers

```
typedef std::vector<AnalysisData> Gambit::ColliderBit::AnalysisNumbers;
```

Container for data from multiple analyses and SRs. 

### typedef AnalysisDataPointers

```
typedef std::vector<AnalysisData*> Gambit::ColliderBit::AnalysisDataPointers;
```


### typedef map_str_AnalysisLogLikes

```
typedef std::map<std::string,AnalysisLogLikes> Gambit::ColliderBit::map_str_AnalysisLogLikes;
```

Typedef for a string-to-AnalysisLogLikes map. 

### typedef AnalysisContainers

```
typedef std::vector<AnalysisContainer> Gambit::ColliderBit::AnalysisContainers;
```

Container for multiple analysis containers. 

### typedef ms

```
typedef std::chrono::milliseconds Gambit::ColliderBit::ms;
```


### typedef steady_clock

```
typedef std::chrono::steady_clock Gambit::ColliderBit::steady_clock;
```


### typedef tp

```
typedef std::chrono::steady_clock::time_point Gambit::ColliderBit::tp;
```


### typedef timer_map_type

```
typedef std::map<std::string,double> Gambit::ColliderBit::timer_map_type;
```


### typedef pair_str_SLHAstruct

```
typedef std::pair<std::string,SLHAstruct> Gambit::ColliderBit::pair_str_SLHAstruct;
```

Typedef for a str-SLHAstruct pair, to pass around SLHA filenames + content. 

### typedef vec_iipair

```
typedef std::vector<std::pair<int,int> > Gambit::ColliderBit::vec_iipair;
```

Typedefs related to cross-sections. 

### typedef vec_PID_pair

```
typedef std::vector<PID_pair> Gambit::ColliderBit::vec_PID_pair;
```


### typedef multimap_int_iipair

```
typedef std::multimap<int,std::pair<int,int> > Gambit::ColliderBit::multimap_int_iipair;
```


### typedef multimap_int_PID_pair

```
typedef std::multimap<int,PID_pair> Gambit::ColliderBit::multimap_int_PID_pair;
```


### typedef multimap_PID_pair_int

```
typedef std::multimap<PID_pair,int> Gambit::ColliderBit::multimap_PID_pair_int;
```


### typedef map_int_xsec

```
typedef std::map<int,xsec_container> Gambit::ColliderBit::map_int_xsec;
```


### typedef map_int_process_xsec

```
typedef std::map<int,process_xsec_container> Gambit::ColliderBit::map_int_process_xsec;
```


### typedef map_iipair_PID_pair_xsec

```
typedef std::map<std::pair<int,int>,PID_pair_xsec_container> Gambit::ColliderBit::map_iipair_PID_pair_xsec;
```


### typedef map_PID_pair_PID_pair_xsec

```
typedef std::map<PID_pair,PID_pair_xsec_container> Gambit::ColliderBit::map_PID_pair_PID_pair_xsec;
```


### typedef HEPUtils_Event

```
typedef HEPUtils::Event Gambit::ColliderBit::HEPUtils_Event;
```

Typedef for a std::function that sets the weight for the input HEPUtils::Event. 

### typedef EventWeighterFunctionType

```
typedef std::function<void(HEPUtils_Event&, const BaseCollider*)> Gambit::ColliderBit::EventWeighterFunctionType;
```


### typedef MixMatrix

```
typedef std::vector< std::vector<double> > Gambit::ColliderBit::MixMatrix;
```


### typedef data_type

```
typedef std::vector<std::vector<double> > Gambit::ColliderBit::data_type;
```


### typedef ParticlePtrs

```
typedef std::vector<const HEPUtils::Particle*> Gambit::ColliderBit::ParticlePtrs;
```

Typedef for a vector of Particle pointers. 

### typedef JetPtrs

```
typedef std::vector<const HEPUtils::Jet*> Gambit::ColliderBit::JetPtrs;
```

Typedef for a vector of Jet pointers. 


## Functions Documentation

### function mk_pseudojet

```
template <typename Vec4T >
inline FJNS::PseudoJet mk_pseudojet(
    const Vec4T & p
)
```


### function mk_p4

```
template <typename Vec4T >
inline HEPUtils::P4 mk_p4(
    const Vec4T & p
)
```


### function fromBottom

```
template <typename EventT >
inline bool fromBottom(
    int n,
    const EventT & evt
)
```


**Todo**: Rewrite using the Pythia > 8.176 particle-based methods 

TodoWhat about partonic decays? 


### function fromTau

```
template <typename EventT >
inline bool fromTau(
    int n,
    const EventT & evt
)
```


**Todo**: Rewrite using the Pythia > 8.176 particle-based methods 

### function fromHadron

```
template <typename EventT >
inline bool fromHadron(
    int n,
    const EventT & evt
)
```


**Todo**: Rewrite using the Pythia > 8.176 particle-based methods 

### function isFinalB

```
template <typename EventT >
inline bool isFinalB(
    int n,
    const EventT & evt
)
```


### function isFinalTau

```
template <typename EventT >
inline bool isFinalTau(
    int n,
    const EventT & evt
)
```


### function isParton

```
template <typename EventT >
inline bool isParton(
    int n,
    const EventT & evt
)
```


### function isFinalParton

```
template <typename EventT >
inline bool isFinalParton(
    int n,
    const EventT & evt
)
```


### function isFinalPhoton

```
template <typename EventT >
inline bool isFinalPhoton(
    int n,
    const EventT & evt
)
```


### function isFinalLepton

```
template <typename EventT >
inline bool isFinalLepton(
    int n,
    const EventT & evt
)
```


### function get_sigma_ee_ll

```
void get_sigma_ee_ll(
    triplet< double > & result,
    const double sqrts,
    const int generation,
    const int l_chirality,
    const int lbar_chirality,
    const double gtol,
    const double ftol,
    const bool gpt_error,
    const bool fpt_error,
    const Spectrum & spec,
    const double gammaZ,
    const bool l_are_gauge_es
)
```


High-level cross section routines.

Retrieve the production cross-section at an e+e- collider for slepton pairs. If l_are_gauge_es = T, then l(bar)_chirality = 1 => (anti-)left-type slepton = 2 => (anti-)right-type slepton If l_are_gauge_es = F, then l(bar)_chirality = 1 => (anti-)slepton is lightest family state = 2 => (anti-)slepton is heaviest family state

Retrieve the production cross-section at an e+e- collider for slepton pairs. If l_are_gauge_es = T, then l(bar)_chirality = 1 => (anti-)left-type slepton = 2 => (anti-)right-type slepton If l_are_gauge_es = F, then l(bar)_chirality = 1 => (anti-)slepton is lightest family state = 2 => (anti-)slepton is heaviest family state 


### function get_sigma_ee_chi00

```
void get_sigma_ee_chi00(
    triplet< double > & result,
    const double sqrts,
    const int chi_first,
    const int chi_second,
    const double tol,
    const bool pt_error,
    const Spectrum & spec,
    const double gammaZ
)
```

Retrieve the production cross-section at an e+e- collider for neutralino pairs. 

### function get_sigma_ee_chipm

```
void get_sigma_ee_chipm(
    triplet< double > & result,
    const double sqrts,
    const int chi_plus,
    const int chi_minus,
    const double tol,
    const bool pt_error,
    const Spectrum & spec,
    const double gammaZ
)
```

Retrieve the production cross-section at an e+e- collider for chargino pairs. 

### function xsec_sleislej

```
double xsec_sleislej(
    int pid1,
    int pid2,
    double sqrts,
    double m1,
    double m2,
    MixMatrix F,
    MixMatrix N,
    const double mN[4],
    double alpha,
    double mZ,
    double gZ,
    double sin2thetaW,
    bool warn_on_CP_violating_masses =true
)
```


Low-level cross section routines.

Cross section [pb] for \( e^+e^- -> \tilde l_i \tilde l_j^* \) To use, call SLHA2BFM first on SLHA mixing matrices constructed as a vector of vectors

Cross section [pb] for \(e^+e^- -> \tilde l_i \tilde l_j^*\) To use, call SLHA2BFM first on SLHA mixing matrices constructed as a vector of vectors 


### function xsec_neuineuj

```
double xsec_neuineuj(
    int pid1,
    int pid2,
    double sqrts,
    double m1,
    double m2,
    MixMatrix N,
    const double mS[2],
    double tanb,
    double alpha,
    double mZ,
    double gZ,
    double sin2thetaW
)
```


Cross section [pb] for \( e^+e^- -> \tilde\chi^0_i \tilde\chi^0_j \) Masses mi and mj for the neutralinos are signed. mS are the selectron masses (left = 0, right = 1). Warning! BFM uses inverted \(\tan\beta\)! Use tanb = 1 / tanb in converting from SLHA.

Cross section [pb] for \(e^+e^- -> \tilde\chi^0_i \tilde\chi^0_j\) Masses mi and mj for the neutralinos are signed. mS are the selectron masses (left = 0, right = 1). Warning! BFM uses inverted \(\tan\beta\)! Use tanb = 1 / tanb in converting from SLHA. 


### function xsec_chaichaj

```
double xsec_chaichaj(
    int pid1,
    int pid2,
    double sqrts,
    double m1,
    double m2,
    MixMatrix V,
    MixMatrix U,
    double msn,
    double alpha,
    double mZ,
    double gZ,
    double sin2thetaW
)
```


Cross section [pb] for \( e^+e^- -> \tilde\chi^+_i \tilde\chi^-_j \) Masses mi and mj for the charginos are signed. msn is electron sneutrino mass.

Cross section [pb] for \(e^+e^- -> \tilde\chi^+_i \tilde\chi^-_j\) Masses mi and mj for the charginos are signed. msn is electron sneutrino mass. 


### function SLHA2BFM_NN

```
void SLHA2BFM_NN(
    MixMatrix & NN,
    double tanb,
    double sin2thetaW
)
```

Functions to convert mass matrices between SLHA and BFM conventions ////////////////////////////////////////////////////////////////////. 

Conversion between SLHA and BFM conventions. \(\tan\beta\) is as per SLHA.

Converts a neutralino mixing matrix in SLHA conventions to BFM conventions, \(\tan\beta\) is as defined in SLHA 


### function SLHA2BFM_VV

```
void SLHA2BFM_VV(
    MixMatrix & VV
)
```

Converts the chargino mixing matrix V in SLHA conventions to BFM conventions. 

### function BFM2SLHA_NN

```
void BFM2SLHA_NN(
    MixMatrix & NN,
    double tanb,
    double sin2thetaW
)
```

Converts a neutralino mixing matrix in BFM conventions to SLHA conventions, \(\tan\beta\) is as defined in SLHA. 

### function BFM2SLHA_VV

```
void BFM2SLHA_VV(
    MixMatrix & VV
)
```

Converts the chargino mixing matrix V in BFM conventions to SLHA conventions. 

### function multiply

```
MixMatrix multiply(
    MixMatrix A,
    MixMatrix B
)
```

Helper function to multiply matrices. 

### function transpose

```
MixMatrix transpose(
    MixMatrix A
)
```

Helper function to find matrix transpose. 

### function print

```
void print(
    MixMatrix A
)
```

Helper function to print a matrix. 

### function operator+

```
inline P2 operator+(
    const P2 & a,
    const P2 & b
)
```


### function operator-

```
inline P2 operator-(
    const P2 & a,
    const P2 & b
)
```


### function operator*

```
inline P2 operator*(
    const P2 & a,
    double f
)
```


### function operator*

```
inline P2 operator*(
    double f,
    const P2 & a
)
```


### function operator/

```
inline P2 operator/(
    const P2 & a,
    double f
)
```


### function to_str

```
inline std::string to_str(
    const P2 & p2
)
```

Make a string representation of the vector. 

### function operator<<

```
inline std::ostream & operator<<(
    std::ostream & ostr,
    const P2 & p2
)
```

Write a string representation of the vector to the provided stream. 

### function to_str

```
inline std::string to_str(
    const LineSegment & lineseg
)
```

Make a string representation of the [LineSegment](). 

### function operator<<

```
inline std::ostream & operator<<(
    std::ostream & ostr,
    const LineSegment & lineseg
)
```

Write a string representation of the vector to the provided stream. 

### function amIaJet

```
inline bool amIaJet(
    const HEPUtils::Jet * jet
)
```

Identifier for jets true. 

### function amIaBJet

```
inline bool amIaBJet(
    const HEPUtils::Jet * jet
)
```

Indentifier for b-jets true. 

### function amIaJet

```
inline bool amIaJet(
    const HEPUtils::Particle * part
)
```

Identifier for jets false. 

### function amIaBJet

```
inline bool amIaBJet(
    const HEPUtils::Particle * part
)
```

Indentifier for b-jets true. 

### function iremoveerase

```
template <typename CONTAINER ,
typename RMFN >
inline void iremoveerase(
    CONTAINER & c,
    const RMFN & fn
)
```

Convenience combination of remove_if and erase. 

### function ifilter_reject

```
inline void ifilter_reject(
    ParticlePtrs & particles,
    std::function< bool(const Particle *)> rejfn,
    bool do_delete =true
)
```

In-place filter a supplied particle vector by rejecting those which fail a supplied cut. 

### function ifilter_select

```
inline void ifilter_select(
    ParticlePtrs & particles,
    std::function< bool(const Particle *)> selfn,
    bool do_delete =true
)
```

In-place filter a supplied particle vector by keeping those which pass a supplied cut. 

### function filter_reject

```
inline ParticlePtrs filter_reject(
    const ParticlePtrs & particles,
    std::function< bool(const Particle *)> rejfn,
    bool do_delete =true
)
```


**Todo**: Optimise by only copying those which are selected (filter_select is canonical) 

Filter a supplied particle vector by rejecting those which fail a supplied cut 


### function filter_select

```
inline ParticlePtrs filter_select(
    const ParticlePtrs & particles,
    std::function< bool(const Particle *)> selfn,
    bool do_delete =true
)
```

Filter a supplied particle vector by keeping those which pass a supplied cut. 

### function ifilter_reject

```
inline void ifilter_reject(
    JetPtrs & jets,
    std::function< bool(const Jet *)> rejfn,
    bool do_delete =true
)
```

In-place filter a supplied jet vector by rejecting those which fail a supplied cut. 

### function ifilter_select

```
inline void ifilter_select(
    JetPtrs & jets,
    std::function< bool(const Jet *)> selfn,
    bool do_delete =true
)
```

In-place filter a supplied jet vector by keeping those which pass a supplied cut. 

### function filter_reject

```
inline JetPtrs filter_reject(
    const JetPtrs & jets,
    std::function< bool(const Jet *)> rejfn,
    bool do_delete =true
)
```


**Todo**: Optimise by only copying those which are selected (filter_select is canonical) 

Filter a supplied particle vector by rejecting those which fail a supplied cut 


### function filter_select

```
inline JetPtrs filter_select(
    const JetPtrs & jets,
    std::function< bool(const Jet *)> selfn,
    bool do_delete =true
)
```

Filter a supplied particle vector by keeping those which pass a supplied cut. 

### function random_bool

```
bool random_bool(
    double eff
)
```

Return a random true/false at a success rate given by a number. 

TodoHandle out-of-range eff values 

TodoHandle out-of-range eff values 


### function random_bool

```
inline bool random_bool(
    const HEPUtils::BinnedFn1D< double > & effmap,
    double x
)
```

Return a random true/false at a success rate given by a 1D efficiency map. 

### function random_bool

```
inline bool random_bool(
    const HEPUtils::BinnedFn2D< double > & effmap,
    double x,
    double y
)
```

Return a random true/false at a success rate given by a 2D efficiency map. 

### function filtereff

```
void filtereff(
    std::vector< const HEPUtils::Particle * > & particles,
    double eff,
    bool do_delete =false
)
```

Utility function for filtering a supplied particle vector by sampling wrt an efficiency scalar. 

### function filtereff

```
void filtereff(
    std::vector< const HEPUtils::Particle * > & particles,
    std::function< double(const HEPUtils::Particle *)> eff_fn,
    bool do_delete =false
)
```

Utility function for filtering a supplied particle vector by sampling an efficiency returned by a provided function object. 

Utility function for filtering a supplied particle vector by sampling wrt a binned 1D efficiency map in pT. 


### function filtereff_pt

```
void filtereff_pt(
    std::vector< const HEPUtils::Particle * > & particles,
    const HEPUtils::BinnedFn1D< double > & eff_pt,
    bool do_delete =false
)
```

Utility function for filtering a supplied particle vector by sampling wrt a binned 1D efficiency map in pT. 

### function filtereff_etapt

```
void filtereff_etapt(
    std::vector< const HEPUtils::Particle * > & particles,
    const HEPUtils::BinnedFn2D< double > & eff_etapt,
    bool do_delete =false
)
```

Utility function for filtering a supplied particle vector by sampling wrt a binned 2D efficiency map in |eta| and pT. 

### function has_tag

```
inline bool has_tag(
    const HEPUtils::BinnedFn2D< double > & effmap,
    double eta,
    double pt
)
```


**Todo**: Also need 1D? Sampling in what variable? 

Randomly get a tag result (can be anything) from a 2D |eta|-pT efficiency map 


### function generateBTagsMap

```
inline std::map< const HEPUtils::Jet *, bool > generateBTagsMap(
    const std::vector< const HEPUtils::Jet * > & jets,
    double bTagEff,
    double cMissTagEff,
    double otherMissTagEff,
    double pTmin =0.,
    double absEtaMax =DBL_MAX
)
```

Return a map<Jet*,bool> containing a generated b-tag for every jet in the input vector. 

### function binIndex

```
template <typename NUM1 ,
typename NUM2 >
inline size_t binIndex(
    NUM1 val,
    const std::vector< NUM2 > & binedges,
    bool allow_overflow =false
)
```


< Below/out of histo range

< Above/out of histo range


### function mk_bin_values

```
inline std::vector< double > mk_bin_values(
    const std::vector< double > & binEdgeValues
)
```

Make a vector of central bin values from a vector of bin edge values using linear interpolation. 

### function makeBinValues

```
inline std::vector< double > makeBinValues(
    const std::vector< double > & binEdgeValues
)
```

Alias. 

### function get_jets

```
template <typename MOM >
inline std::vector< std::shared_ptr< HEPUtils::Jet > > get_jets(
    const std::vector< MOM * > & moms,
    double R,
    double ptmin =0 *GeV,
    FJNS::JetAlgorithm alg =FJNS::antikt_algorithm
)
```

Run jet clustering from any P4-compatible momentum type. 

### function object_in_cone

```
inline bool object_in_cone(
    const HEPUtils::Event & e,
    const HEPUtils::P4 & p4,
    double ptmin,
    double rmax,
    double rmin =0.05
)
```

Check if there's a physics object above ptmin in an annulus rmin..rmax around the given four-momentum p4. 

### function removeOverlap

```
template <typename MOMPTRS1 ,
typename MOMPTRS2 >
void removeOverlap(
    MOMPTRS1 & momstofilter,
    const MOMPTRS2 & momstocmp,
    double deltaRMax,
    bool use_rapidity =false,
    double pTmax =DBL_MAX,
    double btageff =0
)
```


Overlap removal &ndash; discard from first list if within deltaRMax of any from the second list Optional arguments:

* use_rapidity = use rapidity instead of psedurapidity to compute deltaR. Defaults to False
* pTmax = only discard from first list with pT < pTmax. Defaults to DBL_MAX
* btageff = do not discard jets that have a b-tagging efficiency lower than btageff. Defaults to 0 


### function removeOverlap

```
template <typename MOMPTRS1 ,
typename MOMPTRS2 >
void removeOverlap(
    MOMPTRS1 & momstofilter,
    const MOMPTRS2 & momstocmp,
    double(*)(const double) deltaRMax,
    bool use_rapidity =false,
    double pTmax =DBL_MAX,
    double btageff =0
)
```


Overlap removal &ndash; discard from first list if within deltaRmax of any from the second list. Overload of previous function where deltaRmax is a function of the pT of the first list Optional arguments:

* use_rapidity = use rapidity instead of psedurapidity to compute deltaR. Defaults to False
* pTmax = only discard from first list with pT < pTmax. Defaults to DBL_MAX
* btageff = do not discard jets that have a b-tagging efficiency lower than btageff. Defaults to 0 


### function removeOverlapIfBjet

```
template <typename MOMPTRS1 >
void removeOverlapIfBjet(
    MOMPTRS1 & momstofilter,
    std::vector< const HEPUtils::Jet * > & jets,
    double deltaRMax,
    bool use_rapidity =false,
    double pTmax =DBL_MAX
)
```


Overlap removal for checking against b-jets &ndash; discard from first list if within deltaRMax of a b-jet in the second list Optional arguments:

* use_rapidity = use rapidity instead of psedurapidity to compute deltaR. Defaults to False
* pTmax = only discard from first list with pT < pTmax. Defaults to DBL_MAX 


### function all_of

```
template <typename CONTAINER ,
typename FN >
inline bool all_of(
    const CONTAINER & c,
    const FN & f
)
```

Non-iterator version of std::all_of. 

### function any_of

```
template <typename CONTAINER ,
typename FN >
inline bool any_of(
    const CONTAINER & c,
    const FN & f
)
```

Non-iterator version of std::any_of. 

### function none_of

```
template <typename CONTAINER ,
typename FN >
inline bool none_of(
    const CONTAINER & c,
    const FN & f
)
```

Non-iterator version of std::none_of. 

### function getSFOSpairs

```
std::vector< std::vector< const HEPUtils::Particle * > > getSFOSpairs(
    std::vector< const HEPUtils::Particle * > particles
)
```

Utility function for returning a collection of same-flavour, oppsosite-sign particle pairs. 

### function getOSpairs

```
std::vector< std::vector< const HEPUtils::Particle * > > getOSpairs(
    std::vector< const HEPUtils::Particle * > particles
)
```

Utility function for returning a collection of oppsosite-sign particle pairs. 

### function getSSpairs

```
std::vector< std::vector< const HEPUtils::Particle * > > getSSpairs(
    std::vector< const HEPUtils::Particle * > particles
)
```

Utility function for returning a collection of same-sign particle pairs. 

### function sortBy

```
inline void sortBy(
    ParticlePtrs & particles,
    std::function< bool(const Particle *, const Particle *)> cmpfn
)
```

Particle-sorting function. 

### function cmpParticlesByPt

```
inline bool cmpParticlesByPt(
    const HEPUtils::Particle * lep1,
    const HEPUtils::Particle * lep2
)
```

Comparison function to give a particles sorting order decreasing by pT. 

### function sortByPt

```
inline void sortByPt(
    ParticlePtrs & particles
)
```


### function sortBy

```
inline void sortBy(
    JetPtrs & jets,
    std::function< bool(const Jet *, const Jet *)> cmpfn
)
```

Jet-sorting function. 

### function cmpJetsByPt

```
inline bool cmpJetsByPt(
    const HEPUtils::Jet * jet1,
    const HEPUtils::Jet * jet2
)
```

Comparison function to give a jets sorting order decreasing by pT. 

### function sortByPt

```
inline void sortByPt(
    JetPtrs & jets
)
```


### function countPt

```
inline int countPt(
    const std::vector< const Particle * > & particles,
    double pTlim
)
```

Count number of particles that have pT > pTlim. 

### function countPt

```
inline int countPt(
    const std::vector< const Jet * > & jets,
    double pTlim
)
```

Count number of jets that have pT > pTlim. 

### function scalarSumPt

```
inline double scalarSumPt(
    const std::vector< const Particle * > & particles,
    double pTlim =0.
)
```

Scalar sum pT of particles with pT > pTlim (default pTlim = 0) 

### function scalarSumPt

```
inline double scalarSumPt(
    const std::vector< const Jet * > & jets,
    double pTlim =0.
)
```

Scalar sum pT of jets. 

### function LEP208_SLHA1_convention_xsec_selselbar

```
void LEP208_SLHA1_convention_xsec_selselbar(
    triplet< double > & result
)
```


ee --> selectron pair production cross-sections at 208 GeV 


### function LEP208_SLHA1_convention_xsec_selserbar

```
void LEP208_SLHA1_convention_xsec_selserbar(
    triplet< double > & result
)
```


### function LEP208_SLHA1_convention_xsec_serserbar

```
void LEP208_SLHA1_convention_xsec_serserbar(
    triplet< double > & result
)
```


### function LEP208_SLHA1_convention_xsec_serselbar

```
void LEP208_SLHA1_convention_xsec_serselbar(
    triplet< double > & result
)
```


### function LEP208_SLHA1_convention_xsec_se1se1bar

```
void LEP208_SLHA1_convention_xsec_se1se1bar(
    triplet< double > & result
)
```


### function LEP208_SLHA1_convention_xsec_se1se2bar

```
void LEP208_SLHA1_convention_xsec_se1se2bar(
    triplet< double > & result
)
```


### function LEP208_SLHA1_convention_xsec_se2se2bar

```
void LEP208_SLHA1_convention_xsec_se2se2bar(
    triplet< double > & result
)
```


### function LEP208_SLHA1_convention_xsec_se2se1bar

```
void LEP208_SLHA1_convention_xsec_se2se1bar(
    triplet< double > & result
)
```


### function LEP208_SLHA1_convention_xsec_smulsmulbar

```
void LEP208_SLHA1_convention_xsec_smulsmulbar(
    triplet< double > & result
)
```


ee --> smuon pair production cross-sections at 208 GeV 


### function LEP208_SLHA1_convention_xsec_smulsmurbar

```
void LEP208_SLHA1_convention_xsec_smulsmurbar(
    triplet< double > & result
)
```


### function LEP208_SLHA1_convention_xsec_smursmurbar

```
void LEP208_SLHA1_convention_xsec_smursmurbar(
    triplet< double > & result
)
```


### function LEP208_SLHA1_convention_xsec_smursmulbar

```
void LEP208_SLHA1_convention_xsec_smursmulbar(
    triplet< double > & result
)
```


### function LEP208_SLHA1_convention_xsec_smu1smu1bar

```
void LEP208_SLHA1_convention_xsec_smu1smu1bar(
    triplet< double > & result
)
```


### function LEP208_SLHA1_convention_xsec_smu1smu2bar

```
void LEP208_SLHA1_convention_xsec_smu1smu2bar(
    triplet< double > & result
)
```


### function LEP208_SLHA1_convention_xsec_smu2smu2bar

```
void LEP208_SLHA1_convention_xsec_smu2smu2bar(
    triplet< double > & result
)
```


### function LEP208_SLHA1_convention_xsec_smu2smu1bar

```
void LEP208_SLHA1_convention_xsec_smu2smu1bar(
    triplet< double > & result
)
```


### function LEP208_SLHA1_convention_xsec_staulstaulbar

```
void LEP208_SLHA1_convention_xsec_staulstaulbar(
    triplet< double > & result
)
```


ee --> stau pair production cross-sections at 208 GeV 


### function LEP208_SLHA1_convention_xsec_staulstaurbar

```
void LEP208_SLHA1_convention_xsec_staulstaurbar(
    triplet< double > & result
)
```


### function LEP208_SLHA1_convention_xsec_staurstaurbar

```
void LEP208_SLHA1_convention_xsec_staurstaurbar(
    triplet< double > & result
)
```


### function LEP208_SLHA1_convention_xsec_staurstaulbar

```
void LEP208_SLHA1_convention_xsec_staurstaulbar(
    triplet< double > & result
)
```


### function LEP208_SLHA1_convention_xsec_stau1stau1bar

```
void LEP208_SLHA1_convention_xsec_stau1stau1bar(
    triplet< double > & result
)
```


### function LEP208_SLHA1_convention_xsec_stau1stau2bar

```
void LEP208_SLHA1_convention_xsec_stau1stau2bar(
    triplet< double > & result
)
```


### function LEP208_SLHA1_convention_xsec_stau2stau2bar

```
void LEP208_SLHA1_convention_xsec_stau2stau2bar(
    triplet< double > & result
)
```


### function LEP208_SLHA1_convention_xsec_stau2stau1bar

```
void LEP208_SLHA1_convention_xsec_stau2stau1bar(
    triplet< double > & result
)
```


### function LEP208_SLHA1_convention_xsec_chi00_11

```
void LEP208_SLHA1_convention_xsec_chi00_11(
    triplet< double > & result
)
```


ee --> neutralino pair production cross-sections at 208 GeV 


### function LEP208_SLHA1_convention_xsec_chi00_12

```
void LEP208_SLHA1_convention_xsec_chi00_12(
    triplet< double > & result
)
```


### function LEP208_SLHA1_convention_xsec_chi00_13

```
void LEP208_SLHA1_convention_xsec_chi00_13(
    triplet< double > & result
)
```


### function LEP208_SLHA1_convention_xsec_chi00_14

```
void LEP208_SLHA1_convention_xsec_chi00_14(
    triplet< double > & result
)
```


### function LEP208_SLHA1_convention_xsec_chi00_22

```
void LEP208_SLHA1_convention_xsec_chi00_22(
    triplet< double > & result
)
```


### function LEP208_SLHA1_convention_xsec_chi00_23

```
void LEP208_SLHA1_convention_xsec_chi00_23(
    triplet< double > & result
)
```


### function LEP208_SLHA1_convention_xsec_chi00_24

```
void LEP208_SLHA1_convention_xsec_chi00_24(
    triplet< double > & result
)
```


### function LEP208_SLHA1_convention_xsec_chi00_33

```
void LEP208_SLHA1_convention_xsec_chi00_33(
    triplet< double > & result
)
```


### function LEP208_SLHA1_convention_xsec_chi00_34

```
void LEP208_SLHA1_convention_xsec_chi00_34(
    triplet< double > & result
)
```


### function LEP208_SLHA1_convention_xsec_chi00_44

```
void LEP208_SLHA1_convention_xsec_chi00_44(
    triplet< double > & result
)
```


### function LEP208_SLHA1_convention_xsec_chipm_11

```
void LEP208_SLHA1_convention_xsec_chipm_11(
    triplet< double > & result
)
```


ee --> chargino pair production cross-sections at 208 GeV 


### function LEP208_SLHA1_convention_xsec_chipm_12

```
void LEP208_SLHA1_convention_xsec_chipm_12(
    triplet< double > & result
)
```


### function LEP208_SLHA1_convention_xsec_chipm_22

```
void LEP208_SLHA1_convention_xsec_chipm_22(
    triplet< double > & result
)
```


### function LEP208_SLHA1_convention_xsec_chipm_21

```
void LEP208_SLHA1_convention_xsec_chipm_21(
    triplet< double > & result
)
```


### function LEP205_SLHA1_convention_xsec_selselbar

```
void LEP205_SLHA1_convention_xsec_selselbar(
    triplet< double > & result
)
```


ee --> selectron pair production cross-sections at 205 GeV 


### function LEP205_SLHA1_convention_xsec_selserbar

```
void LEP205_SLHA1_convention_xsec_selserbar(
    triplet< double > & result
)
```


### function LEP205_SLHA1_convention_xsec_serserbar

```
void LEP205_SLHA1_convention_xsec_serserbar(
    triplet< double > & result
)
```


### function LEP205_SLHA1_convention_xsec_serselbar

```
void LEP205_SLHA1_convention_xsec_serselbar(
    triplet< double > & result
)
```


### function LEP205_SLHA1_convention_xsec_se1se1bar

```
void LEP205_SLHA1_convention_xsec_se1se1bar(
    triplet< double > & result
)
```


### function LEP205_SLHA1_convention_xsec_se1se2bar

```
void LEP205_SLHA1_convention_xsec_se1se2bar(
    triplet< double > & result
)
```


### function LEP205_SLHA1_convention_xsec_se2se2bar

```
void LEP205_SLHA1_convention_xsec_se2se2bar(
    triplet< double > & result
)
```


### function LEP205_SLHA1_convention_xsec_se2se1bar

```
void LEP205_SLHA1_convention_xsec_se2se1bar(
    triplet< double > & result
)
```


### function LEP205_SLHA1_convention_xsec_smulsmulbar

```
void LEP205_SLHA1_convention_xsec_smulsmulbar(
    triplet< double > & result
)
```


ee --> smuon pair production cross-sections at 205 GeV 


### function LEP205_SLHA1_convention_xsec_smulsmurbar

```
void LEP205_SLHA1_convention_xsec_smulsmurbar(
    triplet< double > & result
)
```


### function LEP205_SLHA1_convention_xsec_smursmurbar

```
void LEP205_SLHA1_convention_xsec_smursmurbar(
    triplet< double > & result
)
```


### function LEP205_SLHA1_convention_xsec_smursmulbar

```
void LEP205_SLHA1_convention_xsec_smursmulbar(
    triplet< double > & result
)
```


### function LEP205_SLHA1_convention_xsec_smu1smu1bar

```
void LEP205_SLHA1_convention_xsec_smu1smu1bar(
    triplet< double > & result
)
```


### function LEP205_SLHA1_convention_xsec_smu1smu2bar

```
void LEP205_SLHA1_convention_xsec_smu1smu2bar(
    triplet< double > & result
)
```


### function LEP205_SLHA1_convention_xsec_smu2smu2bar

```
void LEP205_SLHA1_convention_xsec_smu2smu2bar(
    triplet< double > & result
)
```


### function LEP205_SLHA1_convention_xsec_smu2smu1bar

```
void LEP205_SLHA1_convention_xsec_smu2smu1bar(
    triplet< double > & result
)
```


### function LEP205_SLHA1_convention_xsec_staulstaulbar

```
void LEP205_SLHA1_convention_xsec_staulstaulbar(
    triplet< double > & result
)
```


ee --> stau pair production cross-sections at 205 GeV 


### function LEP205_SLHA1_convention_xsec_staulstaurbar

```
void LEP205_SLHA1_convention_xsec_staulstaurbar(
    triplet< double > & result
)
```


### function LEP205_SLHA1_convention_xsec_staurstaurbar

```
void LEP205_SLHA1_convention_xsec_staurstaurbar(
    triplet< double > & result
)
```


### function LEP205_SLHA1_convention_xsec_staurstaulbar

```
void LEP205_SLHA1_convention_xsec_staurstaulbar(
    triplet< double > & result
)
```


### function LEP205_SLHA1_convention_xsec_stau1stau1bar

```
void LEP205_SLHA1_convention_xsec_stau1stau1bar(
    triplet< double > & result
)
```


### function LEP205_SLHA1_convention_xsec_stau1stau2bar

```
void LEP205_SLHA1_convention_xsec_stau1stau2bar(
    triplet< double > & result
)
```


### function LEP205_SLHA1_convention_xsec_stau2stau2bar

```
void LEP205_SLHA1_convention_xsec_stau2stau2bar(
    triplet< double > & result
)
```


### function LEP205_SLHA1_convention_xsec_stau2stau1bar

```
void LEP205_SLHA1_convention_xsec_stau2stau1bar(
    triplet< double > & result
)
```


### function LEP205_SLHA1_convention_xsec_chi00_11

```
void LEP205_SLHA1_convention_xsec_chi00_11(
    triplet< double > & result
)
```


ee --> neutralino pair production cross-sections at 205 GeV 


### function LEP205_SLHA1_convention_xsec_chi00_12

```
void LEP205_SLHA1_convention_xsec_chi00_12(
    triplet< double > & result
)
```


### function LEP205_SLHA1_convention_xsec_chi00_13

```
void LEP205_SLHA1_convention_xsec_chi00_13(
    triplet< double > & result
)
```


### function LEP205_SLHA1_convention_xsec_chi00_14

```
void LEP205_SLHA1_convention_xsec_chi00_14(
    triplet< double > & result
)
```


### function LEP205_SLHA1_convention_xsec_chi00_22

```
void LEP205_SLHA1_convention_xsec_chi00_22(
    triplet< double > & result
)
```


### function LEP205_SLHA1_convention_xsec_chi00_23

```
void LEP205_SLHA1_convention_xsec_chi00_23(
    triplet< double > & result
)
```


### function LEP205_SLHA1_convention_xsec_chi00_24

```
void LEP205_SLHA1_convention_xsec_chi00_24(
    triplet< double > & result
)
```


### function LEP205_SLHA1_convention_xsec_chi00_33

```
void LEP205_SLHA1_convention_xsec_chi00_33(
    triplet< double > & result
)
```


### function LEP205_SLHA1_convention_xsec_chi00_34

```
void LEP205_SLHA1_convention_xsec_chi00_34(
    triplet< double > & result
)
```


### function LEP205_SLHA1_convention_xsec_chi00_44

```
void LEP205_SLHA1_convention_xsec_chi00_44(
    triplet< double > & result
)
```


### function LEP205_SLHA1_convention_xsec_chipm_11

```
void LEP205_SLHA1_convention_xsec_chipm_11(
    triplet< double > & result
)
```


ee --> chargino pair production cross-sections at 205 GeV 


### function LEP205_SLHA1_convention_xsec_chipm_12

```
void LEP205_SLHA1_convention_xsec_chipm_12(
    triplet< double > & result
)
```


### function LEP205_SLHA1_convention_xsec_chipm_22

```
void LEP205_SLHA1_convention_xsec_chipm_22(
    triplet< double > & result
)
```


### function LEP205_SLHA1_convention_xsec_chipm_21

```
void LEP205_SLHA1_convention_xsec_chipm_21(
    triplet< double > & result
)
```


### function LEP188_SLHA1_convention_xsec_selselbar

```
void LEP188_SLHA1_convention_xsec_selselbar(
    triplet< double > & result
)
```


ee --> selectron pair production cross-sections at 188.6 GeV 


### function LEP188_SLHA1_convention_xsec_selserbar

```
void LEP188_SLHA1_convention_xsec_selserbar(
    triplet< double > & result
)
```


### function LEP188_SLHA1_convention_xsec_serserbar

```
void LEP188_SLHA1_convention_xsec_serserbar(
    triplet< double > & result
)
```


### function LEP188_SLHA1_convention_xsec_serselbar

```
void LEP188_SLHA1_convention_xsec_serselbar(
    triplet< double > & result
)
```


### function LEP188_SLHA1_convention_xsec_se1se1bar

```
void LEP188_SLHA1_convention_xsec_se1se1bar(
    triplet< double > & result
)
```


### function LEP188_SLHA1_convention_xsec_se1se2bar

```
void LEP188_SLHA1_convention_xsec_se1se2bar(
    triplet< double > & result
)
```


### function LEP188_SLHA1_convention_xsec_se2se2bar

```
void LEP188_SLHA1_convention_xsec_se2se2bar(
    triplet< double > & result
)
```


### function LEP188_SLHA1_convention_xsec_se2se1bar

```
void LEP188_SLHA1_convention_xsec_se2se1bar(
    triplet< double > & result
)
```


### function LEP188_SLHA1_convention_xsec_smulsmulbar

```
void LEP188_SLHA1_convention_xsec_smulsmulbar(
    triplet< double > & result
)
```


ee --> smuon pair production cross-sections at 188.6 GeV 


### function LEP188_SLHA1_convention_xsec_smulsmurbar

```
void LEP188_SLHA1_convention_xsec_smulsmurbar(
    triplet< double > & result
)
```


### function LEP188_SLHA1_convention_xsec_smursmurbar

```
void LEP188_SLHA1_convention_xsec_smursmurbar(
    triplet< double > & result
)
```


### function LEP188_SLHA1_convention_xsec_smursmulbar

```
void LEP188_SLHA1_convention_xsec_smursmulbar(
    triplet< double > & result
)
```


### function LEP188_SLHA1_convention_xsec_smu1smu1bar

```
void LEP188_SLHA1_convention_xsec_smu1smu1bar(
    triplet< double > & result
)
```


### function LEP188_SLHA1_convention_xsec_smu1smu2bar

```
void LEP188_SLHA1_convention_xsec_smu1smu2bar(
    triplet< double > & result
)
```


### function LEP188_SLHA1_convention_xsec_smu2smu2bar

```
void LEP188_SLHA1_convention_xsec_smu2smu2bar(
    triplet< double > & result
)
```


### function LEP188_SLHA1_convention_xsec_smu2smu1bar

```
void LEP188_SLHA1_convention_xsec_smu2smu1bar(
    triplet< double > & result
)
```


### function LEP188_SLHA1_convention_xsec_staulstaulbar

```
void LEP188_SLHA1_convention_xsec_staulstaulbar(
    triplet< double > & result
)
```


ee --> stau pair production cross-sections at 188.6 GeV 


### function LEP188_SLHA1_convention_xsec_staulstaurbar

```
void LEP188_SLHA1_convention_xsec_staulstaurbar(
    triplet< double > & result
)
```


### function LEP188_SLHA1_convention_xsec_staurstaurbar

```
void LEP188_SLHA1_convention_xsec_staurstaurbar(
    triplet< double > & result
)
```


### function LEP188_SLHA1_convention_xsec_staurstaulbar

```
void LEP188_SLHA1_convention_xsec_staurstaulbar(
    triplet< double > & result
)
```


### function LEP188_SLHA1_convention_xsec_stau1stau1bar

```
void LEP188_SLHA1_convention_xsec_stau1stau1bar(
    triplet< double > & result
)
```


### function LEP188_SLHA1_convention_xsec_stau1stau2bar

```
void LEP188_SLHA1_convention_xsec_stau1stau2bar(
    triplet< double > & result
)
```


### function LEP188_SLHA1_convention_xsec_stau2stau2bar

```
void LEP188_SLHA1_convention_xsec_stau2stau2bar(
    triplet< double > & result
)
```


### function LEP188_SLHA1_convention_xsec_stau2stau1bar

```
void LEP188_SLHA1_convention_xsec_stau2stau1bar(
    triplet< double > & result
)
```


### function LEP188_SLHA1_convention_xsec_chi00_11

```
void LEP188_SLHA1_convention_xsec_chi00_11(
    triplet< double > & result
)
```


ee --> neutralino pair production cross-sections at 188.6 GeV 


### function LEP188_SLHA1_convention_xsec_chi00_12

```
void LEP188_SLHA1_convention_xsec_chi00_12(
    triplet< double > & result
)
```


### function LEP188_SLHA1_convention_xsec_chi00_13

```
void LEP188_SLHA1_convention_xsec_chi00_13(
    triplet< double > & result
)
```


### function LEP188_SLHA1_convention_xsec_chi00_14

```
void LEP188_SLHA1_convention_xsec_chi00_14(
    triplet< double > & result
)
```


### function LEP188_SLHA1_convention_xsec_chi00_22

```
void LEP188_SLHA1_convention_xsec_chi00_22(
    triplet< double > & result
)
```


### function LEP188_SLHA1_convention_xsec_chi00_23

```
void LEP188_SLHA1_convention_xsec_chi00_23(
    triplet< double > & result
)
```


### function LEP188_SLHA1_convention_xsec_chi00_24

```
void LEP188_SLHA1_convention_xsec_chi00_24(
    triplet< double > & result
)
```


### function LEP188_SLHA1_convention_xsec_chi00_33

```
void LEP188_SLHA1_convention_xsec_chi00_33(
    triplet< double > & result
)
```


### function LEP188_SLHA1_convention_xsec_chi00_34

```
void LEP188_SLHA1_convention_xsec_chi00_34(
    triplet< double > & result
)
```


### function LEP188_SLHA1_convention_xsec_chi00_44

```
void LEP188_SLHA1_convention_xsec_chi00_44(
    triplet< double > & result
)
```


### function LEP188_SLHA1_convention_xsec_chipm_11

```
void LEP188_SLHA1_convention_xsec_chipm_11(
    triplet< double > & result
)
```


ee --> chargino pair production cross-sections at 188.6 GeV 


### function LEP188_SLHA1_convention_xsec_chipm_12

```
void LEP188_SLHA1_convention_xsec_chipm_12(
    triplet< double > & result
)
```


### function LEP188_SLHA1_convention_xsec_chipm_22

```
void LEP188_SLHA1_convention_xsec_chipm_22(
    triplet< double > & result
)
```


### function LEP188_SLHA1_convention_xsec_chipm_21

```
void LEP188_SLHA1_convention_xsec_chipm_21(
    triplet< double > & result
)
```


### function ALEPH_Selectron_Conservative_LLike

```
void ALEPH_Selectron_Conservative_LLike(
    double & result
)
```


LEP Slepton Log-Likelihoods 


### function ALEPH_Smuon_Conservative_LLike

```
void ALEPH_Smuon_Conservative_LLike(
    double & result
)
```


### function ALEPH_Stau_Conservative_LLike

```
void ALEPH_Stau_Conservative_LLike(
    double & result
)
```


### function L3_Selectron_Conservative_LLike

```
void L3_Selectron_Conservative_LLike(
    double & result
)
```


### function L3_Smuon_Conservative_LLike

```
void L3_Smuon_Conservative_LLike(
    double & result
)
```


### function L3_Stau_Conservative_LLike

```
void L3_Stau_Conservative_LLike(
    double & result
)
```


### function L3_Neutralino_All_Channels_Conservative_LLike

```
void L3_Neutralino_All_Channels_Conservative_LLike(
    double & result
)
```


LEP Gaugino Log-Likelihoods 


### function L3_Neutralino_Leptonic_Conservative_LLike

```
void L3_Neutralino_Leptonic_Conservative_LLike(
    double & result
)
```


### function L3_Chargino_All_Channels_Conservative_LLike

```
void L3_Chargino_All_Channels_Conservative_LLike(
    double & result
)
```


### function L3_Chargino_Leptonic_Conservative_LLike

```
void L3_Chargino_Leptonic_Conservative_LLike(
    double & result
)
```


### function OPAL_Chargino_Hadronic_Conservative_LLike

```
void OPAL_Chargino_Hadronic_Conservative_LLike(
    double & result
)
```


### function OPAL_Chargino_SemiLeptonic_Conservative_LLike

```
void OPAL_Chargino_SemiLeptonic_Conservative_LLike(
    double & result
)
```


### function OPAL_Chargino_Leptonic_Conservative_LLike

```
void OPAL_Chargino_Leptonic_Conservative_LLike(
    double & result
)
```


### function OPAL_Degenerate_Chargino_Conservative_LLike

```
void OPAL_Degenerate_Chargino_Conservative_LLike(
    double & result
)
```


### function OPAL_Chargino_All_Channels_Conservative_LLike

```
void OPAL_Chargino_All_Channels_Conservative_LLike(
    double & result
)
```


### function OPAL_Neutralino_Hadronic_Conservative_LLike

```
void OPAL_Neutralino_Hadronic_Conservative_LLike(
    double & result
)
```


### function I1

```
double I1(
    double s,
    double m1,
    double m2,
    double mk,
    double ml
)
```


Integrals for t-channel neutralino diagrams m1 and m2 are masses of final state sleptons mk and ml are neutralino masses 


### function I2

```
double I2(
    double s,
    double m1,
    double m2,
    double mk,
    double ml
)
```


### function I3

```
double I3(
    double s,
    double m1,
    double m2,
    double mk
)
```


### function mkAnalysis

```
Analysis * mkAnalysis(
    const str & name
)
```

Factory definition. 

**Note**: The caller is responsible for deleting the returned analysis object. 

**Todo**: Move to a separate file 

Create a new analysis based on a name string 


### function getDetector

```
str getDetector(
    const str & name
)
```

Return the detector to be used for a given analysis name, checking that the analysis exists. 

Return the detector to be used for a given analysis name (and check that the analysis exists). 


### function operator<<

```
inline std::ostream & operator<<(
    std::ostream & os,
    const Cutflow & cf
)
```

Print a [Cutflow]() to a stream. 

### function operator<<

```
inline std::ostream & operator<<(
    std::ostream & os,
    const Cutflows & cfs
)
```

Print a [Cutflows]() to a stream. 

### function convertParticleEvent

```
template <typename EventT >
void convertParticleEvent(
    const EventT & pevt,
    HEPUtils::Event & result,
    double antiktR,
    double jet_pt_min
)
```


**Todo**: Overlap between jets and prompt containers: need some isolation in MET calculation 

Convert a hadron-level EventT into an unsmeared HEPUtils::Event 


TodoTemporarily using quark-based tagging instead &ndash; fix 

TodoTemporarily using quark-based tagging instead &ndash; fix 

TodoWhat's wrong with having a W daughter? Doesn't that just mark a final tau? 

TodoMove out-of-acceptance MET contribution to [BuckFast](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1buckfast/)

Jet finding TodoChoose jet algorithm via detector _settings? Run several algs? 

Do jet b-tagging, etc. and add to the Event TodoUse ghost tagging? 

We need to _remove_ this b-tag in the detector sim if outside the tracker acceptance!

TodoReplace with HEPUtils::any(bhadrons, [&](const auto& pb){ pj.delta_R(pb) < 0.4 }) 

< TodoHard-coded radius!!! 

< TodoHard-coded radius!!! 

< TodoHard-coded radius!!! 

Calculate missing momentum


### function convertPartonEvent

```
template <typename EventT >
void convertPartonEvent(
    const EventT & pevt,
    HEPUtils::Event & result,
    double antiktR,
    double jet_pt_min
)
```

Convert a partonic (no hadrons) EventT into an unsmeared HEPUtils::Event. 

TodoWe should leave this for the detector sim / analysis to deal with 

Todo_Some_ photons should be included in jets!!! Ignore for now since no FSR 

TodoTodoLepton dressing 

TodoOnly include hadronic tau fraction? 

Jet finding Todochoose jet algorithm via _settings? 

This b-tag is removed in the detector sim if outside the tracker acceptance!


Calculate missing momentum


### function all_PID_pairs_to_process_codes

```
const multimap_PID_pair_int & all_PID_pairs_to_process_codes()
```


### function dropHepMCEventPy8Collider

```
template <typename PythiaT ,
typename hepmc_writerT >
void dropHepMCEventPy8Collider(
    const PythiaT * Pythia,
    const safe_ptr< Options > & runOptions
)
```

Drop a HepMC file for the event. 

### function generateEventPy8Collider

```
template <typename PythiaT ,
typename EventT ,
typename hepmc_writerT >
void generateEventPy8Collider(
    HEPUtils::Event & event,
    const MCLoopInfo & RunMC,
    const Py8Collider< PythiaT, EventT, hepmc_writerT > & HardScatteringSim,
    const EventWeighterFunctionType & EventWeighterFunction,
    const int iteration,
    void(*)() wrapup,
    const safe_ptr< Options > & runOptions
)
```

Generate a hard scattering event with Pythia. 

### function getPy8Collider

```
template <typename PythiaT ,
typename EventT ,
typename hepmc_writerT >
void getPy8Collider(
    Py8Collider< PythiaT, EventT, hepmc_writerT > & result,
    const MCLoopInfo & RunMC,
    const SLHAstruct & slha,
    const str model_suffix,
    const int iteration,
    void(*)() wrapup,
    const Options & runOptions
)
```

Retrieve a Pythia hard-scattering Monte Carlo simulation. 

### function makeLine

```
inline LineSegment makeLine(
    const P2 & pt1,
    const P2 & pt2
)
```

Factory function for lines. 

### function addInQuad

```
inline double addInQuad(
    const double & a,
    const double & b
)
```

Add two numbers in quadrature. 

**Todo**: Use HEPUtils add_quad 

### function sortByPT13

```
bool sortByPT13(
    const HEPUtils::Jet * jet1,
    const HEPUtils::Jet * jet2
)
```


### function sortByPT13_sharedptr

```
bool sortByPT13_sharedptr(
    std::shared_ptr< HEPUtils::Jet > jet1,
    std::shared_ptr< HEPUtils::Jet > jet2
)
```


### function sortByMass

```
bool sortByMass(
    const HEPUtils::Jet * jet1,
    const HEPUtils::Jet * jet2
)
```


### function sortByMass_sharedptr

```
bool sortByMass_sharedptr(
    std::shared_ptr< HEPUtils::Jet > jet1,
    std::shared_ptr< HEPUtils::Jet > jet2
)
```


### function calcMT

```
double calcMT(
    HEPUtils::P4 jetMom,
    HEPUtils::P4 metMom
)
```


### function sortByPT_1l

```
bool sortByPT_1l(
    const HEPUtils::Jet * jet1,
    const HEPUtils::Jet * jet2
)
```


### function sortByPT_1l_sharedptr

```
bool sortByPT_1l_sharedptr(
    std::shared_ptr< HEPUtils::Jet > jet1,
    std::shared_ptr< HEPUtils::Jet > jet2
)
```


### function sortByMass_1l

```
bool sortByMass_1l(
    const HEPUtils::Jet * jet1,
    const HEPUtils::Jet * jet2
)
```


### function sortByMass_1l_sharedptr

```
bool sortByMass_1l_sharedptr(
    std::shared_ptr< HEPUtils::Jet > jet1,
    std::shared_ptr< HEPUtils::Jet > jet2
)
```


### function calcMT_1l

```
double calcMT_1l(
    HEPUtils::P4 jetMom,
    HEPUtils::P4 metMom
)
```


### function sortByPT_j

```
bool sortByPT_j(
    const HEPUtils::Jet * jet1,
    const HEPUtils::Jet * jet2
)
```


### function sortByPT_l

```
bool sortByPT_l(
    const HEPUtils::Particle * lep1,
    const HEPUtils::Particle * lep2
)
```


### function sortByPT_jet

```
bool sortByPT_jet(
    const HEPUtils::Jet * jet1,
    const HEPUtils::Jet * jet2
)
```


### function sortByPT_lep

```
bool sortByPT_lep(
    const HEPUtils::Particle * lep1,
    const HEPUtils::Particle * lep2
)
```


### function sortByPT_RJ3L

```
bool sortByPT_RJ3L(
    const HEPUtils::Jet * jet1,
    const HEPUtils::Jet * jet2
)
```


### function sortLepByPT_RJ3L

```
bool sortLepByPT_RJ3L(
    const HEPUtils::Particle * lep1,
    const HEPUtils::Particle * lep2
)
```


### function SortLeptons

```
bool SortLeptons(
    const pair< TLorentzVector, int > lv1,
    const pair< TLorentzVector, int > lv2
)
```


### function SortJets

```
bool SortJets(
    const TLorentzVector jv1,
    const TLorentzVector jv2
)
```


### function DEFINE_ANALYSIS_FACTORY

```
DEFINE_ANALYSIS_FACTORY(
    ATLAS_13TeV_ZGammaGrav_CONFNOTE_80invfb 
)
```


### function sortByPT

```
bool sortByPT(
    const HEPUtils::Jet * jet1,
    const HEPUtils::Jet * jet2
)
```


### function sortByPT_2lep

```
bool sortByPT_2lep(
    const HEPUtils::Particle * lep1,
    const HEPUtils::Particle * lep2
)
```


### function Phi_mpi_pi

```
double Phi_mpi_pi(
    double x
)
```


### function _Phi_mpi_pi

```
double _Phi_mpi_pi(
    double x
)
```


### function _setEventWeight_unity

```
void _setEventWeight_unity(
    HEPUtils::Event & event,
    const BaseCollider * 
)
```

A function that sets the event weight to unity, with zero uncertainty. 

### function setEventWeight_unity

```
void setEventWeight_unity(
    EventWeighterFunctionType & result
)
```


Module function providing an instance of EventWeighterFunctionType pointing to _setEventWeight_unity 


### function _setEventWeight_fromCrossSection

```
void _setEventWeight_fromCrossSection(
    HEPUtils::Event & event,
    const BaseCollider * HardScatteringSim_ptr,
    const map_int_process_xsec & ProcessCrossSectionsMap,
    const int use_trust_level
)
```

A function that sets the event weight based on the process cross-sections. 

### function setEventWeight_fromCrossSection

```
void setEventWeight_fromCrossSection(
    EventWeighterFunctionType & result
)
```


Module function providing an instance of EventWeighterFunctionType pointing to _setEventWeight_fromCrossSection 


### function getDummyColliderObservable

```
void getDummyColliderObservable(
    double & result
)
```

Dummy observable that creates a dependency on TestModel1D. 

This is used to satisfy the normal GAMBIT model requrements in a minimal way. This is useful in the case where we just want to run ColliderBit on a single point with a custom Pythia version, using Pythia's SLHA interface. 


### function operateLHCLoop

```
void operateLHCLoop(
    MCLoopInfo & result
)
```

LHC Loop Manager. 

### function getLHCEventLoopInfo

```
void getLHCEventLoopInfo(
    map_str_dbl & result
)
```

Store some information about the event generation. 

### function CollectAnalyses

```
void CollectAnalyses(
    AnalysisDataPointers & result
)
```

Loop over all analyses and collect them in one place. 

### function set_CS

```
void set_CS(
    hb_ModelParameters & result,
    const HiggsCouplingsTable & couplings,
    int n_neutral_higgses
)
```

Helper function to set HiggsBounds/Signals parameters cross-section ratios from a GAMBIT HiggsCouplingsTable. 

### function set_SMLikeHiggs_ModelParameters

```
void set_SMLikeHiggs_ModelParameters(
    const SubSpectrum & spec,
    const HiggsCouplingsTable & couplings,
    hb_ModelParameters & result
)
```

Helper function for populating a HiggsBounds/Signals ModelParameters object for SM-like Higgs. 

### function SMLikeHiggs_ModelParameters

```
void SMLikeHiggs_ModelParameters(
    hb_ModelParameters & result
)
```

SM-like (SM + possible invisibles) Higgs model parameters for HiggsBounds/Signals. 

### function MSSMLikeHiggs_ModelParameters

```
void MSSMLikeHiggs_ModelParameters(
    hb_ModelParameters & result
)
```

MSSM-like (MSSM + NMSSM + ...) Higgs model parameters for HiggsBounds/Signals. 

### function calc_HB_LEP_LogLike

```
void calc_HB_LEP_LogLike(
    double & result
)
```

Get a LEP chisq from HiggsBounds. 

### function calc_HS_LHC_LogLike

```
void calc_HS_LHC_LogLike(
    double & result
)
```

Get an LHC chisq from HiggsSignals. 

### function FeynHiggs_HiggsProd

```
void FeynHiggs_HiggsProd(
    fh_HiggsProd_container & result
)
```

Higgs production cross-sections from FeynHiggs. 

### function calc_loglikes_for_analysis

```
AnalysisLogLikes calc_loglikes_for_analysis(
    const AnalysisData & adata,
    bool USE_COVAR,
    bool USE_MARG,
    bool combine_nocovar_SRs,
    bool set_zero_loglike
)
```

Forward declaration of funtion in LHC_likelihoods. 

For a given analysis, calculate per-SR loglikes and the overall analysis loglike. Return the results as an AnalysLogLikes object. 


If (simplified) SR-correlation info is available, so use the covariance matrix to construct composite marginalised likelihood Despite initial thoughts, we can't just do independent LL calculations in a rotated basis, but have to sample from the covariance matrix.

This means we can't use the nulike LL functions, which operate in 1D only. Also, log-normal sampling in the diagonal basis is not helpful, since the rotation will re-generate negative rates.

TodoSupport NSL, i.e. skewness correction 

TodoUnify this for both cov and no-cov, feeding in one-element Eigen blocks as Ref<>s for the latter? 

TodoCompute the background-only covariance decomposition and likelihood only once 

TodoOnly compute this once per run 

TodoUse newer (?) one-step Eigen constructors for (const) single-element arrays 

TodoOr compute all the exp DLLs first, then only the best-expected SR's obs DLL? 

TodoTodoOnly compute this once per run 

TodoOnly compute this once per run 

If (simplified) SR-correlation info is available, so use the covariance matrix to construct composite marginalised likelihood Despite initial thoughts, we can't just do independent LL calculations in a rotated basis, but have to sample from the covariance matrix.

This means we can't use the nulike LL functions, which operate in 1D only. Also, log-normal sampling in the diagonal basis is not helpful, since the rotation will re-generate negative rates.

TodoSupport NSL, i.e. skewness correction 

TodoUnify this for both cov and no-cov, feeding in one-element Eigen blocks as Ref<>s for the latter? 

TodoCompute the background-only covariance decomposition and likelihood only once 

TodoOnly compute this once per run 

TodoUse newer (?) one-step Eigen constructors for (const) single-element arrays 

TodoOr compute all the exp DLLs first, then only the best-expected SR's obs DLL? 

TodoTodoOnly compute this once per run 

TodoOnly compute this once per run 


### function fill_analysis_info_map

```
void fill_analysis_info_map()
```

Forward declarations of functions in this file. 

A function for filling the analysis_info_map. This is where all the analysis-specific numbers and file names go. 


### function DMEFT_results

```
void DMEFT_results(
    AnalysisDataPointers & result
)
```

Results from DMEFT analyses before any modification of the MET spectrum. 

### function get_all_DMEFT_signal_yields

```
void get_all_DMEFT_signal_yields(
    std::vector< double > & sr_nums,
    const DMEFT_analysis_info & analysis_info,
    const Spectrum & spec
)
```

Fill the input vector with the total DMEFT signal prediction for each SR in the given LHC analysis. 

### function get_DMEFT_signal_yields_dim6_operator

```
void get_DMEFT_signal_yields_dim6_operator(
    std::vector< double > & signal_yields,
    const str,
    const DMEFT_analysis_info & analysis_info,
    double m,
    double O1,
    double O2,
    double lambda
)
```

Fill the input vector with the DMEFT signal prediction for a given set of dim-6 operators. 

### function get_DMEFT_signal_yields_dim7_operator

```
void get_DMEFT_signal_yields_dim7_operator(
    std::vector< double > & signal_yields,
    const str,
    const DMEFT_analysis_info & analysis_info,
    double m,
    double O,
    double lambda
)
```

Fill the input vector with the DMEFT signal prediction for a given dim-7 operator. 

### function DMEFT_results_profiled

```
void DMEFT_results_profiled(
    AnalysisDataPointers & result
)
```

Results from DMEFT analyses after profiling over the 'a' parameter in the smooth cut-off of the MET spectrum. 

### function DMEFT_results_cutoff

```
void DMEFT_results_cutoff(
    AnalysisDataPointers & result
)
```

Results from DMEFT analyses after imposing a hard cut-off of the MET spectrum. 

### function signal_modifier_function

```
void signal_modifier_function(
    AnalysisData & adata,
    double lambda,
    double a
)
```


Function to modify the DMEFT LHC signal prediction for ETmiss bins where ETmiss > Lambda. Alt 1: Gradually turn off the ETmiss spectrum above Lambda by multiplying the spectrum with (ETmiss/Lambda)^-a 


### function signal_cutoff_function

```
void signal_cutoff_function(
    AnalysisData & adata,
    double lambda
)
```


Function to modify the DMEFT LHC signal prediction for ETmiss bins where ETmiss > Lambda. Alt 2: Simply put a hard cut-off in the ETmiss spectrum for ETmiss > Lambda 


### function _gsl_target_func

```
void _gsl_target_func(
    const size_t,
    const double * a,
    void * fparams,
    double * fval
)
```

A target function for the GSL optimiser. 

### function calc_DMEFT_profiled_LHC_nuisance_params

```
void calc_DMEFT_profiled_LHC_nuisance_params(
    map_str_dbl & result
)
```


### function InterpolatedMCInfo

```
void InterpolatedMCInfo(
    MCLoopInfo & result
)
```


This makes an [MCLoopInfo](/documentation/code/main/classes/structgambit_1_1colliderbit_1_1mcloopinfo/) object for satisfying the ColliderBit dependency chain (This will not be needed once we have a general system for simulation-less analyses.) 


### function limit_LLike

```
double limit_LLike(
    double x,
    double x95,
    double sigma
)
```

LEP limit likelihood function. 

Incorporate theoretical uncertainty in a 95% limit xPredicted cross section 

x95Experimental 95% upper limit on cross section 

sigmaTheoretical uncertainty on predicted cross section 

Log-likelihood


### function is_xsec_sane

```
bool is_xsec_sane(
    const triplet< double > & xsecWithError
)
```

LEP limit debugging function. 

### function LEP207_SLHA1_convention_xsec_chi00_11

```
void LEP207_SLHA1_convention_xsec_chi00_11(
    triplet< double > & result
)
```


### function L3_Gravitino_LLike

```
void L3_Gravitino_LLike(
    double & result
)
```


L3 search for gravitinos at 207 GeV

We use a limit from Fig. 6c of [https://doi.org/10.1016/j.physletb.2004.01.010](https://doi.org/10.1016/j.physletb.2004.01.010).

We use the 95% upper limit on \[
\sigma(ee \to \chi^0_1\chi^0_1) \textrm{BR}(\chi^0_1 \to \tilde{G}\gamma)^2
\]


### function getActiveProcessCodes

```
void getActiveProcessCodes(
    std::vector< int > & result
)
```

Get the list of active collider process codes. 

### function getAnalysisContainer

```
void getAnalysisContainer(
    AnalysisContainer & result,
    const str & detname,
    const MCLoopInfo & RunMC,
    const xsec_container & TotalCrossSection,
    int iteration
)
```

Retrieve an analysis container for a specific detector. 

### function getBuckFastATLAS

```
void getBuckFastATLAS(
    BaseDetector *& result
)
```

Retrieve a [BuckFast]() sim of [ATLAS](). 

### function getBuckFastCMS

```
void getBuckFastCMS(
    BaseDetector *& result
)
```

Retrieve a [BuckFast]() sim of [CMS](). 

### function getBuckFastIdentity

```
void getBuckFastIdentity(
    BaseDetector *& result
)
```

Retrieve an Identity [BuckFast]() sim (no sim) 

### function getHepMCEvent

```
void getHepMCEvent(
    HEPUtils::Event & result
)
```

A nested function that reads in HepMC event files and converts them to HEPUtils::Event format. 

### function getLHEvent

```
void getLHEvent(
    HEPUtils::Event & result
)
```

A nested function that reads in Les Houches Event files and converts them to HEPUtils::Event format. 

### function convert_xsecs_to_fb

```
std::pair< double, double > convert_xsecs_to_fb(
    double input_xsec,
    double input_xsec_uncert,
    str input_unit,
    bool input_fractional_uncert
)
```


Helper function that takes a cross-section value in fb or pb, along with an absolute or relative uncertainty, and returns the xsec and absolute uncertainty in fb. 


### function getPIDPairCrossSectionsMap_prospino

```
void getPIDPairCrossSectionsMap_prospino(
    map_PID_pair_PID_pair_xsec & result
)
```


Get a cross-section from Prospino WORK IN PROGRESS 


### function silly_pid_xsec_constructor

```
PID_pair_xsec_container silly_pid_xsec_constructor(
    PID_pair pid_pair,
    double xsec_val
)
```

Test functions for provding PIDPairCrossSectionsMap (cross-sections in fb) 

### function getPIDPairCrossSectionsMap_testing

```
void getPIDPairCrossSectionsMap_testing(
    map_PID_pair_PID_pair_xsec & result
)
```


### function getProcessCrossSectionsMap

```
void getProcessCrossSectionsMap(
    map_int_process_xsec & result
)
```

Get a map between Pythia process codes and cross-sections. 

### function getEvGenCrossSection

```
void getEvGenCrossSection(
    MC_xsec_container & result
)
```

Compute a cross-section from Monte Carlo. 

### function getEvGenCrossSection_as_base

```
void getEvGenCrossSection_as_base(
    xsec_container & result
)
```

Return [MC_xsec_container]() as the base [xsec_container](). 

### function getNLLFastCrossSection

```
void getNLLFastCrossSection(
    xsec_container & result
)
```

Get a cross-section from NLL-FAST. 

### function checkOptions_getYAMLCrossSection

```
bool checkOptions_getYAMLCrossSection(
    const Options & runOptions,
    const str calling_function,
    std::pair< str, str > & xsec_pnames,
    str & input_unit,
    bool & input_fractional_uncert,
    str & errmsg
)
```

A helper function to check the YAML options for getYAMLCrossSection and getYAMLCrossSection_SLHA. 

### function getYAMLCrossSection

```
void getYAMLCrossSection(
    xsec_container & result
)
```

A function that reads the total cross-section from the input file, but builds up the number of events from the event loop. 

### function getYAMLCrossSection_SLHA

```
void getYAMLCrossSection_SLHA(
    xsec_container & result
)
```

A function that reads a list of (SLHA file, total cross-section) pairs from the input YAML file. 

### function getYAMLCrossSection_param

```
void getYAMLCrossSection_param(
    xsec_container & result
)
```


A function that assigns a total cross-sections directly from the scan parameters (for model ColliderBit_SLHA_scan_model) 


### function getTotalCrossSectionAsMap

```
void getTotalCrossSectionAsMap(
    map_str_dbl & result
)
```

Get cross-section info as map_str_dbl (for simple printing) 

### function getPIDPairCrossSectionsInfo

```
void getPIDPairCrossSectionsInfo(
    map_str_dbl & result
)
```

Output PID pair cross-sections as a str-dbl map, for easy printing. 

### function doCrossSectionConsistencyCheck

```
void doCrossSectionConsistencyCheck(
    bool & result
)
```


A consistency check that ensures that if each event is weighted by a process-level cross-section from an external calculator, then the total cross-section is taken from the event generator 


### function calc_LHC_signals

```
void calc_LHC_signals(
    map_str_dbl & result
)
```

Loop over all analyses and fill a map of predicted counts. 

### function _gsl_calc_Analysis_MinusLogLike

```
void _gsl_calc_Analysis_MinusLogLike(
    const size_t n,
    const double * unit_nuisances_dbl,
    void * fixedparamspack,
    double * fval
)
```


**Note**: Doesn't return a full log-like: the factorial term is missing since it's expensive, fixed and cancels in DLLs 

Loglike objective-function wrapper to provide the signature for GSL multimin


We've dropped the log(n_obs!) terms, since they're expensive and cancel in computing DLL


### function _gsl_calc_Analysis_MinusLogLikeGrad

```
void _gsl_calc_Analysis_MinusLogLikeGrad(
    const size_t n,
    const double * unit_nuisances_dbl,
    void * fixedparamspack,
    double * fgrad
)
```

Loglike gradient-function wrapper to provide the signature for GSL multimin. 

### function _gsl_calc_Analysis_MinusLogLikeAndGrad

```
void _gsl_calc_Analysis_MinusLogLikeAndGrad(
    const size_t n,
    const double * unit_nuisances_dbl,
    void * fixedparamspack,
    double * fval,
    double * fgrad
)
```


### function _gsl_mkpackedarray

```
std::vector< double > _gsl_mkpackedarray(
    const Eigen::ArrayXd & n_preds,
    const Eigen::ArrayXd & n_obss,
    const Eigen::ArrayXd & sqrtevals,
    const Eigen::MatrixXd & evecs
)
```


### function profile_loglike_cov

```
double profile_loglike_cov(
    const Eigen::ArrayXd & n_preds,
    const Eigen::ArrayXd & n_obss,
    const Eigen::ArrayXd & sqrtevals,
    const Eigen::MatrixXd & evecs
)
```


**Note**: Return value is missing the log(n_obs!) terms (n_SR of them) which cancel in LLR calculation 

**Todo**: Pass in the cov, and compute the fixed evals, evecs, and corr matrix as fixed params in here? Via a helper function to reduce duplication 

Return the best log likelihood 


### function marg_loglike_nulike1sr

```
double marg_loglike_nulike1sr(
    const Eigen::ArrayXd & n_preds,
    const Eigen::ArrayXd & n_obss,
    const Eigen::ArrayXd & sqrtevals
)
```


### function marg_loglike_cov

```
double marg_loglike_cov(
    const Eigen::ArrayXd & n_preds,
    const Eigen::ArrayXd & n_obss,
    const Eigen::ArrayXd & sqrtevals,
    const Eigen::MatrixXd & evecs
)
```


TodoShould also implement a check of relative difference 

How to correct negative rates? Discard (scales badly), set to epsilon (= discontinuous & unphysical pdf), transform to log-space (distorts the pdf quite badly), or something else (skew term)? We're using the "set to epsilon" version for now. Ben: I would vote for 'discard'. It can't be that inefficient, surely? Andy: For a lot of signal regions, the probability of none having a negative sample is Prod_SR p(non-negative)_SR... which _can_ get bad.


### function calc_LHC_LogLikes

```
void calc_LHC_LogLikes(
    map_str_AnalysisLogLikes & result
)
```

Loop over all analyses and fill a map of [AnalysisLogLikes]() objects. 

### function get_LHC_LogLike_per_analysis

```
void get_LHC_LogLike_per_analysis(
    map_str_dbl & result
)
```

Extract the combined log likelihood for each analysis. 

### function get_LHC_LogLike_per_SR

```
void get_LHC_LogLike_per_SR(
    map_str_dbl & result
)
```

Extract the log likelihood for each SR. 

### function get_LHC_LogLike_SR_labels

```
void get_LHC_LogLike_SR_labels(
    map_str_str & result
)
```

Extract the labels for the SRs used in the analysis loglikes. 

### function get_LHC_LogLike_SR_indices

```
void get_LHC_LogLike_SR_indices(
    map_str_dbl & result
)
```


**Todo**: Switch result type to map_str_int once we have implemented a printer for this type 

Extract the indices for the SRs used in the analysis loglikes 


### function calc_combined_LHC_LogLike

```
void calc_combined_LHC_LogLike(
    double & result
)
```

Compute the total likelihood combining all analyses. 

### function calc_LHC_LogLike_scan_guide

```
void calc_LHC_LogLike_scan_guide(
    double & result
)
```


A dummy log-likelihood that helps the scanner track a given range of collider log-likelihood values 


### function getNextSLHAFileNameAndContent

```
void getNextSLHAFileNameAndContent(
    pair_str_SLHAstruct & result
)
```


### function getAndReplaceSLHAContent

```
void getAndReplaceSLHAContent(
    pair_str_SLHAstruct & result
)
```


TodoAdd option to save the new SLHA content to file 


### function getSLHAFileElements

```
void getSLHAFileElements(
    map_str_dbl & result
)
```


### function getSLHA1Spectrum

```
void getSLHA1Spectrum(
    SLHAstruct & result
)
```


### function getSLHA2Spectrum

```
void getSLHA2Spectrum(
    SLHAstruct & result
)
```


### function calc_susy_spectrum_scan_guide

```
void calc_susy_spectrum_scan_guide(
    double & result
)
```


### function getActiveProcessCodeToPIDPairsMap

```
void getActiveProcessCodeToPIDPairsMap(
    multimap_int_PID_pair & result
)
```


Get a multimap between the active Pythia process codes and the corresponding PID pair for the two final state particles 


### function getActivePIDPairs

```
void getActivePIDPairs(
    vec_PID_pair & result
)
```

Get a list of all the PID pairs related to active process codes. 

### function runAnalyses

```
void runAnalyses(
    AnalysisDataPointers & result,
    const str & ,
    const MCLoopInfo & RunMC,
    const AnalysisContainer & Container,
    const HEPUtils::Event & SmearedEvent,
    int iteration,
    void(*)() wrapup
)
```

Run all the analyses in a given container. 

### function smearEvent

```
void smearEvent(
    HEPUtils::Event & result,
    const HEPUtils::Event & HardScatteringEvent,
    const BaseDetector & detector,
    const MCLoopInfo & RunMC,
    const int iteration,
    const str & detname
)
```

Smear an event. 


## Attributes Documentation

### variable all_process_codes_to_PID_pairs

```
static const multimap_int_PID_pair all_process_codes_to_PID_pairs;
```


### variable sqrtsGeV

```
static constexpr double sqrtsGeV = 205;
```


### variable GeV

```
static const double GeV = 1;
```

Unit conversions (multiply to construct in standard units, divide to decode to that unit) 

### variable MeV

```
static const double MeV = 1e-3;
```


### variable TeV

```
static const double TeV = 1e3;
```


### variable analysis_info_map

```
std::map< str, DMEFT_analysis_info > analysis_info_map;
```


A global map from analysis name to [DMEFT_analysis_info](/documentation/code/main/classes/classgambit_1_1colliderbit_1_1dmeft__analysis__info/) instance. This map is initialized by the function fill_analysis_info_map, which is called the first time DMEFT_results run. 





-------------------------------

Updated on 2022-08-03 at 00:01:29 +0000